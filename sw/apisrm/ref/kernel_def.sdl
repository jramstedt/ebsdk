/* file:	kernel_def.sdl    
/*
/* Copyright (C) 1990, 1995 by    
/* Digital Equipment Corporation, Maynard, Massachusetts.
/* All rights reserved.
/*
/* This software is furnished under a license and may be used and copied
/* only  in  accordance  of  the  terms  of  such  license  and with the
/* inclusion of the above copyright notice. This software or  any  other
/* copies thereof may not be provided or otherwise made available to any
/* other person.  No title to and  ownership of the  software is  hereby
/* transferred.
/*
/* The information in this software is  subject to change without noticec
/* and  should  not  be  construed  as a commitment by digital equipment
/* corporation.
/*
/* Digital assumes no responsibility for the use  or  reliability of its
/* software on equipment which is not supplied by digital.
/*
/*
/* Abstract:	Kernel data structure definitions for
/*		EVAX/Cobra firmware.
/*                                                   
/* Author:	AJ Beaverson
/*
/* Modifications:
/*
/*	dwn	15-Sep-1995	Added DDB$K_TOKEN
/*
/*	cto	14-Jan-1994	Diag_common addition/subtractions to PCB
/*
/*	kl	19-Aug-1993	Ruby merge
/*
/*	pel	15-Jan-1993	Conditionalize for morgan
/*
/*	phk	22-Jun-1992	Add FB driver
/*
/*	ajb	28-May-1992	Create FLASH, which is an unstructured
/*				uniform byte stream for flash roms.
/*
/*	ajb	30-Apr-1992	Trim semaphore names to 16 characters for a
/*				savings of 6500 bytes.  Semaphore names are
/*				exist only for human readability, and are not
/*				used by programs or scripts.
/*
/*	ajb	30-Apr-1992	Remove rlock, wlock from inodes.  The pipe
/*				driver is the only driver that uses them, so
/*				let it create a private structure that hangs
/*				of the misc field.
/*
/*	ajb	06-feb-1992	Use ifsymbol constructs
/*				to encode max_processor
/*
/*	pel	05-Feb-1992	put IOB w/in FILE quadword aligned.
/*				Pad FILE struct to be multiple of quadwords.
/*
/*	hcb	27-Jan-1992	include platform.defs
/*
/*	pel	22-Jan-1992	expand IOB bytes_written,read, io_count to qwd
/*
/*	pel	09-Jan-1992	Add len field to RAB struct
/*
/*	pel	19-Dec-1991	Add SWAP DDB entry
/*
/*	phk	15-Nov-1991	Add code_entry to FILE structure
/*
/*	phk	08-Oct-1991	Add EL & TEE  DDB entries
/*
/*	hcb	03-Oct-1991	Add Cobra Primary IO space driver DDB entry 
/*
/*	pel	30-Sep-1991	make lbus, fbus csr driver DDB entries instead
/*				of separate csr drivers for each device.
/* 
/*	pel	11-Sep-1991	gen MAX_DRIVERS automatically; add SCRAM, NCR
/*				csr drivers.
/* 
/*	jds	16-Aug-1991	Added EX (XNA) DDB entry.
/* 
/*	phk	31-Jul-1991	Add MODE_M_SILENT
/*
/*	ajb	29-May-1991	Add stack size to INODE
/*
/*	hcb	22-May-1991	Add memtest setjmp id
/*
/*	ajb	22-May-1991	Export a pointer to the shell's parse structure
/*				into the PCB so that EXIT, BREAK, certain SET
/*				commands and CONTROL X can touch the current
/*				shell.
/*
/*	pel	20-May-1991	Add pcb pointer to IOB
/*
/*	ajb	17-May-1991	Remember parent's pid when starting a process.
/*
/*	dtm	15-May-1991	Add GBUS driver to DDB
/*
/*	twp	14-May-1991	Removed error fields in PCB that have been
/*				moved into the IOB.  Added two new EV's
/*				to diag_ev structure (completion and startup)
/*
/*	ajb	09-May-1991	Add control-c flink/blink to PCB
/*
/*      djm	25-Apr-1991	Added XCT to driver database.
/*
/*	phk	24-Apr-1991	Add CSR to driver database.
/*
/*	ajb	24-Apr-1991	statically allocate standard filenames in
/*				the PCB.
/*
/*	ajb	23-Apr-1991	Add MAX_PATHNAME, which is the largest size
/*				a protocol string can be.
/*
/*	dwb	16-Apr-1991	Increase MAX_DRIVERS to 64.
/*
/*	kl	16-Apr-1991	Entry constants, saved_pcb field for VAX 
/*				entry context.	
/*
/*	jad	04-Apr-1991	Add PBQ.
/*
/*	kl	02-Apr-1991	Add MBX to DDB
/*
/*	pel	29-Mar-1991	add iobq to PCB
/*
/*	hcb	29-Mar-1991	Add DDB$K_MOPLP to driver database.
/*
/*	jds	28-Mar-1991	Added FPR, PT driver defs.
/*
/*	pel	27-Mar-1991	add IOB structure to FILE structure; delete
/*				fatal_errors from pcb
/*
/*	ajb	21-mar-1991	Insure at least one character of pushback for
/*				all file types.
/*
/*	jad	13-Mar-1991	Add ff to driver database.
/*
/*	pel	12-Mar-1991	collapse inode wrt_ref, rd_ref into just ref.
/*
/*	db	11-Mar-1991	Add DDB$K_IIC
/*
/*	phk	08-Mar-1991	Add DDB$K_DMA
/*
/*	kl	01-Mar-1991	Change HWRPB communications driver to a TT
/*				port driver.
/*
/*	twp	25-Feb-1991	Removed expected, received, failing_vec, and
/*				failing_addr fields from PCB - will only be
/*				used for extended error reports if so desired.
/*				Removed cleanup routine from PCB -- diagnostic
/*				will now load cleanup routine as direct
/*				pcb rundown routine.  Removed req_section and
/*				req_passes not needed in the PCB -- can be 
/*				referenced directly from QSTRUCT array.  Also
/*				renamed the 'sections' variable in the dispatch
/*				table to now be 'groups'.
/*
/*	ajb	25-Feb-1991	Add pointer to qualifiers in PCB.
/*
/*	jad	21-Feb-1991	Add DDB$K_NDBR
/*
/*	sfs	19-Feb-1991	Add ALLOW_COLON and ALLOW_SLASH to DDB; remove
/*				REF from INODE.
/*
/*	ajb	14-Feb-1991	Pass values through semaphores.  The value
/*				is OR'd in so that it can be treated as a 
/*				cluster of event flags.
/*
/*	mrc	05-Feb-1991	Added contents of STATUS_BLOCK structure
/*				directly into PCB.  Eliminated DIAG_FLAGS.
/*				Defined a process kill setjmp id
/*				(PROC_KILL_SJ_ID) used to allow killpending to
/*				jump directly to krn$_process if killpending is
/*				set.  Added to DIAG_EVS structure.
/*
/*	kl	25-Jan-1991	Add VAX exception context to PCB
/*
/*	sfs	25-Jan-1991	Rearrange PCB; add lightweight saved Alpha
/*				context.
/*
/*	pel	24-Jan-1991	add ptr to opened semaphore to PCB.
/* 
/*	jds	16-Jan-1991	Added Alpha setjmp structure.
/* 
/*	mrc	14-Jan-1991	Add STATUS_BLOCK structure and diag constants.
/*				Also add DIAG_DIS_TABLE structure, DIAG_FLAGS
/*				structure and DIAG_EVS structure. Update PCB
/*				to have a pointer to the status block.
/*
/*	kl	03-Jan-1991	Add hwrpb_comm driver entry
/*
/*	sfs	20-Dec-1990	Add exception R2 through R7 to ALPHA_CTX.
/*
/*	ajb	19-Dec-1990	Add drivers types for ssc tt port and tty class
/*				driver.
/*
/*	ajb	12-Dec-1990	Add a Poll Queue Element. These live on a
/*				polling queue, visited by the timer process
/*				every tick, and are used to trigger drivers
/*				when we are running polled.
/*
/*	ajb	11-Dec-1990	Add adutt driver entry
/*
/*	jds	07-Dec-1990	Added setjmp/longjmp defs.
/*
/*	ajb	06-Dec-1990	Add a structure that describes the stack as
/*				delivered by PAL code, with some enhancements
/*				to allow saving of context.
/*
/*	pel	05-Dec-1990	use ! to define DEF_PERMISSION
/*
/*	pel	29-Nov-1990	add a_stdin/out/err to PCB. increase max_fopen.
/*				In PCB keep pointers to stdin/out/err filenames
/*				instead of the names themselves.
/*                                                                         
/*	jds	16-Nov-1990	Restructured entry context.
/*
/*	ajb	15-Nov-1990	Add timestamp in PCB so that we keep better
/*				track of time.
/*
/*	kl	15-Nov-1990	add handler queue to PCB
/*
/*	dtm	15-Nov-1990	add entry context fields for callback parameters
/*
/*	ajb	14-nov-1990	remove control t fields
/*
/*	pel	14-Nov-1990	Chgd MODE_M_ values; added create, rewrite 
/*				Add DVX_WILDCARD, SEARCH_START
/*                                                                         
/*	jds	12-Nov-1990	Add ids for examine/deposit drivers.
/*
/*	sfs	08-Nov-1990	Add protocol drivers.
/*
/*	ajb	08-Nov-1990	Add access modes for stdin, stdout and stderr
/*
/*	jad	07-Nov-1990	Add DDB$K_EA
/*
/*	pel	05-Nov-1990	Add MODE_M_FIXED to prevent a file from moving
/*
/*	ajb	02-Nov-1990	Remove ownership queues for semaphores and
/*				timers, save FPRs on Alpha
/*
/*	sfs	31-Oct-1990	Define Alpha hardware context.
/*
/*	pel	29-Oct-1990	Add local_offset field to FILE file descriptor.
/*
/*	kl	25-Oct-1990	Modify entry_context
/*
/*	sfs	24-Oct-1990	Modify LOCK structure.
/*
/*	ajb	16-Oct-1990	Add PCB_ALIGNMENT
/*
/*	dtm	15-Oct-1990	break out environment variable definitions
/*
/*	jad	11-Oct-1990	Add MOPDL to driver database.
/*
/*	sfs	09-Oct-1990	Add "status" and "count" fields to FILE.
/*
/*	kl	05-Oct-1990	add entry_ctx
/*
/*	kl	05-Oct-1990	add last_processor field to PCB	
/*
/*	dtm	05-Oct-1990	add environment variable action routines
/*
/*	pel	02-Oct-1990	delete inode fl,bl. reduce MAX_INODES to 200.
/*
/*	ajb	01-Oct-1990	make pcb size a multiple of 4
/*
/*	ajb	28-Sep-1990	Add validation entry point to drivers
/*
/*	dtm	25-Sep-1990	Change EV$NOSYSTEM to EV$USER.
/*
/*	jad	24-Sep-1990	Add to NI_GBL environment variable pointer.
/*
/*	dtm	19-Sep-1990	Add environment variable definitions
/*
/*	jad	07-Sep-1990	Add Misc field to control T Queue.
/*
/*	ajb	04-Sep-1990	Add user defined startup routine.
/*
/*	jad	30-aug-1990	Add alternate to TIMERQ.
/*
/*	pel	17-Aug-1990	Add access mode field to FILE, file descriptor.
/*                              Add binary permission inode attribute.
/*
/*	pel	14-Aug-1990	Add fields to inode per file_sys design spec.
/*
/*	jad	13-Aug-1990	Add some ni definitions
/*
/*	ajb	08-Aug-1990	Bump up idle stack size
/*
/*	ajb	01-Aug-1990	Add process quantums
/*
/*	ajb	30-Jul-1990	Create a spinlock data structure
/*
/*	ajb	26-Jul-1990	Add a field in the PCB that indicates what
/*				state the process is in.
/*
/*	ajb	25-Jul-1990	Add ownership queue for timer queue elements.
/*
/*	ajb	24-Jul-1990	Add process ids to PCB
/*
/*	jad	24-Jul-1990	Add MOP to driver database.
/*
/*	kl	20-Jul-1990     Additional documentation.
/*
/*	kl,dm	17-Jul-1990	Multiprocessor upgrade (first pass)
/*
/*	ajb	4-Jul-1990	Add nokill bit to PCB so processes can protect
/*				themselves when necessary.
/*
/*	ajb	3-Jul-1990	Add backpointer to semaphore in PCB for when
/*				the PCB is on a semaphore queue.
/*
/*	jad	20-Jun-1990	Add EZ to driver database.
/*
/*	ajb	13-Jun-1990	Bump up minimum stack size
/*
/*	sfs	30-May-1990	Add SCSI and DSSI definitions.
/*
/*	ajb	14-May-1990	Add a small buffer in the file descriptor
/*				to support pushing back at least one character
/*				into the input strream.
/*
/*	ajb	11-May-1990	Add address of completion semaphore to PCB.
/*
/*	ajb	20-Apr-1990	Added file system definitions.
/*
/*	ajb	07-Mar-1990	Initial entry.
/*
module	$kerneldef;
                      
iflanguage cc
literal;
#define TIMEOUT$K_SEM_VAL 0x80000000	/* Value bposted by krn$_timer */
end_literal;
end_iflanguage cc;

constant KRN$K_MINSTACK	equals	4096;	/* minimum stack size
constant MAX_PRI	equals	8;	/* number of priorities
constant MAX_NAME	equals 32;	/* max size of an identifier
constant MAX_IPL	equals 31;
constant MAX_WHOAMI	equals 1;	/* maximum value that whoami can return.
constant MAX_CPU	equals 2;	/* max number of cpus allowed
constant IPL_SYNC	equals 31;	/* kernel synchronization IPL
constant IPL_RUN	equals 0;	/* normally running IPL
constant MAX_ARGS	equals 64;	/* max # procedure arguments 
constant DEF_ALLOC	equals 2048;	/* default allocation size for newly created files
constant DEF_EXPAND	equals 512;	/* default expansion size for files
constant DEF_QUANTUM	equals 10;	/* default process quantum, in ticks
constant PCB_ALIGNMENT	equals 128;	/* required HW pcb alignment for evax
constant ERROR_ENTRY 	equals	1;	/* error entry
constant SYSTEM_RESET_ENTRY equals 2;	/* system_reset_entry
constant CALLBACK_ENTRY     equals 4;	/* callback entry
constant EXTERNAL_ENTRY     equals 8;	/* external entry
constant NODE_RESET_ENTRY   equals 16;	/* node reset entry

/*+
/* ===============================================
/* = QUEUE - queue structure                     =
/* ===============================================
/*
/* STRUCTURE OVERVIEW:
/*
/*	A standard console queue is a double linked list.	
/*
/*
/* STRUCTURE MEMBERS:
/*
/*:
/*       ----------------------------------------------------------------------
/*       Structure Members    | Data Type  | Description
/*       ----------------------------------------------------------------------
/*                     flink  |	address	   | forward link 
/*                            |	       	   | 
/*                     blink  |	address    | backward link
/*:      ----------------------------------------------------------------------
/*
/*-
/*

aggregate "QUEUE" structure prefix "" tag "";
	flink	address (QUEUE);
	blink	address (QUEUE);
end QUEUE;


/*+
/* ===============================================
/* = SEMAPHORE - semaphore structure 		 =
/* ===============================================
/*
/* STRUCTURE OVERVIEW:
/*
/* Semaphore queues are FIFO, and not prioritized. (In most cases, there will 
/* be only one task on the queue).
/*
/* STRUCTURE MEMBERS:
/*
/*:
/*       ----------------------------------------------------------------------
/*       Structure Members    | Data Type  | Description
/*       ----------------------------------------------------------------------
/*                     flink  |	byte 	   | forward link 
/*                            |	       	   | 
/*                     blink  |	address    | backward link
/*                            |	       	   | 
/*		       gsq    | queue      | global semaphore queue
/*                            |	       	   | 
/*                     count  | longword   | count
/*                            |	       	   | 
/*		       value  | longword   | value that krn$_wait will return
/*                            |	       	   | 
/*                     name   | string     | name
/*:      ----------------------------------------------------------------------
/*
/*-
/*

aggregate SEMAPHORE structure prefix "" tag "";
	flink	address (SEMAPHORE);
	blink	address (SEMAPHORE);
	gsq	QUEUE;
	count	longword;
	"value"	longword;
	name	byte dimension 2*8;
end SEMAPHORE;

/*
/* Structure of a file entry
/*

/*+
/* ===============================================
/* = NI_GBL - NI Global data definitions	 =
/* ===============================================
/*
/* STRUCTURE OVERVIEW:
/*
/* This structure is to be pointed to by the misc feild in the inode.
/* It simply contains pointers to the NI data structures to be used by the
/* drivers.
/*
/* STRUCTURE MEMBERS:
/*
/*:
/*       ----------------------------------------------------------------------
/*       Structure Members    | Data Type  | Description
/*       ----------------------------------------------------------------------
/*                     pbp    |	address    | Pointer to the port block info
/*                            |	       	   | 
/*                     dlp    |	address    | Pointer to the datalink info
/*                            |	       	   | 
/*                     mbp    |	address    | Pointer to the MOP block info
/*                            |	       	   | 
/*                     mcp    |	address    | Pointer to the MOP counters
/*                            |	       	   | 
/*                     enp    |	address    | Pointer to environment variables
/*:      ----------------------------------------------------------------------
/*
/*-
/*

aggregate NI_GBL struct prefix "" tag "";
	pbp	address;		/*Pointer to the port block info
	dlp	address;		/*Pointer to the datalink info
	mbp	address;		/*Pointer to the MOP block info
	mcp	address;		/*Pointer to the MOP counters
	lpp	address;		/*Pointer to device loopback info
	enp	address;		/*Pointer to environment variables
end NI_GBL;


aggregate DDB struct prefix "" tag "";
	name	address (byte);		/* how this device wants to be called
	"read"	address (ENTRY);	/* read routine
	write	address (ENTRY);	/* write routine
	open	address (ENTRY);	/* open routine
	close	address (ENTRY);	/* close routine
	expand	address (ENTRY);	/* expand routine
	delete	address (ENTRY);	/* delete routine
	create	address (ENTRY);	/* address of create routine
	setmode	address (ENTRY);	/* sets interrupt/polled mode
	validation address (ENTRY);	/* validation routine
	misc	longword;		/* class specific use
	allow_info	bitfield;
	allow_next	bitfield;
	flash		bitfield;	/* is a flash update driver
	block		bitfield;	/* is a block device
	sequential	bitfield;	/* can't be fseek'd
	net_device	bitfield length 2;	/* is a network device
	filesystem	bitfield;	/* is a filesystem
end DDB;

constant DDB$K_INTERRUPT	equals 0;	/* set to interrupt mode
constant DDB$K_POLLED		equals 1;	/* set to polled mode
constant DDB$K_STOP		equals 2;	/* set to stopped
constant DDB$K_START		equals 3;	/* set to start
constant DDB$K_ASSIGN		equals 4;	/* assign controller letters
constant DDB$K_LOOPBACK_INTERNAL equals 5;	/* device internal loopback
constant DDB$K_LOOPBACK_EXTERNAL equals 6;	/* device external loopback
constant DDB$K_NOLOOPBACK	equals 7;	/* no loopback
constant DDB$K_OPEN		equals 8;	/* file open
constant DDB$K_CLOSE		equals 9;	/* file close
constant DDB$K_READY		equals 10;	/* get ready to boot
constant DDB$K_MULTICAST	equals 11;	/* enable multicast

constant DDB$K_ETHERNET		equals 1;	/* Ethernet device 
constant DDB$K_FDDI		equals 2;	/* FDDI device
constant DDB$K_TOKEN		equals 3;	/* TOKEN RING 

/*+
/* ===============================================
/* = INODE - file entry structure 		 =
/* ===============================================
/*
/* STRUCTURE OVERVIEW:
/*
/* Inodes are allocated from the ilist array.
/* Each inode points to a file. This file may be a read only file, such as a
/* script, a write only file such as a log, an executable, such as a
/* routine which executes a command, etc. The inode also points into the 
/* driver database to a set of routines, associated with a specific driver,
/* that may perform actions on the file.
/*
/*
/* STRUCTURE MEMBERS:
/*
/*:
/*   -------------------------------------------------------------------------
/*   Structure Members | Data Type  | Description
/*   -------------------------------------------------------------------------
/*   dvx           | longword   | index into the driver database
/*                 |            | 
/*   dev           | longword   | address of device structure
/*                 |            | 
/*   inuse         | longword   | set if node is in use
/*                 |	        | 
/*   name          | string     | name of file
/*                 |	        | 
/*   attr          | longword   | file attributes (read,write,execute)
/*                 |	        | 
/*   loc           | address    | address of file
/*                 |	        | 
/*   len           | quadword   | size of file in bytes
/*                 |	        | 
/*   alloc         | quadword   | size allocated
/*                 |	        | 
/*   ref           | longword   | open reference count  (for drivers)
/*                 |	        | 
/*   append_offset | quadword   | + loc = addr to append next block of data to
/*                 |	        | 
/*   misc          | address    | miscellaneous pointer
/*                 |	        | 
/*:  -------------------------------------------------------------------------
/*
/*-
/*

aggregate INODE struct prefix "" tag "";
    flink   address (INODE);	    /* singly linked list of inodes
    dva     address (DDB);          /* pointer to driver dispatch table
    dev     address;                /* pointer to device descriptor
    inuse   longword;               /* set if node is in use
    attr    longword;               /* attribute mask              
    loc     address (byte);         /* first byte of file
    len     quadword;               /* actual size in bytes.
    alloc   quadword;               /* size allocated
    append_offset quadword;         /* + inode.loc = addr to append next data to
    ref     longword;               /* open reference count (for drivers)
    misc    address;                /* miscellaneous pointer
    name    byte dimension (MAX_NAME);
    bs	    longword;		    /* natural block size of the device, normally 0
end INODE;

constant ATTR$M_READ		equals	 1;   /* for compatability
constant ATTR$M_WRITE		equals	 2;   /* writes (and deletes) allowed
constant ATTR$M_EXECUTE		equals	 4;   /* executable file
constant ATTR$M_BINARY 		equals   8;   /* binary file
constant ATTR$M_EXPAND		equals  16;   /* shell expands wildcards
constant ATTR$M_SECURE          equals  32;   /* access allowed in secure mode 
constant ATTR$M_NOFREE          equals  64;   /* don't free file space 
constant ATTR$M_DEVICE          equals  128;  /* device
constant ATTR$M_ADAPTER         equals  256;  /* adapter
constant ATTR$M_BUS             equals  512;  /* bus
constant ATTR$M_FILE            equals  1024; /* file

constant DEF_PERMISSION equals (ATTR$M_READ ! ATTR$M_WRITE);

constant DEF_PUSHBACK	equals 8;	/* max amount of pushback
constant DEF_RBUF	equals 2048;	/* max size of read ahead

/*+                                                                             
/* ===============================================                              
/* = RAB - Read Ahead Buffer                     =                              
/* ===============================================                              
/*                                                                              
/* STRUCTURE OVERVIEW:                                                          
/*                                                                              
/* Drivers that do not supports FSEEKs require buffers, so that                 
/* functions such as ungetc can work in a transparent manner.  Define a         
/* generic read ahead buffer, and allow for a predetermined amount of           
/* pushback.  The buffer is implemented as a circular queue.  Because           
/* these buffers are process specific, no synchronization is required.          
/*                                                                              
/*                                                                              
/* STRUCTURE MEMBERS:                                                           
/*
/*:                                                                             
/*       ---------------------------------------------------------------------- 
/*       Structure Members    | Data Type  | Description                        
/*       ---------------------------------------------------------------------- 
/*                     alloc  | longword   | number of bytes that are allocated 
/*                            |            | 
/*                     len    | longword   | number of bytes in the buffer      
/*                            |            | 
/*                     buf    | address    | pointer to buffer                  
/*                            |            | 
/*                     inx    | longword   | input index                        
/*                            |            | 
/*                     outx   | longword   | output index                       
/*:      ---------------------------------------------------------------------- 
/*                                                                              
/*-                                                                            
/*                                                                              
                                                                                
aggregate RAB struct prefix "" tag "";
	len  	longword unsigned;	/*                                    
	alloc	longword unsigned;	/*                                    
	buf	address (byte);		/*                                    
	inx	longword unsigned;	/*                                    
	outx	longword unsigned;	/*                                    
end RAB;
                                                                               
                                                                               

/*+                                                                             
/* ===============================================                              
/* = IOB  - IO block structure                   =                              
/* ===============================================                              
/*                                                                              
/* STRUCTURE OVERVIEW:                                                          
/* 
/* Contains IO count data.  Every file descriptor and driver port block
/* has an IOB.  All IOBs live on a linked list, iobq, synchronized by the
/* spinlock, spl_iobq.  IOBs are created by fopen and driver init routines 
/* and they may be created by diagnostics or any other code.
/* IOBs are deleted by fclose and drivers or other code.
/*  
/*
/* STRUCTURE MEMBERS:                                                           
/*
/*:                                                                             
/*  ----------------------------------------------------------------------- 
/*    Members    | Data Type  | Description                        
/*  ----------------------------------------------------------------------- 
/*		       sysq   |	queue	   | system wide IOB queue
/*                            |            | 
/*		       pcbq   |	queue      | PCB wide q; all IOBs for 1 PCB
/*                            |            | 
/*		      name    | string     | name string for this IO block 
/*                            |            | 
/*        	      pcb     | address    | address of pcb
/*               	      |            | 
/*		hard_errors   | longword   | number of hard errors reported
/*                            |            | 
/*		soft_errors   | longword   | number of soft errors reported
/*                            |            | 
/*		bytes_read    | quadword   | number of bytes read
/*                            |            | 
/*		bytes_written | quadword   | number of bytes written
/*                            |            | 
/*		io_count      | quadword   | number of I/O operations done
/*                            |            | 
/*		retry_count   | longword   | number of retries performed
/*: ----------------------------------------------------------------------- 
/*                                                                              
/*-                                                                            
/*                                                                              

aggregate IOB struct prefix "" tag "";
	sysq		QUEUE;			/* system wide IOB q
	pcbq		QUEUE;			/* pcb q; all IOBs for 1 pcb
	bytes_read 	quadword;
	bytes_written 	quadword;
	io_count 	quadword;
	name		byte dimension MAX_NAME;
	pcb		address;		/* addr of pcb
	hard_errors 	longword unsigned;
	soft_errors 	longword unsigned;
	retry_count 	longword unsigned;
end IOB;



/*+                                                                             
/* ===============================================                              
/* = File - File descriptor structure            =                              
/* ===============================================                              
/*                                                                              
/* STRUCTURE OVERVIEW:                                                          
/*                                                             
/* When accessing files, a small integer is passed to the routines.  This       
/* integer is an index into an array of pointers to file descriptors.  Each     
/* PCB has a prebuilt array of file descriptors.                                
/*  
/*
/* STRUCTURE MEMBERS:                                                           
/*
/*:                                                                             
/*  ----------------------------------------------------------------------- 
/*    Members    | Data Type  | Description                        
/*  ----------------------------------------------------------------------- 
/*  	  ip     | address    | address of inode
/*               |            | 
/*  local_offset | quadword   | current location in file
/*               |            | 
/*        offset | address    | pointer to current location in file
/*               |            | 
/*        mode   | longword   | access mode
/*               |            | 
/*        rap    | longword   | address of read ahead buffer, 0 if not used
/*               |            | 
/*        status | longword   | status of last operation
/*               |            | 
/*        count  | longword   | count of last operation
/*               |            | 
/*   code_entry  | longword   | code entry point in file
/*               |            |
/*        iob    | IOB        | IOB; contains IO counts 
/*: ----------------------------------------------------------------------- 
/*                                                                              
/*-                                                                            
/*                                                                              

aggregate FILE struct prefix "" tag "";
	flink	     address (FILE);	/* forward link
	blink	     address (FILE);	/* backward link
	local_offset quadword; 		/* current location in file
	iob	     IOB;  		/* IOB; contains IO counts;keep on qwd
	ip	     address (INODE);	/* address of inode
	offset	     address; 		/* pointer to current location in file
        mode         longword;          /* access mode
	rap	     address (RAB);	/* addr of read ahead buf, 0 if not used
        status       longword;          /* status of last operation
        count        longword;          /* count of last operation
        code_entry   longword;          /* code entry point in file
	misc	     longword;		/* miscellaneous field
	pushback     longword;		/* pushback value
	pushed	     longword;		/* is value valid
	quad_fill2	byte dimension (8-(.&7)) fill;
end FILE;

  /* access modes; more description in ANSI C standard, fopen
/*                                                                         
/* Access mode attributes are combined (ORed) to create a file descr mode. 
/* Rewrite access mode attribute means to discard previous file contents if
/* the file existed before the fopen.					   
/*                                                                         
/* access mode     access mode attributes                                  
/*     "r"         read                                                    
/*     "w"         write, rewrite, create                                  
/*     "a"         write, append, create                                    
/*     "r+"        read, write                                             
/*     "w+"        read, write, rewrite, create                            
/*     "a+"        read, write, append, create                              
/*     "f"         fixed, file's memory address will not be moved          
/*     "z"         use memzone if append to above access modes
/*
/* access mode attributes:                                                 
constant  MODE_M_READ	   equals    1;    /* read, same as inode read attrib 
constant  MODE_M_WRITE     equals    2;    /* write,same as inode write attrib
constant  MODE_M_APPEND    equals   16;    /* append                          
constant  MODE_M_REWRITE   equals   32;    /* rewrite, discard old file       
constant  MODE_M_CREATE    equals   64;    /* creation allowed                
constant  MODE_M_SILENT    equals  128;    /* error message disabled
constant  MODE_M_PERM	   equals  256;	   /* file is permanent (fp is malloc'd)
constant  MODE_M_SECURE    equals  512;    /* access allowed in secure mode 
constant  MODE_M_IMMEDIATE equals 1024;    /* complete immediately, don't block
constant  MODE_M_MZONE     equals 2048;    /* use memzone

/*+
/* ===============================================
/* = TIMERQ - Queue of sleeping processes        =
/* ===============================================
/*
/* STRUCTURE OVERVIEW:
/*
/* The timer queue holds those processes that have put themselves
/* to sleep. Each time a timer interrupt is posted on the primary processor,
/* the timer task walks down the timer queue awakening those 
/* processes that have finished sleeping. 
/*
/*                                
/* STRUCTURE MEMBERS:
/*
/*:
/*       ----------------------------------------------------------------------
/*       Structure Members    | Data Type  | Description
/*       ----------------------------------------------------------------------
/*                     flink  |	address    | forward link 
/*                            |            | 
/*                     blink  |	address    | backward link
/*                            |            | 
/*                     msec   |	longword   | time to sleep
/*                            |            | 
/*                     sem    |	semaphore  | semaphore the sleeper waits on
/*                            |            | 
/*                     active |	longword   | active flag (TRUE = active)
/*                            |            | 
/*                     perm   |	longword   | permanent flag (TRUE = permanent)
/*                            |            | 
/*                     alt    |	longword   | alternate flag (TRUE = alternate)
/*:      ----------------------------------------------------------------------
/*
/*-
/*

aggregate TIMERQ structure prefix "" tag "";
	flink	address (TIMERQ);
	blink	address (TIMERQ);
	msec	longword;
	sem	SEMAPHORE;
	active	longword;
	perm	longword;
	alt	longword;
end TIMERQ;

/*+
/* =======================================================
/* = DELAYYQ - Queue of processes awaiting creation      =
/* =======================================================
/*
/* STRUCTURE OVERVIEW:
/*
/* This queue contains processes whose creation has been delayed.
/* After a delay interval is complete, each process will be created.
/*
/*
/* STRUCTURE MEMBERS:
/*
/*:
/*       ----------------------------------------------------------------------
/*       Structure Members    | Data Type  | Description
/*       ----------------------------------------------------------------------
/*                     flink  |	address    | forward link 
/*                            |            | 
/*                     blink  |	address    | backward link
/*                            |            | 
/*                     msec   |	longword   | number of milliseconds to delay
/*                            |            | 
/*               use_tt_not_nl|	longword   | flag to use "tt", not "nl"
/*                            |            | 
/*                     code   |	address    | code to run
/*                            |            | 
/*                     startup|	address    | process startup routine
/*                            |            | 
/*                     sem    |	SEMAPHORE  | pointer to completion semaphore
/*                            |            | 
/*                     pri    |	longword   | process priority
/*                            |            | 
/*                    affinity|	longword   | process affinity
/*                            |            | 
/*                     stack  |	longword   | size of process stack
/*                            |            | 
/*                     name   |	array      | process name
/*                            |            | 
/*                     a0     |	longword   | first argument
/*                            |            | 
/*                     a1     |	longword   | second argument
/*                            |            | 
/*                     a2     |	longword   | third argument
/*                            |            | 
/*                     a3     |	longword   | fourth argument
/*:      ----------------------------------------------------------------------
/*
/*-
/*
aggregate DELAYQ structure prefix "" tag "";
	flink		address (DELAYQ);
	blink		address (DELAYQ);
	msec		longword;
	use_tt_not_nl	longword;
	code		address (ENTRY);
	startup		address (ENTRY);
	sem		address (SEMAPHORE);
	pri		longword;
	affinity	longword;
	stack		longword;
	name		byte dimension MAX_NAME;
	a0		longword;
	a1		longword;
	a2		longword;
	a3		longword;
end DELAYQ;

/*+
/* ===============================================
/* = POLLQ - Queue of poll routines              =
/* ===============================================
/*
/* STRUCTURE OVERVIEW:
/*
/* This queue contains all the active poll routines.  On every timer tick,
/* the timer process walks down this queue calling the routines.  Drivers
/* register/deregister their poll routines in this queue as a result of a
/* call to xx_setmode.
/*
/*
/* STRUCTURE MEMBERS:
/*
/*:
/*       ----------------------------------------------------------------------
/*       Structure Members    | Data Type  | Description
/*       ----------------------------------------------------------------------
/*                     flink  |	address    | forward link 
/*                            |            | 
/*                     blink  |	address    | backward link
/*                            |            | 
/*                     routine|	address    | poll routine to call
/*                            |            | 
/*                     param  |	longword   | parameter to pass to routine
/*:      ----------------------------------------------------------------------
/*
/*-
/*
aggregate POLLQ structure prefix "" tag "";
	flink	address (POLLQ);
	blink	address (POLLQ);
	routine	address (ENTRY);
	param	longword;
end POLLQ;

/*+
/* ===============================================
/* = PBQ - Queue of port blocks                  =
/* ===============================================
/*
/* STRUCTURE OVERVIEW:
/*
/* This queue contains generic pointers to a list of port blocks.
/*
/* STRUCTURE MEMBERS:
/*
/*:
/*       ----------------------------------------------------------------------
/*       Structure Members    | Data Type  | Description
/*       ----------------------------------------------------------------------
/*                     flink  |	address    | forward link 
/*                            |            | 
/*                     blink  |	address    | backward link
/*                            |            | 
/*                     pb     |	address    | Address of a port block.
/*:      ----------------------------------------------------------------------
/*
/*-
/*
aggregate PBQ structure prefix "" tag "";
	flink	address (PBQ);
	blink	address (PBQ);
	pb	address;
end PBQ;

/*+
/* ==============================================================
/* = DIAG_DIS_TABLE - diagnostic dispatch table                 =
/* ==============================================================
/*
/* STRUCTURE OVERVIEW:
/*
/* The diagnostic dispatch table contains the information necessary to
/* dispatch to tests.  A diagnostic program should define and initialize
/* an array of DIAG_DIS_TABLE to create the dispatch table.  Each entry in
/* the array will describe a single test.
/*
/* STRUCTURE MEMBERS:
/*
/*:
/*   --------------------------------------------------------------------
/*   Structure Member   | Data Type     | Description
/*   --------------------------------------------------------------------
/*   routine            | address       | address of test routine
/*                      |               |
/*   groups             | longword      | name of groups to which this test
/*                      |               | belongs
/*:  --------------------------------------------------------------------
/*-
/*

aggregate DIAG_DIS_TABLE struct prefix "" tag "";
    routine address (entry);
    groups longword unsigned;
end DIAG_DIS_TABLE;

/*+
/* ==============================================================
/* = DIAG_EVS - diagnostic environment variable states          =
/* ==============================================================
/*
/* STRUCTURE OVERVIEW:
/*
/* The diagnostic evs structure consists of bits used to represent the
/* current state of the global diagnostic environment variables.  These
/* bits should not be modified by the diagnostic program, but can be read
/* to determine the current state of the environment variables.
/*
/* STRUCTURE MEMBERS:
/*
/*:
/*   --------------------------------------------------------------------
/*   Structure Member   | Data Type     | Description
/*   --------------------------------------------------------------------
/*   bell               | bitfield      | set if D_BELL is ON
/*                      |               |
/*   clean              | bitfield      | set if D_CLEANUP is ON
/*                      |               |
/*   comp               | bitfield      | set if D_COMPLETE is ON
/*                      |               |
/*   eop                | bitfield      | set if D_EOP is ON
/*                      |               |
/*   head               | bitfield      | set if D_STARTUP is ON
/*                      |               |
/*   log                | bitfield      | set if D_LOGERR is ON
/*                      |               |
/*   oper               | bitfield      | set if D_OPER is ON
/*                      |               |
/*   quick              | bitfield      | set if D_QUICK is ON
/*                      |               |
/*   status             | bitfield      | set if D_STATUS is ON
/*                      |               |
/*   tt                 | bitfield      | set if D_TRACE is ON
/*                      |               |
/*   halt_hard          | bitfield      | set if D_HARDERR is HALT
/*                      |               |
/*   loop_hard          | bitfield      | set if D_HARDERR is LOOP
/*                      |               |
/*   halt_soft          | bitfield      | set if D_SOFTERR is HALT
/*                      |               |
/*   loop_soft          | bitfield      | set if D_SOFTERR is LOOP
/*                      |               |
/*   rpt_summ           | bitfield      | set if D_REPORT is SUMMARY
/*                      |               |
/*   rpt_full           | bitfield      | set if D_REPORT is FULL
/*                      |               |
/*   rpt_off            | bitfield      | set if D_REPORT is OFF
/*:  --------------------------------------------------------------------
/*-
/*

aggregate DIAG_EVS struct prefix "" tag "";
    bell bitfield mask;		/* D_BELL state
    clean bitfield mask;	/* D_CLEANUP state
    comp bitfield mask; 	/* D_COMPLETE state
    eop bitfield mask;		/* D_EOP state
    start bitfield mask;   	/* D_STARTUP state
    logs bitfield mask;		/* D_LOGSERR state
    logh bitfield mask;		/* D_LOGHERR state
    oper bitfield mask;		/* D_OPER state
    quick bitfield mask;	/* D_QUICK state
    status bitfield mask;	/* D_STATUS state
    tt bitfield mask;		/* D_TRACE state
    halt_hard bitfield mask;	/* D_HARDERR state
    loop_hard bitfield mask;	/* D_HARDERR state
    halt_soft bitfield mask;	/* D_SOFTERR state
    loop_soft bitfield mask;	/* D_SOFTERR state
    rpt_summ bitfield mask;	/* D_REPORT state
    rpt_full bitfield mask;	/* D_REPORT state
    rpt_off bitfield mask;	/* D_REPORT state
end DIAG_EVS;

aggregate ALPHA_HW_PCB structure prefix "alpha_hw_pcb$" tag "";
	r2	quadword;
	r3	quadword;
	r4	quadword;
	r5	quadword;
	r6	quadword;
	r7	quadword;
	r8	quadword;
	r9	quadword;
	r10	quadword;
	r11	quadword;
	r12	quadword;
	r13	quadword;
	r14	quadword;
	r15	quadword;
	r26	quadword;
	r27	quadword;
	r29	quadword;
	r30	quadword;
end ALPHA_HW_PCB;

aggregate ALPHA_CTX structure prefix "acx$" tag "";
	acp	quadword;
	exc_r2	quadword;
	exc_r3	quadword;
	exc_r4	quadword;
	exc_r5	quadword;
	exc_r6	quadword;
	exc_r7	quadword;
	r8	quadword;
	r9	quadword;
	r10	quadword;
	r11	quadword;
	r12	quadword;
	r13	quadword;
	r14	quadword;
	r15	quadword;
	r18	quadword;
	r19	quadword;
	r20	quadword;
	r21	quadword;
	r22	quadword;
	r23	quadword;
	r24	quadword;
	r25	quadword;
	r26	quadword;
	r27	quadword;
	r28	quadword;
	r29	quadword;
	r30	quadword;
	r0	quadword;
	r1	quadword;
	r16	quadword;
	r17	quadword;
	r2	quadword;	/* this part is delivered by PAL
	r3	quadword;
	r4	quadword;
	r5	quadword;
	r6	quadword;
	r7	quadword;
	pc	quadword;
	ps	quadword;
end ALPHA_CTX;

/*+
/* ===============================================
/* = PCB - Process Context Block                 =
/* ===============================================
/*
/* STRUCTURE OVERVIEW:
/*
/* Process context.
/*
/*
/* STRUCTURE MEMBERS:
/*
/*:
/*       ----------------------------------------------------------------------
/*       Structure Members    | Data Type  | Description
/*       ----------------------------------------------------------------------
/*		flink 	      | address    | forward link
/*                            |            | 
/*	        blink 	      | address    | backward link
/*                            |            | 
/*	        alpha_hw_pcb  | ALPHA_HW_PCB | Alpha hardware context
/*                            |            | 
/*	        semp          | address    | semaphore the process may be waiting on
/*                            |            | 
/*		ctrlcq        |	queue	   | control C queue
/*                            |            | 
/*		pq            |	queue	   | PCB queue
/*                            |            | 
/*		dq            |	queue      | dynamic memory ownership queue
/*                            |            | 
/*		hq            |	queue      | handler queue
/*                            |            | 
/*		sjq           |	queue      | setjmp queue
/*                            |            | 
/*		iobq          |	queue      | IO block queue for this PCB
/*                            |            | 
/*              pstate        | longword   | process state
/*                            |            | 
/*		shellp	      | longword   | address of shell's context if this
/*                            |            | process is a shell.
/*                            |            | 
/*		killpending   | longword   | bit requesting that process exit
/*                            |            | 
/*		cmd_mode      | longword   | command mode
/*                            |            | 
/*		cmd_switch    | longword   | command mode switch
/*                            |            | 
/*		stdin_name    | address    | filename addr for standard input
/*                            |            | 
/*		stdout_name   | address    | filename addr for standard output
/*                            |            | 
/*		stderr_name   | address    | filename addr for standard error
/*                            |            | 
/*		stdin	      | address    | address of stdin  file descriptor
/*                            |            |                   
/*		stdout	      | address    | address of stdout file descriptor
/*                            |            | 
/*		stderr	      | address    | address of stderr file descriptor
/*                            |            | 
/*              qexpire       | longword   | number of ticks to go before the
/*                            |            | quantum expires
/*                            |            | 
/*              qexpire_dec   | longword   | value by which qexpire is
/*                            |            | decremented on every timer tick.
/*                            |            | 
/*              quantum       | longword   | number of timer ticks that this
/*                            |            | process gets to run before being
/*                            |            | bumped
/*                            |            | 
/*              timestamp     | quadword   | value of timer when this process
/*                            |            | was swapped in.
/*                            |            | 
/*		cputime	      | quadword   | number of nsec process was running
/*                            |            | 
/*              exit_status   |	longword   | final exit status for the process
/*                            |            | 
/*              affinity      |	longword   | cpu affinity mask
/*                            |            | 
/*            created_affinity|	longword   | cpu affinity mask at creation
/*                            |            | 
/*              parentpid     | longword   | process id of parent
/*                            |            | 
/*              pid           | longword   | process id
/*                            |            | 
/*              last_processor| longword   | last processor this process ran on
/*                            |            | 
/*		name	      | array      | process name
/*                            |            | 
/*		startup	      | address    | user defined startup routine
/*                            |            | 
/*		task	      | address    | task address
/*                            |            | 
/*		rundown	      |	address    | rundown routine
/*                            |            | 
/*	        completion    |	address    | posted by rundown routine
/*                            |            | 
/*	        opened        |	SEMAPHORE  | posted by krn$_process
/*                            |            | 
/*	        pri	      | longword   | 0 <= pri <= MAX_PRI
/*                            |            | 
/*	        acp           | ALPHA_CTX  | ptr to Alpha hardware context
/*                            |            | (on the stack)
/*                            |            | 
/*		qualp	      | address    | address of qualifier list
/*			      |            |
/*		dev_name      | byte array | name of target device
/*                            |            | 
/*		test_mask     | address    | array of test numbers 
/*                            |            | 
/*		dispatch      | address    | address of diag dispatch table
/*                            |            | 
/*		sup_dev       | address    | names of supported devices
/*                            |            | 
/*		globals       | address    | generic pointer
/*                            |            | 
/*		diag_common   | address    | address of common diagnostic
/*			      |            | structure variables
/*                            |            | 
/*		evs           | longword   | current state of global diag evs
/*                            |            | 
/*		stacksize     |	longword   | size of stack in bytes
/*                            |            | 
/*		argc	      | longword   | argument count
/*                            |            | 
/*	   	argv          | array      | argument list
/*                            |            | 
/*		stack	      |	array      | process stack
/*:      ----------------------------------------------------------------------
/*
/*-
/*
constant SIGNAL_KILL    	equals 1;	/* bit assignments for
constant SIGNAL_CONTROLC	equals 2;	/* killpending field

aggregate PCB structure prefix "pcb$" tag "";
	flink		address (PCB);		/* forward link
	blink		address (PCB);          /* backward link
	alpha_hw_pcb	ALPHA_HW_PCB;		/* Alpha hardware context
	semp		address (SEMAPHORE);	/* back pointer to semaphore
	ctrlcq		QUEUE;			/* Control C queue
	pq		QUEUE;			/* PCB queue
	dq		QUEUE;			/* dynamic memory ownership q
	hq		QUEUE;			/* handler queue
	sjq		QUEUE;			/* setjmp queue
	iobq		QUEUE;			/* IO block queue for this pcb
	pstate		longword;		/* process state
	shellp		longword;		/* address of shell's context
	killpending	longword;		/* please exit...
	cmd_mode	longword;		/* command mode
	cmd_switch	longword;		/* command mode switch

	fq		QUEUE;			/* file queue
	stdin_name	address (byte);
	stdout_name	address (byte);
	stderr_name	address (byte);
	stdin_mode	byte dimension (8);	/* access modes for 
	stdout_mode	byte dimension (8);	/* standard channels
	stderr_mode	byte dimension (8);
	stdin		address (FILE);         /* addr of stdin file descr
	stdout		address (FILE);         /* addr of stdout file descr
	stderr		address (FILE);         /* addr of stderr file descr

	quad_fill0	byte dimension (8-(.&7)) fill;
	timestamp	quadword;
	cputime		quadword;		/* number of nsec process was running
	qexpire		longword;
	qexpire_dec	longword;
	quantum		longword;

	exit_status	longword;		/* final status code
	affinity	longword;
	created_affinity	longword;
	parentpid	longword;		/* parent's pid
	pid		longword;
	last_processor  longword;
	name		byte dimension MAX_NAME;
	startup		address (entry);	/* user defined startup
	task		address (entry);	/* task address
	rundown		address (entry);	/* rundown routine
	completion	address (SEMAPHORE);	/* posted by rundown routine
	opened    	address (SEMAPHORE);	/* posted by krn$_process
	pri		longword;		/* 0 <= pri <= MAX_PRI
	acp		address (ALPHA_CTX);	/* context is on stack

	qualp		address;
	dev_name 	byte dimension MAX_NAME;
	test_mask 	address (byte unsigned);
	dis_table 	address (DIAG_DIS_TABLE);
	sup_dev 	address (byte);
	globals 	address;
	diag_common 	address;

	stacksize	longword;		/* # bytes in stack
	argc		longword;
	argv		longword dimension (4);	/* keep this first 
	quad_fill2	byte dimension (8-(.&7)) fill;
	stack		byte dimension (8);	/* this must be last
end PCB;




/*
/* Process states
/*
constant (
	NULL,
	WAIT,
	READY,
	RUNNING
) equals 1 increment 1 prefix "KRN$K" tag "";

/*
/* Error Types
/*
constant (
	HARD,
	SOFT,
	FATAL,
) equals 1 increment 1 prefix "DIAG$K" tag "";

/*+
/* ============================================================================
/* = LOCK - spinlock data structures                                          =
/* ============================================================================
/*
/* STRUCTURE OVERVIEW:
/*
/*      This data structure defines a spinlock.
/*
/* STRUCTURE MEMBERS:
/*
/*:
/*       ----------------------------------------------------------------------
/*       Structure Members    | Data Type  | Description
/*       ----------------------------------------------------------------------
/*                      lock  |  longword  | contents of the actual lock
/*                            |            |
/*                   req_ipl  |  longword  | IPL that spinlock must run at
/*                            |            |
/*                   sav_ipl  |  longword  | IPl previous to spinlock, and the
/*                            |            | IPL that will be restored.
/*                            |            |
/*                  attempts  |  longword  | number of times this spinlock has been
/*                            |            | taken
/*                            |            |
/*                   retries  |  longword  | number of times the lock has failed
/*                            |            |
/*                     owner  |  longword  | the PID of the current owner
/*                            |            |
/*                     count  |  longword  | number of concurrent locks
/*:      ----------------------------------------------------------------------
/*
/*-
aggregate LOCK structure prefix "" tag "";
	"value"		longword;
	req_ipl		longword;
	sav_ipl		longword;
	attempts	longword;
	retries		longword;
	owner		longword;
	count		longword;
	next_number	longword;
	now_serving	longword;
	pad		longword dimension (7);	/* Ensure 64byte alignment
end LOCK;

/*+
/* ===============================================
/* = HQE - Handler queue entry			 =
/* ===============================================
/*
/* STRUCTURE OVERVIEW:
/*
/* Handler queue entry
/*
/*
/* STRUCTURE MEMBERS:
/*
/*:
/*       ----------------------------------------------------------------------
/*       Structure Members    | Data Type  | Description
/*       ----------------------------------------------------------------------
/*                     flink  |	address    | forward link 
/*                            |            | 
/*                     blink  |	address    | backward link
/*                            |            | 
/*                     vector |	longword   | SCB index
/*                            |            | 
/*                     handler|	address    | address of handler
/*                            |            | 
/*                     param  |	longword   | SCB parameter
/*:      ----------------------------------------------------------------------
/*
/*-
/*

aggregate HQE structure prefix "" tag "";
	flink	address (HQE);
	blink	address (HQE);
	vector	longword;
	handler	address (entry);	
	param	longword;
end HQE;

/*+
/* ==============================================
/* = ASJD - Alpha SetJmp Data			=
/* ==============================================
/*
/* STRUCTURE OVERVIEW:
/*
/* The Alpha SetJmp Data structure holds sufficient information to implement setjmp/longjmp on an Alpha machine,
/* given an execution environment which complies with the Alpha standard calling conventions.
/*
/* STRUCTURE MEMBERS:
/*
/*:
/*       -------------------------------------------------------------------------------------------------------
/*       Structure Members    | Data Type  | Description
/*       -------------------------------------------------------------------------------------------------------
/*                     sp     | quadword   | SP after space is reserved for ASJD structure on the stack in setjmp.
/*                            |            |
/*                     rn     | quadword   | Rn at time of setjmp call (n=1:15, 26, 27, 29).
/*                            |            |
/*                     fn     | quadword   | Fn at time of setjmp call (n=2:9).
/*:      -------------------------------------------------------------------------------------------------------
/*
/*-
/*
aggregate ASJD structure prefix "ASJD$" tag "";
	sp	quadword;
	r1	quadword;
	r2	quadword;
	r3	quadword;
	r4	quadword;
	r5	quadword;
	r6	quadword;
	r7	quadword;
	r8	quadword;
	r9	quadword;
	r10	quadword;
	r11	quadword;
	r12	quadword;
	r13	quadword;
	r14	quadword;
	r15	quadword;
	r26	quadword;
	r27	quadword;
	r29	quadword;
end ASJD;

/*+
/* ==============================================
/* = SJD_UNION - SetJmp Data Union		=
/* ==============================================
/*
/* STRUCTURE OVERVIEW:
/*
/* The SetJmp Data union is used to handle Alpha setjmp context data.  It is encapsulted in the SJQ
/* structure.
/*
/* STRUCTURE MEMBERS:
/*
/*:
/*       -------------------------------------------------------------------------------------------------------
/*       Structure Members    | Data Type  | Description
/*       -------------------------------------------------------------------------------------------------------
/*                     alpha  | ASJD       | Alpha setjmp data block.
/*:      -------------------------------------------------------------------------------------------------------
/*
/*-
/*
aggregate sjd_union union;
    asjd    ASJD;
end sjd_union;

/*+
/* ==============================================
/* = SJQ - SetJmp Queue				=
/* ==============================================
/*
/* STRUCTURE OVERVIEW:
/*
/* The SetJmp Queue is a per-process queue which holds the environment data required by setjmp/longjmp for the
/* process.
/*
/* STRUCTURE MEMBERS:
/*
/*:
/*       -------------------------------------------------------------------------------------------------------
/*       Structure Members    | Data Type  | Description
/*       -------------------------------------------------------------------------------------------------------
/*                     flink  |	address    | forward link 
/*                            |            | 
/*                     blink  |	address    | backward link
/*                            |            | 
/*                     envid  | longword   | environment identifier
/*                            |            | 
/*		       sjd    | SJD        | setjmp environment data
/*:      -------------------------------------------------------------------------------------------------------
/*
/*-
/*
aggregate SJQ structure prefix "" tag "";
	flink	address (SJQ);			/* Forward link
	blink	address (SJQ);			/* Backward link
	sjd	sjd_union;			/* setjmp environment data
	envid	longword;			/* environment ID
end SJQ;

item jmp_buf longword unsigned typedef;		/* Define jmp_buf type as longint.
constant PROC_KILL_SJ_ID equals 0;		/* Process kill setjmp id.
constant EXDEP_SJ_ID equals 1;			/* Examine/deposit setjmp id.
constant MEMTEST_SJ_ID equals 2;		/* Memtest setjmp id.

end_module;
