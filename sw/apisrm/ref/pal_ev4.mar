	.title	EV4 - ALPHA VMS PALcode for HUDSON CMOS-4 ALPHA chip
	.ident	/V5.56-1/
;
;****************************************************************************
;*									    *
;*  Copyright (c) 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996	    *
;*  by DIGITAL Equipment Corporation, Maynard, Mass.			    *
;* 									    *
;*  This software is furnished under a license and may be used and  copied  *
;*  only  in  accordance  with  the  terms  of  such  license and with the  *
;*  inclusion of the above copyright notice.  This software or  any  other  *
;*  copies  thereof may not be provided or otherwise made available to any  *
;*  other person.  No title to and ownership of  the  software  is  hereby  *
;*  transferred.							    *
;* 									    *
;*  The information in this software is subject to change  without  notice  *
;*  and  should  not  be  construed  as  a commitment by DIGITAL Equipment  *
;*  Corporation.							    *
;* 									    *
;*  DIGITAL assumes no responsibility for the use or  reliability  of  its  *
;*  software on equipment which is not supplied by DIGITAL.		    *
;*									    *
;****************************************************************************

.sbttl	Edit History
;+
; Who		Rev	When		What	
; ------------	---	-----------	--------------------------------
; R.T.WITEK	X0.0	21-Nov-1989	Start first pass
; S.J.MORRIS	X0.1	14-Mar-1990	Finish first pass
; S.J.MORRIS	X1.0	11-Oct-1990	Queue (first working version)
; S.J.MORRIS	X1.1	11-Oct-1990	MTPR_IPL fixed (did not work)
; S.J.MORRIS	X1.2	11-Oct-1990	MFPR_SISR fixed (dest shifted by 1 bit)
; S.J.MORRIS	X1.3	11-Oct-1990	FEN faults Fen/Opdec wrong if FEN=0
; S.J.MORRIS	X1.4	11-Oct-1990	MFPR_PS	SP alignment field not cleared
; S.J.MORRIS	X1.5	11-Oct-1990	Frame builder FOW when writeing non-KSP,
;					reported as ACV
; S.J.MORRIS	X1.6	11-Oct-1990	ASTER Fix to work with EV3 AST's.
; S.J.MORRIS	X2.0	11-Oct-1990	PROBE[w] Fix ACV/TNV determination
; S.J.MORRIS	X2.1	16-Oct-1990	ADUINT Bug fixes to ADU interface code
; S.J.MORRIS	X2.2	16-Oct-1990	FOE Fix FOE vs ACV check
; S.J.MORRIS	X2.3	16-Oct-1990	ASTEN Fix typo in 10-11-90 ASTER fix
; S.J.MORRIS	X3.0	16-Oct-1990	PROBE[w] Error handler was not PIC
; S.J.MORRIS	X3.1	18-Oct-1990	Frame builder PC+4, reported instead of
;					PC when arith or unaligned access fails
;					and the target stack is non-kernel,
;					and bogus.
; S.J.MORRIS	X3.2	18-Oct-1990	Queue Fix alignement checking on 2 queue
;					instr's and insert test code for MP
;					queue cases
; S.J.MORRIS	X3.3	18-Oct-1990	REI Failed REI (other than sp align
;					case) that took  correct tb fill,
;					would report bogus PC.
; S.J.MORRIS	X3.4	18-Oct-1990	GET_ADDR Fix address calculation for
;					 <15> = 1.
; S.J.MORRIS	X3.5	18-Oct-1990	Timer int's Add delivery of delayed
;					timer interrupts.
; S.J.MORRIS	X3.6	18-Oct-1990	Frame builder Force new PS<sw> = 0.
; S.J.MORRIS	X3.7	18-Oct-1990	Frame builder Undo previous, it was ok
;					after all.
; S.J.MORRIS	X3.8	18-Oct-1990	MCHK Stub out MCHK code for now,
;					cause halt.
; S.J.MORRIS	X3.9	27-Nov-1990	Add BOOT debug logging and revision info
; S.J.MORRIS	X3.10	28-Nov-1990	Add more BOOT debug logging
; S.J.MORRIS	X3.11	29-Nov-1990	Change address asignments for ADU IOM.
; S.J.MORRIS	X3.12	10-Dec-1990	Disable performance features for debug
; S.J.MORRIS	X3.13	11-Dec-1990	Remove sole MULQ from pal.
; S.J.MORRIS	X3.14	12-Dec-1990	Implement cycle counter
; S.J.MORRIS	X3.15	13-Dec-1990	Fix MCHK/HALT code for non-adu.
; S.J.MORRIS	X3.16	19-Dec-1990	Have REMQUEld/d return entry addr in R1
; S.J.MORRIS	X3.17	19-Dec-1990	Add stq_c to rei flow to clear lock bit.
; S.J.MORRIS	X3.18	20-Dec-1990	Remove temporary stacks and page tables.
; S.J.MORRIS	X3.19	26-Dec-1990	Add support for IT, AT.
; S.J.MORRIS	X3.20	04-Jan-1991	Fix bug in RSCC.
; S.J.MORRIS	X3.21	07-Jan-1991	Fix returned R1 in REMQUEx/x
; S.J.MORRIS	X3.22	09-Jan-1991	Add support for NPHALT.
; S.J.MORRIS	X3.23	11-Jan-1991	Split XTBIS, to ITBIS, DTBIS per hw.
; S.J.MORRIS	X3.24	15-Jan-1991	Add support for single step
; S.J.MORRIS	X3.25	15-Jan-1991	Add support for FP emulator
; S.J.MORRIS	X3.26	16-Jan-1991	Add iflush's to tbis,tbia,tbiap.
; S.J.MORRIS	X3.27	06-Feb-1991	Integrate FP emulation code.
; S.J.MORRIS	X3.28	06-Feb-1991	Fix bug in CONTinue, trashing pt25.
; S.J.MORRIS	X3.29	14-Feb-1991	Fix alignment of RAX PCB.
; S.J.MORRIS	X3.30	19-Feb-1991	Fix palcode violation in Queue errors.
; S.J.MORRIS	X3.31	13-Mar-1991	Add support of 3 ADU's in a box.
; S.J.MORRIS	X3.32	14-Mar-1991	Add support for virtualizing memory.
; S.J.MORRIS	X3.33	26-Mar-1991	Fix SWPCTX in virtual mode.
; S.J.MORRIS	X3.34	29-Mar-1991	Conditionalize x3.21 support for VMS
; S.J.MORRIS	X3.35	22-Apr-1991	Add EV4 native/pal DTB miss routine.
; S.J.MORRIS	X3.36	23-Apr-1991	Read fill_syndrome before fill_addr.
; S.J.MORRIS	X3.37	24-Apr-1991	Fix rax interface timeing problem.
; S.J.MORRIS	X3.38	03-Jun-1991	Add READ_UNQ,WRITE_UNQ
; S.J.MORRIS	X3.39	03-Jun-1991	Add DTBIS on FOE and FOW.
; S.J.MORRIS	X3.40	03-Jun-1991	Add ev3 pal int bug workaround.
; S.J.MORRIS	X3.41	05-Jun-1991	Add visability to FP regs
; S.J.MORRIS	X3.42	05-Jun-1991	Add dummy support for rd/wr fp_ctl.
; S.J.MORRIS	X3.43	28-Jun-1991	Add code to detect EV4.
; S.J.MORRIS	X3.44	28-Jun-1991	Fix CVTTQ for neg numbers in FP emul.
; S.J.MORRIS	X3.45	28-Jun-1991	Allow FP em to work with MP.
; S.J.MORRIS	X3.46	15-JuL-1991	Fix palcode violation in  x3.39
; S.J.MORRIS	X3.47	18-JuL-1991	Change order reading IPR's in console.
; S.J.MORRIS	X3.48	19-JuL-1991	Add preliminary TBISI & TBISD
; S.J.MORRIS	X3.49	19-JuL-1991	Add preliminary L3 mapped pte's code.
; S.J.MORRIS	X3.50	04-Aug-1991	Fix console saver for EV4 FP present.
; S.J.MORRIS	X3.51	06-Aug-1991	Fix typo in WRITE_UNQ.
; S.J.MORRIS	X3.52	06-Sep-1991	Work around bug in ev4p1 stream buffer.
; S.J.MORRIS	X3.53	12-Sep-1991	Enable EV4 branch history table.
; S.J.MORRIS	X3.54	18-Sep-1991	Fix reg stomping r0 in x3.49
; S.J.MORRIS	X3.55	23-Sep-1991	Reassign entry point for TBISI/TBISD
; S.J.MORRIS	X3.56	23-Sep-1991	Add MF ASTEN/ASTSR
; S.J.MORRIS	X3.57	24-Sep-1991	Make biu and abox ctl's patchable.
; S.J.MORRIS	X3.58	25-Sep-1991	Do not put old ps in R7 for excpt/ints
; S.J.MORRIS	X4.00	30-Sep-1991	Re-write for EV4.
; S.J.MORRIS	X4.01	08-DEC-1991	More re-write for EV4.
; S.J.MORRIS	X4.02	12-Dec-1991	ADD performance monitoring code.
; S.J.MORRIS	X4.03	17-Dec-1991	Fix write_unq.
; S.J.MORRIS	X4.04	24-Dec-1991	Redo interrupt flows.
; S.J.MORRIS	X4.05	07-Jan-1992	Fix Performance counter code.
; S.J.MORRIS	X4.06	07-Jan-1992	Add ASTEN traceing option.
; S.J.MORRIS	X4.07	10-Jan-1992	Add dumy support for mxpr datafx
; S.J.MORRIS	X4.08	10-Jan-1992	Fix bug in bagged REI halt flow
; S.J.MORRIS	X4.09	14-Jan-1992	Rework HW int to remove "extra" ldl/q
; S.F.Shirron	X4.09A	22-Jan-1992	Cobra support
; S.J.MORRIS	X4.10	16-Jan-1992	Add weed out for external soft errors.
; S.J.MORRIS	X4.11	17-Jan-1992	Fix write_unq again.
; S.J.MORRIS	X4.12	22-Jan-1992	Fix error in PHYSICAL_ITB and NDTB.
; S.J.MORRIS	X4.13	22-Jan-1992	Fix error in perfmon zaper into rei.
; S.J.MORRIS	X4.14	22-Jan-1992	Add conditional, for virt phy tb's.
; S.J.MORRIS	X4.15	22-Jan-1992	ADD palcode varient indicator.
; S.J.MORRIS	X4.16	23-Jan-1992	Make bc_ctl fields be symbolic.
; S.J.MORRIS	X4.17	23-Jan-1992	Recalc high sw int on "cont".
; S.J.MORRIS	X4.18	23-Jan-1992	Remove extra load in long vir pte fill.
; S.F.Shirron	X4.18A	24-Jan-1992	Merge changes since X4.09
; S.F.Shirron	X4.18B	04-Feb-1992	Fix MCHK handling, fix MTPR_IPIR
; S.F.Shirron	X4.18C	06-Feb-1992	Set PT3=0 in MCHK, save R17 in MTPR_x
; S.F.Shirron	X4.18D	14-Feb-1992	UART receive buffering, modem support
; S.F.Shirron	X4.18E	24-Feb-1992	Clear pending errors at startup
; S.F.Shirron	X4.18F	24-Feb-1992	Set PT25<9> for EV4 pass1
; S.F.Shirron	X4.18G	28-Feb-1992	Hack in MTPR_MCES to reset IPL table
; S.F.Shirron	X4.18H	09-Mar-1992	Clean up, add serial bus stuff
; S.F.Shirron	X4.18I	09-Mar-1992	Remove serial bus stuff for now
; S.J.MORRIS	X4.19	23-Jan-1992	Detect ev4 pass 2.
; S.J.MORRIS	X4.20	10-Feb-1992	Add "special" debug hooks.
; S.J.MORRIS	X4.21	17-Jan-1992	Add MCHK & ECC handling code.
; S.J.MORRIS	X4.22	18-Feb-1992	Add unaligned fixup in pal.
; S.J.MORRIS	X4.23	04-Mar-1992	Add AMOVRR and AMOVRM.
; S.G.MEIER	X4.24	11-Mar-1992	Add real resident queues.
; S.J.MORRIS	X4.25	13-Mar-1992	Fixup and code shuffleing.
; S.F.Shirron	X4.25A	16-Mar-1992	Merge changes since X4.18
; S.F.Shirron	X4.25B	17-Mar-1992	Build a logout frame for machine checks
; S.J.MORRIS	X4.26	16-Mar-1992	More logging.
; S.J.MORRIS	X4.27	17-Mar-1992	Fix wrong posting of MCHKLOGOUT offset.
; S.J.MORRIS	X4.28	17-Mar-1992	Unlock va/mmcsr on fetch error/ill_una
; S.J.MORRIS	X4.29	17-Mar-1992	Fix baged REI/passive release bug.
; S.J.MORRIS	X4.30	25-Mar-1992	Fix PVC in unaligned recovery.
; S.J.MORRIS	X4.31	25-Mar-1992	Set execp pc to pc on unalign mmerror.
; S.F.Shirron	X4.31A	26-Mar-1992	Merge changes since X4.25
; S.F.Shirron	X4.31B	30-Mar-1992	Fix HW_TIMER to not miss UART interrupts
; S.F.Shirron	X4.31C	04-Apr-1992	Add routine to set HALT LED
; S.F.Shirron	X4.31D	09-Apr-1992	For now, always halt in hw_system_event
; S.J.MORRIS	X4.32	04-Apr-1992	Fix bug in MTPR_PERFMON.
; S.J.MORRIS	X4.33	04-Apr-1992	Fix bug in unaligned LD, with ACV on SP
; S.F.Shirron	X4.33A	10-Apr-1992	Merge changes since X4.31
; J.A.Denisco	X4.33B	10-Apr-1992	Add mchk for uncrds.
; J.A.Denisco	X4.33C	15-Apr-1992	Add hwe stuff in cserve (cobratt).
; S.F.Shirron	X4.33D	21-Apr-1992	Clean up ^P/BREAK, add CSERVE
; S.F.Shirron	X4.33E	24-Apr-1992	Reset HIER/SIER when exiting console
; S.F.Shirron	X4.33F	14-May-1992	Handle Fbus interrupts, fix lost ticks
; S.F.Shirron	X4.33G	27-May-1992	OSF work, clear pending Cbus errors
; S.J.MORRIS	X4.34	23-Apr-1992	Add CSERVE.
; S.J.MORRIS	X4.35	18-Feb-1992	Detect/log ARITH under MCHK errors.
; S.J.MORRIS	X4.36	18-Feb-1992	Read out BC_TAG on MCHK's.
; S.J.MORRIS	X4.37	19-Feb-1992	Add alt mchk impure, and bld LA.
; S.J.MORRIS	X4.38	26-Feb-1992	Clear lock/intr_flags to/from console.
; S.J.MORRIS	X4.39	30-Feb-1992	Rewrite queue instructions.
; S.J.MORRIS	X4.40	02-Apr-1992	Rewrite probe instructions.
; S.J.MORRIS	X4.41	04-Apr-1992	Add trace 2 reg option.
; S.J.MORRIS	X4.42	20-Apr-1992	Disable trace options while in console.
; S.J.MORRIS	X4.43	20-Apr-1992	Add process prefmon option.
; S.J.MORRIS	X4.44	20-Apr-1992	Rewrite MCHK for ECC in HW.
; S.J.MORRIS	X4.45	20-Apr-1992	Finish data alignment ECO.
; S.J.MORRIS	X4.46	26-Apr-1992	Rewrite MCHK pal detected MCHK/HALT's.
; S.J.MORRIS	X4.47	04-May-1992	Remove bonus STx/C and RC's.
; S.J.MORRIS	X4.48	05-May-1992	Clean up REI.
; S.J.MORRIS	X4.49	07-May-1992	Clean up SWPCTX.
; S.J.MORRIS	X4.50	12-May-1992	Add scratch regs to CHMK/CHME.
; S.J.MORRIS	X4.51	13-May-1992	Fix ack of CRD int's.
; S.F.Shirron	X4.51A	27-May-1992	Merge changes since X4.33
; S.F.Shirron	X4.51B	29-May-1992	Add LINT parity error workaround
; S.F.Shirron	X4.51C	02-Jun-1992	Disable Cbus back-to-back transactions
; S.J.MORRIS	X4.52	19-May-1992	PUP with I_super page off, not on.
; S.J.MORRIS	X4.53	19-May-1992	Minor CRD acking fix (again argh...)
; S.J.MORRIS	X4.54	27-May-1992	Fix wrong base reg in mchk logout bldr
; S.J.MORRIS	X4.55	28-May-1992	Remove possible pvc in unaligned fixup.
; S.J.MORRIS	X4.56	05-Jun-1992	ACK CRD's under MCHK's.
; S.J.MORRIS	X4.57	09-Jun-1992	Add more debug features.
; S.J.MORRIS	X4.58	09-Jun-1992	Fix bug in REMQTIx[r].
; S.F.Shirron	X4.58A	10-Jun-1992	Merge changes since X4.51
; S.F.Shirron	X4.58B	10-Jun-1992	Discard some Cbus errors on secondary
; S.F.Shirron	X4.58C	10-Jun-1992	Fix missing interrupt enable for DSR
; S.F.Shirron	X4.58D	11-Jun-1992	Conditionalize ^P and break
; H.Buckingham  X4.58E	23-Jun-1992	Add wr_cbits to cserve
; S.F.Shirron	X4.58F	10-Jul-1992	Fix LINT bug code, add UPDATE_IPL
; S.J.MORRIS	X4.59	27-May-1992	Minor optimization to arith.
; S.J.MORRIS	X4.60	29-May-1992	Fix retval for MTPR_FEN, MTPR_DATAFX.
; S.J.MORRIS	X4.61	10-Jun-1992	Add abox,biu, and fp ctl's to impure.
; S.J.MORRIS	X5.00	19-Jun-1992	Integrate with OSF.
; S.F.Shirron	X5.00A	23-Jun-1992	Merge changes since X4.58
; S.F.Shirron	X5.00B	10-Jul-1992	Fix LINT bug code, add UPDATE_IPL
; S.J.MORRIS	X5.01	25-Jun-1992	Improve mchk/halt register unwinding.
; S.J.MORRIS	X5.02	25-Jun-1992	Don't clober fr0/fpcsr in enter/exit console.
; S.J.MORRIS	X5.03	25-Jun-1992	Add swppal support for OSF.
; S.J.MORRIS	X5.04	01-Jul-1992	Reset xier after baged rei.
; S.F.Shirron	X5.04A	15-Jul-1992	Merge changes since X5.00
; S.F.Shirron	X5.04B	27-Jul-1992	Add local/auxiliary merging
; S.F.Shirron	X5.04C	29-Jul-1992	Read saved values from TOY clock RAM
; S.F.Shirron	X5.04D	31-Jul-1992	Enable SWPPAL
; S.J.MORRIS	X5.05	21-Jul-1992	Fix SW1 and AST.
; S.J.MORRIS	X5.06	21-Jul-1992	Fix alignment check in REMQHIx.
; S.J.MORRIS	X5.07	28-Jul-1992	Update PVC BSR structures.
; S.J.MORRIS	X5.08	28-Jul-1992	Update PCB on HW and SW halts.
; S.J.MORRIS	X5.09	31-Jul-1992	Make trace base/limit be loadable.
; S.F.Shirron	X5.09A	31-Jul-1992	Merge changes since X5.04
; J.A.DeNisco	X5.09B	05-Aug-1992	Add cserve 11
; J.A.DeNisco	X5.09C	06-Aug-1992	A better cserve 11
; J.A.DeNisco	X5.09D	06-Aug-1992	Change baud rate for robust mode
; J.A.DeNisco	X5.09E	11-Aug-1992	Eliminate cserve 11
; S.J.MORRIS	X5.10	13-Aug-1992	Preserve logout ptr accros arith/mchk
; S.J.MORRIS	X5.11	18-Aug-1992	Fix AMOVRx with unaligned dest.
; S.J.MORRIS	X5.12	19-Aug-1992	Fix more AMOVRx probe problems.
; S.F.Shirron	X5.12A	20-Aug-1992	Merge changes since X5.09
; S.F.Shirron	X5.12B	21-Aug-1992	Fix MTPR_PERFMON for Cobra
; S.F.Shirron	X5.12C	26-Aug-1992	Fix baud rate addresses in HWRPB
; S.F.Shirron	X5.12D	28-Aug-1992	Minor work for pass 3
; S.F.Shirron	X5.12E	31-Aug-1992	Delay HALT switch until after callbacks
; S.F.Shirron	X5.12F	01-Sep-1992	Ignore HALT switch if in console mode
; S.J.MORRIS	X5.13	21-Aug-1992	Return correct mmflag on q header probe.
; S.J.MORRIS	X5.14	24-Aug-1992	Fix Ill_una/mmfault case.
; S.J.MORRIS	X5.15	24-Aug-1992	Remove br not taken from tb fills.
; S.J.MORRIS	X5.16	26-Aug-1992	Fix bug in sw1/ast flow.
; S.J.MORRIS	X5.17	27-Aug-1992	Remove RAX support.
; S.J.MORRIS	X5.18	27-Aug-1992	Remove VMS2OSF support.
; S.J.MORRIS	X5.19	08-Sep-1992	Misc clean up.
; S.J.MORRIS	X5.20	08-Sep-1992	Fixup AMOVRx LD_L/ST_C retry failure.
; S.F.Shirron	X5.20A	10-Sep-1992	Merge changes since X5.12
; S.J.MORRIS	X5.21	14-Sep-1992	Fixup typo in 5.20.
; S.F.Shirron	X5.21A	15-Sep-1992	Merge changes since X5.20
; S.F.Shirron	X5.21B	24-Sep-1992	Fix UART interrupt initialization
; S.J.MORRIS	X5.22	14-Sep-1992	Add mp _c debuggingin amovrx.
; S.J.MORRIS	X5.23	21-Sep-1992	Change HALT code to match SRM.
; S.J.MORRIS	X5.24	23-Sep-1992	Change MCHK frame to match SRM.
; S.F.Shirron	X5.24A	25-Sep-1992	Merge changes since X5.21
; S.F.Shirron	X5.24B	25-Sep-1992	Work on machine check stuff
; S.F.Shirron	X5.24C	05-Oct-1992	Restore BCC correctly
; S.F.Shirron	X5.24D	05-Oct-1992	Fix trashing of R0 on halts
; S.F.Shirron	X5.24E	07-Oct-1992	Save baud rate for console, fix 300 baud
; S.F.Shirron	X5.24F	08-Oct-1992	Properly save BIU_STAT and BIU_ADDR
; S.F.Shirron	X5.24G	13-Oct-1992	Preserve IPL when unblocking interrupts
; S.F.Shirron	X5.24H	14-Oct-1992	Fix CTB addresses (in HWRPB)
; S.F.Shirron	X5.24I	16-Oct-1992	Reset PCBB before entering console
; S.J.MORRIS	X5.25	16-Oct-1992	Optimize pass 2 mchk workaround.
; S.F.Shirron	X5.25A	16-Oct-1992	Merge changes since X5.24
; S.F.Shirron	X5.25B	24-Oct-1992	Modify PAL banner
; S.F.Shirron	X5.25C	11-Nov-1992	Fix BIU_STAT/BIU_ADDR in the 630 frame
; S.F.Shirron	X5.25D	13-Nov-1992	Add halt code for mailbox timeout
; S.J.MORRIS	X5.26	28-Sep-1992	Optimizations to queue instrs.
; S.J.MORRIS	X5.27	29-Sep-1992	Preserve mchk code on dbl mchk's.
; S.J.MORRIS	X5.28	06-Oct-1992	Flush Dcache on Mchk's.
; S.J.MORRIS	X5.29	07-Oct-1992	Add support for EV45.
; S.J.MORRIS	X5.30	08-Oct-1992	Set Sier properly on AST's.
; S.J.MORRIS	X5.31	23-Oct-1992	Calc impure ptr during reset.
; S.J.MORRIS	X5.32	13-Nov-1992	Disable CRD's if MCES<DPC> is set.
; S.J.MORRIS	X5.33	13-Nov-1992	Default ABOX_CTL has CRD's disabled.
; S.J.MORRIS	X5.34	18-Nov-1992	Fix swppal to addr.
; S.J.MORRIS	X5.35	20-Nov-1992	Set Ra/Rb in hw_rei to R31.
; S.J.MORRIS	X5.36	23-Nov-1992	Let I-cache parity error be retryable.
; S.F.Shirron	X5.36A	30-Nov-1992	Merge changes since X5.25
; S.J.MORRIS	X5.37	30-Nov-1992	Optimize arith flow.
; S.F.Shirron	X5.37A	07-Dec-1992	Merge changes since X5.36
; S.F.Shirron	X5.37B	08-Dec-1992	Capture I/O and memory CSRs
; S.F.Shirron	X5.37C	29-Dec-1992	Fix bug in HW_CBUS_ERROR
; S.F.Shirron	X5.37D	19-Jan-1993	Add workaround for FIVECT parity errors
; S.F.Shirron	X5.37E	09-Feb-1993	Fix LINT bug and NO ACK bug workarounds
; S.F.Shirron	X5.37F	09-Feb-1993	Add MBs, clear CBE when clearing SIC
; S.J.MORRIS	X5.38	14-Jan-1993	Fix EV45 ic-par bug, and arith+mchk bug.
; S.J.MORRIS	X5.39	15-Jan-1993	Update flush_ic stalls.
; S.F.Shirron	X5.39A	11-Feb-1993	Merge changes since X5.37
; S.F.Shirron	X5.39B	25-Feb-1993	Remove VMS2OSF for good
; S.F.Shirron	X5.39C	10-Mar-1993	CSR15 is four bits, not two
; S.F.Shirron	X5.39D	11-Mar-1993	Add CFW, GENERIC, and LCADS support
; S.F.Shirron	X5.39E	22-Mar-1993	Turn off BCC allocation when resetting
; J.A.DeNisco	X5.39F	26-Mar-1993	Add Jensen support
; J.A.DeNisco	X5.39G	29-Mar-1993	Add Sable support
; S.F.Shirron	X5.39H	30-Mar-1993	Work around C³ bug (BCC allocation off)
; S.F.Shirron	X5.39I	05-Apr-1993	Implement CFLUSH
; J.A.DeNisco	X5.39J	02-Apr-1993	Add Morgan support
; M.Ciaffi		22-Apr-1993	Set HWE in ICCSR for Sable system
; S.J.MORRIS	X5.40	26-Apr-1993	Fix bug in queue unlock error recover.
; S.F.Shirron	X5.40A	23-Apr-1993	Merge changes since X5.39
; J.A.DeNisco	X5.40B	29-Apr-1993	Add PCI init code.
; D. T. Rice	X5.40C	29-Apr-1993	Started the interrupt/machine check
;					integeration for morgan.
; S.J.MORRIS    X5.41   28-Apr-1993     Fix INSQUEQ/D with unaligned H.
; S.F.Shirron	X5.41A	29-Apr-1993	Merge changes since X5.40
; J.A.DeNisco	X5.41B	06-May-1993	Don't write biu_ctl for jensen.
; D.T. Rice	X5.41C  06-May-1993	Merge in the Morgan changes.  This
;					included a couple of bug fixes in
;					handling the pic.  There was an improper
;					use of r14.
; S.F.Shirron	X5.41D	12-May-1993	Add CSERVEs for START and CALLBACK
; H.Buckingham  X5.41E	13-May-1993	Add sromtt_putc for Sable
; J.A.DeNisco		21-May-1993	Don't restore biu_ctl for morgan.
; D.T.Rice	X5.41F	26-May-1993	Corrected error in morgan eoi sequence.
;					The sequence failed to clear the cascade
;					interrupt from the first controller.
; S.G.MEIER	X5.42	14-Apr-1993	Fix swppal bug, 
;					Allow swppal to address 0,
;					fix IC parity error bug,
;					Add EV45 ctl bits.
; S.J.MORRIS	X5.43	22-Jun-1993	Fix 3 bugs due to new MT/MF Palcode restriction
; S.J.MORRIS	X5.44	22-Jun-1993	Fix bogus unknown mchk code.
; S.F.Shirron	X5.44A	30-Jun-1993	Merge changes since X5.41
; S.F.Shirron	X5.44B	06-Aug-1993	Use names for numeric constants
; E.A.Rasmussen X5.44C  28-Aug-1993     Added EB64 support.
; J.A.DeNisco	X5.44D	03-Sep-1993	Support jensen interrupts.
; S.F.Shirron	X5.44E	07-Sep-1993	Fix problems found during Sable debug
; E.A.Rasmussen X5.44F  17-Sep-1993     Added EB64+ support.
; P.E.LaRochelleX5.44G  23-Sep-1993     reset_morgan_hardware, mask de200 and
;					COM1, COM2 interrupts via PIC chip.
; ************* These are from Hudson and didn't get back into CMS **********
; E.A.Rasmussen X5.44G	21-Sep-1993	Added LCA4 and EB66 support.
; E.A.Rasmussen X5.44H  15-Oct-1993	Fix problem with enabling CRD interrupts
;					for LCA.
; P.E.LaRochelleX5.44I  10-Nov-1993	Fix setup of SIO config space base
;					address by adding ldah r12, ^x100(r12)
;****************************************************************************
; C.G.Heiter	X5.44H	30-Sep-1993	Add Medulla support
; P.E.LaRochelleX5.44I  05-Oct-1993     reset_morgan_hardware, mask floppy ints
; S.F.Shirron	X5.44J	13-Oct-1993	Sable fixes (mostly for MP)
; S.F.Shirron	X5.44K	24-Nov-1993	Add support for detection of EV45
; S.J.MORRIS	X5.45	19-Aug-1993	Add stall to uni-p MTPR_IPIR case, extend abox_ctl
; S.J.MORRIS	X5.46	07-Oct-1993	Fix PVC in CHMK, frame builder, and REI.
; J.Wiedemeier	X5.47	30-Nov-1993	Add support for LCA4s.
; S.F.Shirron	X5.47A	01-Dec-1993	Merge changes since X5.44
; D.T. Rice	X5.47B	15-Dec-1993	Merged in the Mustang changes and the
;					changes needed by eb66 at the time the
;					code was pulled.  Lean support was also
;					added.
; P.E.LaRochelleX5.47C	17-Dec-1993	Turn all PIC IRQs off except IRQ2
; C.G.Heiter	X5.47D	23-Dec-1993	Medulla: BL1 release
; C.G.Heiter	X5.47E	29-Dec-1993	Medulla: merge in LCA support 
; S.F.Shirron	X5.47F	11-Jan-1994	Add CSERVE JUMP_TO_ARC
; D.T. Rice	X5.47G  18-Jan-1994	Add in new interrupt support for
;					mustang.  An additional level of
;					interrupts were added to support the pci
;					devices.
; S.F.Shirron	X5.47H	04-Feb-1994	Add sanity check in PAL$AST_INTERRUPT,
;					add pass 2 T2 changes
; D.T. Rice	X5.47I	10-Feb-1994	Merged avanti changes with ast changes
; D.T. Rice	X5.47J	07-Feb-1994	Added a conditional for LCA4_PASS2 so
;					that initial debug of the pass 2 chip
;					could be done.  Note that on the
;					addresses for the io, mem, and config
;					space have been changed and have been
;					added as a condtional outside the code.
; J.Wiedemeier  X5.48	04-Feb_1994	Fix interrupt passive release problem
;					Fix unknown mchk code for LCA
;					Fix potential memory error left after scrub (LCA)
; S.F.Shirron	X5.48A	11-Feb-1994	Merge changes since X5.47
; D. T. Rice	X5.48B	14-Feb-1994	change machine check handler to return
;					error codes greater than 255.  This is
;					not mandatory but avoids confusion
;					later.  
; J. Peacock	X5.48C  16-Feb-1994	Avanti Machine Check Handler
; S.F.Shirron	X5.48D	17-Feb-1994	Add more Sable interrupt dispatching
; J. Peacock	X5.48E  18-Feb-1994	Avanti Machine Check Codes
; D. T. Rice	X5.48F	21-Feb-1994	Broke the mustang out as a separate
;					conditional.  Most of the code is eb66
;					based.  The reset code is where the
;					difference is.  The initial init code
;					had the SIO hard coded and on mustang it
;					moved there by breaking the code.  The
;					init is now a copy of eb64 and eb66 init
;					with the exception that it now sizes the
;					sio.
; J. Peacock	X5.48G  22-Feb-1994	Avanti Config Cycles Apecs Pass 2
; J. Peacock	X5.48H  23-Feb-1994	Avanti Allow halt request to come in unmasked
; J. Peacock	X5.48I  23-Feb-1994	Avanti reset_avanti_hardware config cycles
; J. Peacock	X5.48J  23-Feb-1994	Avanti iadcon not set up right
; J. Uban	X5.48K  23-Feb-1994	Medulla interrupt prioritization at SIO
; P.E.LaRochelleX5.48L	24-Feb-1994	Clear SIO IRQ2 not IRQ1 at hw reset
; J. Peacock	X5.48M  25-Feb-1994	Avanti eoi revisited for vms
; D. Rice	X5.48N	25-Feb-1994	Remove specific eoi from eb66 and
;					mustang interrupt code.  Drivers in os
;					are now responsible.
; S.F.Shirron	X5.48O	01-Mar-1994	Fix Cobra/Sable logging of BC parity
;					errors
; J.M.Peacock 	X5.48P	02-Mar-1994	Add Mikasa Initial Support
; D.T.Rice	X5.48Q  02-Mar-1994	correct processor table for lca4
; S.F.Shirron	X5.48R	02-Mar-1994	Add support for any CPU being primary
; D.T. Rice	X5.48S	04-Mar-1994	Enable halt, cpu errors and correct
;					order of saving data on machine check
;					frame.  Address information may be
;					invalid.
; J. Uban	X5.48T  4-Mar-1994	Simplify Medulla int priorities, add VME
; J. Peacock 	X5.48U  7-Mar-1994   	Avanti/Mikasa halt entry
; J. Uban	X5.48V  11-Mar-1994	More Simplify Medulla ints, more VME
; J. Peacock    X5.48W  17-Mar-1994	Mikasa PCI interrupt handler and ipl table
; J. Uban	X5.48X  17-Mar-1994	Redo Medulla MCHK code (clone from Mustang)
; J. Uban	X5.48Y  25-Mar-1994	pal$logout_area moved, force reassemble
; J. Uban	X5.48Z  29-Mar-1994	Enable IRQ0: PCI SERR, HALT(wdog/switch)
; J. Peacock    X5.49A  31-Mar-1994	Additional Machine Check Code for Mikasa
; J. Peacock    X5.49B  06-Apr-1994	Additional Machine Check Entries for Mikasa
; J. Peacock    X5.49C  07-Apr-1994	Fix the last insert for mikasa
; J. Gold	X5.49D  11-Apr-1994	Modify Jensen eisa_r/w macros, new thre
; S.F.Shirron	X5.48-31  13-Apr-1994	Fix the PALcode banner
; J.Peacock	X5.48-32  21-Apr-1994	Device Ipl Fix
; S.F.Shirron	X5.48-33  09-May-1994	Fix restarts for primary
; J.Peacock 	X5.48-34  17-May-1994	Mikasa Interrupt Controller changes
; J.Peacock 	X5.48-35  25-May-1994	Mikasa Halt Handler 
; J.Peacock 	X5.48-36  26-May-1994	Mikasa ignore fan faults till ready
; J.Peacock 	X5.48-37  31-May-1994	Mikasa set fer bit to zero for rev b
; J.Peacock 	X5.48-38  06-Jun-1994   Avanti and Mikasa: clock ipl set to 22
; J.Uban	X5.48-39  08-Jun-1994   Break out VIC interrupt bits, and
;					remove use of VIP_ICR register, Medulla
; H.Buckingham  X5.48-40  10-Jun-1994	Add config_mem to cserve
; J.Peacock 	X5.48-41  14-Jun-1994   Mikasa: and imr with irr 
; J.Peacock 	X5.48-42  15-Jun-1994   Mikasa and Avanti: passive release irq7 check
; J.Uban	X5.48-43  16-Jun-1994   Medulla: interrupt performance changes
; J.Peacock 	X5.48-44  16-Jun-1994   Mikasa eisa id 5000
; E.A.Rasmussen X5.48-45  21-Jun-1994	Update EB64+ for pass 2
; S.F.Shirron	X5.48-46  24-Jun-1994	Remove IPL table hacks (block/unblock)
; E.A.Rasmussen X5.48-47  29-Jun-1994	EB64+ device interrupt handling changes
; J.Peacock 	X5.48-48  29-Jun-1994   Mikasa eoi conditional
; J.Peacock 	X5.48-49  01-Jul-1994   Mikasa mode select = 0x6b
; D.Rice	x5.48-50  06-Jul-1994	Mustang/avanti/mikasa passive release
;					fix.  ISR is 0b not 0a.
; E.A.Rasmussen x5.48-51  08-Jul-1994	Enable device interrupts and fix passive
;					release (ISR = ^x0B) for EB64+
; S.F.Shirron	X5.48-52  13-Jul-1994	Preserve the EISA clock divisor for Sable
; J.Uban	X5.48-53  13-Jul-1994   Medulla: watchdog diag support cserve
; J.Peacock 	X5.48-54  18-Jul-1994   Mikasa set harx2 to zero in reset routine
; E.A.Rasmussen X5.48-55  19-Jul-1994	EB64+: Remove UART initialization
; D.T.Rice	X5.48-56  20-Jul-1994	AVANTI/MUSTANG/MIKASA - merged in the
;					changes for avanti/mikasa/mustang
;					machine check handler.
; E.A.Rasmussen X5.48-57  29-Jul-1994	EB64+: Enable PCI option slot interrupts
; D.T.Rice	x5-48-58  10-Aug-1994	Mustang II/Avanti/Mikasa - corrected
;					machine check frame builder to properly
;					save biu_stat, biu_addr, and iccsr.
;					PAL temps were improperly used.
; E.A.Rasmussen X5.48-59  11-Aug-1994	EB64+: Corrected machine check frame builder
;					same problem as Mustang II/Avanti/Mikasa
; E.A.Rasmussen X5.48-60  02-Sep-1994   EB64+: Remove SIO cfg init, fix NMI mchk
;					reason, and PCI interrupt mask init.
; D.T.Rice	X5.48-61  09-Sep-1994	Document changes made for avanti/mustang
;					,mikasa and eb64p to make interrupts
;					cleaner.  Additional changes for
;					jump_to_arc and r13 fix in lca error
;					handler.
; D.T.Rice	X5.48-62		Corrected the machine check handlers
;					for avanti, mikasa and eb64p to generate
;					the proper information for vector 660.
; D.T.Rice	X5.48-63		Correct in avanti machine check handler.
;					Avanti needed to handle parity.
; H.Buckingham  X5.48-64 13-Sep-1994	Add Sable simm sizing to cserves
; D.T.Rice	X5.48-65 13-Sep-1994	Correct ipl for mikasa back to 20
; D.T.Rice	X5-48-66 15-Sep-1994	Correct the avanti device ipl back to
;					20.  I had inadvertently changed it to
;					21.
; E.A.Rasmussen X5.48-67 19-Sep-1994	EB64+: remove RTC init code, done in SROM.
; S.McGrane	X5.48-68 20-Sep-1994	Include Noname build support.
; D.T.Rice	X5.48-69 23-Sep-1994	New machine check frames for Mikasa,
;					Avanti, EB64P, and Mustang II.  Correcte the
;					frame builder for EB66, Mustang I, and
;					EB66, Noname, Burns and Lean.  Also
;					added the LCA4 fix for the PC update
;					problem.  This will be a permanent fix
;					in the next release of the PALcode.
; D.T.Rice	X5.48-70 27-Sep-1994	New interrupt handler for
;					noname/lean/burns/eb66.  Replaced all of
;					the redundant code with a common
;					handler.
; E.A.Rasmussen	X5.48-71 29-Sep-1994	Add Cabriolet support (EB64+ variant)
; R.N.Ferrara	X5.48-72  5-Oct-1994	Medulla Changes Only:
;					1. Added mb on interrupt entry to flush
;					   write buffer
;					2. Included PC adjustment on machine
;					   checks (to be like all other
;					   platforms).
; E.A.Rasmussen X5.48-73  7-Oct-1994	Fix shifting of upper PCI interrupt
;					status bits for EB64+/Cabriolet.
; N.O.Hernandez X5.48-74 10-Oct-1994	Changed devipl from 21 to 20 and enabled
;					machine check reports for Burns.
; N.O.Hernandez X5.48-75 10-Oct-1994	Disabled COM2 initialization. Port is
;					not used.
; D. Baird	x5.48-76 12-Oct-1994    Add coma_base3 and coma_cfg3 to logout
;					frame, and fix a problem with the 
;					halt switch on Mikasa.
; E.A.Rasmussen x5.48-77 13-Oct-1994	Changed devipl from 21 to 20, added cserve
;					functions for enabling/disabling PCI
;					interrupts for EB64+.  Also save a copy
;					of the EB64+ PCI interrupt mask in the
;					impure area.
; D.T. Rice	X5.48-77 13-Oct-1994	New power management code for mikasa.
; D.T. Rice	X5.48-78 14-oct-1994	Merge with hudson
; N.O.Hernandez X5.48-79 17-Oct-1994	Fixed genipl table. Added irq1, 3, 4 ipls.
; R.N. Ferrara  X5.48-80 26-Oct-1994	Medulla Changes Only: Changed VME IACK ipl to 20
; C.G. Heiter   X5.48-81 26-Oct-1994	Medulla: change testing of DMA status int
; D.T.Rice	X5.48-82 9-Nov-1994	New fan fail and hi temp fault detection
;					code.  The errors are now polled.  A bit
;					in pt25 has been taken to allow
;					enable/diable of this.
; E.A.Rasmussen	X5.48-83 10-Nov-1994	ECO 440: Fixed LCA memory error interrupt mask.
;
; D.T.Rice	X5.48-84 16-Nov-1994	Corrected machine check frame for avanit.
;
; E.A.Rasmussen X5.48-85 18-Nov-1994	Enable NMI and EPIC error interrupts for EB64+
;
; D.T.Rice	X5.48-86 14-Dec-1994	Forced the pci arbiter control to slow
;					response as the default.  NEeds to get
;					corrected in the config code to look for
;					the slowest device and use that value.
; D.T.Rice	X5.48-87 15-Dec-1994	Corrected the logout frame size for
;					mikasa/mustang/avanti.  LAF$SIZE was
;					used instead of MCHK$MCHK_SIZE.
; E.A.Rasmussen X5.48-88 27-Dec-1994	Updated EB66 for pass 2.
; E.A.Rasmussen X5.48-89 10-Jan-1995	Added support for EB66+ (EB66 variant)
; E.A.Rasmussen X5.48-90 12-Jan-1995	EB Boards: enable IRQ12/M mouse function
;					by setting ICD<4> in SIO config space.
; E.A.Rasmussen X5.48-91 26-Jan-1995	EB Boards: save SROM parameters in impure area.
; S.F.Shirron	X5.48-92 17-Feb-1995	Implement settable baud rate for COM1,
;					detect XIO and reset PCI bus if present
; E.A.Rasmussen X5.48-93 24-Feb-1995	Enable NMI, I/O and Memory Controller error
;					interrupts for EB66 and EB66+.
; E.A.Rasmussen X5.48-94 10-Mar-1995	EB Boards: Initialize IADCON register in 
;					hardware reset flow.
; S.F.Shirron	X5.48-95  11-Apr-1995	Add pass 1 XIO interrupt support.
; R.H.Baker     X5.48-96 18-Apr-1995    Enabled 660/670 machine checks for AVANTI
; D.T.Rice	X5.48-97 19-apr-1995	Fix last edit properly
; E.A.Rasmussen X5.48-98 26-Apr-1995	Changed short frame logout area address setup
;					for EB boards.
; D.T.Rice	X5.48-99 2-May-1995	Correct logout frame for apecs.  Config,
;					and base registers were wrong.  Also
;					added a check for valid pci interrupt on
;					mikasa to avoid the halt on b step
;					bridge.
; D.T.Rice	X5.48-100 2-may-1995	Corrected the error code for avanti.
;					herr was being generated on tag parity.
; D.T.Rice	X5.48-101 4-may-1995	One more correction.  Forced taperr,
;					 herr and  tcaperr to exit if detected
;					 rather than scann for other errors.
; S.F.Shirron	X5.48-102 23-May-1995	Add SLynx support.
; S.McGrane	X5.48-103 31-May-1995	Add K2 support.
; A. Palmeri    x5.48-104 14-Jun-1995   Changed the machine check logout frame
;					for Mikasa on the PCEB
; E.A.Rasmussen X5.48-105 15-Jun-1995	Clear all but low byte on 1st read of PCI
;					interrupt request register for all Alpha
;					Evaluation Boards.
; D.T.Rice	X5.48-106 20-Jun-1995	Clear HAXR2 in machine check save code.
;					Mikasa would fail if probing bus other;					than 0.
; S.McGrane	X5.48-107 22-Jun-1995	Include K2 hardware init, interrupt
;					and exception handlers and logout
;					frame code.
; S.McGrane	X5.48-108 29-Jun-1995	K2 watchdog and server management
;					changes and BIU_CTL checking bug fix.
; S.McGrane	X5.48-109 21-Jul-1995	Fix bug in the v_ecc, v_seo and v_crd
;					BIU_STAT check PALcode.
; D.T.Rice	X5.48-110 17-Aug-1995	Noritake base changes
; D.T.Rice	X5.48-111 17-Aug-1995	Merged Noritake with the main code base.
; S.F.Shirron	X5.48-112 21-Aug-1995	Fix T3 initialization.
; D.T.Rice	X5.48-113 6-Sep-1995	Correct noritake interrupt handler
; E.A.Rasmussen X5.48-114 06-Sep-1995	Fixed masking of PCI interrupt requests for 
;					EB64+/EB66+ and APC64 platforms.
; A. Palmeri    X5.48-115 04-Oct-1995   Fixed setup for Noritake to support
;					only 2 EISA slots 
; N. Hernandez  X5.48-116 27-Oct-1995   Fixed problems with BURNS dealing with
;					IO errors. Added PCI bus reset code.
; S.F.Shirron	X5.48-117 02-Nov-1995	For Lynx, set XIO_ICIC to 1.
; S.F.Shirron	X5.48-118 08-Nov-1995	Add byte/word emulation.
; S.McGrane	X5.48-119 08-Nov-1995	Minor K2 interrupt changes.
; S.F.Shirron	X5.48-120 10-Nov-1995	Add Dstream fault handler to byte/word
;					emulation code.
; E.A.Rasmussen X5.48-121 04-Dec-1995	Add SROM parameters to CSERVE jump_to_arc
;					for EB platforms.
; E.A.Rasmussen X5.48-122 05-Dec-1995	Fix saving of BIU_CTL value for EB platforms.
; J.Wiedemeier	X5.49	15-Feb-1994	Add second definition of movcsr with regs of laf builder for LCA
; J.Wiedemeier	X5.50	03-Mar-1994	Correct LCA mchk clobbering ESR and IOC_STAT[1]
; J.Wiedemeier	X5.51	22-Mar-1994	Fix mchk decision bug
; J.Wiedemeier	V5.52	04-Apr-1994	Modify to work with both macro64 and macroe
; J.Wiedemeier	V5.53	19-Apr-1994	Fix exc_addr in LCA pal$error_interrupt for mchk
; S.F.Shirron	V5.53-1	13-Dec-1995	Merge changes since X5.48.
; N. Hernandez	V5.53-2	21-Dec-1995	Burns: Corrected code in reset_lean_hardware.
;					PCI/ISA bus resets were not being done.
; N. Hernandez	V5.53-3	29-Dec-1995	Burns: Added delay after PCI reset.
; S.F.Shirron	V5.53-4	15-Jan-1996	Turn on all pass 3 T3 features.
; S.McGrane	X5.53-5 17-Jan-1996	Merge in all K2 hardware debug updates.
; P.Domings	X5.53-6 22-Jan-1996	Add MTU support (Alpha Multia).
; A.Palmeri	X5.53-7 23-Jan-1996	Change the ESC GPCS register mapping
; S.F.Shirron	V5.53-8	31-Jan-1996	Turn off read mult for pass 3 T3.
; D. Hoag   	V5.53-9 06-Feb-1996	disable Medulla serial output if graphics mode.
; J. Ervin	V5.53-10 20-Feb-1996	Cortex: Initial support.
; J.Wiedemeier  V5.54   14-Mar-1996	Added CLRFEN
; J.Wiedemeier	V5.55	18-Mar-1996	Fix ear/esr order in lca4 crd_interrupt flow
; J.Wiedemeier	V5.56	19-Mar-1996	Fix PCI reset on LCA4 to use proper base
; S.F.Shirron	V5.56-1	22-Feb-1996	Merge changes since V5.53.
; J. Ervin	V5.56-2 03-Apr-1996	Cortex: Added combott, fix pwrup output.
; J. Ervin	V5.56-3 17-Apr-1996	Cortex: Fix periodic rt timer int.
; J. Ervin	V5.56-4 10-Jun-1996	Cortex: align vms/osf impure vars.
; A. Palmeri    V5.56-5 23-Oct-1996     Noritake add support for server management
;					interrupt vectors
; A. Palmeri    V5.56-6 30-Oct-1996     Fix interrupt mask for Noritake
; A. Palmeri    V5.56-7 24-Jan-1997     Allow ENV Noritake interrupts to go 
;                                        to VMS 
		vltr == 1	; x = 0, v = 1
		vmaj == 5
		vmin == 56
		vvar == 7
		vmod == 0


	pal$version_h = <vvar@24> ! <vltr@16> ! <vmaj@8> ! <vmin@0>

;-

.sbttl	Register usage
;+
;	SP	  Native R30
;	R31	  Read 0 / write bit bucket
;-


.sbttl	ALPHA symbol definitions


	PALDEF_VER	== 3		; Check revision's on the include files
	ALPHADEF_VER	== 3		; Check revision's on the include files
	LCADEF_VER	== 1		; Check revisions on the include files

	.iif df MACRO64$,	  $MACRO64_DEFS


	$PALDEFS			; Check against the file
	$ALPHADEFS			; Check against the file
	$LCADEFS			; Check against the file

	$PSDEF		GLOBAL
	$PTEDEF		GLOBAL
	$VADEF		GLOBAL
	$PCBDEF		GLOBAL
	$SCBDEF		GLOBAL
	$FRMDEF		GLOBAL
	$EXSDEF		GLOBAL


.sbttl	Hardware symbol definitions


	.iif df MACRO64$,	$MACRO64_EVX_DEFS GLOBAL
	$EV4_DEFS	GLOBAL
	$PAL_FUNC	GLOBAL
	$HALT_CODES	GLOBAL
	$MCHK_CODES	GLOBAL
	$VMS_MXR	GLOBAL
	$TVDEF		GLOBAL

	$PAL_IMPURE
	$PAL_LOGOUT
	$LCA4_DEFS	GLOBAL	; keep this AFTER $PAL_LOGOUT

	$PAL_DEF
	$CSERVE_DEF

.sbttl	PALcode configuration options

; There are a number of options that may be assembled into this version of
; PALcode. They should be adjusted in a prefix assembly file (i.e. do not edit
; the following). The options that can be adjusted cause the resultant PALcode
; to reflect the desired target system.


; CPU CHIP support
; There are minor differences between various EV cpu chips, select the
; the proper cpu chip with the following symbol

	.iif ndf ev3_cpu, ev3_cpu			== 0
	.iif ndf ev4_cpu, ev4_cpu			== 1
	.iif ndf ev4_pass1, ev4_pass1			== 0
	.iif ndf ev4_pass2, ev4_pass2			== 0
	.iif ndf ev4_pass3, ev4_pass3			== 1
	.iif ndf lca4, lca4				== 0
	.iif ndf lca4_pass2, lca4_pass2			== 0

	assume <ev3_cpu+ev4_cpu> eq 1	; Only one CPU chip may be selected
	assume <ev4_pass1+ev4_pass2+ev4_pass3> eq 1; Only one EV4 Pass chip may be selected
	assume <ev3_cpu> eq 0		; EV3 support code not implimented


; size of space allocated for palcode functions differs between
; ev4 pass 1 and pass 2. With pass 1 being 8, and pass 2 being 16.
	.iif ndf pfunc_size, pfunc_size 		== 8+<<ev4_pass2!ev4_pass3>*8>


; VIRTUAL machine support
; There is suppport built in for virtualizeing memory

	.iif ndf virtualize_memory, virtualize_memory	== 0
	.iif ne  virtualize_memory, .print 0; Virtualized memory has been included, should not be in official release
	.iif ndf virtualize_phy_tb, virtualize_phy_tb	== virtualize_memory
	.iif ne  virtualize_phy_tb, .print 0; Virtualized physical tb has been included, should not be in official release

; LOWcore ipl table support
; If low core i.e. < 2k, pa is available to use as a low core ipl table
; it is used, this is a performance enhancement..

	.iif ndf low_core_ipl, low_core_ipl	= 1
	low_core_ipl == low_core_ipl
	.iif eq  low_core_ipl, .print 0; Low core IPL has NOT been included, should be in official release

; Physical console support
; The ability to map pa=va for console use exists.
	.iif ndf enable_physical_console, enable_physical_console == 0

	
; SROM tty console support
; The ability to use the EV serial line as a tt device
	.iif ndf sable_sromtt_debug, sable_sromtt_debug == 0

; SYSTEM board support
; The differences in systems typically revolve around different schemes for
; supporting interrupts or selecting different console support.
; Use the following symbols to select the proper system

	.iif ndf adu_system, adu_system			== 0
	.iif ndf laser_system, laser_system		== 0
	.iif ndf flamingo_system, flamingo_system	== 0
	.iif ndf sable_system, sable_system		== 0
	.iif ndf lynx_system, lynx_system		== 0
	.iif ndf medulla_system, medulla_system		== 0
	.iif ndf mtu_system, mtu_system			== 0
	.iif ndf k2_system, k2_system			== 0
	.iif ndf lean_system, lean_system		== 0
	.iif ndf avanti_system, avanti_system		== 0
	.iif ndf mikasa_system, mikasa_system		== 0
	.iif ndf noritake_system, noritake_system	== 0
	.iif ndf cortex_system, cortex_system  		== 0

	.iif ndf generic_system, generic_system		== 0

	.iif ndf xio_icic, xio_icic == lynx_system

	sable_system_debug	== 0
	medulla_system_debug	== 0
	medulla_old_sio_ints	== 0
	
	cfw_system		== 1

	.if ne	cfw_system
	.iif ne	virtualize_memory, .print 0; Virtualized memory is NOT supported for Cobra
	.iif eq low_core_ipl, .print 0; ONLY low core IPL is supported for CFW
	.endc
	.if ne	sable_system
	$pal_logout_sable
	.endc

	.if ne	avanti_system
	$pal_logout_avanti
	.endc

	.if ne	k2_system
	$pal_logout_k2
	.endc

	.if ne	mikasa_system ! noritake_system 
	$pal_logout_mikasa
	.endc

	.if ne	cortex_system
	$pal_logout_cortex
	.endc

	assume <adu_system+cfw_system> eq 1	; Only one system may be selected

; cache block alignment.
; There is the option to align large block of code on 16 instruction 
; boundaries instead of 8. This is for sytem with large fill size blocks
; on there bcache. It should be off for all others.

	.iif ndf enable_2x_cache_block_alignment, enable_2x_cache_block_alignment == laser_system;



; LDx/L STx/C retry count
; This sets the maximum number of times that the LDx/L STx/C will be tried
; inorder to obtain a lock prior to giveing up and requeueing the instruction

	.iif ndf ldxl_stxc_retry_count, ldxl_stxc_retry_count	== 32


; CACHE support
; These options can be used to selectivly disable and setup the caches

	.iif ndf disable_icache, disable_icache		== 0
	.iif ndf disable_dcache, disable_dcache		== 0
	.iif ndf enable_16kdcache, enable_16kdcache	== 0
	.iif ndf disable_cache_parity, disable_cache_parity == 0
	.iif ndf enable_byte_parity, enable_byte_parity == 0
	.iif ndf enable_imap_en, enable_imap_en		== 0
	.iif ndf disable_sbuf, 	 disable_sbuf		== 0
	.iif ndf disable_bcache, disable_bcache		== 0
	.iif ndf disable_oe,	 disable_oe		== 0
	.iif ndf bc_size, 	 bc_size		== 1
	.iif ndf enable_double_inval,	 enable_double_inval		== 0
	.iif ndf enable_fast_lock,	 enable_fast_lock 		== 0
	.iif ndf enable_imap_en,	 enable_imap_en		== 0
	.iif ndf enable_byte_parity,	 enable_byte_parity		== 0
	.iif ndf disable_ecc, disable_ecc		== 0

	.iif ndf bc_rd_spd, 	 bc_rd_spd		== 2
	.iif ndf bc_wr_spd, 	 bc_wr_spd		== 2
	.iif ndf bc_we_ctl, 	 bc_we_ctl		== 1
	.iif ndf bc_pa_dis, 	 bc_pa_dis		== 8

	assume <disable_oe&enable_fast_lock> eq 0		; Cannot be in fast lock mode with disable_oe asserted

; PAL option support

; PALcode FUNCTION support
; PALcode can be assembled with or without various of the SRM architected 
; features. It is recomended that ALL of the SRM features remain enabled,
; and NO testing has been performed with any of them disabled. The code
; saveings from disabling them is minimal.

	.iif ndf disable_probe, disable_probe		== 0
	.iif ndf disable_queue, disable_queue		== 0

	.iif ndf disable_chmx, disable_chmx		== 0
	.iif ndf disable_chmk, disable_chmk		== 0
	.iif ndf disable_chme, disable_chme		== 0
	.iif ndf disable_chms, disable_chms		== 0
	.iif ndf disable_chmu, disable_chmu		== 0


	.iif ne disable_probe, .print 0; PROBE instructions have been excluded
	.iif ne disable_queue, .print 0; QUEUE instructions have been excluded

	.iif ne disable_chmx, .print 0; CHMx instructions have been excluded
	.iif ne disable_chmk, .print 0; CHMK instruction has been excluded
	.iif ne disable_chme, .print 0; CHME instruction has been excluded
	.iif ne disable_chms, .print 0; CHMS instruction has been excluded
	.iif ne disable_chmu, .print 0; CHMU instruction has been excluded


; multiprocessor support can be enabled for a max of n processors by
; setting the following to the number of processors on the system.
; Note that this is really the max cpuid.

	.iif ndf max_cpuid, max_cpuid 			== 8



; Some debuging features may be present, and they can be turned by with the
; following symbols. Note that they may have sever side effects and thought
; must be given to releaseing a version of pal with any of these enabled.
; Generally it would be a bad idea.

	.iif ndf enable_debug_boot, enable_debug_boot == 0
	.iif ne  enable_debug_boot, .print 0; BOOT DEBUG support code has been included, should not be in official release

	.iif ndf enable_debug_sptrace, enable_debug_sptrace	== 0
	.iif ndf enable_debug_pstrace, enable_debug_pstrace	== 0
	.iif ndf enable_debug_astentrace, enable_debug_astentrace == 0
	.iif ndf enable_debug_trace2reg, enable_debug_trace2reg == 0
	.iif ndf enable_debug_pctrace, enable_debug_pctrace	== <enable_debug_sptrace ! enable_debug_pstrace ! enable_debug_astentrace ! enable_debug_trace2reg>
	.iif ne  enable_debug_pctrace, .print 0; PC trace support code has been included, should not be in official release
	.iif ndf enable_debug_special, enable_debug_special	== 0
	.iif ne  enable_debug_special, .print 0; Special DEBUG support code has been included, should not be in official release
	.iif ndf enable_debug_pcevent, enable_debug_pcevent	== 0
	.iif ne  enable_debug_pcevent, .print 0; PC EVENT DEBUG support code has been included, should not be in official release

	.iif ndf  disable_tracepc, disable_tracepc	= 0 ; local, not gbl
	.iif ndf  $$debug_boot$$,  $$debug_boot$$	= 1 ; local, not gbl


	.iif ndf adu_pause_support, adu_pause_support	== 0
	.iif ne  adu_pause_support, .print 0; ADU PAUSE support code has been included, should not be in official release

	.iif ndf disable_pipeline, disable_pipeline	== 0
	.iif ne  disable_pipeline, .print 0; PIPELINE disable code has been included, should not be in official release

	.iif ndf disable_bht, disable_bht		== 0
	.iif ne  disable_bht, .print 0; Branch History Table has been disabled, should not be in official release

	.iif ndf disable_mchkcrd, disable_mchkcrd	== 0
	.iif ne  disable_mchkcrd, .print 0; MCHKCRD disable code has been included, should not be in official release


	.iif ndf enable_debug_mp, enable_debug_mp	== 0
	.iif ne  enable_debug_mp, .print 0; DEBUG mp support code has been included, should not be in official release

	.iif ndf enable_nphalt, enable_nphalt		== 0
	.iif ne  enable_nphalt, .print 0; DEBUG NON-PRIV HALT support code has been included, should not be in official release

	.iif ndf enable_sstep, enable_sstep		== 0
	.iif ne  enable_sstep, .print 0; SINGLE STEP support code has been included, should not be in official release



	.if ne	cfw_system
	pal$ipltbl		== pal$ipl_table_base
	pal$bitbucket           == pal$ipltbl-<8*1>
	pal$ncrtable		== pal$ipltbl-<8*2>
	pal$secondary		== pal$ipltbl-<8*3>
	pal$callback		== pal$ipltbl-<8*4>
	pal$lockflag		== pal$ipltbl-<8*5>
	pal$memory0		== pal$ipltbl-<8*6>
	pal$memory1		== pal$ipltbl-<8*7>
	pal$memory2		== pal$ipltbl-<8*8>
	pal$memory3		== pal$ipltbl-<8*9>
	pal$biu_ctl		== pal$ipltbl-<8*10>
	pal$cpu0		== pal$ipltbl-<8*11>
	pal$cpu1		== pal$ipltbl-<8*12>
	pal$cpu2		== pal$ipltbl-<8*13>
	pal$cpu3		== pal$ipltbl-<8*14>
	pal$primary		== pal$ipltbl-<8*15>
	.iff
	Pal$IplTbl		== pal_low_core_start ; low core area available to pal
	Pal$BitBucket		== Pal$IplTbl+<32*8>
	.endc



; Pal code version info
;
	.if ndf pal$version_l

	vms_pal == 1
	osf_pal == 2

	pal_type = vms_pal

	pal$version_l = <<ev4_cpu@31> ! <ev3_cpu@30> ! -
		<adu_system@28> ! -
		<laser_system@26> ! <flamingo_system@25> ! -
		<pal_type @8> ! <max_cpuid @0>>
	.endc




;+
;
; pt25 bit definitions
;
;-

pt25$v_sirr	== 0
pt25$v_adu	== 10
pt25$v_rpcc	== 11
pt25$v_ss	== 12
pt25$v_mck	== 16
pt25$v_sce	== 17
pt25$v_pce	== 18
pt25$v_dpc	== 19
pt25$v_dsc	== 20
pt25$v_switch	== 21
pt25$v_tip	== 63


;
; because of a the way the hardware is designed, I needed a way of indicating
; whether or not the over temp and fan faults should be checked.  This seems to
; be the most logical way of doing it.
; 
.if	ne	mikasa_system ! noritake_system
pt25$v_inhibit_fan_fault == 62
pal$halt_button_pressed == ^x100
.endc


hirrr$v_irq0 = 10
hirrr$v_irq1 = 11
hirrr$v_irq2 = 12
hirrr$v_irq3 = 5
hirrr$v_irq4 = 6
hirrr$v_irq5 = 7
hirrr$m_irq0 = 1@hirrr$v_irq0
hirrr$m_irq1 = 1@hirrr$v_irq1
hirrr$m_irq2 = 1@hirrr$v_irq2
hirrr$m_irq3 = 1@hirrr$v_irq3
hirrr$m_irq4 = 1@hirrr$v_irq4
hirrr$m_irq5 = 1@hirrr$v_irq5
hirrr$m_pc0 = 1@hirrr$v_pc0
hirrr$m_pc1 = 1@hirrr$v_pc1

	.if ne	cfw_system

.macro	genipltbl	irq0=-1, irq1=-1, irq2=-1, irq3=-1, irq4=-1, irq5=-1, -
			cre=0, pc0=0, pc1=0, sle=0
	;
	; The IPL table is indexed by IPL (0-31 inclusive) to give
	; values to be stuffed into the HIER and SIER hardware
	; registers directly for when we need to change the IPL.
	;
	; The table assumes that the IRQ0-5 lines correspond to
	; various IPLs.
	;
	; To facilitate generation of the IPL table, we define a macro that
	; takes as input the IPL that each Interrupt ReQuest line wants to be
	; serviced at.  The macro then generates the table based on these
	; priorities.
	;

	;
	; step for each interrupt level
	;
	ipl = 0
	.repeat 32

	;
	; generate a bitmask for this ipl level
	;
	bits = 0
	mask = 1
	.irp	iname,<irq0,irq1,irq2,irq3,irq4,irq5>
	.if gt	<iname - ipl>
	bits = bits ! mask
	.endc
	mask = mask @ 1
	.endr

	;
	; Shift the bits into the proper positions for the HIER and SIER
	; We can create one quadword that goes to both registers, since
	; the significant fields in the HIER are ignored in the SIER,
	; and the significant fields in the SIER are ignored in the HIER.
	;
	; The !@#$%^&* VMS assembler doesn't handle 64 bit constants, so
	; we generate the quad as two longs
	;
	low_hier_value = -
		<bits @ hierw$v_hier> ! -
		<cre @ hierw$v_cre> ! -
		<pc0 @ hierw$v_pc0> ! -
		<pc1 @ hierw$v_pc1>

	;
	; set up the software ipl bits
	;
	softipl = 0
	.if le	<ipl - 15>
	softipl =  ^x7fff & ^c<<1@<ipl+0>>-1>
	.endc
	high_hier_value = -
		<softipl @ <hierw$v_sier - 32>> ! -
		<sle @ <hierw$v_sle - 32>>

	.long	low_hier_value, high_hier_value
	ipl = ipl + 1
	.endr
.endm

	.if ne	generic_system

.macro	cfw_setup
.endm

.macro	cfw_lock
.endm

.macro	cfw_putc	c
.endm

.macro	cfw_unlock
.endm

	.endc

	.if ne	sable_system

pic1 = ^x20

esc = ^x22
addr = 0
data = 1

rtco = ^x70
rtcd = ^x71

pic2 = ^xa0

com1 = ^x3f8
com2 = ^x2f8
thr = 0
rbr = 0
dll = 0
ier = 1
dlm = 1
iir = 2
fcr = 2
lcr = 3
mcr = 4
lsr = 5
msr = 6
scr = 7
lsr$v_dr = 0 + 8
lsr$v_thre = 5 + 8
lcr$m_sbs = 4
lcr$m_dla = 128
mcr$m_dtr = 1
mcr$m_rts = 2
mcr$m_out1 = 4
mcr$m_out2 = 8
fcr$m_fe = 1
fcr$m_rfr = 2
fcr$m_tfr = 4
baud_9600 = 12
char_8bit = 3

nmiecsr = ^x461
bus_reset = 1

iic = ^x530
s1 = 1
s1$m_pin = 128

iack = ^x532

pic0 = ^x534

.macro	delay	n,?l1
	get_addr r12, <n*1000*100>, r31
l1:	subq	r12, #1, r12
	bne	r12, l1
.endm

.macro	combo_setup
	lda	r15, ^x3a0(r31)
	sll	r15, #24-5, r15
	lda	r15, com1(r15)
	sll	r15, #5, r15
.endm

.macro	combo_lock	?l1, ?l2, ?l3
	lda	r14, 1(r31)
	sll	r14, #24, r14
l1:	ldq/pl	r12, pal$lockflag(r31)
	blbs	r12, l2
	bis	r12, #1, r12
	stq/pc	r12, pal$lockflag(r31)
	bne	r12, l3
l2:	subq	r14, #1, r14
	bgt	r14, l1
l3:	stall	2
.endm

.macro	combo_unlock
	stq/p	r31, pal$lockflag(r31)
.endm

.macro	combott_putc 	c, ?l1
	.if ne	sable_sromtt_debug
	sromtt_putc	<c>
	.iff
l1:	ldl/p	r12, lsr@5(r15)
	srl	r12, #lsr$v_thre, r12
	pvc$violate	1008
	blbc	r12, l1
.if idn <%extract(0,1,c)> <r>
	and	c, #^xff, r12
.iff
	lda	r12, <c>&^xff(r31)
.endc
	stl/p	r12, thr@5(r15)
	mb
	.endc
.endm

.macro	combott_puth	w=16, ?l1, ?l2
	lda	r17, w*4(r31)
l1:	subq	r17, #4, r17
	srl	r16, r17, r19
	and	r19, #15, r19
	lda	r18, ^x30(r19)
	cmpult	r19, #10, r19
	pvc$violate	1008
	bne	r19, l2
	addq	r18, #^x27, r18
l2:	combott_putc	r18
	pvc$violate	1008
	bne	r17, l1
.endm

.macro	eisa_read	p, setup=1, hose=0
.if ne	setup
.if ne	hose
	lda	r15, ^x1c0(r31)
.iff
	lda	r15, ^x3a0(r31)
.endc
	sll	r15, #24-5, r15
	lda	r15, p(r15)
	sll	r15, #5, r14
	and	r15, #3, r15
.endc
	ldl/p	r12, (r14)
	mb
	extbl	r12, r15, r12
.endm

.macro	eisa_write	p, c, setup=1, hose=0
.if ne	setup
.if ne	hose
	lda	r15, ^x1c0(r31)
.iff
	lda	r15, ^x3a0(r31)
.endc
	sll	r15, #24-5, r15
	lda	r15, p(r15)
	sll	r15, #5, r14
	and	r15, #3, r15
.endc
.if idn <%extract(0,1,c)> <r>
	and	c, #^xff, r13
.iff
	lda	r13, <c>&^xff(r31)
.endc
	insbl	r13, r15, r13
	stl/p	r13, (r14)
	mb
.endm

.macro	cfw_setup
	combo_setup
.endm

.macro	cfw_lock
	combo_lock
.endm

.macro	cfw_putc	c, ?l1
	combott_putc	<c>
.endm

.macro	cfw_unlock
	combo_unlock
.endm

	.if ne	sable_sromtt_debug

.macro	sromtt_putc	c,?l1,?l2,?l3,?l4,?l5,?l6
	mt	r1, pt1
.if idn <%extract(0,1,c)> <r>
	and	c, #^xff, r1
.iff
	lda	r1, <c>&^xff(r31)
.endc
	lda	r12, ^xdb0(r31)		; fix the baud rate for now
					; This will work for 5.26 only

	lda	r13, 8(r31)		; Set the bit count.
	mt 	r31, SL_XMIT		; Send the start bit.
	rcc	r14
	zap	r14, ^xf0, r14
	addq	r14, r12, r14
	zap	r14, ^xf0, r14
l1:
	rcc	r15			; Read the CC.
	zap	r15, ^xf0, r15
	cmplt	r14, r15, r12		; Continue waiting until the start bit
	beq	r12, l1           	; stays on the line for an entire bit-time.
l2:
	sll	r1, 4, r12		; Start the data bits at r10<4>.
	mt 	r12, SL_XMIT		; Send the first data bit.
	srl	r1, 1, r1             	; Shift right, to the next data bit.
	subq	r13, 1, r13		; Decrement the bit count.
	lda	r12, ^xdb0(r31)		; fix the baud rate for now
					; This will work for 5.26 only
	rcc	r14
	zap	r14, ^xf0, r14
	addq	r14, r12, r14
	zap	r14, ^xf0, r14
l3:
	rcc	r15			; Read the CC.
	zap	r15, ^xf0, r15
	cmplt	r14, r15, r12		; Continue waiting unti the data bit
	beq	r12, l3           	; stays on the line for an entire bit-time.
	bne	r13, l2            	; Continue until 8 data bits have been sent.
	lda	r12, ^x10(r31)
	mt 	r12, SL_XMIT           	; Send the stop bit.
	lda	r12, ^xdb0(r31)		; fix the baud rate for now
					; This will work for 5.26 only
	rcc	r14
	zap	r14, ^xf0, r14
	addq	r14, r12, r14
	zap	r14, ^xf0, r14
l4: 
	rcc	r15                     ; Read the CC.
	zap	r15, ^xf0, r15
	cmplt	r14, r15, r12           ; Continue waiting until the stop bit
	beq	r12, l4            	; stays on the line for an entire bit-time.
l5:
	mf	r12, sl_rcv
	bne	r12, l5
l6:
	mf	r12, sl_rcv
	beq	r12, l6
	mf	r1, pt1
.endm

	.endc

	.endc

	.if ne	mikasa_system ! noritake_system ! avanti_system ! k2_system ! cortex_system

.sbttl	EB64+ PALcode Macros and Definitions
;----------------------------------------------------------------------
;
; EB64+ Address Space Partitioning
;
;	   Address Bit
;	33 32 31 30 29 28	Description
;	-----------------	-------------------------
;        0  1  1  0  0	-	DECchip 21071-CA CSRs
;	 0  1  1  0  1	0	DECchip 21071-DA CSRs
;	 0  1  1  0  1  1	PCI Interrupt ACK
;	 0  1  1  1  0  0	PCI Sparse I/O
;	 0  1  1  1  1	-	PCI Configuration 
;	 1  0  -  -  -	-	PCI Sparse Memory
;	 1  1  -  -  -	-	PCI Dense Memory
;
; The following definitions need to be shifted left 28 bits
; to obtain their respective reference points.
;

coma_base	= ^x18		; DECchip 21071-CA CSR base address.
epic_base	= ^x1A		; DECchip 21071-DA CSR base address.
i_ack		= ^x1B		; Interrupt acknowledge.
io_base		= ^x1C		; I/O base address.
cfig_base	= ^x1E		; Configuration base address.
esc_addr	= ^x22		; Mikasa I/O Address at 22
esc_data	= ^x23		; Mikasa I/O Data    at 23


;
; DECchip 21071-CA (Commanche) Control and Status Register Definitions
;

coma_gcr	= ^x000		; General control register
coma_edsr	= ^x040		; Error and diagnostic status register
coma_ter	= ^x060 	; Tag enable register
coma_elar	= ^x080 	; Error low address register
coma_ehar	= ^x0A0 	; Error high address register
coma_ldlr	= ^x0C0 	; LDx_L low address register
coma_ldhr	= ^x0E0 	; LDx_L high address register

coma_gtr	= ^x200 	; Global timing register
coma_rtr	= ^x220 	; Refresh timing register
coma_vfp	= ^x240 	; Video frame pointer register
coma_pdlr	= ^x260 	; Presence detect low data register
coma_pdhr	= ^x280 	; Presence detect high data register

coma_base0	= ^x800		; Bank 0 base address register
coma_base1	= ^x820 	; Bank 1 base address register
coma_base2	= ^x840 	; Bank 2 base address register
coma_base3	= ^x860 	; Bank 3 base address register
coma_base4	= ^x880 	; Bank 4 base address register
coma_base5	= ^x8A0 	; Bank 5 base address register
coma_base6	= ^x8C0 	; Bank 6 base address register
coma_base7	= ^x8E0 	; Bank 7 base address register
coma_base8	= ^x900		; Bank 8 base address register

coma_cnfg0	= ^xA00 	; Bank 0 configuration register
coma_cnfg1	= ^xA20 	; Bank 1 configuration register
coma_cnfg2	= ^xA40 	; Bank 2 configuration register
coma_cnfg3	= ^xA60 	; Bank 3 configuration register
coma_cnfg4	= ^xA80 	; Bank 4 configuration register
coma_cnfg5	= ^xAA0 	; Bank 5 configuration register
coma_cnfg6	= ^xAC0 	; Bank 6 configuration register
coma_cnfg7	= ^xAE0 	; Bank 7 configuration register
coma_cnfg8	= ^xB00 	; Bank 8 configuration register

coma_btra0	= ^xC00		; Bank 0 timing register A
coma_btra1	= ^xC20 	; Bank 1 timing register A
coma_btra2	= ^xC40 	; Bank 2 timing register A
coma_btra3	= ^xC60 	; Bank 3 timing register A
coma_btra4	= ^xC80 	; Bank 4 timing register A
coma_btra5	= ^xCA0 	; Bank 5 timing register A
coma_btra6	= ^xCC0		; Bank 6 timing register A
coma_btra7	= ^xCE0 	; Bank 7 timing register A
coma_btra8	= ^xD00 	; Bank 8 timing register A

coma_btrb0	= ^xE00 	; Bank 0 timing register B
coma_btrb1	= ^xE20 	; Bank 1 timing register B
coma_btrb2	= ^xE40 	; Bank 2 timing register B
coma_btrb3	= ^xE60 	; Bank 3 timing register B
coma_btrb4	= ^xE80 	; Bank 4 timing register B
coma_btrb5	= ^xEA0 	; Bank 5 timing register B
coma_btrb6	= ^xEC0 	; Bank 6 timing register B
coma_btrb7	= ^xEE0 	; Bank 7 timing register B
coma_btrb8	= ^xF00 	; Bank 8 timing register B

;
; DECchip 21071-CA Error and Diagnostic Status Register Definitions 
;

edsr$v_losterr	= 0		; Multiple Errors 
edsr$v_taperr 	= 1		; Bcache tag address parity error
edsr$v_tcperr 	= 2		; Bcache tag control parity error
edsr$v_nxmerr	= 3		; Non-existent memory error
edsr$v_dmacause = 4		; DMA transaction caused error
edsr$v_viccause	= 5		; Victim write caused error
edsr$v_reqcause	= 6		; Cycle request which cause error bits 
edsr$v_pass2	= 13		; Pass 1 = 0; Pass 2 = 1
edsr$v_ldxlock	= 14		; LDx_L locked
edsr$v_wrpend	= 15		; Write Pending

edsr$m_losterr	= 1@edsr$v_losterr
edsr$m_taperr 	= 1@edsr$v_taperr
edsr$m_tcperr 	= 1@edsr$v_tcperr
edsr$m_nxmerr	= 1@edsr$v_nxmerr
edsr$m_dmacause = 1@edsr$v_dmacause
edsr$m_viccause	= 1@edsr$v_viccause
edsr$m_reqcause	= 1@edsr$v_reqcause
edsr$m_pass2	= 1@edsr$v_pass2
edsr$m_ldxlock	= 1@edsr$v_ldxlock
edsr$m_wrpend	= 1@edsr$v_wrpend

;
; DECchip 21071-DA (Epic) Control and Status Register Definitions
;

epic_dcsr	= ^x000		; Diagnostic control and status register
epic_pear	= ^x020		; PCI error address register
epic_sear	= ^x040		; sysBus error address register
epic_tbr1	= ^x0C0		; Translated base 1 register
epic_tbr2	= ^x0E0		; Translated base 2 register
epic_pbr1	= ^x100		; PCI base 1 register
epic_pbr2	= ^x120		; PCI base 2 register
epic_pmr1	= ^x140		; PCI mask 1 register
epic_pmr2	= ^x160		; PCI mask 2 register
epic_haxr0	= ^x180		; Host address extension register 0
epic_haxr1	= ^x1A0		; Host address extension register 1
epic_haxr2	= ^x1C0		; Host address extension register 2
epic_pmlt	= ^x1E0		; PCI master latency timer
epic_tag0	= ^x200		; TLB tag 0 register
epic_tag1	= ^x220		; TLB tag 1 register
epic_tag2	= ^x240		; TLB tag 2 register
epic_tag3	= ^x260		; TLB tag 3 register
epic_tag4	= ^x280		; TLB tag 4 register
epic_tag5	= ^x2A0		; TLB tag 5 register
epic_tag6	= ^x2C0		; TLB tag 6 register
epic_tag7	= ^x2E0		; TLB tag 7 register
epic_data0	= ^x300		; TLB data 0 register
epic_data1	= ^x320		; TLB data 1 register
epic_data2	= ^x340		; TLB data 2 register
epic_data3	= ^x360		; TLB data 3 register
epic_data4	= ^x380		; TLB data 4 register
epic_data5	= ^x3A0		; TLB data 5 register
epic_data6	= ^x3C0		; TLB data 6 register
epic_data7	= ^x3E0		; TLB data 7 register
epic_tbia	= ^x400		; TLB invalidate all register

;
; DECchip 21071-DA Diagnostic Control and Status Register Definitions
;

dcsr$v_tenb	= 0		; Translation buffer enable (scatter/gather)
dcsr$v_penb	= 2		; Prefetch enable on dma reads
dcsr$v_dcei	= 3		; Disable correctable errors
dcsr$v_iort	= 5		; I/O retry timeout error
dcsr$v_lost	= 6		; Lost error
dcsr$v_ddpe	= 8		; DMA data parity error
dcsr$v_iope	= 9		; I/O parity error
dcsr$v_tabt	= 10		; Target abort error
dcsr$v_ndev	= 11		; No device error
dcsr$v_cmrd	= 12		; Correctable memory read error
dcsr$v_umrd	= 13		; Uncorrectable memory read error
dcsr$v_iptl	= 14		; Invalid page table lookup (scatter/gather)
dcsr$v_merr	= 15		; Memory cycle error
dcsr$v_byp	= 16		; Disable read bypass bits
dcsr$v_pcmd	= 18		; PCI command cycle type
dcsr$v_pass2	= 31		; Pass 1 = 0; Pass 2 = 1

dcsr$m_tenb	= 1@dcsr$v_tenb
dcsr$m_penb	= 1@dcsr$v_penb
dcsr$m_dcei	= 1@dcsr$v_dcei
dcsr$m_iort	= 1@dcsr$v_iort
dcsr$m_lost	= 1@dcsr$v_lost
dcsr$m_ddpe	= 1@dcsr$v_ddpe
dcsr$m_iope	= 1@dcsr$v_iope
dcsr$m_tabt	= 1@dcsr$v_tabt
dcsr$m_ndev	= 1@dcsr$v_ndev
dcsr$m_cmrd	= 1@dcsr$v_cmrd
dcsr$m_umrd	= 1@dcsr$v_umrd
dcsr$m_iptl	= 1@dcsr$v_iptl
dcsr$m_merr	= 1@dcsr$v_merr
dcsr$m_byp	= 3@dcsr$v_byp
dcsr$m_pcmd	= ^xF@dcsr$v_pcmd
dcsr$m_pass2	= 1@dcsr$v_pass2

.if eq noritake_system

; Utility Register Definitions

util$v_flash	= 0		; Flash Space Enable
util$v_fanoff 	= 1		; Fan Off 
util$v_halt 	= 2		; halt button
util$v_hitemp  	= 3		; hi temperature 
util$v_ps1fail	= 4		; power supply 1 fail
util$v_ps2fail	= 5		; power supply 2 fail
util$v_fan1fail	= 6		; fan 1 fail 
util$v_fan2fail	= 7		; fan 2 fail

util$m_flash	= 1@0		; Flash Space Enable
util$m_fanoff 	= 1@1		; Fan Off 
util$m_halt 	= 1@2		; halt button
util$m_hitemp  	= 1@3		; hi temperature 
util$m_ps1fail	= 1@4		; power supply 1 fail
util$m_ps2fail	= 1@5		; power supply 2 fail
util$m_fan1fail	= 1@6		; fan 1 fail 
util$m_fan2fail	= 1@7		; fan 2 fail
.endc

.if ne noritake_system
;
; noritake Utility Register Definitions

util$v_flash    = 0             ; Flash Space Enable
util$v_dcoff    = 1             ; DC power off
util$v_res      = 2             ; reserved
util$v_res1     = 3             ; reserved
util$v_halt     = 4             ; halt button
util$v_flshrdy  = 5             ; Flash ready
util$v_res2     = 6             ; reserved
util$v_vgastat  = 7             ; embedded VGA status

util$m_flash    = 1@0           ; Flash Space Enable
util$m_dcoff    = 1@1           ; DC power off
util$m_res      = 1@2           ; reserved
util$m_res1     = 1@3           ; reserved
util$m_halt     = 1@4           ; halt button
util$m_flshrdy  = 1@5           ; Flash ready
util$m_res2     = 1@6           ; reserved
util$m_vgastat  = 1@7           ; embedded VGA status

; bits 0-1 reserved
nori$v_ps2fail  = 2             ; power supply 2 fail
nori$v_ps1fail  = 3             ; power supply 1 fail
nori$v_tempfail = 4             ; temp exceeded max
nori$v_tempwarn = 5             ; temp warning
nori$v_fan2fail = 6             ; fan 2 fail
nori$v_fan1fail = 7             ; fan 1 fail

nori$m_ps2fail  = 1@2           ; power supply 2 fail
nori$m_ps1fail  = 1@3           ; power supply 1 fail
nori$m_tempfail = 1@4           ; temp exceeded max
nori$m_tempwarn = 1@5           ; temp warning
nori$m_fan2fail = 1@6           ; fan 2 fail
nori$m_fan1fail = 1@7           ; fan 1 fail

nori$v_allbits  = ^xfc          ; gives all bits

nor_irr1        =  ^x0542       ; interrupt request register [word]
nor_irr2        =  ^x0544       ; interrupt request register [word]
nor_irr3        =  ^x0546       ; interrupt request register [word]
nor_imr1        =  ^x054a       ; interrupt mask register [word]
nor_imr2        =  ^x054c       ; interrupt mask register [word]
nor_imr3        =  ^x054e       ; interrupt mask register [word]
.endc

;
; DECchip 21071-DA (Epic) Machine Check Codes
; Pal Code uses the first 255 reason codes
;

mchk$c_iort	= ^x201		; I/O retry timeout error
mchk$c_ddpe	= ^x202		; DMA data parity error
mchk$c_iope	= ^x203		; I/O data parity error
mchk$c_tabt	= ^x204		; Target abort error
mchk$c_ndev	= ^x205		; No device error 
mchk$c_cmrd	= ^x206		; Correctable memory read error
mchk$c_umrd	= ^x207		; Uncorrectable memory read error
mchk$c_iptl	= ^x208		; Invalid page table lookup (scatter/gather)
mchk$c_merr	= ^x209		; Memory cycle error

;
; DECchip 21071-CA (Commanche) Machine Check Codes (HW Vector 0x20)
; 

mchk$c_ctaperr 	= ^x20A		; Bcache tag address parity error
mchk$c_ctcperr 	= ^x20B		; Bcache tag control parity error
mchk$c_nxmerr	= ^x20C		; Non-existent memory error

; SIO Errors ( IOCHECK in NMI Status Register)

mchk$c_serr	= ^x20D		; serr bit asserted
;
; Make these different for K2.
;
.if eq	k2_system
mchk$c_iochk	= ^x20D		; iochk bit asserted
.if_false
mchk$c_iochk	= ^x20E		; iochk bit asserted
.endc

;
; Mikasa Specific Machine Check Codes  
; These codes based on Utility Register 
;
; 0 - flash space enable
; 1 - fan off 
; 2 - halt button 
; 3 - hi temperature
; 4 - power supply 1 failed
; 5 - power supply 2 failed
; 6 - fan 1 failed
; 7 - fan 2 failed

;
; Noritake Specific Machine Check Codes  
; These codes based on Utility Register 
;
; 0 - spare
; 1 - spare
; 2 - power supply 2 failed
; 3 - power supply 1 failed
; 4 - Temp failure
; 5 - Temp warning
; 6 - fan 2 failed
; 7 - fan 1 failed

; These come in at vector 660 and are fatal
; 
mchk$c_TempFail   = ^x220		; Temperature to high
mchk$c_PSFail	  = ^x221		; complete power supply failure
;
; These come in at vector 620 and are non-fatal.  The os must decide what to do.
mchk$c_Fan1Fail	  = ^x223		; Fan 1 failure
mchk$c_Fan2Fail	  = ^x224		; Fan 2 failure
mchk$c_PS1Fail	  = ^x225		; power supply 1 failure
mchk$c_TempWarn	  = ^x226		; Temperature Warning
mchk$c_PS2Fail	  = ^x227		; Power supply 2 failure
mchk$c_unused	  = ^x228		; 
mchk$c_FanWarn	  = ^x229		; Fan fail warning (K2)


;
; These are Unknown codes, i.e. could not figure out the error 
;

mchk$c_siounk	= ^x240		; Unknown SIO NMI Error
mchk$c_pciunk	= ^x250		; Unknown DECchip 21071-DA Error
mchk$c_comunk	= ^x260		; Unknown DECchip 21071-CA Error (possible parity error)- cpu reported

icw1		= 0		; Initialization control word 1 offset
icw2		= 1		; Initialization control word 2 offset
icw3		= 1		; Initialization control word 3 offset
icw4		= 1		; Initialization control word 4 offset

ocw1		= 1		; Operational control word 1 offset
ocw2		= 0		; Operational control word 2 offset
ocw3		= 0		; Operational control word 3 offset

.if ne k2_system
;
; K2 PCI interrupt accelerator defs.
;
k2$l_int_conf	= ^x0500
k2$w_watchdog	= ^x0504
k2$w_management	= ^x0506
k2$l_int_reg1	= ^x0510
k2$l_int_reg2	= ^x0514
k2$l_int_reg3	= ^x0518
k2$l_int_reg4	= ^x051c

int_reg_base	= ^x0510
mask_conf_reg	= ^x3fc0
mask_int_reg	= ^xffff
accel_enable	= ^xbfc0
watchdog_init	= ^x011b
management_init	= ^x01e0
;
; K2 SIO defs.
;

p_byte          = ^x0
p_word          = ^x1
p_tribyte       = ^x2
p_dblword       = ^x3

sio$w_status	= <^x06@5> ! <p_word@3>
sio$b_rev	= <^x08@5> ! <p_byte@3>
sio$b_ubcsa	= <^x4E@5> ! <p_byte@3>
sio$b_ubcsb	= <^x4F@5> ! <p_byte@3>
sio$l_pirq	= <^x60@5> ! <p_dblword@3>

sio$irq_mask0	= ^x21
sio$irq_mask1	= ^xA1
sio$irq_edge0	= ^x4D0
sio$irq_edge1	= ^x4D1
sio$irq_ocw3c0	= ^x20
sio$irq_ocw3c1	= ^xA0
sio$b_nmisc     = ^x61
sio$b_nmienable = ^x70
sio$b_dma_stat0	= ^x08
sio$b_dma_stat1	= ^xD0

sio_irr		= ^x0A
sio_isr		= ^x0B
;
; These are error codes used by K2 :-
;
;	1. That come in at vector 660 and are fatal
; 
;mchk$c_TempFail   = ^x220		; Temperature to high
;mchk$c_Fan1Fail   = ^x223		; Fan 1 failure
;
;	2. That come in at vector 620 and are non-fatal.  
;	   The os must decide what to do.
;
;mchk$c_TempWarn   = ^x226		; CPU Temperature Warning
;mchk$c_FanWarn	   = ^x229		; System Fan fail Warning
;
.endc;
;
;
; Dallas DS1287A Real Time Clock (RTC) definitions
;
rtcadd		= ^x70		; RTC address register.
rtcdat		= ^x71		; RTC data register.

.endc


	.if ne	lean_system ! mtu_system

; SIO Errors ( IOCHECK in NMI Status Register)

mchk$c_serr	= ^x14		; serr bit asserted
mchk$c_iochk	= ^x15		; iochk bit asserted

;
; EB66 Address Space Partitioning
;
;	   Address Bit
;	33 32 31 30 29 28	Description
;	-----------------	-------------------------
;	 0  1  0  0  1  0	Memory Controller CSRs
;	 0  1  1  0  0  0	I/O Controller CSRs
;	 0  1  1  1  0  0	PCI Interrupt ACK
;	 0  1  1  1  1  0	PCI Configuration
;	 1  0  0  0  0  0	PCI Memory
;	 1  1  0  0  0  0	PCI I/O
;
; The following definitions need to be shifted left 28 bits
; to obtain their respective reference points.
;

.iif	ndf	LCA4_PASS2, LCA4_PASS2 = 0	; default to p1
.if eq	LCA4_PASS2
i_ack		= ^x1C		; Interrupt acknowledge.
cfig_base	= ^x1E		; Configuration base address.
io_base		= ^x30		; I/O base address.
.if_false
i_ack		= ^x1A		; Interrupt acknowledge.
cfig_base	= ^x1E		; Configuration base address.
io_base		= ^x1C		; I/O base address.
.endc

	.endc

	.if ne avanti_system ! -
		k2_system ! -
		lean_system ! -
		mtu_system ! -
		mikasa_system ! -
		noritake_system ! -
		cortex_system

p_byte          = ^x0
p_word          = ^x1
p_tribyte       = ^x2
p_dblword       = ^x3

irr		= ^x534			; Mikasa Interrupt Request Register
imr		= ^x536			; Mikasa Interrupt Mask Register
utility		= ^x532			; Mikasa Utility Register 
iic 		= ^x530			; Address of the OCP inteface GPCS0 asserted
s1 		= 1			
s1$m_pin 	= 128

imr$m_psi	= ^x2000		; power subsystem interrupt enable
imr$m_temp_warn	= ^x4000		; power subsystem teperature warning enable

;
; 82378IB System I/O (SIO) Configuration Register Definitions
;

sio$b_pcr	= <^x40@5> ! <p_byte@3>	; PCI Control Register
sio$b_pac	= <^x41@5> ! <p_byte@3>	; PCI Arbiter Control
sio$b_iadcon	= <^x48@5> ! <p_byte@3>	; ISA Address Decoder Control
sio$b_iadrbe	= <^x49@5> ! <p_byte@3>	; ISA Address Decoder ROM Block Enable
sio$b_icd	= <^x4D@5> ! <p_byte@3> ; ISA Clock Divisor
sio$b_ubcsa	= <^x4E@5> ! <p_byte@3>	; Utility Bus Chip Select A
sio$b_ubcsb	= <^x4F@5> ! <p_byte@3>	; Utility Bus Chip Select B

;
; PAC - PCI Arbiter Control Register Definitions
;
;	  Bit	Size	Description
;	 -----	----	---------------------------------
;	 <7:5>	  3	Reserved - RAZ
;	 <4:3>	  2	Master Retry Timer
;			   0 0	Timer disabled, Retries never masked
;			   0 1	Retries unmasked after 16 PCICLK's
;			   1 0  Retries unmasked after 32 PCICLK's
;			   1 1	Retries unmasked after 64 PCICLK's
;	   <2>	  1	Bus Park Enable
;	   <1>	  1	Bus Lock Enable
;	   <0>	  1	Guaranteed Access Time Mode Enable

pac$v_gat	= 0
pac$m_gat       = ^x1
pac$v_bl	= 1
pac$m_bl        = ^x2
pac$v_bp	= 2
pac$m_bp        = ^x4
pac$v_mrt	= 3
pac$m_mrt       = ^x18

pac$k_init      = ^x04
;pcr$k_init      = ^x6c
; changed because slow response is what is needed at this time.
pcr$k_init      = ^x60

pcrx$k_init     = ^x00
;
; IADCON - ISA Address Decoder Control Register Definitions
;
;	  Bit	Size	Description
;	 -----	----	---------------------------------
;	 <7:4>	  4	Top of Memory  1-16 Mbytes
;	 <0:3>	  4	Memory Block Enables
;			   0	0-512 Kbyte Memory
;			   1	512-640 Kbyte Memory
;			   2	640-768 Kbyte VGA Memory
;			   3	896-960 Kbyte Low BIOS
;

iad$v_mb        = 0
iad$m_mb	= ^xF
iad$v_tom       = 4
iad$m_tom	= ^xF

iad$k_init      = ^xFF

;
; IADRBE - ISA Address Decoder ROM Block Enable Register Definitions
;
;	  Bit	Size	Description
;	 -----	----	---------------------------------
;	   <7>    1	880-896K Memory Enable
;	   <6>    1	864-880K Memory Enable
;	   <5>    1	848-864K Memory Enable
;	   <4>    1	832-848K Memory Enable
;	   <3>    1	816-832K Memory Enable
;	   <2>    1	800-816K Memory Enable
;	   <1>    1	784-800K Memory Enable
;	   <0>    1	768-784K Memory Enable
;

rbe$k_init	= ^xFF

;
; UBCSA - Utility Bus Chip Select A Register Definitions
;
;	  Bit	Size	Description
;	 -----	----	---------------------------------
;	   <7>    1	Extended BIOS Enable
;	   <6>    1	Lower BIOS Enable
;	   <5>    1	Floppy Disk Address Locations Enable
;	   <4>    1	IDE Decode Enable
;	 <3:2>    2	Floppy Disk Address Locations Enable	
;	   <1>    1	Keyboard Controller Address Location Enable
;	   <0>    1	RTC Address Location Enable
;

uba$v_rtc	= 0
uba$m_rtc       = ^x1
uba$v_kbd	= 1
uba$m_kbd       = ^x2
uba$v_fl	= 2
uba$m_fl        = ^x2C
uba$v_lbios	= 6
uba$m_lbios     = ^x40
uba$v_xbios	= 7
uba$m_xbios     = ^x80

;
; Need the BIOS bits disabled for K2.
;
.if eq	k2_system
uba$k_init      = ^xFF
.if_false
uba$k_init      = ^x3F
.endc

;
; UBCSB - Utility Bus Chip Select B Register Definitions
;
;	  Bit	Size	Description
;	 -----	----	---------------------------------
;	   <7>    1	Configuration RAM Decode Enable
;	   <6>    1	Port 92 Enable
;	 <5:4>    2	Parallel Port Enable
;			   0 0	3BCh - 3BFh (LPT1)
;			   0 1	378h - 37Fh (LPT2)
;			   1 0	278h - 27Fh (LPT3)
;			   1 1	Disabled
;	 <3:2>    2	Serial Port B Enable
;			   0 0	3F8h - 3FFh (COM1)
;			   0 1	2F8h - 2FFh (COM2)
;			   1 0	Reserved
;			   1 1	Disabled
;	 <1:0>    2	Serial Port A Enable
;			   0 0	3F8h - 3FFh (COM1)
;			   0 1	2F8h - 2FFh (COM2)
;			   1 0	Reserved
;			   1 1	Disabled
;

ubb$v_com1	= 0
ubb$m_com1      = ^x03
ubb$v_com2	= 2
ubb$m_com2      = ^x0C
ubb$v_lpt	= 4
ubb$m_lpt       = ^x30
ubb$v_port92	= 6
ubb$m_port92    = ^x40
ubb$v_cfig	= 7
ubb$m_cfig      = ^x80

ubb$k_init	= ^xFF

;
; 82378IB System I/O (SIO) DMA Register Definitions
;
sio$b_dcm       = ^xD6

;
; DCM - DMA Channel Mode Register Definitions
;
;	  Bit	Size	Description
;	 -----	----	---------------------------------
;	 <7:6>    2	DMA Transfer Mode
;                          0 0  Demand mode
;                          0 1  Single mode
;                          1 0  Block mode
;                          1 1  Cascade mode
;	   <5>    1	Address Increment/Decrement Select
;	   <4>    1	Autoinitialize Enable
;	 <3:2>    2	DMA Transfer Type
;                          0 0  Verify transfer
;                          0 1  Write transfer
;                          1 0  Read transfer
;                          1 1  Illegal
;	 <1:0>    2	DMA Channel Select
;                          0 0  Channel 0
;                          0 1  Channel 1
;                          1 0  Channel 2
;                          1 1  Channel 3
;
dcm$k_init      = ^xC1

;
; 82378IB System I/O (SIO) Control Register Definitions
;
sio$b_nmisc     = ^x61
sio$b_nmi	= ^x70

nmiecsr = ^x461
bus_reset = 1

;
; NMISC - NMI Status and Control Register Definitions
;
;	  Bit	Size	Description
;	 -----	----	---------------------------------
;	   <7>    1	SERR Status
;	   <6>    1	IOCHK Status
;	   <5>    1	Timer Counter 2 Status
;	   <4>    1	Refresh Cycle Toggle
;	   <3>    1	IOCHK Enable
;          <2>    1     SERR Enable
;          <1>    1     Speaker Data Enable
;          <0>    1     Timer Counter 2 Enable
;

nmisc$v_serr      = 7
nmisc$v_iochk     = 6
nmisc$v_iochk_en  = 3
nmisc$v_serr_en   = 2

nmisc$m_serr      = 1@nmisc$v_serr
nmisc$m_iochk     = 1@nmisc$v_iochk
nmisc$m_iochk_en  = 1@nmisc$v_iochk_en
nmisc$m_serr_en   = 1@nmisc$v_serr_en

;
; NMI - NMI Enable and Real-Time Clock Address Register Definitions
;
;	  Bit	Size	Description
;	 -----	----	---------------------------------
;	   <7>    1	NMI Enable
;	 <6:0>    7	Real Time Clock Address
;
nmi$v_enable	= 7
nmi$m_enable	= 1@nmi$v_enable
nmi$v_rtcadd	= 0
nmi$m_rtcadd	= ^x7F

; Cortex uses fdc37c665gt, not 87312, so ignore 87312 symbols.
.if eq	cortex_system
;
; 87312 UART Serial Port Definitions
;
com1	= ^x3F8			; COM1 serial line port address.
com2	= ^x2F8			; COM2 serial line port address.
bindex	= ^x26E			; 87312 Index Register 
bdata	= ^x26F			; 87312 Data Register 
bindex1	= ^x398			; 87312 Index Register address
bdata1	= ^x399			; 87312 Data Register 
ind_fer = 0			; FER
ind_far = 1			; FAR
ind_ptr = 2			; PTR
ind_fcr = 3			; FCR  -  87303 extended config regs
ind_pcr = 4			; PCR
ind_krr = 5			; KRR
ind_pmc = 6			; PMC
ind_tup = 7			; TUP
ind_sid = 8			; SID
ind_asc = 9			; ASC
ind_cs0cf0 = 10			; CS0CF0
ind_cs0cf1 = 11			; CS0CF1
ind_cs1cf0 = 12			; CS1CF0
ind_cs1cf1 = 13			; CS1CF1

fdc$b_rbr	= 0		; Receive buffer register offset
fdc$b_thr	= 0		; Transmitter holding register offset
fdc$b_dll	= 0		; Divisor latch (LS) offset
fdc$b_dlh	= 1		; Divisor latch (MS) offset
fdc$b_ier	= ^x1		; Interrupt enable register offset
fdc$b_iir	= ^x2		; Interrupt identification register offset
fdc$b_lcr	= ^x3		; Line control register offset
fdc$b_mcr	= ^x4		; Modem control register offset
fdc$b_lsr	= ^x5		; Line status register offset
fdc$b_msr	= ^x6		; Modem status register offset
fdc$b_scr	= ^x7		; Scratch register offset

dla$k_brg	= 12		; Baud rate generator divisor = 9600 
lsr$v_thre	= 5		; Transmitter holding register empty bit offset

lcr$v_wls	= 0
lcr$v_stb	= 2
lcr$v_pen	= 3
lcr$v_eps	= 4
lcr$v_dlab	= 7

lcr$m_wls	= 3@lcr$v_wls
lcr$m_stb	= 1@lcr$v_stb
lcr$m_pen	= 1@lcr$v_pen
lcr$m_eps	= 1@lcr$v_eps
lcr$m_dlab	= 1@lcr$v_dlab

lcr$k_init	=  <1@lcr$v_stb> ! <3@lcr$v_wls>

;
; MCR - Modem Control Register Definitions
;
;	  Bit	Size	Description
;	 -----	----	---------------------------------
;	 <7:5>    3	RAZ
;	   <4>    1	Loop
;	   <3>    1	IRQ Enable
;	   <2>	  1	Out1 Bit
;	   <1>    1	Request to Send
;	   <0>	  1	Data Terminal Ready
;

mcr$v_dtr	= 0
mcr$v_rts	= 1
mcr$v_out1	= 2
mcr$v_irq	= 3
mcr$v_loop	= 4

mcr$m_dtr	= 1@mcr$v_dtr
mcr$m_rts	= 1@mcr$v_rts
mcr$m_out1	= 1@mcr$v_out1
mcr$m_irq	= 1@mcr$v_irq
mcr$m_loop	= 1@mcr$v_loop

mcr$k_init	= <1@mcr$v_irq> ! <1@mcr$v_out1> ! <1@mcr$v_rts> ! <1@mcr$v_dtr>

.endc
;
; Intel 82C59 Priority Interrupt Controller (PIC) Register Definitions
;

pic1		= ^x20		; Controller 1 base address.
pic2		= ^xA0		; Controller 2 base address.

int1	= ^x20			; Controller 1 base address.
int2	= ^xA0			; Controller 2 base address.

;
; both definitions are being included to limit the number of edits
; 

int$b_icw1	= 0		; Initialization control word 1 offset
icw1		= 0		; Initialization control word 1 offset
int$b_icw2	= 1		; Initialization control word 2 offset
icw2		= 1		; Initialization control word 2 offset
int$b_icw3	= 1		; Initialization control word 3 offset
icw3		= 1		; Initialization control word 3 offset
int$b_icw4	= 1		; Initialization control word 4 offset
icw4		= 1		; Initialization control word 4 offset

int$b_ocw1	= 1		; Operational control word 1 offset
ocw1		= 1		; Operational control word 1 offset
int$b_ocw2	= 0		; Operational control word 2 offset
ocw2		= 0		; Operational control word 2 offset
int$b_ocw3	= 0		; Operational control word 3 offset
ocw3		= 0		; Operational control word 3 offset

;
; DS1287A Real Time Clock (RTC) definitions
;
rtcadd		= ^x70		; RTC address register.
rtcdat		= ^x71		; RTC data register.

;
; Config Cycle IDSEL using pass 2 embedded and type 0 access only
;
cbyte		= ^x00		; configuration read 1 byte
cword 		= ^x08		; configuration read 2 byte
ctribyte	= ^x10		; configuration read 3 byte
clong 		= ^x18		; configuration read 4 byte

cfig_810	= ^x0006	; High Bits 810 
cfig_pceb	= ^x0007	; High Bits PCI bridge chip
cfig_slot0	= ^x000B	; High Bits slot 0 bits 
cfig_slot1	= ^x000C	; High Bits slot 1 bits 
cfig_slot2	= ^x000D	; High Bits slot 2 bits 

; Config Space Address of PCEB registers
pceb_vid	= ^x0000	; vendor id at 0:1 [word]
pceb_did	= ^x0002	; device id at 2:3 [word]		
pceb_command    = ^x0004 	; command register 4:5 [word]
pceb_status	= ^x0006	; status  register 6:7 [word]
pceb_latency	= ^x000D	; latency value D [byte]
pceb_revision   = ^x0008	; revision register 8 [byte]
pceb_control	= ^x0040	; pci control register [byte]
pceb_arbcon	= ^x0041	; pci arb control  register [byte]
pceb_arbpri	= ^x0042	; pci arb priority register [byte]	

;
; ESC configuration space registers 
; accessed using index/data pairs
;
esc_id		= ^x0002	; esc ID value [byte]	
esc_revision	= ^x0008	; esc revision id [byte	

; ESC registers in I/O space
esc_int0	= ^x0021	; esc interrupt controller 0
esc_int1	= ^x00A1	; esc interrupt controller 1
esc_elcr0	= ^x04D0	; edge level control 0	
esc_elcr1	= ^x04D1	; edge level control 1	
esc_last_eisa	= ^x0464	; eisa last bus master 	
esc_nmi_stat	= ^x0061	; NMI status register		

;
; Mikasa specific registers
;
mik_utility	= ^x0532	; utility register [word] (all that fan stuff)
mik_irr		= ^x0534	; interrupt request register [word]			
mik_imr		= ^x0536	; interrupt mask register [word]	

;
; Noriake specific registers
;
.if  ne noritake_system
nor_irr1	=  ^x0542	; interrupt request register [word]	
nor_irr2	=  ^x0544	; interrupt request register [word]	
nor_irr3        =  ^x0546	; interrupt request register [word]	
nor_imr1	=  ^x054a	; interrupt mask register [word]		
nor_imr2	=  ^x054c	; interrupt mask register [word]		
nor_imr3        =  ^x054e	; interrupt mask register [word]		

.endc

;
; Macro definitions
;


;
; MACRO to do a config read cycle
; Assume Longword Access only
;
.macro  cfg_read idsel , register, mask=clong, tmp0=r6, tmp1=r7
	bis	r31,r31,tmp0			; Clear out tmp0
	lda	tmp1, cfig_base(r31)		; Load Config base address 1E
	sll	tmp1, 28, tmp1			; Shift Left 28 1.E000.0000
	ldah	tmp1, idsel (tmp1)		; Or in which device to config (0.0080.0000) for example
	lda	tmp0, register(r31)		; Register Offset in config space
	sll	tmp0,5,tmp0			; Shift left by 5 for sparse offset
	bis	tmp1,tmp0,tmp1			; Config address in tmp1 
	bis	tmp1,#mask,tmp1			; Or in the byte mask (1,2,3,4 bytes)
        ldl/p   tmp0, (tmp1)			; Read the Data from config space
.endm

;
; MACRO to do a config write
;
.macro  cfg_write device , register, value, mask=clong, tmp0=r6, tmp1=r7
	bis	r31,r31,tmp0			; Clear out tmp0
	lda	tmp1, cfig_base(r31)		; Load Config base address 1E
	sll	tmp1, 28, tmp1			; Shift Left 28 1.E000.0000
	ldah	tmp1, idsel (tmp1)		; Or in which device to config (0.0080.0000) for example
	lda	tmp0, register(r31)		; Register Offset in config space
	sll	tmp0, 5,tmp0			; Shift left by 5 for sparse offset
	bis	tmp1, tmp0,tmp1			; Config address in tmp1 
	lda	tmp0, value (r31)		; Value to write in tmp0
	bis	tmp1,#mask,tmp1			; Or in the byte mask (1,2,3,4 bytes)
        stl/p   tmp0, (tmp1)			; Read the Data from config space
	mb
.endm

;
; Macro definitions
;

;
; MACRO to write an 8-bit byte to an I/O space address
;
.macro  out     port, val, tmp0=r12, tmp1=r13
        byte_loc = <<port & ^x3> * 8>	; Byte enable bits of port address.

	lda	tmp1, io_base(r31)	; Load I/O base address.
	sll	tmp1, <28-5>, tmp1
	lda	tmp1, port(tmp1)	; Form the port address.
        sll     tmp1, 5, tmp1		; Shift it into correct position.
        bis     r31, val, tmp0		; Load the port data.
.if     ne      byte_loc
        sll     tmp0, byte_loc, tmp0	; Get data into the proper byte lane.
.endc
        stl/p   tmp0, (tmp1)		; Write the data out to the port.
        mb				; Make sure it gets there.
.endm

;
; MACRO to read an 8-bit byte from an I/O space address
;
.macro  in      port, tmp0
	byte_loc = <<port & ^x3> * 8>	; Byte enable bits of port address.

	lda	tmp0, io_base(r31)	; Load I/O base address.
	sll	tmp0, <28-5>, tmp0
	lda	tmp0, port(tmp0)	; Form the port address.
        sll     tmp0, 5, tmp0		; Shift it into correct position.
        ldl/p   tmp0, (tmp0)		; Read the data from the port.
.if	ne	byte_loc
	srl	tmp0, byte_loc, tmp0	; Return data in low byte.
.endc
	and	tmp0, #^xff, tmp0	; clear away garbage
.endm

;
; MACRO to read a 16-bit word from an I/O space address
;
.macro  in_word      port, tmp0
	byte_loc = <<port & ^x3> * 8>	; Byte enable bits of port address.

	lda	tmp0, io_base(r31)	; Load I/O base address.
	sll	tmp0, <28-5>, tmp0
	lda	tmp0, port(tmp0)	; Form the port address.
        sll     tmp0, 5, tmp0		; Shift it into correct position.
	lda	tmp0, 8(tmp0)		; make it a word operation
        ldl/p   tmp0, (tmp0)		; Read the data from the port.
.if	ne	byte_loc
	srl	tmp0, byte_loc, tmp0	; Return data in low word.
.endc
.endm

;
; MACRO to write a 16-bit word to an I/O space address
;
.macro  out_word     port, val, tmp0=r12, tmp1=r13
        byte_loc = <<port & ^x3> * 8>	; Byte enable bits of port address.

	lda	tmp1, io_base(r31)	; Load I/O base address.
	sll	tmp1, <28-5>, tmp1
	lda	tmp1, port(tmp1)	; Form the port address.
        sll     tmp1, 5, tmp1		; Shift it into correct position.
	lda	tmp1, 8(tmp1)		; make it a word operation
        bis     r31, val, tmp0		; Load the port data.
.if     ne      byte_loc
        sll     tmp0, byte_loc, tmp0	; Get data into the proper byte lane.
.endc
        stl/p   tmp0, (tmp1)		; Write the data out to the port.
        mb				; Make sure it gets there.
.endm

;
; MACRO to acknowledge interrupts
;
; A typical SIO interrupt acknowledge sequence is as follows.
; The CPU generates an interrupt acknowledge cycle that is
; translated into a single PCI command and broadcast across
; the PCI bus to the SIO.  The SIO interrupt controller
; translates this command into the two INTA# pulses expected
; by the interrupt controller subsystem.
;
; On the first iAck cycle, the cascading priority is resolved 
; to determine which of the two controllers will output the 
; interrupt vector onto the data bus.  On the second iAck cycle, 
; the appropriate controller drives the data bus with an 8-bit 
; pointer to the correct interrupt vector for the highest priority 
; interrupt.
;
.macro  iack    tmp0=r14, tmp1=r13
	lda	tmp1, i_ack(r31)	; Load iAck address.
	sll	tmp1, #28, tmp1		; Shift it into the correct position.
        ldl/p   tmp0, (tmp1)		; Initiate PCI iAck cycle.
.endm

;
; MACRO to read a DECchip 21071-CA (Commanche) CSR
;
.macro  in_coma csr, tmp0=r0, tmp1=r6
        bis     r31, r31, tmp0          ; Clear out tmp0
        lda     tmp1, coma_base(r31)    ; Load DECchip 21071-CA base address.
        sll     tmp1, #28, tmp1         ; Shift it into correct position.
        lda     tmp1, csr(tmp1)         ; Or in the CSR offset.
        ldl/p   tmp0, (tmp1)            ; Read the data from the register.
.endm

;
; MACRO to write a DECchip 21071-CA (Commanche) CSR
;
.macro  out_coma csr, value, tmp0=r6, tmp1=r7
        bis     r31, r31, tmp0          ; Clear out tmp0
        lda     tmp1, coma_base(r31)    ; Load DECchip 21071-CA base address.
        sll     tmp1, #28, tmp1         ; Shift it into correct position.
        lda     tmp1, csr(tmp1)         ; Or in the CSR offset.
        lda     tmp0, value(r31)        ; Load the register data.
        stl/p   tmp0, (tmp1)            ; Write the data out to the register.
        mb                              ; Make sure it gets there.
.endm

;
; MACRO to read a DECchip 21071-DA (Epic) CSR
;
.macro  in_epic csr, tmp0=r6, tmp1=r7
        bis     r31, r31, tmp0          ; Clear out tmp0
        lda     tmp1, epic_base(r31)    ; Load DECchip 21071-DA base address.
        sll     tmp1, #28, tmp1         ; Shift it into position.
        lda     tmp1, csr(tmp1)         ; Or in the CSR offset.
        ldl/p   tmp0, (tmp1)            ; Read the data from the register.
.endm

;
; MACRO to write a DECchip 21071-DA (Epic) CSR
;
.macro  out_epic csr, value, tmp0=r6, tmp1=r7
        bis     r31, r31, tmp0          ; Clear out tmp0
        lda     tmp1, epic_base(r31)    ; Load DECchip 21071-DA base address.
        sll     tmp1, #28, tmp1         ; Shift it into position
        lda     tmp1, csr(tmp1)         ; Or in the CSR offset
        lda     tmp0, value(r31)        ; Load the register data.
        stl/p   tmp0, (tmp1)            ; Write the data out to the register.
        mb                  		; Make sure it gets there.
.endm


.macro	cfw_setup
.endm	

.macro	cfw_lock
.endm

.macro	cfw_putc	c
.endm

.macro	cfw_unlock
.endm

	.endc
	
	.endc


	.if ne	medulla_system
.sbttl	Medulla PALcode Macros and Definitions

;
; Medulla platform specific definitions and macros.
;
;   A few conventions are followed for Medulla. It is assumed that R12-R15
; are generally available for use by the reset and interrupt code and are
; used as follows:
;	R12	used to form and hold the latest address calculated
;	R13	used as parameter data passing
;	R14	used as a "scratch" register
;	R15	used as a "scratch" register
;
; Compile-time initializations:
;
;   This variable is used to make sure that if an address setup is not done
;   in one of the macro calls, then the last address held in R12 is the same
;   one as that expected by the current macro invocation. 
	medu$last_addr 		== 0

;   This value is the number of bits to be shifted for the PCI address. For 
;   LCADS, the shift distance is 7 bits, while it is 5 for LCA.
     	.if ne medulla_lcads
	  MEDU$K_PCI_ADDR_SHIFT	== 7
	.iff
	  MEDU$K_PCI_ADDR_SHIFT	== 5
	.endc

	.if ne	lca4
; Carve out a piece of the impure area
;
.macro	.blkq	n
$$$dot = $$$dot + <n * 8>
.endm

;;;$$$dot = pal$impure_base + impure$medulla_scratch_offset
$$$dot = pal$impure_base

medu_impure_base = $$$dot

$$$dot = $$$dot + impure$medulla_scratch_offset

;MEDULLA DEBUG
; debug area
medu$q_temp1 = $$$dot - medu_impure_base
	.blkq	1
medu$q_temp2 = $$$dot - medu_impure_base
	.blkq	1
medu$q_temp3 = $$$dot - medu_impure_base
	.blkq	1
;MEDULLA DEBUG

; Mask of enabled interrupts, this IPL, one bit per device
;
medu$q_last_masked = $$$dot - medu_impure_base
	.blkq	1

; Mask of enabled interrupts, one bit per device
;
medu$q_enabled_ints_mask = $$$dot - medu_impure_base
	.blkq	1

; Count of watchdog interrupts received
;
medu$q_wdog_ints_count = $$$dot - medu_impure_base
	.blkq	1

.mdelete	.blkq
	.endc

;
; Module base addresses and registers.
;
MEDU$K_VIP_HIBASE       = <^x0010>              ; * 1000H for real
MEDU$K_UART_BASE	= <^x6000>
MEDU$MOD_DISP_REG	= <^x2400>
MEDU$MOD_CONFIG_REG	= <^x2800>
MEDU$MOD_CNTRL_REG	= <^x2C00>
MEDU$MOD_RSTREASON_REG	= <^x3000>
MEDU$ENET_ID_REG	= <^x3800>
MEDU$HBEAT_CLR_REG	= <^x2000>


;
; medu$pci_addr (PciDevAddr, AddrReg, AddrSetup)
; 
;   Description: 
;	This macro generates a PCI physical address from the input PCI-based 
;	device address.  The macro works both for the LCADS and LCA systems.
;   Input Parameters: 
;	PciDevAddr - the device address in PCI space.
;	AddrReg - temporary register where address is formed. If no register
;		is specified, then R12 is used as default. 
;	AddrSetup - this flag tells the assembler whether or not the address
;		for the LED register needs to be set up prior to the write. 
;		It is assumed that address setup is required. 
;   Detail:
;	Address = 3.0000.0000 + (PCI & 0xffff << 5)    LCA setup
;	Address = 3.0000.0000 + (PCI & 0xffff << 7)    LCADS setup
;
.macro	medu$pci_addr	PciDevAddr, AddrReg=r12, AddrSetup=1
   .if ne AddrSetup
        medu$last_addr == PciDevAddr		; Save addr in compiler variable
	lda	AddrReg, PciDevAddr(r31)	; AddrReg = 0.0000.xxxx
	.if ne <<PciDevAddr>&^x8000>
	zap	AddrReg,#^x0fc,AddrReg		; Clear out any sign-extension
	.endc
      .if ne medulla_lcads
	ldah	AddrReg, ^x600(AddrReg)		; AddrReg = 0.0600.xxxx
      .iff
;; joes		LCA4 pass 1 and pass 2 support
        .if ne lca4_pass2
	  ldah	AddrReg, ^xE00(AddrReg)		; AddrReg = 0.0E00.xxxx
        .iff
	  ldah	AddrReg, ^x1800(AddrReg)	; AddrReg = 0.1800.xxxx
        .endc
;; joes
      .endc
	sll	AddrReg, #MEDU$K_PCI_ADDR_SHIFT, AddrReg ; AddrReg = 3.00yy.yyy0
   .endc
.endm

;
; medu$pci_vme_addr (PciRegOffset, AddrReg, AddrSetup)
; 
;   Description: 
;	This macro generates a PCI physical address for sparse memory
;	space VIP and VIC registers from the input PCI-based 
;	register offset.  The macro works both for the LCADS and LCA systems.
;   Input Parameters: 
;	PciRegOffset - the VME register offset in PCI space.
;	AddrReg - temporary register where address is formed. If no register
;		is specified, then R12 is used as default. 
;	AddrSetup - this flag tells the assembler whether or not the address
;		for the LED register needs to be set up prior to the write. 
;		It is assumed that address setup is required. 
;   Detail:
;	Address = 2.0200.0000 + (PCI & 0xffff << 5)    LCA setup
;	Address = 2.0200.0000 + (PCI & 0xffff << 7)    LCADS setup
;
.macro	medu$pci_vme_addr	PciRegOffset, AddrReg=r12, AddrSetup=1
   .if ne AddrSetup
        medu$last_addr == PciRegOffset	; Save addr in compiler variable
	lda	AddrReg, PciRegOffset(r31)	; AddrReg = 0.0010.0xxx
	.if ne <<PciRegOffset>&^x8000>
	zap	AddrReg,#^x0fc,AddrReg		; Clear out any sign-extension
	.endc
      .if ne medulla_lcads
	ldah	AddrReg, <^x400+MEDU$K_VIP_HIBASE>(AddrReg)	; = 0.0410.0000
      .iff
	ldah	AddrReg, <^x1000+MEDU$K_VIP_HIBASE>(AddrReg)	; = 0.1010.0000
      .endc
	sll	AddrReg, #MEDU$K_PCI_ADDR_SHIFT, AddrReg ; AddrReg = 2.yyy0.0000
   .endc
.endm

;
; medu$reset_pci (PciDevAddr, TempReg1, TempReg2)
; 
;   Description: 
;	This macro generates the appropriate PCI bus reset code either for the 
;	LCADS or the LCA. 
;   Input Parameters: 
;	AddrReg - temporary register where the PCI control register address is 
;		formed. If no register is specified, then R12 is used as 
;		default. 
;	TempReg1 - temporary register. R13 is used as default. 
;	TempReg2 - temporary register. R14 is used as default. 
;
.macro	medu$reset_pci	AddrReg=r12, TempReg1=r13, TempReg2=r14, ?Reset, ?Calm
   .if ne medulla_lcads
	;
	; For the LCADS version, we need to set the RST bit in the LCADS PCI
	; control/status register at 3.0000.0060 for 100us.
	; 
        medu$last_addr == ^x300000060
	ldah	AddrReg, ^x3000(r31)	; AddrReg = 0.3000.0000
	sll     AddrReg, #4, AddrReg	; AddrReg = 3.0000.0000
	lda     AddrReg, ^x060(AddrReg)	; AddrReg = 3.0000.0060 = LCADS PCI CSR
	ldl/p   TempReg1, (AddrReg)	; Read the current value
	and	TempReg1, #^x1F, TempReg1 	; Clear the LEDS feld <7:5>
	or	TempReg1, #^x21, TempReg1	; Set LED1 <5> and the PCI reset <0> bits
	stl/p   TempReg1, (AddrReg)	; Write it out
	mb				; Flush it out of the write buffer

	;
	; Wait for 100 us = (100k ns / 10 ns/cycle) = 10k cycles = 2710H
	;
	pci_delay = ^x4000
	lda	TempReg2, pci_delay(r31)
      Reset:
	stall	1
	subq	TempReg2, #1, TempReg2
	bne	TempReg2, Reset

	and	TempReg1, #^xfe, TempReg1	; Clear the PCI reset <0> bit 
	or	TempReg1, #^x40, TempReg1	; Set LED2 (<6>)
	stl/p   TempReg1, (AddrReg)	; Write it out
	mb				; Flush it out of the write buffer
	;
	; Wait for the PCI devices to settle down:
	;   Wait for 100 us = (100k ns / 10 ns/cycle) = 10k cycles = 2710H

	lda	TempReg2, pci_delay(r31)
      Calm:
	stall	1
	subq	TempReg2, #1, TempReg2
	bne	TempReg2, Calm

   .iff
	;
	; LCA PCI reset code...
	;
   .endc
.endm

;
; medu$write_led (Character, AddrReg, CharReg, AddrSetup)
; 
;   Description: 
;	This macro writes the character to the LED. Do not delay.
;   Input Parameters: 
;	Character - the character to be written to the LED. The value must
;		    be the value from Figure 10 of the Medulla HW spec. 
;	AddrReg - temporary register where address is formed. If no register
;		is specified, then R12 is used as default. 
;	CharReg - temporary register where character value is stored. If no
;		register is specified, then R14 is used as default.
;	AddrSetup - this flag tells the assembler whether or not the address
;		for the LED register needs to be set up prior to the write. 
;		It is assumed that address setup is required. 
;   Detail:
;	Base PCI address = MEDU$MOD_DISP_REG
;		   
.macro	medu$write_led	Character, AddrReg=r12, CharReg=r14, AddrSetup=1
	;
	; Set up the PCI address if necessary. 
	; 
	medu$pci_addr	MEDU$MOD_DISP_REG, AddrReg, AddrSetup
        .iif ne <<medu$last_addr>-<MEDU$MOD_DISP_REG>>, .print 0; Wrong LED address set up!!!
	or	r31, #'Character', CharReg	; Move the data into a register
	stl/p	CharReg, (AddrReg)		; Write out the character.
	mb					; Flush it
.endm

;
; medu$write_led_readable (Character, AddrReg, CharReg)
; 
;   Description: 
;	This macro writes the character to the LED and delays so that the 
;	character can be read. 
;   Input Parameters: 
;	Character - the character to be written to the LED. The value must
;		    be the value from Figure 10 of the Medulla HW spec. 
;	AddrReg - temporary register where address is formed. 
;	CharReg - temporary register where character value is stored. 
;   Detail:
;	Base PCI address = MEDU$MOD_DISP_REG
;		   
.macro	medu$write_led_readable	Character, AddrReg=r12, CharReg=r14, ?Label
	;
	; Put the value on the LED. 
	;
	medu$write_led	<Character>
	;
	; Delay for about 1/2 second. 
	;
	ldah	CharReg, ^x0200(r31)
     Label:
	subq	CharReg, #1, CharReg
	bne	CharReg, Label
.endm

;
; medu$read_sio (SioRegOffset, ResultReg, AddrReg, AddrSetup)
; 
;   Description: 
;	This macro reads the designated register in the SIO chip. The complete 
;	address is set up with this macro. 
;	Note: No memory barrier is perfromed.
;   Input Parameters: 
;	SioRegOffset - the offset of the SIO register to be read. 
;	ResultReg - The register where the data is to be read into. 
;	AddrReg - volatile temporary register used within the macro. If no 
;		register is given, then r14 will be used. 
;	AddrSetup - this flag tells the assembler whether or not the address
;		for the LED register needs to be set up prior to the write. 
;		It is assumed that address setup is required. 
;   Detail:
;	The SIO base address is first formed, and the register offset value 
;	parameter specifies the offset into the SIO memory space. The register
;	is then read into the ResultReg register. No memory barrier is issued.
;		   
.macro	medu$read_sio	SioRegOffset, ResultReg=r13, AddrReg=r12, AddrSetup=1
	;
	; Set up the PCI address if necessary. 
	; 
	medu$pci_addr	SioRegOffset, AddrReg, AddrSetup ; setup PCI addr
     .if ne AddrSetup
	medu$last_addr == <^x3@32> + <SioRegOffset@5>	; any unique value ok
     .endc
	medu$this_addr == <^x3@32> + <SioRegOffset@5>
        .iif ne <<medu$last_addr>-<medu$this_addr>>, .print 0; Wrong SIO read address set up!!!
	ldl/p   ResultReg, (AddrReg)		; Read the value
	extbl	ResultReg, #SioRegOffset&3, ResultReg ; Extract correct byte lane
.endm

;
; medu$write_sio (Data, SioRegOffset, AddrReg, TempReg1, AddrSetup)
; 
;   Description: 
;	This macro performs writes to the designated register in the SIO chip. 
;	The complete address is set up with this macro. 
;   Input Parameters: 
;	Data - the data value to be written to the SIO register.
;	SioRegOffset - the SIO register to be written. This is a numeric value.
;	AddrReg, TempReg1 - temporary registers. These registers are volatile. 
;		If no registers are given, R12 and R15 are assumed. 
;	AddrSetup - this flag tells the assembler whether or not the address
;		for the LED register needs to be set up prior to the write. 
;		It is assumed that address setup is required. 
;   Detail:
;	The SIO base address is first formed, and the register address passed
;	specifies the offset in the SIO memory space. The requested data is
;	then written to the appropriate address. No memory barrier is issued.
;		   
.macro	medu$write_sio	Data, SioRegOffset, AddrReg=r12, TempReg1=r14, AddrSetup=1
	;
	; Set up the PCI address if necessary. 
	; 
	medu$pci_addr	SioRegOffset, AddrReg, AddrSetup ; setup PCI addr
      .if ne AddrSetup
	medu$last_addr == <^x3@32> + <SioRegOffset@5>	; Any unique value ok
      .endc
	medu$this_addr == <^x3@32> + <SioRegOffset@5>
        .iif ne <<medu$last_addr>-<medu$this_addr>>, .print 0; Wrong SIO write address set up!!!
      .if identical <%extract(0,1,Data)> <r> 
;;;  	and	Data, #^xff, TempReg1
	insbl	Data, #SioRegOffset&3, TempReg1	; Insert correct byte lane
      .iff
	lda	TempReg1, <Data>&^xff(r31)	; Load the value into a register
	insbl	TempReg1, #SioRegOffset&3, TempReg1	; Insert correct byte lane
      .endc
	stl/p   TempReg1, (AddrReg)		; Write it out
	mb					; Force it out
.endm


;
; 
; medu$iack
; 
;   Description: 
;	This macro performs the interrupt acknowledge to the SIO's PIC. 
;   Input Parameters: 
;	TempReg1 - a temporary register for this macro to use.
;	Vector  - a register which will hold the interrupt vector after the 
;		  IACK is complete. 
;   Detail:
;	After forming the interrupt acknowledge cycle address, the SIO's PIC
;	is addressed. This write will cause the PIC to acknowdge the interrupt
;	and place the interrupt vector on the data bus, landing in the "Vector" 
;	register. A memory barrier is used to ensure that the data is in the
;	"Vector" register by the next instruction after this macro.
;		   
.macro	medu$iack	Vector=r13, TempReg1=r14, ?done
   .if ne medulla_lcads
	;
	; Check PIC1 (master):
	;
	medu$write_sio	<^x0c>, SIO$B_PIC1_OCW3
	medu$read_sio	SIO$B_PIC1_OCW3, AddrSetup=0
	medu$write_sio	<^x08>, SIO$B_PIC1_OCW3, AddrSetup=0
	; See if the interrupt came from the slave PIC (PIC2).
	cmpeq	Vector, #2, TempReg1
	beq	TempReg1, done

	;
	; It came from the slave PIC. Figure out the vector.
	;
	medu$write_sio	<^x0c>, SIO$B_PIC2_OCW3
	medu$read_sio	SIO$B_PIC2_OCW3, AddrSetup=0
	medu$write_sio	<^x08>, SIO$B_PIC2_OCW3, AddrSetup=0
	; Add 8 to make it vectors 8-15.
	addq	Vector, #8, Vector
     done:
	; 
   .iff
	;
	; LCA version
	;   ###   Need to check the IRQ7 to see if it was passive release
	;   ### or a real IRQ7. 
;;joes
	.if ne lca4_pass2
	ldah	TempReg1, ^x1A00(r31)		; TempReg1 = 0.1A00.0000
	.iff
	ldah	TempReg1, ^x1C00(r31)		; TempReg1 = 0.1C00.0000
	.endc
;; joes
        sll     TempReg1, #4, TempReg1		; TempReg1 = 1.C000.0000
	ldl/p   Vector, (TempReg1)		; IAck the Int and get vector
   .endc
.endm

;
; medu$write_module_reg (Data, ModRegOffset, AddrReg, TempReg, AddrSetup)
; 
;   Description: 
;	This macro performs writes to the designated module register. The
;	available registers are:
;		MEDU$MOD_DISP_REG
;		MEDU$MOD_CONFIG_REG
;		MEDU$MOD_CNTRL_REG
;		MEDU$MOD_RSTREASON_REG
;		MEDU$ENET_ID_REG
;		MEDU$HBEAT_CLR_REG
;	The complete address is set up with this macro. 
;   Input Parameters: 
;	Data - the data value to be written to the module register.
;	ModRegOffset - the Module register to be written (from the list above).
;	AddrReg, TempReg - temporary registers. These registers are volatile. 
;	AddrSetup - this flag tells the assembler whether or not the address
;		for the LED register needs to be set up prior to the write. 
;		It is assumed that address setup is required. 
;   Detail:
;	The module register base address is first formed, and the ModReg
;	address passed specifies which register is to be written. The passed
;	value is then written to the appropriate address. No memory barrier is 
;	issued.
;   
.macro	medu$write_module_reg	Data, ModRegOffset, AddrReg=r12, TempReg=r13, AddrSetup=1
	;
	; Set up the PCI address if necessary. 
	; 
	medu$pci_addr	ModRegOffset, AddrReg, AddrSetup ; setup PCI addr
      .if ne AddrSetup
	medu$last_addr == <^x3@32> + <ModRegOffset@-11>	; Any unique value ok
      .endc
	medu$this_addr == <^x3@32> + <ModRegOffset@-11>
        .iif ne <<medu$last_addr>-<medu$this_addr>>, .print 0; Wrong module address set up!!!
      .if identical <%extract(0,1,Data)> <r> 
	and	Data, #^xff, TempReg
      .iff
	or	r31, #<Data>, TempReg		; Load the value into a register
      .endc
	stl/p   TempReg, (AddrReg)		; Write out the value
	mb					; Flush it
.endm

;
; medu$write_toy (Data, ToyOffset, AddrReg, TempReg, AddrSetup)
; 
;   Description: 
;	This macro performs writes to the designated register of the TOY chip.
;	The complete address is set up with this macro. 
;   Input Parameters: 
;	Data - the data value to be written to the module register.
;	ToyOffset - the TOY register offset to be written (from the list above).
;	AddrReg, TempReg - temporary registers. These registers are volatile. 
;	AddrSetup - this flag tells the assembler whether or not the address
;		for the LED register needs to be set up prior to the write. 
;		It is assumed that address setup is required. 
;   Detail:
;	The TOY register base address is first formed, and the ToyOffset
;	address passed specifies which register is to be written. The passed
;	value is then written to the appropriate address. No memory barrier is 
;	issued.
;   
.macro	medu$write_toy	Data=r13, ToyOffset, AddrReg=r12, TempReg=r14, AddrSetup=1
	.if ne medulla_pass1
	;
	; There is a bug in the wiring of the TOY clock for pass 1, so compute
	; the address that works with pass 1 Medulla modules. 
	;
	.iif eq <<ToyOffset>-<^x00>>, Address == <^x8000>
	.iif eq <<ToyOffset>-<^x01>>, Address == <^xC000>
	.iif eq <<ToyOffset>-<^x02>>, Address == <^xA000>
	.iif eq <<ToyOffset>-<^x03>>, Address == <^xE000>
	.iif eq <<ToyOffset>-<^x04>>, Address == <^x9000>
	.iif eq <<ToyOffset>-<^x05>>, Address == <^xD000>
	.iif eq <<ToyOffset>-<^x06>>, Address == <^xB000>
	.iif eq <<ToyOffset>-<^x07>>, Address == <^xF000>
	.iif eq <<ToyOffset>-<^x08>>, Address == <^x8800>
	.iif eq <<ToyOffset>-<^x09>>, Address == <^xC800>
	.iif eq <<ToyOffset>-<^x0a>>, Address == <^xA800>
	.iif eq <<ToyOffset>-<^x0b>>, Address == <^xE800>
	.iif eq <<ToyOffset>-<^x0c>>, Address == <^x9800>
	.iif eq <<ToyOffset>-<^x0d>>, Address == <^xD800>
	.if_false
	  Address == <ToyOffset&^xffff>
	.endc 
	;
	; Set up the PCI address if necessary. 
	; 
	medu$pci_addr	Address, AddrReg, AddrSetup ; setup PCI addr
      .if ne AddrSetup
	medu$last_addr == Address
      .endc
	medu$this_addr == Address
        .iif ne <<medu$last_addr>-<medu$this_addr>>, .print 0; Wrong TOY write address set up!!!
      .if identical <%extract(0,1,Data)> <r> 
	and	Data, #^xff, TempReg
      .iff
	lda	TempReg, <Data>&^xff(r31)	; Load the value into a register
      .endc
	insbl	TempReg, #ToyOffset&3, TempReg	; Insert correct byte lane
	stl/p   TempReg, (AddrReg)		; Write out the value
	mb
.endm

;
; medu$read_toy (ToyOffset, AddrReg, ResultReg, AddrSetup)
; 
;   Description: 
;	This macro reads the designated register of the TOY chip.
;	The complete address is set up with this macro. 
;	Caution: No memory barrier is issued.
;   Input Parameters: 
;	ToyOffset - the TOY register to be read (from the "write" list above).
;	AddrReg - temporary register to hold the address.
;	ResultReg - register to hold the data read from the TOY.
;	AddrSetup - this flag tells the assembler whether or not the address
;		for the LED register needs to be set up prior to the write. 
;		It is assumed that address setup is required. 
;   Detail:
;	The TOY register base address is first formed, and the ToyOffset
;	address passed specifies which register is to be written. The is then 
;	performed from the appropriate address into the register provided. 
;   
.macro	medu$read_toy	ToyOffset, AddrReg=r12, ResultReg=r13, AddrSetup=1
	.if ne medulla_pass1
	;
	; There is a bug in the wiring of the TOY clock for pass 1, so compute
	; the address that works with pass 1 Medulla modules. 
	;
	.iif eq <<ToyOffset>-<^x00>>, Address == <^x8000>
	.iif eq <<ToyOffset>-<^x01>>, Address == <^xC000>
	.iif eq <<ToyOffset>-<^x02>>, Address == <^xA000>
	.iif eq <<ToyOffset>-<^x03>>, Address == <^xE000>
	.iif eq <<ToyOffset>-<^x04>>, Address == <^x9000>
	.iif eq <<ToyOffset>-<^x05>>, Address == <^xD000>
	.iif eq <<ToyOffset>-<^x06>>, Address == <^xB000>
	.iif eq <<ToyOffset>-<^x07>>, Address == <^xF000>
	.iif eq <<ToyOffset>-<^x08>>, Address == <^x8800>
	.iif eq <<ToyOffset>-<^x09>>, Address == <^xC800>
	.iif eq <<ToyOffset>-<^x0a>>, Address == <^xA800>
	.iif eq <<ToyOffset>-<^x0b>>, Address == <^xE800>
	.iif eq <<ToyOffset>-<^x0c>>, Address == <^x9800>
	.iif eq <<ToyOffset>-<^x0d>>, Address == <^xD800>
	.if_false
	  Address == <ToyOffset&^xffff>
	.endc 
	;
	; Set up the PCI address if necessary. 
	; 
	medu$pci_addr	Address, AddrReg, AddrSetup ; setup PCI addr
      .if ne AddrSetup
	medu$last_addr == Address
      .endc
	medu$this_addr == Address
        .iif ne <<medu$last_addr>-<medu$this_addr>>, .print 0; Wrong TOY read address set up!!!
	ldl/p   ResultReg, (AddrReg)		; Read the value
	extbl	ResultReg, #ToyOffset&3, ResultReg ; Extract correct byte lane
.endm


;
; 8530 UAR/T macro routines and definitions
;

;	Definitions
;
MEDU$UART_CHA_RDWR	= <^x08@MEDU$K_PCI_ADDR_SHIFT> ; UAR/T Rd/Wr register offset for Channel A 
MEDU$UART_CHA_RXTX	= <^x0c@MEDU$K_PCI_ADDR_SHIFT> ; UAR/T Rx/Tx register offset for Channel A 
MEDU$UART_CHB_RDWR	= <^x00@MEDU$K_PCI_ADDR_SHIFT> ; UAR/T Rd/Wr register offset for Channel B
MEDU$UART_CHB_RXTX	= <^x04@MEDU$K_PCI_ADDR_SHIFT> ; UAR/T Rx/Tx register offset for Channel B

MEDU$WR3		= 3
MEDU$WR4		= 4
MEDU$WR5		= 5
MEDU$WR11		= 11
MEDU$WR12		= 12
MEDU$WR13		= 13
MEDU$WR14		= 14

MEDU$RX_CONTROL		= ^xc1	; WR3 value: 8 bits/char, rx enable
MEDU$GENERAL_SETUP	= ^x44	; WR4 value: 1 stop bit/char x16 clock mode
MEDU$TX_CONTROL		= ^x68	; WR5 value: 8 bits/char, tx enable
MEDU$BAUD_RATE_GEN	= ^x56	; WR11 value: BR generator out,
				;	      Rx Clk = Tx Clk = BR gen
MEDU$TIME_CONST_LOW  	= ^x32  ; WR12 value: 9600 baud (low byte) X16clk
MEDU$TIME_CONST_HIGH 	= ^x00  ; WR13 value: 9600 baud (hi byte) X16clk
MEDU$BAUD_AS_CLK	= ^x03	; WR14 value: Baud Rate gen/enable

;
; medu$putc (Char, AddrSetup)
; 
;   Description: 
;	This macro writes the specified character onto the UAR/T channel A. 
;	The complete address is set up with this macro and R25 and R28 are
;	used a temporary registers -- thus they will be volatile. 
;   Input Parameters: 
;	Char - the ASCII character to be written to the UAR/T which is
;		already in a register or the ASCI value itself. This macro
;		will figure out which it is. 
;	AddrSetup - this flag tells the assembler whether or not the address
;		for the LED register needs to be set up prior to the write. 
;		It is assumed that address setup is required. 
;   Detail:
;	The 8530 UAR/T base address is first formed, then we wait for the 
;	transmit buffer to empty. After it is empty, the character is written
;	out. 
;   
.macro	medu$putc	Char, AddrSetup=1, ?Label, ?Label1
	;
	; Check for EV "graphic_console" and skip output
	; to uart if set to 1.
	;
	medu$pci_addr   <^x8017>,r28    ; graphic_console
	ldl/p   r28, (r28)              ; Read it in.
	extbl   r28, #<^x8017&3>, r28   ; Extract correct byte lane
	blbs    r28, Label1		; if EV set, branch to Lable1
	;
	; Set up the PCI address if necessary. 
	; 
	medu$pci_addr	MEDU$K_UART_BASE, r25, AddrSetup ; setup PCI addr
      .if ne AddrSetup
	medu$last_addr == MEDU$K_UART_BASE		; Any unique value ok
      .endc
	medu$this_addr == MEDU$K_UART_BASE
        .iif ne <<medu$last_addr>-<medu$this_addr>>, .print 0; Wrong UART address set up in putc!!!
	;
	; Wait for the transmit buffer to empty.
	;
     Label:
	ldl/p	R28, MEDU$UART_CHA_RDWR(R25)	; read RR0
	srl	R28, #2, R28		; wait until Tx buffer empty
	blbc	R28, Label
	; 
	; Transmit buffer is now empty
	;
      .if identical <%extract(0,1,Char)> <r> 
	and	Char, #^xff, R28
      .iff
	lda	R28, <Char>&^xff(r31)	; Load the character into a register
      .endc
	stl/p	R28, MEDU$UART_CHA_RXTX(R25)
	mb
     Label1:
.endm


;--------------------------------------------------------------------
; Definitions for the VIP and VIC register offsets in PCI from base
;--------------------------------------------------------------------
;
; VIC Register Offset Definitions
;
VIC$B_IICR = ^x00	; VMEbus Interrupter Interrupt Control Reg
VIC$B_VICR1 = ^x04	; VMEbus Interrupt Control Registers 1-7
VIC$B_VICR2 = ^x08
VIC$B_VICR3 = ^x0C
VIC$B_VICR4 = ^x10
VIC$B_VICR5 = ^x14
VIC$B_VICR6 = ^x18
VIC$B_VICR7 = ^x1C
VIC$B_DMASICR = ^x20	;  DMA Status Register
VIC$B_LICR1 = ^x24	; Local Interrupt Status Registers 1-7
VIC$B_LICR2 = ^x28
VIC$B_LICR3 = ^x2C
VIC$B_LICR4 = ^x30
VIC$B_LICR5 = ^x34
VIC$B_LICR6 = ^x38
VIC$B_LICR7 = ^x3C
VIC$B_ICGSICR = ^x40	; ICGS Interrupt Control Register
VIC$B_ICMSICR = ^x44	; ICMS Interrupt Control Register
VIC$B_EGICR = ^x48	; Error Group Interrupt Control Reg
VIC$B_ICGSIVBR = ^x4C	; ICGS Vector Base Register
VIC$B_ICMSVBR = ^x50	; ICMS Vector Base Register
VIC$B_LIVBR = ^x54	; Local Interrupt Vector Base Register
VIC$B_EGIVBR = ^x58	; Error Group Interrupt Vector Base Reg
VIC$B_ICSR = ^x5C	; IPC Switch Register
VIC$B_ICR0 = ^x60	; Interprocessor Communication Registers 0-7
VIC$B_ICR1 = ^x64
VIC$B_ICR2 = ^x68
VIC$B_ICR3 = ^x6C
VIC$B_ICR4 = ^x70
VIC$B_ICR5 = ^x74
VIC$B_ICR6 = ^x78
VIC$B_ICR7 = ^x7C
VIC$B_IRSR = ^x80	; VMEbus interrupt RQ/Status Register 
VIC$B_IVBR1 = ^x84	; VMEbus interrupt Vector BASE Reg 1-7
VIC$B_IVBR2 = ^x88
VIC$B_IVBR3 = ^x8C
VIC$B_IVBR4 = ^x90
VIC$B_IVBR5 = ^x94
VIC$B_IVBR6 = ^x98
VIC$B_IVBR7 = ^x9C
VIC$B_TTR = ^xA0	; Transfer Timeout Reg
VIC$B_LBTR = ^xA4	; Local Bus Timing Reg
VIC$B_BTDR = ^xA8	; Block Transfer Definition Reg
VIC$B_ICR = ^xAC	; Interface CNFG Reg
VIC$B_ARCR = ^xB0	; Arbiter/Requester CNFG Reg
VIC$B_AMSR = ^xB4	; Address Modifier Source Reg
VIC$B_BESR = ^xB8	; Bus Error Status Reg
VIC$B_DMASR = ^xBC	; DMA Status Reg
VIC$B_SS0CR0 = ^xC0	; Slave Select 0/Control Reg 0
VIC$B_SS0CR1 = ^xC4	; Slave Select 0/ Control Reg 1
VIC$B_SS1CR0 = ^xC8	; Slave Select 1 /Control Reg 0
VIC$B_SS1CR1 = ^xCC	; Slave Select 1 /Control Reg 1
VIC$B_RCR = ^xD0	; Release Control Reg
VIC$B_BTCR = ^xD4	; Block Transfer Control Block
VIC$B_BTLR0 = ^xD8	; Block Transfer Length Reg 0
VIC$B_BTLR1 = ^xDC	; Block Transfer Length Reg 1
VIC$B_SRR = ^xE0	; System Reset Reg
			; 0xE4       Undefined in VIC068 and VIC64 Spec
			; 0xE8-0xFC  Reserved Locations
;
; VIP Register Offset Definitions
;
VIP$B_CR = ^x100	; VIP Control Register
VIP$B_BESR = ^x104	; VIP Bus Error/Status Reg
VIP$B_ICR = ^x108	; VIP Interrupt Control Reg
VIP$B_IRR = ^x10C	; VIP Interrupt Reason Reg
VIP$B_HWIPL = ^x110	; VIP Hardware IPL mask Reg
VIP$B_DIAGCSR = ^x114	; VIP Diag Control/Status Reg
VIP$B_LMCSR = ^x118	; VIP Location Monitor CSR
VIP$B_OBISGABR = ^x11C	; Outbound Internal S/G Entry ABR
VIP$B_OBISGMSK = ^x120	; Outbound Internal S/G Entry Mask
VIP$B_OBISGWORD = ^x124 ; Outbound Internal S/G Control Word
VIP$B_IBISGMSK = ^x128	; Inbound Internal S/G Entry Mask
VIP$B_IBISGWORD = ^x12C ; Inbound Internal S/G Control Word
VIP$B_SGCCHIX = ^x130	; VIP SG Cached Index
VIP$B_SGCWRD = ^x134	; SG Cached Control Word
VIP$B_PCIERTADR = ^x138	; VIP PCI Error Target Address Reg
VIP$B_PCIERTCBE = ^x13C	; VIP PCI Tarfet Command and Byte Enables
VIP$B_PCIERIADR = ^x140	; VIP PCI Error Initiator Address Register
VIP$B_LERADR = ^x144	; VIP LOcal bus error address reg


;--------------------------------------------------------------------
; Definitions for Interrupt Mask, for VIP and VIC
;--------------------------------------------------------------------
IMASK$V_VIC_LIRQ1 = 17
IMASK$V_VIC_LIRQ2 = 18
IMASK$V_VIC_LIRQ3 = 19
IMASK$V_VIC_LIRQ4 = 20
IMASK$V_VIC_LIRQ5 = 21
IMASK$V_VIC_LIRQ6 = 22
IMASK$V_VIC_LIRQ7 = 23

IMASK$V_VME_IRQ1 = 25
IMASK$V_VME_IRQ2 = 26
IMASK$V_VME_IRQ3 = 27
IMASK$V_VME_IRQ4 = 28
IMASK$V_VME_IRQ5 = 29
IMASK$V_VME_IRQ6 = 30
IMASK$V_VME_IRQ7 = 31

IMASK$V_VIC_DMA_STAT = 36
IMASK$V_VIC_VME_IACK = 37

IMASK$V_IRQ0_HALT = 38

IMASK$V_VIC_ERR_SYSFAIL = 40
IMASK$V_VIC_ERR_ARBTMO = 41
IMASK$V_VIC_ERR_WRPOST = 42
IMASK$V_VIC_ERR_ACFAIL = 43

IMASK$V_VIC_ICMS0 = 44
IMASK$V_VIC_ICMS1 = 45
IMASK$V_VIC_ICMS2 = 46
IMASK$V_VIC_ICMS3 = 47

IMASK$V_VIC_ICGS0 = 48
IMASK$V_VIC_ICGS1 = 49
IMASK$V_VIC_ICGS2 = 50
IMASK$V_VIC_ICGS3 = 51

;--------------------------------------------------------------------
; Definitions for the Programmable Interrupt Controller in the SIO
;--------------------------------------------------------------------
SIO$B_PIC1_ICW1 = ^x20
SIO$B_PIC1_ICW2 = ^x21
SIO$B_PIC1_ICW3 = ^x21
SIO$B_PIC1_ICW4 = ^x21
SIO$B_PIC1_MASK = ^x21
SIO$B_PIC1_ELCR = ^x4D0
SIO$B_PIC1_OCW1 = ^x21
SIO$B_PIC1_OCW2 = ^x20
SIO$B_PIC1_OCW3 = ^x20

SIO$B_PIC2_ICW1 = ^xA0
SIO$B_PIC2_ICW2 = ^xA1
SIO$B_PIC2_ICW3 = ^xA1
SIO$B_PIC2_ICW4 = ^xA1
SIO$B_PIC2_MASK = ^xA1
SIO$B_PIC2_ELCR = ^x4D1
SIO$B_PIC2_OCW1 = ^xA1
SIO$B_PIC2_OCW2 = ^xA0
SIO$B_PIC2_OCW3 = ^xA0
SIO$C_EOI =	  ^x0

SIO$V_PIC1_IRQ7 = 7
SIO$M_PIC1_IRQ7 = <1@SIO$V_PIC1_IRQ7>
SIO$V_PIC1_IRQ6 = 6
SIO$M_PIC1_IRQ6 = <1@SIO$V_PIC1_IRQ6>
SIO$V_PIC1_IRQ5 = 5
SIO$M_PIC1_IRQ5 = <1@SIO$V_PIC1_IRQ5>
SIO$V_PIC1_IRQ4 = 4
SIO$M_PIC1_IRQ4 = <1@SIO$V_PIC1_IRQ4>
SIO$V_PIC1_IRQ3 = 3
SIO$M_PIC1_IRQ3 = <1@SIO$V_PIC1_IRQ3>
SIO$V_PIC1_IRQ1 = 1
SIO$M_PIC1_IRQ1 = <1@SIO$V_PIC1_IRQ1>

SIO$V_PIC2_IRQ7 = 7	; ## check these...
SIO$M_PIC2_IRQ7 = <1@SIO$V_PIC2_IRQ7>
SIO$V_PIC2_IRQ6 = 6
SIO$M_PIC2_IRQ6 = <1@SIO$V_PIC2_IRQ6>
SIO$V_PIC2_IRQ5 = 5
SIO$M_PIC2_IRQ5 = <1@SIO$V_PIC2_IRQ5>
SIO$V_PIC2_IRQ4 = 4
SIO$M_PIC2_IRQ4 = <1@SIO$V_PIC2_IRQ4>
SIO$V_PIC2_IRQ3 = 3
SIO$M_PIC2_IRQ3 = <1@SIO$V_PIC2_IRQ3>
SIO$V_PIC2_IRQ2 = 2
SIO$M_PIC2_IRQ2 = <1@SIO$V_PIC2_IRQ2>
SIO$V_PIC2_IRQ1 = 1
SIO$M_PIC2_IRQ1 = <1@SIO$V_PIC2_IRQ1>
SIO$V_PIC2_IRQ0 = 0
SIO$M_PIC2_IRQ0 = <1@SIO$V_PIC2_IRQ0>

;--------------------------------------------------------------------
; Other Definitions for the SIO
;--------------------------------------------------------------------
SIO$B_NMI_CSR = ^x61
SIO$B_NMI_ENB = ^x70

SIO$V_NMICSR_PCISERR_DSB = 2
SIO$M_NMICSR_PCISERR_DSB = <1@SIO$V_NMICSR_PCISERR_DSB>
SIO$V_NMICSR_IOCHK_DSB = 3
SIO$M_NMICSR_IOCHK_DSB = <1@SIO$V_NMICSR_IOCHK_DSB>
SIO$V_NMICSR_IOCHK_STS = 6
SIO$M_NMICSR_IOCHK_STS = <1@SIO$V_NMICSR_IOCHK_STS>
SIO$V_NMICSR_PCISERR_STS = 7
SIO$M_NMICSR_PCISERR_STS = <1@SIO$V_NMICSR_PCISERR_STS>

SIO$V_NMIENB_NMI_DSB = 7
SIO$M_NMIENB_NMI_DSB = <1@SIO$V_NMIENB_NMI_DSB>

MCHK$C_PCISERR = ^xa0		; PCI SERR machine check code

;
; Medulla Interrupt bit definitions for IRQs coming into SIO and VIC64.
;
MEDU$V_IRQ_HEARTBEAT = 	SIO$V_PIC1_IRQ1
MEDU$M_IRQ_HEARTBEAT = 	SIO$M_PIC1_IRQ1
MEDU$V_IRQ_PCI_OPT_A = 	SIO$V_PIC1_IRQ3
MEDU$M_IRQ_PCI_OPT_A = 	SIO$M_PIC1_IRQ3
MEDU$V_IRQ_UART =	SIO$V_PIC1_IRQ4
MEDU$M_IRQ_UART =	SIO$M_PIC1_IRQ4
MEDU$V_IRQ_INTRVL_TMR =	SIO$V_PIC1_IRQ5
MEDU$M_IRQ_INTRVL_TMR =	SIO$M_PIC1_IRQ5
MEDU$V_IRQ_NI =		SIO$V_PIC1_IRQ6
MEDU$M_IRQ_NI =		SIO$M_PIC1_IRQ6
MEDU$V_IRQ_SCSI =	SIO$V_PIC1_IRQ7
MEDU$M_IRQ_SCSI =	SIO$M_PIC1_IRQ7

MEDU$V_IRQ_VME_RESET =	SIO$V_PIC2_IRQ0	; SIO IRQ 8
MEDU$M_IRQ_VME_RESET =	SIO$M_PIC2_IRQ0	; SIO IRQ 8

MEDU$V_IRQ_PCI_OPT_B = 	SIO$V_PIC2_IRQ1	; SIO IRQ 9
MEDU$M_IRQ_PCI_OPT_B = 	SIO$M_PIC2_IRQ1	; SIO IRQ 9
MEDU$V_IRQ_PCI_OPT_C = 	SIO$V_PIC2_IRQ2	; SIO IRQ 10
MEDU$M_IRQ_PCI_OPT_C = 	SIO$M_PIC2_IRQ2	; SIO IRQ 10
MEDU$V_IRQ_PCI_OPT_D = 	SIO$V_PIC2_IRQ3	; SIO IRQ 11
MEDU$M_IRQ_PCI_OPT_D = 	SIO$M_PIC2_IRQ3	; SIO IRQ 11

MEDU$V_IRQ_VME_IRQ1 = 	SIO$V_PIC2_IRQ1	; SIO IRQ 9
MEDU$M_IRQ_VME_IRQ1 = 	SIO$M_PIC2_IRQ1	; SIO IRQ 9
MEDU$V_IRQ_VME_IRQ2 = 	SIO$V_PIC2_IRQ2	; SIO IRQ 10
MEDU$M_IRQ_VME_IRQ2 = 	SIO$M_PIC2_IRQ2	; SIO IRQ 10
MEDU$V_IRQ_VME_IRQ3 = 	SIO$V_PIC2_IRQ3	; SIO IRQ 11
MEDU$M_IRQ_VME_IRQ3 = 	SIO$M_PIC2_IRQ3	; SIO IRQ 11

MEDU$V_IRQ_VME_IRQ4 = 	SIO$V_PIC2_IRQ4	; SIO IRQ 12
MEDU$M_IRQ_VME_IRQ4 = 	SIO$M_PIC2_IRQ4	; SIO IRQ 12
MEDU$V_IRQ_VME_IRQ5 = 	SIO$V_PIC2_IRQ5	; SIO IRQ 13
MEDU$M_IRQ_VME_IRQ5 = 	SIO$M_PIC2_IRQ5	; SIO IRQ 13
MEDU$V_IRQ_VME_IRQ6 = 	SIO$V_PIC2_IRQ6	; SIO IRQ 14
MEDU$M_IRQ_VME_IRQ6 = 	SIO$M_PIC2_IRQ6	; SIO IRQ 14
MEDU$V_IRQ_VME_IRQ7 = 	SIO$V_PIC2_IRQ7	; SIO IRQ 15
MEDU$M_IRQ_VME_IRQ7 = 	SIO$M_PIC2_IRQ7	; SIO IRQ 15

.macro	medu$puth	w=16, ?l1, ?l2
	lda	r17, w*4(r31)
l1:	subq	r17, #4, r17
	srl	r16, r17, r19
	and	r19, #15, r19
	lda	r18, ^x30(r19)
	cmpult	r19, #10, r19
	pvc$violate	1008
	bne	r19, l2
	addq	r18, #^x27, r18
l2:	medu$putc	r18
	pvc$violate	1008
	bne	r17, l1
.endm

.macro	cfw_setup
.endm

.macro	cfw_lock
.endm

.macro	cfw_putc	c
	medu$putc	<c>
.endm

.macro	cfw_unlock
.endm
;
; End of Medulla platform-specific definitions and macros.
;
	.endc

	.if ne	cortex_system
;
; Carve out a piece of the impure area to store SROM parameters
; and the PCI interrupt mask.  
;
.macro	.blkq	n
$$$dot = $$$dot + <n * 8>
.endm

$$$dot = pal$impure_base

cortex_impure_base = $$$dot

$$$dot = $$$dot + impure$cortex_scratch_offset

cortex$srom = $$$dot - cortex_impure_base
	.blkq	8

; Mask of enabled interrupts.  Used by CSERVE to provide interface to O/S
; to enable/disable int sources.  Also used in pal$hw_interrupt to mask IRR
; bits read from Xilinx interrupt controller.  Stolen from Medulla, but this
; concept is used in Cabriolet as well.

cortex$q_enabled_ints_mask = $$$dot - cortex_impure_base
	.blkq	1

; Count of watchdog interrupts received. Stolen from Medulla.
;
medu$q_wdog_ints_count = $$$dot - cortex_impure_base
	.blkq	1

; Flag required for halt action 1=Vector via 820 on halt sw
;				0=Halt to console as normal
; This is required for functionality specific to VxWorks
; and is set/reset via CSERVE function 50.  Included here only as a
; placeholder to preserve alignment between osf pal and vms pal.
medu$q_halt_action = $$$dot - cortex_impure_base
	.blkq	1


.mdelete	.blkq

;; Cortex PALcode Macros and Definitions, largely stolen from Medulla,
;; inserted here to accomodate code lifted from Medulla.
;

;
; A few conventions are followed for Medulla, and stolen here for Cortex.
; It is assumed that R12-R15
; are generally available for use by the reset and interrupt code and are
; used as follows:
;	R12	used to form and hold the latest address calculated
;	R13	used as parameter data passing
;	R14	used as a "scratch" register
;	R15	used as a "scratch" register
;
; Compile-time initializations:
;
;   This variable is used to make sure that if an address setup is not done
;   in one of the macro calls, then the last address held in R12 is the same
;   one as that expected by the current macro invocation. 
	medu$last_addr 		== 0

;   This value is the number of bits to be shifted for the PCI address. 
;   See the medu$pci_addr macro below to see how this is used.
	  MEDU$K_PCI_ADDR_SHIFT	== 5
;
; Module base addresses and registers.
;
MEDU$K_VIP_HIBASE       = <^x0010>              ; * 1000H for real
MEDU$K_UART_BASE	= <^x3F8>		; COM1 base address. 
MEDU$MOD_DISP_REG	= <^x800>		; In Xilinx.     
MEDU$MOD_CONFIG_REG	= <^x801>		; In Xilinx.  
MEDU$MOD_CNTRL_REG	= <^x80D>		; In Xilinx.  
MEDU$MOD_RSTREASON_REG	= <^x80E>		; In Xilinx.  
MEDU$HBEAT_CLR_REG	= <^x80C>		; In Xilinx.  
                                        
cd_suppress		= <^x8019> 		; countdown suppression byte.
						; suppress countdown output
						; in reset_cortex_hardware if
						; nonzero.
console_ev		= <^x8017>		; 1 = graphics console.
                                                ; 0 = serial console.
; FDC37C665GT Serial Port (COM) definitions
;
com1	= ^x3F8			; COM1 serial line port address.
com2	= ^x2F8			; COM2 serial line port address.

rbr	= 0			; Receive buffer register offset
thr	= 0			; Transmitter holding register offset
dll	= 0			; Divisor latch (LS) offset
dlh	= 1			; Divisor latch (MS) offset
ier	= ^x1			; Interrupt enable register offset
iir	= ^x2			; Interrupt identification register offset
fcr	= ^x2			; Fifo control register offset
lcr	= ^x3			; Line control register offset
mcr	= ^x4			; Modem control register offset
lsr	= ^x5			; Line status register offset
msr	= ^x6			; Modem status register offset
scr	= ^x7			; Scratch register offset

; Define configuration select register.  Write 55 55 to enter config, AA to
; exit.  Address of config register goes in CSR, data is read/written via 
; config data register, CDR.
csr	= ^x3F0			; Configuration Select Register
cdr	= ^x3F1			; Configuration Data Register

dla$k_brg  = 12			; Baud rate generator divisor = 9600 

lsr$v_thre = 5			; Transmitter holding register empty bit offset

lcr$m_wls  = 3			; Word length select mask
lcr$m_stb  = 4			; Number of stop bits mask
lcr$m_pen  = 8			; Parity enable mask
lcr$m_dlab = 128		; Divisor latch access bit mask
lcr$k_init = <lcr$m_wls!lcr$m_stb>

mcr$m_dtr  = 1			; Data terminal ready mask
mcr$m_rts  = 2			; Request to send mask
mcr$m_out1 = 4			; Output 1 control mask
mcr$m_out2 = 8			; UART interrupt enable mask
mcr$k_init = <mcr$m_dtr!mcr$m_rts!mcr$m_out1!mcr$m_out2> 


;; Cortex uses two routines are used by the cortex_int_enable and 
;; cortex_int_disable CSERVEs to perform a simple bit-fiddle of the interrupt
;; mask to translate between the CSERVE format and the format used in the 
;; impure area which more closely matches the interrupt mask registers of the
;; Xilinx interrupt control gate array.

; The bits of the interrupt mask formats are as follows:
; 
; CSERVE   Impure         Source
;+-------+--------+--------------------+
;|  -    |   0    | VME_IPL3 (vmsipl20)|
;+-------+--------+--------------------+
;|  -    |   1    |      SIO           |
;+-------+--------+--------------------+
;|  2    |   2    |    ETHERNET        |
;+-------+--------+--------------------+
;|  3    |   3    |     SCSI           |
;+-------+--------+--------------------+
;|  4    |   4    |    PMCO_IRQB       |
;+-------+--------+--------------------+
;|  5    |   5    |    PMC1_IRQB       |
;+-------+--------+--------------------+
;|  6    |   6    |    PMC0_IRQC       |
;+-------+--------+--------------------+
;|  7    |   7    |    PMC1_IRQC       |
;+-------+--------+--------------------+
;|  8    |   8    |    PMC0_IRQD       |
;+-------+--------+--------------------+
;|  9    |   9    |    PMCO_IRQD       |
;+-------+--------+--------------------+
;|  -    |   10   | VME_IPL4 (vmsipl21)|
;+-------+--------+--------------------+
;|  10   |   11   |    PMC0_IRQA       |
;+-------+--------+--------------------+
;|  11   |   12   |    PMC1_IRQA       |
;+-------+--------+--------------------+
;|  12   |   13   |    VME_RESET       |
;+-------+--------+--------------------+
;|  -    |   14   | VME_IPL6 (vmsipl23)|
;+-------+--------+--------------------+
;|  13   |   15   | RT interval timer  |
;+-------+--------+--------------------+
;|  14   |   16   | Periodic RT timer  |
;+-------+--------+--------------------+
;|  -    |   17   | VME_IPL5 (vmsipl22)|
;+-------+--------+--------------------+
;|  15   |   18   | 1ms Heartbeat timer|
;+-------+--------+--------------------+
;|  18   |   19   | VIP Location Mon.  |
;+-------+--------+--------------------+
; 
; and then bits 63:23 are identical between the two formats.
; 
; The bits that are _not_ in the same places between the two masks are all
; displaced by either 1, 2, or 3 bits between the two masks, and all lie
; between bits 19:10 of the two masks.
; 
; The following symbols are used in the translation, which occurs in three 
; steps.  First bits offset by 1 bit are translated, then those offset by 
; 2 bits, and finally those offset by 3 bits.  The bit numbers below are with
; respect to the Impure format.
CORTEX$M_XLATE1 = <<1@19>!<1@13>!<1@12>!<1@11>> ; xlate bits 19, 13:11.
CORTEX$M_XLATE2 = <<1@16>!<1@15>> ; xlate bits 16:15
CORTEX$M_XLATE3 = <1@18>	; xlate bit  18

; The following symbols represents a mask with 1's where the bits of the two
; formats are different.  This is used to zap out the incorrect bits before
; bis'ing them in from one format to the other.  The first line turns on the
; bits xlating from CSERVE to Impure, and the second line turns on the bits 
; xlating from Impure to CSERVE.
CORTEX$M_XLATE_CTOI_ZAP = <<CORTEX$M_XLATE1>!<CORTEX$M_XLATE2>!<CORTEX$M_XLATE3>>
CORTEX$M_XLATE_ITOC_ZAP = <<CORTEX$M_XLATE1@-1>!<CORTEX$M_XLATE2@-2>!<CORTEX$M_XLATE3@-3>>   


;
; medu$pci_addr (PciDevAddr, AddrReg, AddrSetup)
; 
; ===========> MODIFIED FOR CORTEX <===============
;
;   Description: 
;	This macro generates a PCI physical address from the input PCI-based 
;	device address.  The macro works both for the LCADS and LCA systems.
;   Input Parameters: 
;	PciDevAddr - the device address in PCI I/O space.
;	AddrReg - temporary register where address is formed. If no register
;		is specified, then R12 is used as default. 
;	AddrSetup - this flag tells the assembler whether or not the address
;		for the LED register needs to be set up prior to the write. 
;		It is assumed that address setup is required. 
;   Detail:
;	Address = 1.C000.0000 + (PCI & 0xffff << 5)    LCA setup
;
.macro	medu$pci_addr	PciDevAddr, AddrReg=r12, AddrSetup=1
   .if ne AddrSetup
        medu$last_addr == PciDevAddr		; Save addr in compiler variable
	lda	AddrReg, PciDevAddr(r31)	; AddrReg = 0.0000.xxxx
	.if ne <<PciDevAddr>&^x8000>
	zap	AddrReg,#^x0fc,AddrReg		; Clear out any sign-extension
	.endc
    .endc
    ldah	AddrReg, ^xE00(AddrReg)	; AddrReg = 0.0E00.xxxx
    sll	AddrReg, #MEDU$K_PCI_ADDR_SHIFT, AddrReg ; AddrReg = 1.C0yy.yyy0
.endm

;
; medu$pci_vme_addr (PciRegOffset, AddrReg, AddrSetup)
; 
;   Description: 
;	This macro generates a PCI physical address for sparse memory
;	space VIP and VIC registers from the input PCI-based 
;	register offset.  The macro works both for the LCADS and LCA systems.
;   Input Parameters: 
;	PciRegOffset - the VME register offset in PCI space.
;	AddrReg - temporary register where address is formed. If no register
;		is specified, then R12 is used as default. 
;	AddrSetup - this flag tells the assembler whether or not the address
;		for the LED register needs to be set up prior to the write. 
;		It is assumed that address setup is required. 
;   Detail:
;	Address = 2.0200.0000 + (PCI & 0xffff << 5)    LCA setup
;	Address = 2.0200.0000 + (PCI & 0xffff << 7)    LCADS setup
;
.macro	medu$pci_vme_addr	PciRegOffset, AddrReg=r12, AddrSetup=1
   .if ne AddrSetup
        medu$last_addr == PciRegOffset	; Save addr in compiler variable
	lda	AddrReg, PciRegOffset(r31)	; AddrReg = 0.0010.0xxx
	.if ne <<PciRegOffset>&^x8000>
	zap	AddrReg,#^x0fc,AddrReg		; Clear out any sign-extension
	.endc
	ldah	AddrReg, <^x1000+MEDU$K_VIP_HIBASE>(AddrReg)	; = 0.1010.0000
	sll	AddrReg, #MEDU$K_PCI_ADDR_SHIFT, AddrReg ; AddrReg = 2.yyy0.0000
   .endc
.endm


; medu$read_sio (SioRegOffset, ResultReg, AddrReg, AddrSetup)
; 
;   Description: 
;	This macro reads the designated register in the SIO chip. The complete 
;	address is set up with this macro. 
;	Note: No memory barrier is perfromed.
;   Input Parameters: 
;	SioRegOffset - the offset of the SIO register to be read. 
;	ResultReg - The register where the data is to be read into. 
;	AddrReg - volatile temporary register used within the macro. If no 
;		register is given, then r14 will be used. 
;	AddrSetup - this flag tells the assembler whether or not the address
;		for the LED register needs to be set up prior to the write. 
;		It is assumed that address setup is required. 
;   Detail:
;	The SIO base address is first formed, and the register offset value 
;	parameter specifies the offset into the SIO memory space. The register
;	is then read into the ResultReg register. No memory barrier is issued.
;		   
.macro	medu$read_sio	SioRegOffset, ResultReg=r13, AddrReg=r12, AddrSetup=1
	;
	; Set up the PCI address if necessary. 
	; 
	medu$pci_addr	SioRegOffset, AddrReg, AddrSetup ; setup PCI addr
     .if ne AddrSetup
	medu$last_addr == <^x3@32> + <SioRegOffset@5>	; any unique value ok
     .endc
	medu$this_addr == <^x3@32> + <SioRegOffset@5>
        .iif ne <<medu$last_addr>-<medu$this_addr>>, .print 0; Wrong SIO read address set up!!!
	ldl/p   ResultReg, (AddrReg)		; Read the value
	extbl	ResultReg, #SioRegOffset&3, ResultReg ; Extract correct byte lane
.endm

;
; medu$write_sio (Data, SioRegOffset, AddrReg, TempReg1, AddrSetup)
; 
;   Description: 
;	This macro performs writes to the designated register in the SIO chip. 
;	The complete address is set up with this macro. 
;   Input Parameters: 
;	Data - the data value to be written to the SIO register.
;	SioRegOffset - the SIO register to be written. This is a numeric value.
;	AddrReg, TempReg1 - temporary registers. These registers are volatile. 
;		If no registers are given, R12 and R15 are assumed. 
;	AddrSetup - this flag tells the assembler whether or not the address
;		for the LED register needs to be set up prior to the write. 
;		It is assumed that address setup is required. 
;   Detail:
;	The SIO base address is first formed, and the register address passed
;	specifies the offset in the SIO memory space. The requested data is
;	then written to the appropriate address. No memory barrier is issued.
;		   
.macro	medu$write_sio	Data, SioRegOffset, AddrReg=r12, TempReg1=r14, AddrSetup=1
	;
	; Set up the PCI address if necessary. 
	; 
	medu$pci_addr	SioRegOffset, AddrReg, AddrSetup ; setup PCI addr
      .if ne AddrSetup
	medu$last_addr == <^x3@32> + <SioRegOffset@5>	; Any unique value ok
      .endc
	medu$this_addr == <^x3@32> + <SioRegOffset@5>
        .iif ne <<medu$last_addr>-<medu$this_addr>>, .print 0; Wrong SIO write address set up!!!
      .if identical <%extract(0,1,Data)> <r> 
;;;  	and	Data, #^xff, TempReg1
	insbl	Data, #SioRegOffset&3, TempReg1	; Insert correct byte lane
      .iff
	lda	TempReg1, <Data>&^xff(r31)	; Load the value into a register
	insbl	TempReg1, #SioRegOffset&3, TempReg1	; Insert correct byte lane
      .endc
	stl/p   TempReg1, (AddrReg)		; Write it out
	mb					; Force it out
.endm

;
; medu$write_toy (Data, ToyOffset, AddrReg, TempReg, AddrSetup)
; 
;   Description: 
;	This macro performs writes to the designated register of the TOY chip.
;	The complete address is set up with this macro. 
;   Input Parameters: 
;	Data - the data value to be written to the module register.
;	ToyOffset - the TOY register offset to be written (from the list above).
;	AddrReg, TempReg - temporary registers. These registers are volatile. 
;	AddrSetup - this flag tells the assembler whether or not the address
;		for the LED register needs to be set up prior to the write. 
;		It is assumed that address setup is required. 
;   Detail:
;	The TOY register base address is first formed, and the ToyOffset
;	address passed specifies which register is to be written. The passed
;	value is then written to the appropriate address. No memory barrier is 
;	issued.
;   
.macro	write_toy	Data=r13, ToyOffset, AddrReg=r12, TempReg=r14, AddrSetup=1
	  Address == <ToyOffset&^xffff>
	;
	; Set up the PCI address if necessary. 
	; 
	medu$pci_addr	Address, AddrReg, AddrSetup ; setup PCI addr
      .if ne AddrSetup
	medu$last_addr == Address
      .endc
	medu$this_addr == Address
        .iif ne <<medu$last_addr>-<medu$this_addr>>, .print 0; Wrong TOY write address set up!!!
      .if identical <%extract(0,1,Data)> <r> 
	and	Data, #^xff, TempReg
      .iff
	lda	TempReg, <Data>&^xff(r31)	; Load the value into a register
      .endc
	insbl	TempReg, #ToyOffset&3, TempReg	; Insert correct byte lane
	stl/p   TempReg, (AddrReg)		; Write out the value
	mb
.endm

;
; medu$read_toy (ToyOffset, AddrReg, ResultReg, AddrSetup)
; 
;   Description: 
;	This macro reads the designated register of the TOY chip.
;	The complete address is set up with this macro. 
;	Caution: No memory barrier is issued.
;   Input Parameters: 
;	ToyOffset - the TOY register to be read (from the "write" list above).
;	AddrReg - temporary register to hold the address.
;	ResultReg - register to hold the data read from the TOY.
;	AddrSetup - this flag tells the assembler whether or not the address
;		for the LED register needs to be set up prior to the write. 
;		It is assumed that address setup is required. 
;   Detail:
;	The TOY register base address is first formed, and the ToyOffset
;	address passed specifies which register is to be written. The is then 
;	performed from the appropriate address into the register provided. 
;   
.macro	read_toy	ToyOffset, AddrReg=r12, ResultReg=r13, AddrSetup=1
	  Address == <ToyOffset&^xffff>
	;
	; Set up the PCI address if necessary. 
	; 
	medu$pci_addr	Address, AddrReg, AddrSetup ; setup PCI addr
      .if ne AddrSetup
	medu$last_addr == Address
      .endc
	medu$this_addr == Address
        .iif ne <<medu$last_addr>-<medu$this_addr>>, .print 0; Wrong TOY read address set up!!!
	ldl/p   ResultReg, (AddrReg)		; Read the value
	extbl	ResultReg, #ToyOffset&3, ResultReg ; Extract correct byte lane
.endm


;
; medu$write_module_reg (Data, ModRegOffset, AddrReg, TempReg, AddrSetup)
; 
;   Description: 
;	This macro performs writes to the designated module register. The
;	available registers are:
;		MEDU$MOD_DISP_REG
;		MEDU$MOD_CONFIG_REG
;		MEDU$MOD_CNTRL_REG
;		MEDU$MOD_RSTREASON_REG
;		MEDU$ENET_ID_REG
;		MEDU$HBEAT_CLR_REG
;	The complete address is set up with this macro. 
;   Input Parameters: 
;	Data - the data value to be written to the module register.
;	ModRegOffset - the Module register to be written (from the list above).
;	AddrReg, TempReg - temporary registers. These registers are volatile. 
;	AddrSetup - this flag tells the assembler whether or not the address
;		for the LED register needs to be set up prior to the write. 
;		It is assumed that address setup is required. 
;   Detail:
;	The module register base address is first formed, and the ModReg
;	address passed specifies which register is to be written. The passed
;	value is then written to the appropriate address. No memory barrier is 
;	issued.
;   
.macro	medu$write_module_reg	Data, ModRegOffset, AddrReg=r12, TempReg=r13, AddrSetup=1
	;
	; Set up the PCI address if necessary. 
	; 
	medu$pci_addr	ModRegOffset, AddrReg, AddrSetup ; setup PCI addr
      .if ne AddrSetup
	medu$last_addr == <^x3@32> + <ModRegOffset@-11>	; Any unique value ok
      .endc
	medu$this_addr == <^x3@32> + <ModRegOffset@-11>
        .iif ne <<medu$last_addr>-<medu$this_addr>>, .print 0; Wrong module address set up!!!
      .if identical <%extract(0,1,Data)> <r> 
	and	Data, #^xff, TempReg
      .iff
	or	r31, #<Data>, TempReg		; Load the value into a register
      .endc
	stl/p   TempReg, (AddrReg)		; Write out the value
	mb					; Flush it
.endm


;--------------------------------------------------------------------
; Definitions for the VIP and VIC register offsets in PCI from base
;--------------------------------------------------------------------
;
; VIC Register Offset Definitions
;
VIC$B_IICR = ^x00	; VMEbus Interrupter Interrupt Control Reg
VIC$B_VICR1 = ^x04	; VMEbus Interrupt Control Registers 1-7
VIC$B_VICR2 = ^x08
VIC$B_VICR3 = ^x0C
VIC$B_VICR4 = ^x10
VIC$B_VICR5 = ^x14
VIC$B_VICR6 = ^x18
VIC$B_VICR7 = ^x1C
VIC$B_DMASICR = ^x20	;  DMA Status Register
VIC$B_LICR1 = ^x24	; Local Interrupt Status Registers 1-7
VIC$B_LICR2 = ^x28
VIC$B_LICR3 = ^x2C
VIC$B_LICR4 = ^x30
VIC$B_LICR5 = ^x34
VIC$B_LICR6 = ^x38
VIC$B_LICR7 = ^x3C
VIC$B_ICGSICR = ^x40	; ICGS Interrupt Control Register
VIC$B_ICMSICR = ^x44	; ICMS Interrupt Control Register
VIC$B_EGICR = ^x48	; Error Group Interrupt Control Reg
VIC$B_ICGSIVBR = ^x4C	; ICGS Vector Base Register
VIC$B_ICMSVBR = ^x50	; ICMS Vector Base Register
VIC$B_LIVBR = ^x54	; Local Interrupt Vector Base Register
VIC$B_EGIVBR = ^x58	; Error Group Interrupt Vector Base Reg
VIC$B_ICSR = ^x5C	; IPC Switch Register
VIC$B_ICR0 = ^x60	; Interprocessor Communication Registers 0-7
VIC$B_ICR1 = ^x64
VIC$B_ICR2 = ^x68
VIC$B_ICR3 = ^x6C
VIC$B_ICR4 = ^x70
VIC$B_ICR5 = ^x74
VIC$B_ICR6 = ^x78
VIC$B_ICR7 = ^x7C
VIC$B_IRSR = ^x80	; VMEbus interrupt RQ/Status Register 
VIC$B_IVBR1 = ^x84	; VMEbus interrupt Vector BASE Reg 1-7
VIC$B_IVBR2 = ^x88
VIC$B_IVBR3 = ^x8C
VIC$B_IVBR4 = ^x90
VIC$B_IVBR5 = ^x94
VIC$B_IVBR6 = ^x98
VIC$B_IVBR7 = ^x9C
VIC$B_TTR = ^xA0	; Transfer Timeout Reg
VIC$B_LBTR = ^xA4	; Local Bus Timing Reg
VIC$B_BTDR = ^xA8	; Block Transfer Definition Reg
VIC$B_ICR = ^xAC	; Interface CNFG Reg
VIC$B_ARCR = ^xB0	; Arbiter/Requester CNFG Reg
VIC$B_AMSR = ^xB4	; Address Modifier Source Reg
VIC$B_BESR = ^xB8	; Bus Error Status Reg
VIC$B_DMASR = ^xBC	; DMA Status Reg
VIC$B_SS0CR0 = ^xC0	; Slave Select 0/Control Reg 0
VIC$B_SS0CR1 = ^xC4	; Slave Select 0/ Control Reg 1
VIC$B_SS1CR0 = ^xC8	; Slave Select 1 /Control Reg 0
VIC$B_SS1CR1 = ^xCC	; Slave Select 1 /Control Reg 1
VIC$B_RCR = ^xD0	; Release Control Reg
VIC$B_BTCR = ^xD4	; Block Transfer Control Block
VIC$B_BTLR0 = ^xD8	; Block Transfer Length Reg 0
VIC$B_BTLR1 = ^xDC	; Block Transfer Length Reg 1
VIC$B_SRR = ^xE0	; System Reset Reg
			; 0xE4       Undefined in VIC068 and VIC64 Spec
			; 0xE8-0xFC  Reserved Locations
;
; VIP Register Offset Definitions
;
VIP$B_CR = ^x100	; VIP Control Register
VIP$B_BESR = ^x104	; VIP Bus Error/Status Reg
VIP$B_ICR = ^x108	; VIP Interrupt Control Reg
VIP$B_IRR = ^x10C	; VIP Interrupt Reason Reg
VIP$B_HWIPL = ^x110	; VIP Hardware IPL mask Reg
VIP$B_DIAGCSR = ^x114	; VIP Diag Control/Status Reg
VIP$B_LMCSR = ^x118	; VIP Location Monitor CSR
VIP$B_OBISGABR = ^x11C	; Outbound Internal S/G Entry ABR
VIP$B_OBISGMSK = ^x120	; Outbound Internal S/G Entry Mask
VIP$B_OBISGWORD = ^x124 ; Outbound Internal S/G Control Word
VIP$B_IBISGMSK = ^x128	; Inbound Internal S/G Entry Mask
VIP$B_IBISGWORD = ^x12C ; Inbound Internal S/G Control Word
VIP$B_SGCCHIX = ^x130	; VIP SG Cached Index
VIP$B_SGCWRD = ^x134	; SG Cached Control Word
VIP$B_PCIERTADR = ^x138	; VIP PCI Error Target Address Reg
VIP$B_PCIERTCBE = ^x13C	; VIP PCI Tarfet Command and Byte Enables
VIP$B_PCIERIADR = ^x140	; VIP PCI Error Initiator Address Register
VIP$B_LERADR = ^x144	; VIP LOcal bus error address reg


;--------------------------------------------------------------------
; Definitions for impure interrupt mask bits for the four vme int 
; mask bits and the SIO int mask bit.  These bits must always be 
; "1" in the impure mask and in the xilinx interrupt mask registers.
;--------------------------------------------------------------------
IMASK$V_VMEIPL3 = 0
IMASK$V_SIO 	= 1
IMASK$V_VMEIPL4 = 10
IMASK$V_VMEIPL6 = 14
IMASK$V_VMEIPL5 = 17

IMASK$M_SIO = <1@IMASK$V_SIO>
IMASK$M_VMEIPL3 = <1@IMASK$V_VMEIPL3>
IMASK$M_VMEIPL4 = <1@IMASK$V_VMEIPL4>
IMASK$M_VMEIPL5 = <1@IMASK$V_VMEIPL5>
IMASK$M_VMEIPL6 = <1@IMASK$V_VMEIPL6>

IMASK$M_MBO = <IMASK$M_SIO ! IMASK$M_VMEIPL3 ! IMASK$M_VMEIPL4 ! IMASK$M_VMEIPL5 ! IMASK$M_VMEIPL6>

; The following four symbols are used to srl the stored interrupt mask into
; position for masking with the value read from the Xilinx registers. 
CORTEX$V_IRQ0_SHIFT  =  0		; srl mask bits for ^x804-805 regs.
CORTEX$V_IRQ1_SHIFT  =  10		; srl mask bits for ^x803 reg.
CORTEX$V_IRQ2_SHIFT  =  17		; srl mask for ^x802 reg (irq2).
CORTEX$V_IRQ3_SHIFT  =  13		; srl mask for ^x802 regs (irq3).


;--------------------------------------------------------------------




;--------------------------------------------------------------------
; Definitions for impure Interrupt Mask, for VIP and VIC
;--------------------------------------------------------------------
; VIP LIRQs 1, 3, 4, 5, and 6 are unused.
IMASK$V_VIC_LIRQ2 = 19
IMASK$V_VIC_LIRQ7 = 23

IMASK$V_VME_IRQ1 = 25
IMASK$V_VME_IRQ2 = 26
IMASK$V_VME_IRQ3 = 27
IMASK$V_VME_IRQ4 = 28
IMASK$V_VME_IRQ5 = 29
IMASK$V_VME_IRQ6 = 30
IMASK$V_VME_IRQ7 = 31

IMASK$V_VIC_DMA_STAT = 36
IMASK$V_VIC_VME_IACK = 37

IMASK$V_IRQ0_HALT = 38

IMASK$V_VIC_ERR_SYSFAIL = 40
IMASK$V_VIC_ERR_ARBTMO = 41
IMASK$V_VIC_ERR_WRPOST = 42
IMASK$V_VIC_ERR_ACFAIL = 43

IMASK$V_VIC_ICMS0 = 44
IMASK$V_VIC_ICMS1 = 45
IMASK$V_VIC_ICMS2 = 46
IMASK$V_VIC_ICMS3 = 47

IMASK$V_VIC_ICGS0 = 48
IMASK$V_VIC_ICGS1 = 49
IMASK$V_VIC_ICGS2 = 50
IMASK$V_VIC_ICGS3 = 51

;--------------------------------------------------------------------
; Definitions for the Programmable Interrupt Controller in the SIO
;--------------------------------------------------------------------
SIO$B_PIC1_ICW1 = ^x20
SIO$B_PIC1_ICW2 = ^x21
SIO$B_PIC1_ICW3 = ^x21
SIO$B_PIC1_ICW4 = ^x21
SIO$B_PIC1_MASK = ^x21
SIO$B_PIC1_ELCR = ^x4D0
SIO$B_PIC1_OCW1 = ^x21
SIO$B_PIC1_OCW2 = ^x20
SIO$B_PIC1_OCW3 = ^x20

SIO$B_PIC2_ICW1 = ^xA0
SIO$B_PIC2_ICW2 = ^xA1
SIO$B_PIC2_ICW3 = ^xA1
SIO$B_PIC2_ICW4 = ^xA1
SIO$B_PIC2_MASK = ^xA1
SIO$B_PIC2_ELCR = ^x4D1
SIO$B_PIC2_OCW1 = ^xA1
SIO$B_PIC2_OCW2 = ^xA0
SIO$B_PIC2_OCW3 = ^xA0
SIO$C_EOI =	  ^x0

SIO$V_PIC1_IRQ7 = 7
SIO$M_PIC1_IRQ7 = <1@SIO$V_PIC1_IRQ7>
SIO$V_PIC1_IRQ6 = 6
SIO$M_PIC1_IRQ6 = <1@SIO$V_PIC1_IRQ6>
SIO$V_PIC1_IRQ5 = 5
SIO$M_PIC1_IRQ5 = <1@SIO$V_PIC1_IRQ5>
SIO$V_PIC1_IRQ4 = 4
SIO$M_PIC1_IRQ4 = <1@SIO$V_PIC1_IRQ4>
SIO$V_PIC1_IRQ3 = 3
SIO$M_PIC1_IRQ3 = <1@SIO$V_PIC1_IRQ3>
SIO$V_PIC1_IRQ1 = 1
SIO$M_PIC1_IRQ1 = <1@SIO$V_PIC1_IRQ1>

SIO$V_PIC2_IRQ7 = 7	; ## check these...
SIO$M_PIC2_IRQ7 = <1@SIO$V_PIC2_IRQ7>
SIO$V_PIC2_IRQ6 = 6
SIO$M_PIC2_IRQ6 = <1@SIO$V_PIC2_IRQ6>
SIO$V_PIC2_IRQ5 = 5
SIO$M_PIC2_IRQ5 = <1@SIO$V_PIC2_IRQ5>
SIO$V_PIC2_IRQ4 = 4
SIO$M_PIC2_IRQ4 = <1@SIO$V_PIC2_IRQ4>
SIO$V_PIC2_IRQ3 = 3
SIO$M_PIC2_IRQ3 = <1@SIO$V_PIC2_IRQ3>
SIO$V_PIC2_IRQ2 = 2
SIO$M_PIC2_IRQ2 = <1@SIO$V_PIC2_IRQ2>
SIO$V_PIC2_IRQ1 = 1
SIO$M_PIC2_IRQ1 = <1@SIO$V_PIC2_IRQ1>
SIO$V_PIC2_IRQ0 = 0
SIO$M_PIC2_IRQ0 = <1@SIO$V_PIC2_IRQ0>

;--------------------------------------------------------------------
; Other Definitions for the SIO
;--------------------------------------------------------------------
SIO$B_NMI_CSR = ^x61
SIO$B_NMI_ENB = ^x70

SIO$V_NMICSR_PCISERR_DSB = 2
SIO$M_NMICSR_PCISERR_DSB = <1@SIO$V_NMICSR_PCISERR_DSB>
SIO$V_NMICSR_IOCHK_DSB = 3
SIO$M_NMICSR_IOCHK_DSB = <1@SIO$V_NMICSR_IOCHK_DSB>
SIO$V_NMICSR_IOCHK_STS = 6
SIO$M_NMICSR_IOCHK_STS = <1@SIO$V_NMICSR_IOCHK_STS>
SIO$V_NMICSR_PCISERR_STS = 7
SIO$M_NMICSR_PCISERR_STS = <1@SIO$V_NMICSR_PCISERR_STS>

SIO$V_NMIENB_NMI_DSB = 7
SIO$M_NMIENB_NMI_DSB = <1@SIO$V_NMIENB_NMI_DSB>

MCHK$C_PCISERR = ^xa0		; PCI SERR machine check code

;
; Cortex (medulla) Interrupt bit definitions for IRQs coming into Xilinx and 
; VIC64.
;
MEDU$V_IRQ_HEARTBEAT = 	SIO$V_PIC1_IRQ1
MEDU$M_IRQ_HEARTBEAT = 	SIO$M_PIC1_IRQ1
MEDU$V_IRQ_PCI_OPT_A = 	SIO$V_PIC1_IRQ3
MEDU$M_IRQ_PCI_OPT_A = 	SIO$M_PIC1_IRQ3
MEDU$V_IRQ_UART =	SIO$V_PIC1_IRQ4
MEDU$M_IRQ_UART =	SIO$M_PIC1_IRQ4
MEDU$V_IRQ_INTRVL_TMR =	SIO$V_PIC1_IRQ5
MEDU$M_IRQ_INTRVL_TMR =	SIO$M_PIC1_IRQ5
MEDU$V_IRQ_NI =		SIO$V_PIC1_IRQ6
MEDU$M_IRQ_NI =		SIO$M_PIC1_IRQ6
MEDU$V_IRQ_SCSI =	SIO$V_PIC1_IRQ7
MEDU$M_IRQ_SCSI =	SIO$M_PIC1_IRQ7

MEDU$V_IRQ_VME_RESET =	SIO$V_PIC2_IRQ0	; SIO IRQ 8
MEDU$M_IRQ_VME_RESET =	SIO$M_PIC2_IRQ0	; SIO IRQ 8

MEDU$V_IRQ_PCI_OPT_B = 	SIO$V_PIC2_IRQ1	; SIO IRQ 9
MEDU$M_IRQ_PCI_OPT_B = 	SIO$M_PIC2_IRQ1	; SIO IRQ 9
MEDU$V_IRQ_PCI_OPT_C = 	SIO$V_PIC2_IRQ2	; SIO IRQ 10
MEDU$M_IRQ_PCI_OPT_C = 	SIO$M_PIC2_IRQ2	; SIO IRQ 10
MEDU$V_IRQ_PCI_OPT_D = 	SIO$V_PIC2_IRQ3	; SIO IRQ 11
MEDU$M_IRQ_PCI_OPT_D = 	SIO$M_PIC2_IRQ3	; SIO IRQ 11

MEDU$V_IRQ_VME_IRQ1 = 	SIO$V_PIC2_IRQ1	; SIO IRQ 9
MEDU$M_IRQ_VME_IRQ1 = 	SIO$M_PIC2_IRQ1	; SIO IRQ 9
MEDU$V_IRQ_VME_IRQ2 = 	SIO$V_PIC2_IRQ2	; SIO IRQ 10
MEDU$M_IRQ_VME_IRQ2 = 	SIO$M_PIC2_IRQ2	; SIO IRQ 10
MEDU$V_IRQ_VME_IRQ3 = 	SIO$V_PIC2_IRQ3	; SIO IRQ 11
MEDU$M_IRQ_VME_IRQ3 = 	SIO$M_PIC2_IRQ3	; SIO IRQ 11

MEDU$V_IRQ_VME_IRQ4 = 	SIO$V_PIC2_IRQ4	; SIO IRQ 12
MEDU$M_IRQ_VME_IRQ4 = 	SIO$M_PIC2_IRQ4	; SIO IRQ 12
MEDU$V_IRQ_VME_IRQ5 = 	SIO$V_PIC2_IRQ5	; SIO IRQ 13
MEDU$M_IRQ_VME_IRQ5 = 	SIO$M_PIC2_IRQ5	; SIO IRQ 13
MEDU$V_IRQ_VME_IRQ6 = 	SIO$V_PIC2_IRQ6	; SIO IRQ 14
MEDU$M_IRQ_VME_IRQ6 = 	SIO$M_PIC2_IRQ6	; SIO IRQ 14
MEDU$V_IRQ_VME_IRQ7 = 	SIO$V_PIC2_IRQ7	; SIO IRQ 15
MEDU$M_IRQ_VME_IRQ7 = 	SIO$M_PIC2_IRQ7	; SIO IRQ 15

	.endc


	.DISABLE GLOBAL		; force everything to be defined

	.SHOW	BINARY		; Force listing of all instuctions

.sbttl	HW_VECs	- Hardware dispatch entry points into PALcode

;+
; Entry:
;
;	NOTE THESE MUST BE FIRST THING IN PAL PSECT.
;
; EV4 HARWARE VECTORS into PAL 
;
;addr	 len	use
;----	----	------------------------------
;0000	  8	reset
;0020	  16	machine check
;0060	  32	arithmatic trap
;00E0	  64	interrupt
;01E0	 128	Dsteam mm fault
;03E0	 256	Istream TB miss
;07E0	  64	Istream acv
;08E0	  64	Dstream TB miss (native)
;09E0	  64	Dstream TB miss (pal)
;0BE0	 256	Istream Tag Parity Error
;0FE0	 128	Istream Data Parity Error
;11E0	 128	Unaligned data
;13E0	1024	Illegal opcode
;17E0	1080	Floating point disabled
;2000	2048	Call pal
;-


.sbttl	PAL temp's - PAL temp register usage

;+
; PAL temp usage
;
;	pt0   Scratch & error recovery (not preserved accross mm errors)
;	pt1   Scratch & error recovery (not preserved accross mm errors)
;	pt2   Shadow register for iccsr 
;	pt3   ITB & NDTB miss flows, else scratch
;
;	pt4   ITB & NDTB miss flows, else scratch
;	pt5   ITB & NDTB miss flows, else scratch
;	pt6   ITB & NDTB miss flows, else scratch
;	pt7   Impure Pointer in virtualized format
;
;	pt8   Offset to physical memory address 0 for virtualized memory
;	pt9   Shadow register for PS
;	pt10  SCC system cycle counter
;	pt11  UNQ or debug
;
;	pt12  Saved r12 - for exception frame building
;	pt13  Saved r13 - for exception frame building
;	pt14  Saved r14 - for exception frame building
;	pt15  Saved r15 - for exception frame building
;
;	pt16  Saved r16 - for exception frame building
;	pt17  Saved r17 - for exception frame building
;	pt18  Saved r18 - for exception frame building
;	pt19  Saved r19 - for exception frame building
;
;	pt20  PDTB miss flows, else scratch
;	pt21  PDTB miss flows, else scratch
;	pt22  PDTB miss flows, else scratch
;	pt23  PDTB miss flows, else scratch
;
;	pt24  PRBR
;	pt25  Flags.. See description above at pt25$v_
;		
;	pt26  KSP
;	pt27  WHAMI<7:0> & IOM<11:8> & CLUMP<15:12>
;
;	pt28  PTBR	Stored in Virtualized addr format
;	pt29  L3VIRT	Base VA used for virtual pte loading
;	pt30  SCBB	Stored in Virtualized addr format
;	pt31  PCBB	Stored in Virtualized addr format
;
;-

.sbttl	BEGIN	- Begining of PAL code

;+
;
; Start us off in the right psect
;
;-

	.if defined MACRO64$
	  .psect	psect_00_PALcode, 13, exe, nowrt, ovr, mix
	.iff
	  .psect	psect_00_PALcode, page, exe, nowrt, ovr
	.endc
	.if ne enable_debug_pcevent
	.if defined MACRO64$
	  .psect psect_98_Perftext, 13, noexe, nowrt, con
	.iff
	  .psect psect_98_Perftext, page, noexe, nowrt, con
	.endc
	  pal$perftext::
	  .psect	psect_00_PALcode
	.endc

PAL$START::
	GOTO_NEW_CODE			; set start of new code space



.sbttl	RESET	- Hardware reset flow

;+
; PAL$HW_VEC_RESET
;addr	len	use
;----	---	------------------------------
;0000	 8	Reset
;
; Entry:
;	Vectored into via hardware dispatch when reset is released.
;
;	R0 = whami ! IOM ! cluster
;	R1 = palbase
;	R2 = base of scratch area
;	R3
;	R4 = base of virtual memory
;
; Function:
;	Initialize processor and board
;	Initialize PAL state
;	Initialize processor privleged state
;	Dispatch to console
;
;-

	START_HW_VECTOR	RESET,no_trace=1, noshift=1

	.if ne	cfw_system
	.iff
	;+ code for dummy console support
	lda	r3, <hlt$c_reset ! <1@8>>(r31); set halt code to reset
	br	r31, PAL$FAKE_CONT_RESET; br around revision info
	;- code for dummy console support
	.endc

	lda	r3, hlt$c_reset(r31)	; set halt code to reset
	br	r31, PAL$REAL_CONT_RESET; branch over static data
	.long	pal$version_h		; our pal version info	
	.long	pal$version_l		;
	.long	0
	.long	0
	.if ne	adu_system
	    . = . -4
	    .long	<patch$jam_addrs-pal$start>; offset to jam list
	.endc

	CONT_HW_VECTOR	RESET, ibr=0


PAL$FAKE_CONT_RESET:

	.if ne	adu_system
	;+ code to dummy up console support
	lda	r0, <<13@8>!<4@0>>(r31)	; whami
	mf	r1, pal_base		; get pal base
	get_addr r2, <^xe580>, r31	; base of scratch
	or	r31, r31, r4		; base of virtual memory
	;- code to dummy up console support
	.endc


	; if the swpal bit of pt25 is set, we have been entered as
	; a result of a switch pal. Since we don't support being entered
	; via switch pal, we will ignore that, and just reset the machine.

	
	mf	r15, pt25		; see if we are here on a swppal
	srl	r15, #pt25$v_switch, r29; isolate the bit
	blbc	r29, pal$real_cont_reset; not swppal, so just come on up

	or	r31, #1, r29		; get a one
	sll	r20, #pt25$v_switch, r29; in "switch" pos
	bic	r15, r29, r15		; clear switch bit in pt25
	mt	r15, pt25		; update the chip



PAL$REAL_CONT_RESET:

	.if ne	cfw_system

pal$impure_base_cpu0 = pal$impure_base + pal$impure_common_size + <0 * pal$impure_specific_size>
pal$impure_base_cpu1 = pal$impure_base + pal$impure_common_size + <1 * pal$impure_specific_size>
pal$impure_base_cpu2 = pal$impure_base + pal$impure_common_size + <2 * pal$impure_specific_size>
pal$impure_base_cpu3 = pal$impure_base + pal$impure_common_size + <3 * pal$impure_specific_size>

	mt	r31, flush_ic		; Zap out our I-stream cache
	mb				;
	stall	5			;
	mb				;
	.if ne	generic_system
	lda	r0, (r31)		; Set WHAMI
	.endc
	.if ne	sable_system
	lda	r1, ^x380(r31)		; Read from 3800000c0
	sll	r1, #24, r1		;
	ldq/p	r0, ^x0c0(r1)		;
	srl	r0, #5, r0		; Isolate the commander ID
	and	r0, #7, r0		; 1=CPU1, 2=CPU2, 3=CPU3, 0=CPU4
	subq	r0, #1, r0		; 0=CPU1, 1=CPU2, 2=CPU3, -1=CPU4
	and	r0, #3, r0		; 0=CPU1, 1=CPU2, 2=CPU3, 3=CPU4
	.endc
	.if ne	mtu_system
	lda	r0, (r31)		; Set WHAMI
	.endc
        .if ne  lean_system
        lda     r0, (r31)               ; Set WHAMI
        .endc
        .if ne  cortex_system
	sget_addr r0, pal$impure_base, r31 ; Get base of PAL scratch area
	lda	r0, cortex$srom(r0)	; Point to SROM parameter save area
	stq_p	r2, pal$biu_ctl(r31)	; Save BIU_CTL 
	srl	r19, 16, r1		; Shift SROM signature into low word
	get_addr r2, <^xDECB>, r31	; Load the validation pattern
	zapnot	r1, 3, r1		; Clear all but low word
	cmpeq	r1, r2, r1		; Is the SROM signature valid?
	beq	r1, 10$			; If not, don't save SROM parameters
	stq_p	r16,  0(r0)		; Save processor identifier
	stq_p	r17,  8(r0)		; Save size of contiguous good memory (bytes)
	stq_p	r18, 16(r0)		; Save cycle count (picoseconds)
	stq_p	r19, 24(r0)		; Save signature and system revision identifier
	stq_p	r20, 32(r0)		; Save active processor mask
	stq_p	r21, 40(r0)		; Save system context value
10$:	lda     r0, (r31)               ; Set WHAMI
	bis	r31, r31, r19		; Clear SROM signature
        .endc
        .if ne  avanti_system ! mikasa_system ! noritake_system ! k2_system
	; 16 quadwords for srom information
	; Which is registers r16 thru r28
	br	r0,avanti$datax		; Set up r0
.align  quad
avanti$data:
	.long 	^x4156414E			; 'AVAN'
	.long	^x54492020			; 'TI  '
	.quad	0				; R16 
	.quad 	0				; R17
	.quad 	0				; R18
	.quad 	0				; R19
	.quad	0				; R20
	.quad 	0				; R21
	.quad 	0				; R22
	.quad 	0				; R23
	.quad 	0				; R24
	.quad 	0				; R25
	.quad 	0				; R26
	.quad 	0				; R27
	.quad 	0				; R28
	.quad 	0				; Reserved
	.quad 	0				; Reserved
avanti$datax:
	stq_p	r16, 8(r0)		
	stq_p	r17,16(r0)		
	stq_p	r18,24(r0)		
	stq_p	r19,32(r0)		
	stq_p	r20,40(r0)		
	stq_p	r21,48(r0)		
	stq_p	r22,56(r0)		
	stq_p	r23,64(r0)		
	stq_p	r24,72(r0)		
	stq_p	r25,80(r0)		
	stq_p	r26,88(r0)		
	stq_p	r27,96(r0)		
	stq_p	r28,104(r0)		
        lda     r0, (r31)               ; Set WHAMI
        .endc
	.if ne	medulla_system
	lda	r0, (r31)		; Set WHAMI
	.endc
	br	r1, 0$			; Get current PC
8$:	.long	0
0$:	ldl/p	r5, (r1)		; See if we're the first CPU here
	bne	r5, 9$			; Branch if we're not
	stq/p	r0, pal$primary(r31)	; Declare ourselves to be the primary
	stl/p	r1, (r1)		;  and prevent others from doing it too
9$:	sget_addr r1, pal$start-8$, r1	;  Base of PALcode
	sget_addr r2, pal$impure_base, r31 ; Base of scratch area
;;;	or	r31, r31, r4		; Base of virtual memory
	.if ne	low_core_ipl
	get_addr r4, pal$ipltbl, r31	; Get base of IPL table
	.iff
	get_addr r4, pal$ipltblhi-pal$start, r1 ; Get base of IPL table
	.endc
	.if ne	sable_system
	ldq/p	r5, pal$primary(r31)	; Adjust IPL table for MP
	cmpeq	r5, r0, r5		;  (add ^X200 for secondaries)
	xor	r5, #1, r5		;
	sll	r5, #9, r5		;
	addq	r4, r5, r4		;
	.endc
	.endc

	mt	r4, pt8			; save virtual memory base
	.if eq lca4
	t = 0
.iif eq disable_bcache,	t = t ! <1@<bc$v_en>>
.iif eq disable_ecc,	t = t ! <1@<bc$v_ecc>>
.iif eq disable_oe,t = t ! <1@<bc$v_oe>>
	t = t ! <0@<bc$v_fhit>>
.iif ne enable_fast_lock, t = t ! <1@<bc$v_fast_lock>>
.iif ne enable_imap_en, t = t ! <1@<bc$v_imap_en>>
.iif ne enable_byte_parity, t = t ! <1@<bc$v_byte_parity>>

	t = t ! <bc_rd_spd@<bc$v_rd_spd>>
	t = t ! <bc_wr_spd@<bc$v_wr_spd>>
	t = t ! <bc_we_ctl@<bc$v_we_ctl>>
	t = t ! <bc_size@<bc$v_size>>


	t1 = 0
.iif ne enable_byte_parity,	t1= t1 ! <1@<bc$v_byte_parity-32>>
.iif ne enable_imap_en,		t1 = t1 ! <1@<bc$v_imap_en-32>>


	or	r31, #bc_pa_dis, r4	; get bc_pa_dis field
	sll	r4, #bc$v_pa_dis, r4	; shift to correct spot
patch$biu_ctl::				; patch point to "change" biu settings
	get_addr r15, t, r4		; merge in the rest of the biu_ctl bits
	get_addr r4, t1, r31		; get high bits
	sll	r4, #32, r4		; move to pos
	or	r15, r4, r15		; merge them in
	.if ne	cfw_system
	ldq/p	r22, pal$biu_ctl(r31)	; Get current value
	cmovne	r22, r22, r15		; Replace current BIU_CTL if non-zero
	mf	r20, pt20		; Fetch signature registers
	mf	r21, pt21		;
	mf	r22, pt22		; Fetch BIU_CTL
	xor	r20, r21, r5		; Check for proper values
	addq	r5, #1, r5		;
	bne	r5, 1$			; Nope, check failed
	lda	r4, ^x5678(r31)		; Load expected pattern
	ldah	r4, ^x1234(r4)		;
	sll	r4, #32, r5		;
	or	r4, r5, r4		;
	xor	r4, r20, r5		; Check for proper values
	bne	r5, 1$			; Nope, check failed
	or	r22, r31, r15		; Transfer BIU_CTL from PT22
1$:	stq/p	r15, pal$biu_ctl(r31)	;  and save it
	.endc

	.if ne	generic_system ! -
		avanti_system ! -
		mikasa_system ! - 
		noritake_system ! -
		mtu_system ! -
		k2_system ! -
		lean_system ! -
		medulla_system ! -
		cortex_system
	.iff
	mt	r15, biu_ctl		; init biu_ctl
	.endc
	mb
	mb
	.endc
	mt	r31, flush_ic		; flush the icache
	mb
	mb
	mt	r31, flush_ic		; make sure no i-stream data snuck
	mb				; in due to a pending fill.
	mb
	DEBUG_BOOT r29


	t = 0
.if eq  disable_mchkcrd
	t = t ! <1@<abox$v_mchk>>
;;;	t = t ! <1@<abox$v_crd>>	; CRD's off by default!
.endc
.iif eq disable_dcache,		t = t ! <1@<abox$v_dc>>
.iif eq disable_sbuf,		t = t ! <1@<abox$v_sbuf>>
.iif ne enable_16kdcache,	t = t ! <1@<abox$v_dc_16k>>
.iif ne disable_cache_parity,	t = t ! <1@<abox$v_c_nochk_par>>
.iif ne enable_double_inval,	t = t ! <1@<abox$v_double_inval>>
patch$abox_ctl::			; patch point to "change" abox settings
	get_addr r14, t, r31 		; get abox_ctl bits
	mt	r14, abox_ctl		; init abox_ctl
	DEBUG_BOOT r29



	t = 0
.if eq  disable_pipeline
	t = t ! <1@<iccsrw$v_vax-32>>
	t = t ! <1@<iccsrw$v_bpe-32>>
	t = t ! <1@<iccsrw$v_jse-32>>
.iif eq disable_bht,	t = t ! <1@<iccsrw$v_bhe-32>>
	t = t ! <1@<iccsrw$v_di-32>>
.endc
.iif ne generic_system, t = t ! <1@<iccsrw$v_hwe-32>>
	.if ne	sable_sromtt_debug
.iif ne sable_system, t = t ! <1@<iccsrw$v_hwe-32>>
	.endc
.iif ne medulla_system, t = t ! <1@<iccsrw$v_hwe-32>>
	lda	r4, <t>(r31) 		; get high iccsr bits
	sll	r4, #32, r4		; shift to position
	or	r4, #<1@iccsrw$v_ev3>, r4 ; set ev3 to detect ev4's presence
	mt	r4, pt2_iccsr		; init iccsr
	stall	3
	mf	r29, iccsr		; get iccsr back to check for ev4
	and	r29, #<1@iccsrr$v_ev3>, r29 ; should be set if EV3, clr if EV4
	cmpeq	r29, r31, r29		; r29 = 1 if ev4
	sll	r29, #iccsrw$v_ev3, r29	; mask with ev3 set if ev4
	bic	r4, r29, r29		; clear ev3 bit in pt2 if ev4
	mt	r29, pt2		; save in pt2




; check for ev4 pass 1 vs pass 2
	mt	r31, itbzap			; zap all TB entries
	lda	r4, ^x7FFF(r31)
	mt	r4, dtb_ctl			; tb_ctl to large page
	sll	r4, #32, r5
	stall	1
	mt	r5, itb_pte			; write 1's to pte
	mt	r31, itbzap			; reset pointer
	srl	r5, #19, r5
	stall	3
	mf	r4, itb_pte			; read back 
	stall	3
	mf	r4, ipte_temp			; read back 
	cmpeq	r4, r5, r4			; 0 if pass 2, 1 if pass 1
	cmpeq	r4, r31, r4			; 1 if pass 2, 0 if pass 1
	sll	r4, #iccsrw$v_ev4P2, r4		; move to spot
	or	r29, r4, r29			; merge into iccsr
	mt	r29, pt2			; save




; reset all integer gpr's to ensure that the Z bit is properly set
	.macro clean_reg n
	or	r'n', r31, r'n'
	.endm

	DEBUG_BOOT r29
	t = 0
	.repeat 31
	  clean_reg \t
	  t = t + 1
	.endr


	DEBUG_BOOT r29
	virtualize r1, r4		; virtualize palbase
	virtualize r2, r4,noload=1	; virtualize impure
	mt	r31, alt_mode		; set alt_mode to kern
	mt	r0, pt27		; initialize WHAMI
	mb
	mb
	mt	r1, pal_base		; initialize PAL_BASE
	mb
	mb

	.if ne	adu_system
	and	r0, #^xff, r0		; isolate whami
	subq	r0, #3, r0		; whami - 3

	mulq	r0, #<pal$impure_specific_size/8>, r0 ; whami * per_node size/8
	addq	r0, #pal$impure_common_size/8, r0; add common area
	sll	r0, #3, r0		; * 8
	addq	r2, r0, r2		; addr our impure area offset
	.endc				; end of adu specific address calculation

	.if ne	cfw_system
	mulq	r0, #pal$impure_specific_size/8, r4 ; WHAMI * per node size/8
	addq	r4, #pal$impure_common_size/8, r4 ; Add common size
	sll	r4, #3, r4		; Multiply by 8
	addq	r2, r4, r2		; Get specific address of impure area
	.endc

	mt	r2, pt7			; initialize impure area ptr

	zapnot	r3, #1, r0		; isolate halt code
	mt	r0, pt0			; save entry type

	cmpult	r0, r3, r3		; get <adu> flag
	lda	r3, <1@<pt25$v_dpc-pt25$v_adu>>(r3) ; set MCES<DPC>
	sll	r3, #pt25$v_adu, r3	; <adu> is entry type
	mt	r3, pt25		; set MCES

	DEBUG_BOOT r29
	or	r1, r31, r0		; get pal base
	lda	r1, ^X1F00(r31)		; build PS (IPL=31,CM=K,VMM=0,SW=0)
	mt	r1, PT9_PS		; set new ps

	.if ne	cfw_system
	stall	2			; Stall for MT above
	mf	r1, pt27		; Compute where to store the
	lda	r2, pal$impure_base+impure$cpu_type_offset(r31) ;  pass number
	s8addq	r1, r2, r1		;
	.if eq	lca4
	mf	r2, pt2			; See if we're EV4 P1
	lda	r3, 2(r31)		;
	srl	r2, #iccsrw$v_ev4p2, r2	;
	and	r2, #1, r2		;
	xor	r2, #1, r2		;
	blbs	r2, 3$			; This is pass 1
	mf	r2, dc_stat		; Get DC_STAT<2:0>
	and	r2, #7, r2		;
	br	r3, 2$			;
	.long	2,2			;  000 = EV4 P2.1
	.long	1,6			;  001 = EV45 P1.1
	.long	0,0			;  010 =
	.long	2,6			;  011 = EV45 P2
	.long	0,0			;  100 =
	.long	0,6			;  101 = EV45 P1.0
	.long	0,0			;  110 =
	.long	3,2			;  111 = EV4 P3
	.iff
	lda	r2, lca4_pass2(r31)
	br	r3, 2$
	.long	1,4			; 0 = LCA4 P1 or P1.1
	.long	2,4			; 1 = LCA4 P2
	.endc
2$:	s8addq	r2, r3, r2		; Point to the right spot
	ldl/p	r3, 4(r2)		;
	ldl/p	r2, (r2)		;
3$:	stl/p	r2, (r1)		; Save the results
	stl/p	r3, 4(r1)		;
	.endc

	stall	2
	mf	r1, pt7			; get addr of impure area
	stq/p	r14, cns$abox_ctl(r1)	; save abox_ctl
	.if eq	lca4
	stq/p	r15, cns$biu_ctl(r1)	; save biu_ctl
	.endc




	.if ne <enable_debug_pctrace ! enable_debug_special ! enable_debug_pcevent>

	  ; note the data area pointer and bic mask must be set up so
	  ; that the alignment of the data area pointer will ensure that
	  ; the bic mask will clear the pointer at the correct size
	  ; typically, if data area is aligned to N, then the data size is N/2
	  get_addr r1, <16*1024*1024>, r31; debug area is 16mb long
	  sll	r1, #32, r1		; shift to high long
	  get_addr r1, <32*1024*1024>, r1; debug area is at 32mb, aligned to 32mb
	  virtualize r1, r4,noload=1	; virtualize debug area
	  mt		r1, pt11	; set starting debug trace addr
	  .if ne enable_debug_pcevent
	    lda	r29, <$$debug_boot$$last*16>(r31); get size of perf data area
	    stq/p	r29, (r1)	; save size of data area
	    get_addr r29, <patch$jam_addrs-pal$start>, r0 ; get addr of text data
	    ldl/p	 r29, <3*4>(r29); get offset to text
	    addq	r0, r29, r29	; now is read addr
	    stq/p	r29, 8(r1)	; save addr of text as second quad
	  .endc
	.iff
	  mt	r31, pt11		; set unq to zero
	.endc
	



	DEBUG_BOOT r29
	mt	R31, astrr		; stop AST's
	mt	R31, aster		; stop AST's
	mt	R31, sirr		; stop SW interrupts

	DEBUG_BOOT r29
	mt	r31, xtbzap		; clear the tb's
	mt	r31, sl_clr		; clear the sl_clr reg.


	; init the jsr stack
	bsr	r1, 10$			; push pc
	pvc$jsr	j1, dest=1
	br	r31, 50$		; join common

10$:	bsr	r2, 20$			; push pc
	pvc$jsr	j2, dest=1
	pvc$jsr	j1
	ret	r31, (r1)		; pop pc

20$:	bsr	r3, 30$			; push pc
	pvc$jsr	j3, dest=1
	pvc$jsr	j2
	ret	r31, (r2)		; pop pc

30$:	bsr	r4, 40$			; push pc
	pvc$jsr	j4, dest=1
	pvc$jsr	j3
	ret	r31, (r3)		; pop pc

40$:	stall	4			; wait 4 cycles
	pvc$jsr	j4
	ret	r31, (r4)		; pop pc
50$:


	DEBUG_BOOT r29
	mt	R31, exc_sum		; clear out exeception summary reg
	or	r31, #64, r1		; prepare to loop 64 times to clear reg
	pvc$violate	85		; this is ok, during reset flow
60$:	mf	R31, exc_sum		; read exeception summary 64 times
	subq	r1, #4, r1		; dec loop counter
	pvc$violate	85		; this is ok, during reset flow
	mf	R31, exc_sum		; read exeception summary 64 times
	pvc$violate	85		; this is ok, during reset flow
	mf	R31, exc_sum		; read exeception summary 64 times
	pvc$violate	85		; this is ok, during reset flow
	mf	R31, exc_sum		; read exeception summary 64 times
	bne	r1, 60$			; loop till zero


	DEBUG_BOOT r29
	or	r31, #1, r2		; get a one
	sll	r2, #32, r2		; shift to <32>
	mt	r31, cc			; clear Cycle Counter
	mt	r2, cc_ctl		; clear and enable the Cycle Counter
	mt	r31, pt10		; clear System Cycle Counter



	DEBUG_BOOT r29
	mf	r2, va			; unlock va
	mf	r3, dc_addr		; unlock dc_addr
	.if ne lca4
	mf	r3, dc_stat		; unlock dc_stat
	.iff
	mf	r2, biu_addr		; unlock biu_addr
	mf	r3, fill_addr		; unlock fill_addr
	mf	r3,  dc_stat		; unlock dc_stat
	mt	r31, bc_tag		; unlock bc_tag
	.endc

	.if ne lca4
	; Initialize the LCA memory controller's Error Status Register.
	; The system may heav been powered up with some of the ESR flags
	; set.  These flags are write-1-to-clear.  Also writes '1' to 
	; esr<ice> to disable logging of correctable errors
	DEBUG_BOOT r29
	get_high_addr r1, mem$csr_base	; get mem cntlr csr base
	lda	r2, esr$m_init(r31)	; load ESR init mask
	stq/p	r2, mem$q_esr(r1)	; clear the error status flags
	mb

	; Clear the RST bit in the LCA I/O controller's CSR to allow the
	; PCI bus to run and set LOST and ERR bits to clear errors
	; in IOCSTAT0
	get_high_addr r1, ioc$csr_base	; get io cntlr CSR base
	mb
	stq/p	r31, ioc$q_pci_rst(r1)	; make sure PCI is allowed to run
	mb

	lda	r2, stat0$m_init(r31)	; load IOCSTAT0 init mask
	stq/p	r2, ioc$q_stat0(r1)	; initialize IOCSTAT0
	mb
	.endc


	DEBUG_BOOT r29
	or	r31, #1, r1		; get bogus scbb value
	mt	r1, pt30		; load scbb

	DEBUG_BOOT r29
	get_addr r1, <bt$pcb-pal$start>, r0; get address
	mt	r1, pt31		; load pcbb

	DEBUG_BOOT r29
	mt	r31, pt24		; clear out prbr

	lda	r1, 2(r31)		; get a two
	sll	r1, #32, r1		; gen up upper bits
	mt	r1, pt29		; set l3 virt base
	mt	r31, pt28		; PTBR



	DEBUG_BOOT r29
	.if ne	sable_system
	;
	; Only do this on the primary.
	;
	stall	2
	mf	r16, pt27
	ldq/p	r15, pal$primary(r31)
	subq	r15, r16, r15
	bne	r15, cop_ipl_tbl_end
	;
	; Build the IPL table at ^x400.
	;
	lda	r16, 0(r31)
	lda	r10, pal$ipltbl(r31)
1000$:	lda	r11, 0(r31)
1010$:	lda	r12, -1(r31)
	sll	r12, r11, r12
	lda	r13, -1@15(r31)
	bic	r12, r13, r12
	sll	r12, #hierw$v_sier, r12
	lda	r13, ^b100000(r31)
	lda	r14, 1@hierw$v_cre(r31)
	cmpult	r11, #^x1f, r15
	cmovne	r15, #^b100001, r13
	cmpult	r11, #^x16, r15
	cmovne	r15, #^b111001, r13
	cmpult	r11, #^x14, r15
	cmovne	r15, #^b111111, r13
	bic	r13, r16, r13
	cmoveq	r15, r31, r14
	sll	r13, #hierw$v_hier, r13
	bis	r12, r13, r12
	bis	r12, r14, r12
	stq/p	r12, (r10)
	addq	r10, #8, r10
	addq	r11, #1, r11
	cmpeq	r11, #32, r15
	beq	r15, 1010$
1020$:	stq/p	r12, (r10)
	addq	r10, #8, r10
	addq	r11, #1, r11
	cmpeq	r11, #64, r15
	beq	r15, 1020$
	xor	r16, #^b000110, r16
	bne	r16, 1000$
	.iff
	.if	ne low_core_ipl
	; copy ipl table to low core
	sget_addr r1, <Pal$IplTblHi-pal$start>, r0,verify=0; get address of high ipl table
	sget_addr r2, <Pal$IplTbl>, r31	; get address of low ipl table
	.if ne	cfw_system
	lda	r3, ^x100(r31)		; Copy the part for O/S mode
	.iff
	lda	r3, <Pal$IplTblHiEnd-Pal$IplTblHi>(r31); size of table+8
	.endc
cop_ipl_tbl:
	subq	r3, #8, r3		; dec counter
	 ldq/p	r4, (r1)		; fetch next part of table
	addq	r1, #8, r1		; inc input
	 stq/p	r4, (r2)		; store into memory
	addq	r2, #8, r2		; inc output
	bgt	r3, cop_ipl_tbl		; loop till done
	.endc

	assume <pal$ipltbl> lt <^x8000>	; assumes can can use lda
	.endc
cop_ipl_tbl_end:


	DEBUG_BOOT r29
	.if	ne low_core_ipl
	  ldq/p	r2, Pal$IplTbl+<31*8>(r31); get the hw&sw enable bits
	mt	r2, hier		; turn on hw ints
	mt	r2, sier		; turn on sw ints
	stq/pc	r2, Pal$IplTbl+<31*8>(r31); clear lock flag
	.iff
	  sget_addr r3, <Pal$IplTblHi-pal$start>, r0,verify=0; get address of high ipl table
	 ldq/p	r2, <31*8>(r3)		; get the hw&sw enable bits
	mt	r2, hier		; turn on hw ints
	mt	r2, sier		; turn on sw ints
	 stq/pc r2, <31*8>(r3)		; clear lock flag
	.endc



	DEBUG_BOOT r29
	rc	r0			; clear intr_flag


	mf	r0, pt0			; get entry type

	.if ne	cfw_system
	mf	r12, pt27
	ldq/p	r15, pal$primary(r31)
	subq	r15, r12, r15
	bne	r15, 10$
	stq/p	r31, pal$lockflag(r31)
10$:	stq/p	r31, pal$callback(r31)
	.if ne	generic_system
	pvc$jsr		rgh, bsr=1
	bsr	r26, reset_generic_hardware
	.endc
	.if ne	sable_system
	pvc$jsr		rsh, bsr=1
	bsr	r26, reset_sable_hardware
	.endc
        .if ne  lean_system
        pvc$jsr         rph, bsr=1
        bsr     r26, reset_lean_hardware
        .endc
        .if ne  mtu_system
        pvc$jsr         reh, bsr=1
        bsr     r26, reset_mustang_hardware
        .endc
        .if ne  avanti_system  ! k2_system
        pvc$jsr         rph, bsr=1
        bsr     r26, reset_avanti_hardware
        .endc
        .if ne  mikasa_system ! noritake_system 
        pvc$jsr         rph, bsr=1
        bsr     r26, reset_mikasa_hardware
        .endc
	.if ne	medulla_system
	pvc$jsr		rmh, bsr=1
	bsr	r26, reset_medulla_hardware
	.endc
	.if ne	cortex_system
	pvc$jsr		rxh, bsr=1
	bsr	r26, reset_cortex_hardware
	.endc
	mf	r12, pt7
	stq/p	r31, cns$pal_type(r12)
	stq/p	r31, cns$work_request(r12)
	pvc$jsr		spb, bsr=1
	bsr	r26, show_pal_banner
	.endc

;	mt	r0, pt0			; save r0
	DEBUG_BOOT r29
	br	r31, pal$enter_console	; enter the cosole


	.if ne	adu_system
patch$jam_addrs::
	.if ne lca4
	.long	0
	.iff
	.long	<patch$biu_ctl-pal$start> ; offset to biu_ctl setter.
	.endc
	.long	<patch$abox_ctl-pal$start>; offset to abox_ctl setter.
	.long	0
	.iif ne enable_debug_pcevent, .long <pal$perftext-pal$start> ; offset to perf text
	.iif ne enable_debug_pctrace, .long <8+<<enable_debug_pstrace ! enable_debug_astentrace ! enable_debug_trace2reg>*8>> ; size of trace slot
	.endc

	END_HW_VECTOR	RESET




.sbttl	MCHK	- Hardware machine check flow

;+
; PAL$HW_VEC_MCHK
;addr	len	use
;----	---	------------------------------
;0020	16	machine check
;
; Entry:
;	Vectored into via hardware dispatch when machine check occurs.
;
; Function:
;	Build machine check logout area
;	Dispatch to handler
;
;-

	START_HW_VECTOR	MCHK
	; Something bad is going on, the best we can hope for is
	; a double single bit error condition on the istream.
	; Assumeing that is the case, we will flush the isteam now.

	mt	r31, flush_ic		; flush the icache
	 mt	r31, alt_mode		; make sure altmode is KERNEL mode
	mt	r0, pt0
	 mf	r0, 0			; read nothing (slow nop)
	mf	r0, 0			; read nothing (slow nop)
	 mf	r0, 0			; read nothing (slow nop)
	br	r31, pal$process_mchk	; continue elsewhere

	END_HW_VECTOR	MCHK


.sbttl	ARITH	- Arithmatic Trap 

;+
; PAL$HW_VEC_ARITH
;addr	len	use
;----	---	------------------------------
;0060	 32	arithmatic trap
;
; Entry:
;	Vectored into via hardware dispatch when arithmetic exception occurs.
;
; Function:
;	Construct exeception summary flags, and dirty register mask
;	Build stack frame
;	Dispatch through SCB
;
;-

	START_HW_VECTOR	ARITH, LONGFLOW=1
	.enable lsb
	mt	r13, pt13
	 mf	r13, exc_sum		; get exc sum
	mt	r12, pt12
	 mf	r12, va			; unlock va
	mt	r14, pt14
	 srl	r13, #exsum$v_swc, r13	; shift data to correct position
	mt	r31, exc_sum		; clear error bits
	 srl	r13, #exs$v_iov, r14	; 1@<0> if int error
	mt	r13, pt17		; save new r5
	 mt	r15, pt15
	and	r14, #1, r14		; clean int flag
	 mt	r14, pt16		; save int flag for later
	.iif eq <ev4_pass3>, CONT_HW_VECTOR	 ARITH, DOUBLE=1

	align_branch_target
10$:	mf	r13, exc_sum		; fetch bit <1>
	 or	r31, r31, r15		; zero the accumulator
	or	r31, #1, r12		; get a one
	 sll	r12, #<exsum$v_msk>, r12; set [f]r31, as loop stopper
 
	align_branch_target
20$:	mf	r14, exc_sum		; fetch bit <0>
	 addq	r15, r15, r15		; shift accumulator by 1 bit

	addq	r12, r12, r12		; position bit 2
	 or	r15, r12, r15		; merge bit 2 into accumulator
	mf	r12, exc_sum		; fetch bit <2>
	 srl	r14, #1, r14		; position bit 0

	or	r15, r13, r15		; merge bit 1 into accumulator
	 or	r15, r14, r15		; merge bit 0 into accumulator
	s4addq	r15, r31, r15		; shift accumulator by 2 bits
	 mf	r13, exc_sum		; fetch bit <1>
	bge	r15, 20$		; br if not done


	; done with 30 bits
	; get remaining 2 bits out
	; and prime the pump for the next 32 bits


	 or	r15, r12, r15		; merge bit 1 into accumulator
	mf	r12, pt16		; are we done?

	 srl	r13, #1, r13		; position bit 0
	or	r15, r13, r15		; merge bit 0 into accumulator
	 .iif ne <ev4_pass3>, CONT_HW_VECTOR	 ARITH, DOUBLE=1

	blbc	r12, 100$		; br if done
	 mf	r12, exc_sum		; fetch bit <2>
	mt	r15, pt16		; save fp masks in pt16
	 br	r31, 10$		; go back and get the int masks




	; r12 = fp data  if r12 < 0, else int data
	; r15 = int data if r12 < 0, else fp data

	.align	quad
100$:	or	r12, r31, r13		; hang on to indicator
	 cmoveq r13, r15, r12		; if not INT, move FP mask to r12
	cmoveq r13, r31, r15		; if not INT, move zero to INT mask

	; r12 has fp mask in high long
	; r15 has int  mask in high long
	 sll	r12, #1, r14		; clean fp results
	mf	r12, exc_addr		; get address of PAL call
	 sll	r15, #1, r15		; clean int results
	srl	r14, #1, r14		; reposition fp results
	 srl	r15, #<32+1>, r15	; reposition int results
	or	r14, r15, r14		; merge fp and int results

	 mf	r15, pt15
ev4_p2 <subq	r12, #2, r12		; dec pc, if needed>
	 mt	r14, pt16		; save new r4
ev4_p2 <bic	r12, #2, r12		; clean pc, if needed>
	 mf	r14, pt14
	lda	r13, scb$v_arith(r31)	; set scb vector to use

	 blbs	r12, pal$mchk_bugchk	; br if arith within PAL
	br	r31, pal$post_km_trap	; go build trap
	.disable lsb
	END_HW_VECTOR	ARITH


.sbttl	INTERRUPT - Interrupt, AST, CRD entry

;+
; PAL$HW_VEC_INTERRUPT
;addr	len	use
;----	---	------------------------------
;00E0	 64	interrupt
;
; Entry:
;	Vectored into via hardware dispatch when interrupt occurs.
;
; Function:
;	Weed out reason for interrupt
;	Perform interrupt specific code
;	Build stack frame
;	Dispatch through SCB
;
;-

	START_HW_VECTOR	INTERRUPT	; 11 cycles to dispatch
	mt	r31, pt3		; save zero value as flag of non-rei flow
pal$interrupt:
	 mt	r13, pt13
	mf	r13, hier		; get hardware enable mask's
	 mt	r12, pt12
	mf	r12, hirr		; get hardware interrupt mask's
	 mt	r14, pt14
	or	r13, #hirrr$m_hwr!hirrr$m_swr!hirrr$m_atr, r13;
	 mt	r15, pt15
	and	r12, r13, r13		; get bits that are req, and enabled
	 mf	r15, va			; unlock va
	stall	1			; for alignment
	 and	r13, #hirrr$m_hwr, r14	; was it a HW interrupt?
	bne	r14, pal$hw_interrupt	; br if yes
	 and	r13, #hirrr$m_swr, r14	; was it a SW interrupt?
	bne	r14, pal$sw_interrupt	; br if yes
	 and	r13, #hirrr$m_atr, r14	; was it an AST?
	beq	r14, dismiss_interrupt	; nope? - passive release
;	 .br	r31, pal$ast_interrupt	; well, let's try for an ast




.sbttl	AST	- AST handler

;+
;
; An AST interrupt has been detected
; Determine which of KESUast it was
;
;-
pal$ast_interrupt:			; 9 cycles decode
	 srl	r13, #hirrr$v_astrr, r12; get Kast to <0>
	srl	r13, #<hirrr$v_astrr+1>, r15; get East to <0>
	 lda	r14, 0(r31)		; get a zero
	blbs	r12, ack_ast		; br if Kast
	 srl	r12, #2, r12		; get Sast to <0>
	addq	r14, #1, r14		; bump the pointer
	 blbs	r15, ack_ast		; br if East
	srl	r15, #2, r15		; get next Uast to <0>
	 addq	r14, #1, r14		; bump the pointer
	blbs	r12, ack_ast		; br if Sast
	 addq	r14, #1, r14		; bump the pointer
	blbc	r15, dismiss_interrupt	; br if NOT Uast
	.iif ne <enable_debug_pctrace ! enable_debug_pcevent>, CONT_HW_VECTOR	 INTERRUPT

;+
; An AST interrupt has been detected and located
; ack the ast, build the frame and post the interrupt
;-
ack_ast:				; 13 cycles to ack, and swap ipl
					; 24 cycles to complete, if from rei

	lda	r12, ^b111111111111100(r31) ; get new sier
 	 mf	r15, hirr		; refetch hirr
	sll	r12, #hierw$v_sier, r12	; move to position
	 mt	r12, sier		; turn on sw ints
	lda	r12, 1(r31)		; get a one	 
	 addq	r14, #hirrr$v_astrr, r13; get spot
	sll	r12, r13, r12		; move 1 to zonk spot
	 sll	r14, #4, r13		; get astmode-1*16
	bic	r15, r12, r15		; ack this ast
	 sll	r15, #<hirrw$v_astrr-hirrr$v_astrr>, r15; get astrr to wrt
	mf	r14, pt9		; get cm ps
	 lda	r13, scb$v_kast(r13)	; calculate new scb vector
	mt	r15, astrr		; clear the request
	 and	r14, #4@ps$v_sw, r14	; get current ps_sw<2>
	mf	r15, pt3		; get rei flag
	 lda	r14, <2@ps$v_ipl>(r14)	; km=0, sw<2>=old, ipl=2
	mt	r14, pt0		; save new ps, for stack builder
	 mf	r12, exc_addr		; get address of PAL call
	beq	r15, pal$post_km_ps_trap; go build trap,unless here from rei


;
; AST detected, while REI'ing
;

	.iif eq <enable_debug_pctrace ! enable_debug_pcevent>, CONT_HW_VECTOR	 INTERRUPT
	 or	r14, r31, r2		; get a copy of the new ps
	mf	r15, pt30		; get scbb
	 mf	r12, pt12
	addq	r13, r15, r15		; get addr of our vector addr
	 mf	r14, pt14
	mt	r2, PT9_PS		; set new ps
	 ldq/p	r2, 0(r15)		; get scbv
	ldq/p	r3, 8(r15)		; get scbp
	 mf	r13, pt13
	bic	r2, #3, r2		; clean low bits of new pc
	 mt	r2, exc_addr		; set new pc
	mf	r15, pt15
	 hw_rei				; Now dispatch through scb to new vector




.sbttl	SWINT	- Software interrupt handler

;+
;
; A software interrupt has been detected
; locate the interrupt
; ack the ast, build the frame and post the interrupt
;
;-
	align_to_double_cache_block	; align for branch target
pal$sw_interrupt:			; 15 cycles
	mf	r14, pt25		; get misc bits
	 sll	r12, <hirrw$v_sirr-hirrr$v_sirr>, r13; move sw ints to write pos
	zap	r14, #1, r12		; remove hi, from pt25
	 and	r14, #^xff, r15		; get hi request
	mt	r12, pt25		; and store it away
	 cmpeq	r15, #1, r12		; is this a sw1 interrupt
	bne	r12, sw1_interrupt	; yes, go check for a pending ast
not_sw1_and_ast:
	 lda	r12, 1(r31)		; get a one
	addq	r15, #hirrw$v_sirr-1, r14; get offset to write pos
	 sll	r12, r14, r12		; get bic mask
	bic	r13, r12, r12		; ack the sw int
	 sll	r15, #4, r14		; * 16 for scb offset
	mt	r12, sirr		; clear the requested interrupt
	 extwl	r12, #4, r12		; get current sw int requests
	lda	r13, <scb$v_sw1-^x10>(r14); set scb vector to use
	 cmple	r12, #1, r14		; any bits set?
	blbc	r14, pal$sw_2interrupt	; go recompute high sw, if more pending
	 stall	1, mxpr=0		; stall for alignment
;	.br	complete_interrupt	; and take the interrupt

; 13 = scb, r15=ipl
; 12 = low sirr, 14 = trash



.sbttl	INTCOMP - Interrupt handler completion routines

;+
; complete_interrupt
;
; a proper interrupt was detected, and decoded
; switch the ipl, and post the trap
;	pt12 = save R12
;	pt13 = save R13
;	pt14 = save R14
;	pt15 = save R15
;	r12 = junk
;	r13 = scbv
;	r14 = new_r4
;	r15 = new ipl
;
;-
;;;	align_to_double_cache_block	; align for branch target
complete_interrupt:			; 9 cycles
	trace_pc	<complete_interrupt>
	mf	r12, pt3		; get rei flag
	bne	r12, complete_rei_interrupt
	.if ne	cfw_system
	mf	r12, pt8		; Get base of IPL table
	s8addq	r15, r12, r12		; Multiply by 8 for quadword index
	sll	r15, #ps$v_ipl, r15	; Move IPL to IPL field
	ldq/p	r12, (r12)		; Get the HW and SW enable bits
	.iff
	.if	ne low_core_ipl
	 s8addq	r15, r31, r12		; x8 for quadword index
	 sll	r15, #ps$v_ipl, r15	; move ipl to ipl field
	ldq/p	r12, Pal$IplTbl(r12)	; get the hw&sw enable bits
	.iff
	 mf	r12, pal_base		; get pal base
	  s8addq r15, r12, r12		; x8 for quadword index
	 sll	r15, #ps$v_ipl, r15	; move ipl to ipl field
	 sget_addr r12, <pal$IplTblHi-pal$start>,r12,verify=0; get addr of enable bits
	ldq/p	r12, (r12)		; get the hw&sw enable bits
	.endc
	.endc

	 or	r15, #4@ps$v_sw, r15	; set ps sw<2>
	mt	r15, pt0		; save IPL only as new ps (km)
	 mt	r12, hier		; turn on hw ints
	mt	r12, sier		; turn on sw ints
	.if ne lca4
	mf	r15, pt25		; get MCES
	and	r12, hierw$m_cre, r12	; isolate CRE bit
	srl	r15, <pt25$v_dpc - hierw$v_cre>, r15 ; move DPC to hierw<cre> pos
	bic	r12, r15, r12		; hierw<cre> & !mces<dpc>
	get_high_addr r15, mem$csr_base
	xor	r12, hierw$m_cre, r12	; toggle it
	sll	r12, <esr$v_ice-hierw$v_cre>, r12  ; move it into position
	stq/p	r12, mem$q_esr(r15)	; write ICE
	mf	r15, pt0		; restore IPL
	.endc
	 mf	r12, exc_addr		; get address of PAL call
	br	r31, pal$post_km_ps_trap; go build trap




	align_to_double_cache_block	; align for branch target
complete_rei_interrupt:			; 9 cycles
	trace_pc	<complete_rei_interrupt>
	.if ne	cfw_system
	mf	r12, pt8		; Get base of IPL table
	s8addq	r15, r12, r12		; Multiply by 8 for quadword index
	sll	r15, #ps$v_ipl, r15	; Move IPL to IPL field
	ldq/p	r12, (r12)		; Get the HW and SW enable bits
	.iff
	.if	ne low_core_ipl
	 s8addq	r15, r31, r12		; x8 for quadword index
	  sll	r15, #ps$v_ipl, r15	; move ipl to ipl field
	ldq/p	r12, Pal$IplTbl(r12)	; get the hw&sw enable bits
	.iff
	 mf	r12, pal_base		; get pal base
	  s8addq r15, r12, r12		; x8 for quadword index
	 sll	r15, #ps$v_ipl, r15	; move ipl to ipl field
	 sget_addr r12, <pal$IplTblHi-pal$start>,r12,verify=0; get addr of enable bits
	ldq/p	r12, (r12)		; get the hw&sw enable bits
	.endc
	.endc

	 or	r15, #4@ps$v_sw, r15	; set ps sw<2>
	mt	r15, PT9_PS		; set new ps
	 or	r14, r31, r4		; r4=newR4
	mt	r12, hier		; turn on hw ints
	 mt	r12, sier		; turn on sw ints

	.if ne lca4
	mf	r15, pt25		; get MCES
	and	r12, hierw$m_cre, r12	; isolate CRE bit
	srl	r15, <pt25$v_dpc - hierw$v_cre>, r15 ; move DPC to hierw<cre> pos
	bic	r12, r15, r12		; hierw<cre> & !mces<dpc>
	get_high_addr r15, mem$csr_base
	xor	r12, hierw$m_cre, r12	; toggle it
	sll	r12, <esr$v_ice-hierw$v_cre>, r12  ; move it into position
	stq/p	r12, mem$q_esr(r15)	; write ICE
	.endc

	mf	r15, pt30		; get scbb
	 mf	r12, pt12
	mf	r14, pt14
	 addq	r13, r15, r15		; get addr of our vector addr
	ldq/p	r2, 0(r15)		; get scbv
	 mf	r13, pt13
	bic	r2, #3, r2		; clean low bits of new pc
	 mt	r2, exc_addr		; set new pc
	ldq/p	r3, 8(r15)		; get scbp
	 mf	r15, pt15
	hw_rei				; Now dispatch through scb to new vector


;+
;
; SWint continue
;
;
; we get here, if we are doing a sw int, and there is a lower priority
; sw int that has been requested (though not necessarilly pending)
;
; out task, is to locate that sw int, and set it as the new highest pending
; sw int in pt25
;
; and to complete the sw int
;
;-

; 13 = scb, r15=ipl
; 12 = low sirr, 14 = trash
	align_to_cache_block		; align for branch target
pal$sw_2interrupt:			; 23 cycles
	mt	r16, pt16
	 lda	r14, 0(r31)		; assume sw int in low bits
	mt	r17, pt17
	 cmpule	r12, #^xff, r16		; see if any swints 's > 7 are reqstd
	xor	r16, #1, r16		; flip <0>
	 stall	1

	extbl	r12, r16, r12		; get byte of interest to <0>
	 cmovne	r16, #8, r14		; update base bit, if workin on high 8


	; reduce to 4 bits
	lda	r17, (r31)		; start at bit 0
	 and	r12, #^xF0, r16		; check the bits that set <2>
	cmovne	r16, r16, r12		; keep the correct half
	 cmovne	r16, #4, r17		; set <2>	
	and	r12, #^xCC, r16		; check the bits that set <1>
	 or	r14, r17, r14		; merge into result
	cmovne	r16, r16, r12		; keep the correct half
	 cmovne	r16, #2, r17		; set <1>	
	and	r12, #^xAA, r16		; check the bits that set <0>
	 or	r14, r17, r14		; merge into result
	cmovne	r16, #1, r17		; set <0>	
	 cmovne	r16, r16, r12		; keep the correct half
	or	r14, r17, r14		; merge into result
	 mf	r12, pt25		; fetch current misc reg
	mf	r16, pt16
	 mf	r17, pt17
	or	r12, r14, r14		; merge the data
	 mt	r14, pt25		; and store it away
	stall	1
	 br	r31, complete_interrupt; go build trap


;+
;
; SW1int
;
;
; we get here, if we are doing a sw1 int. (which is unlikly)
; We need to look for a pending AST as it has higher priority.
; If the AST is pending, we revector back to
; the AST handling code, else we continue processing the sw interrupt.
;
;-

	.align	quad
sw1_interrupt:
	mf	r14, hier		; get hardware enable mask's
	 mf	r12, hirr		; get hardware interrupt mask's
	or	r14, #hirrr$m_hwr!hirrr$m_swr!hirrr$m_atr, r14;
	 and	r12, r14, r14		; get bits that are req, and enabled
	and	r14, #hirrr$m_atr, r12	; any AST's pending?
	 beq	r12, not_sw1_and_ast	; nope, no ast pending

	mf	r13, pt25		; recall pt25
	 or	r13, #1, r13		; reset high sw pending to 1
	mt	r13, pt25		; and save it away

	 or	r14, r31, r13		; restore r13, for the ast code
	br	r31, pal$ast_interrupt	; yes, go do the ast



.sbttl	HWINT	- Hardware interrupt handler

;+
;
; A hardware interrupt has been detected
; locate the interrupt
; ack the ast, build the frame and post the interrupt
;
;-
	align_to_double_cache_block	; align for branch target
pal$hw_interrupt:
	.if ne lca4
	and	r13, #hirrr$m_ierr!hirrr$m_merr, r14 ; error interrupt?
	bne	r14, pal$error_interrupt ; br if yes
	.iff
	and	r13, #hirrr$m_crd, r14	; was it a CRD interrupt?
	 bne	r14, pal$crd_interrupt	; br if yes
	.endc
	trace_pc	<hw_interrupt_detected>

	.if ne	adu_system
	or	r13, r31, r15		; get a copy of the pending hw ints
	mf	r13, pt27		; get whami
	and	r13, #^xff, r13		; isolate whami
	subq	r31, #1, r12		; get io space indicator
	sll	r12, #tv$v_space, r12	; shift io space indicator
	sll	r13, #tv$v_node, r14	; shift to make tv node number
	or	r12, r14, r12		; now have base addr of board


	srl	r15, #HIRRR$V_HIRR20, r14 ; get HALT bit to <0>
	blbs	r14, 30$		; go handle the halt


	lda	r14, <<1@hirrr$v_pc0>!<1@hirrr$v_pc1>>(r31) ; pc mask
	and	r15, r14, r15
	bne	r15, 50$		; go handle pending perfmon int's
	perfmon_support1 == 1		; show support code present

	get_addr r12, <tv$v_cpu_isr>, r12; merge in cpu ISR addr
	ldq/p	r14, (r12)		; get the isr
	srl	r14, #32, r14		; shift to low long
	beq	r14, dismiss_interrupt	; no cpu int's pending all done
	assume  tv$v_cpu_isr_ipl20l gt 0; check irq's above 32
	assume  tv$v_cpu_isr_ipl21l gt 0; check irq's above 32
	assume  tv$v_cpu_isr_ipl22l gt 0; check irq's above 32
	assume  tv$v_cpu_isr_ipl23l gt 0; check irq's above 32
	assume  tv$v_cpu_isr_proc   gt 0; check irq's above 32
	assume  tv$v_cpu_isr_time   gt 0; check irq's above 32



	mt	r0, pt0			; get more scratch regs
	mt	r1, pt1			;
	ffs 	size=32, rs=r14, rd=r15, t0=r0, t1=r1 ; find first set
	mf	r0, pt0			; restore extra scratch regs
	mf	r1, pt1			;


	or	r31, #1, r14		; get a one
	sll	r14, r15, r14		; get mask of INT-32 to clear
	sll	r14, #32, r14		; correct maks of INT to clear

;	.if ne	adu_pause_support
;	cmpeq	r15, #tv$v_cpu_isr_reserved-32, r12; is this a reserved interrupt?
;	bne	r12, 20$		; go do "pause" function, if reserved
;	.endc ; this code is broken... needs one more reg

	stq/p	r14, (r12)		; ack the hw int.
	mb


	cmpeq	r15, #tv$v_cpu_isr_time-32, r12; is this a clock interrupt?
	bne	r12, 10$		; yes
	cmpeq	r15, #tv$v_cpu_isr_reserved-32, r12; is this a reserved interrupt?
	bne	r12, dismiss_interrupt	; dismiss_interrupt if reserved

	subq	r13, #3, r13		; get (whami - 3)
	sll	r13, #5, r13		; get (whami -3)*32
	addq	r13, #128, r13		; get (whami -3)*32 + 128
	addq	r13, r15, r13		; get (whami -3)*32 + 128 + chan


	cmpeq	r15, #tv$v_cpu_isr_proc-32, r12; is this an IP interrupt?
	cmovne	r12, #scb$v_inter@-4, r13 ; yes

	sll	r13, #4, r13		; convert from SCB number to offset
	
	or	r31, #23, r14		; assume this is an IPL 23 interrupt
	cmplt	r15, #<tv$v_cpu_isr_ipl23l-32>, r12; IPL 22 int?
	cmovne	r12, #22, r14		; could be, set ipl, keep checking
	cmplt	r15, #<tv$v_cpu_isr_ipl22l-32>, r12; IPL 21 int?
	cmovne	r12, #21, r14		; could be, set ipl, keep checking
	cmplt	r15, #<tv$v_cpu_isr_ipl21l-32>, r12; IPL 20 int?
	cmovne	r12, #20, r14		; must be, set ipl
	or	r14, r31, r15		; set ipl
	br	r31, complete_interrupt; go build trap
	.endc	


	.if ne	adu_system
	; timer interrupt
	; update the SCC, set up interrupt
	align_to_double_cache_block	; align for branch target
10$:	trace_pc	<timer_interrupt_detected>
	rpcc	r13			; get cycle counter
	 or	r31, #1, r14		; get a 1
	mf	r12, pt10		; get SCC
	 sll	r14, #32, r14		; now a 100000000

	zap	r13,^xf0, r13		; get low long of pcc
	 zap	r12,^xf0, r15		; get low long of pcc
	zap	r12,^x0f, r12		; get high long of SCC

	 subq	r13, r15, r15		; if pcc<31:0> le scc<31:0>
	cmovge r15, r31, r14		; zero wrap, if wrap did not happen

	 addq	r12, r14, r12		; add wrapper to SCC
	or	r12, r13, r12		; merge
	 mt	r12, pt10		; update scc


	lda	r13, scb$v_clock(r31)	; set scb vector
	 or	r31, #22, r15		; set ipl
	br	r31, complete_interrupt; go build trap


	.if ne	adu_pause_support
	; PAUSE interrupt arrived
	; this code is for the ADU only, and should not be included on any
	; other systems. It's purpose is to allow the ADU console to "pause"
	; the running system, without halting it. It does this so that it may
	; play with the ADU memory without any interactions from the ADU
	.align	quad
20$:	ldq/p	r14, (r12)		; get the isr
	srl	r14, #62, r14		; pause bit low
	blbs	r14, 20$		; stay paused while bit is set
	br	r31, dismiss_interrupt	; then dismiss the interrupt
	.endc


	; HALT interrupt arrived
	.align	quad
30$:	trace_pc	<halt_interrupt_detected>
	mf	r12, pt3		; get rei flag
	beq	r12, 40$		; br if "normal" halt
	subq	r12, #1, r12		; change ps+1 back to ps
	mt	r12, pt9_ps		; restore the munged ps

	; reset the hier/sier from the baged rei
	extbl	r12, <ps$v_ipl/8>, r12	; get new IPL
	.if ne	low_core_ipl
	s8addq	r12, r31, r12		; * 8
	 ldq/p	r12, Pal$IplTbl(r12)	; get the hw&sw enable bits
	.iff
	mf	r13, pal_base		; get pal base
	 s8addq	r12, r13, r12		; * 8
	sget_addr r12, <pal$IplTblHi-pal$start>,r12; get addr of enable bits
	 ldq/p	r12, (r12)		; get the hw&sw enable bits
	.endc

	mt	r12, hier		; reset hardware ints
	mt	r12, sier		; reset sw ints

	.if ne lca4
	mf	r15, pt25		; get MCES
	and	r12, hierw$m_cre, r12	; isolate CRE bit
	srl	r15, <pt25$v_dpc - hierw$v_cre>, r15 ; move DPC to hierw<cre> pos
	bic	r12, r15, r12		; hierw<cre> & !mces<dpc>
	get_high_addr r15, mem$csr_base
	xor	r12, hierw$m_cre, r12	; toggle it
	sll	r12, <esr$v_ice-hierw$v_cre>, r12  ; move it into position
	stq/p	r12, mem$q_esr(r15)	; write ICE
	.endc

	mf	r12, exc_addr		; else, was a halt while'st REIing.
	subq	r12, #4, r12		; PC = pc of interrupted REI.
	mt	r12, exc_addr		; and tell the hw about it.

40$:	mf	r12, pt12		; Restore r12
	mf	r13, pt13		; Restore r13
	mf	r14, pt14		; Restore r14
	mf	r15, pt15		; Restore r15

	mt	r0, pt0			; save r0
	stall	2

	pvc$jsr updpcb, bsr=1
	bsr	r0, pal$update_pcb	; update the pcb

	lda	r0, hlt$c_hw_halt(r31)	; set halt code to hw halt
	br	r31, pal$enter_console	; enter the console




; performance counter trigered
	perfmon_support2 == 1		; show support code present
					; set flag showing, that the interrupt
					; support half of the perfmon code is
	align_to_double_cache_block	; present
50$:	lda	r13, 1(r31)		; get a one
	subq	r31, #1, r14		; get a -1
	or	r31, #sl_clr$v_pc0, r12	; get bit pos for pc0 ints
	srl	r15, #hirrr$v_pc0, r15	; get pc0 to <0>
	and	r15, #1, r15		; isolate pc0
	cmovlbc	r15, #sl_clr$v_pc1, r12	; bit pos for pc1 ints
	sll	r13, r12, r13		; now is bit in pos
	bic	r14, r13, r14		; clear pending bit
	mt	r14, sl_clr		; ack the interrupt
	lda	r13, scb$v_perfmon(r31)	; set scb vector
	cmpeq	r15, r31, r14		; r14 = 1 if pc1, 0 if pc0
	or	r31, #29, r15		; set new ipl=29
	br	r31, complete_interrupt	; go build trap
	.endc



	.if ne	generic_system
	pvc$violate	1003
	halt				; Interrupts off, we never get here
	.endc

	.if ne	sable_system

	;
	; Handle the performance monitoring stuff.
	;
	perfmon_support1 == 1

	lda	r12, hirrr$m_pc0!hirrr$m_pc1(r31) ; Get PC bits
	and	r13, r12, r15		; Are any set?
	bne	r15, 10$		; Yep, go look at them

	;
	; Handle those interrupts which are always enabled.
	;
	lda	r12, hirrr$m_irq5(r31)	; Get the system event mask
 	and	r12, r13, r12		; Was it the system event interrupt?
	bne	r12, hw_system_event	; Yes, handle it

	;
	; Handle those interrupts which are enabled if IPL < 31.
	;
	lda	r12, hirrr$m_irq0(r31)	; Get the Cbus error mask
 	and	r12, r13, r12		; Was it the Cbus error interrupt?
	bne	r12, hw_cbus_error	; Yes, handle it

	;
	; Handle those interrupts which are enabled if IPL < 22.
	;
	lda	r12, hirrr$m_irq4(r31)	; Get the timer mask
 	and	r12, r13, r12		; Was it the timer interrupt?
	bne	r12, hw_timer		; Yes, handle it

	lda	r12, hirrr$m_irq3(r31)	; Get the IP request mask
 	and	r12, r13, r12		; Was it the IP request interrupt?
	bne	r12, hw_ip_request	; Yes, handle it

	;
	; Handle those interrupts which are enabled if IPL < 20.
	;
	lda	r12, hirrr$m_irq1(r31)	; Get the SIO mask
	and	r12, r13, r12		; Was it the SIO interrupt?
	bne	r12, hw_sio		; Yes, handle it

	lda	r12, hirrr$m_irq2(r31)	; Get the XIO mask
	and	r12, r13, r12		; Was it the XIO interrupt?
	bne	r12, hw_xio		; Yes, handle it

	br	r31, dismiss_interrupt	; Else, just dismiss this interrupt

	perfmon_support2 == 1

10$:	addq	r31, #1, r13		; Get a 1
	subq	r31, #1, r14		; get a -1
	or	r31, #sl_clr$v_pc0, r12	; Get bit position for PC0 interrupts
	srl	r15, #hirrr$v_pc0, r15	; Get PC0 to <0>
	and	r15, #1, r15		; Isolate PC0
	cmovlbc	r15, #sl_clr$v_pc1, r12	; Get bit position for PC1 interrupts
	sll	r13, r12, r13		; Now get bit in position
	bic	r14, r13, r14		; Clear pending bit
	mt	r14, sl_clr		; Acknowledge the interrupt
	lda	r13, scb$v_perfmon(r31)	; Set SCB vector
	cmpeq	r15, r31, r14		; R4 = 1 if PC1, 0 if PC0
	or	r31, #29, r15		; Set IPL
	br	r31, complete_interrupt	; Go build trap

	.endc

	.if ne	lean_system

.sbttl	LEAN Hardware Interrupt Handler
;----------------------------------------------------------------------
;
; LEAN Hardware Interrupt Handler
;
;	The order for parsing interrupts is IRQ0, IRQ1 and IRQ2.
;	IRQ3, IRQ4 and IRQ5 are ignored for now.
;
; INPUT PARAMETERS:
;
;	Reg	Usage
;	r13	HIRR masked with HIER.
;	r14	unchanged - 2 to denote we got a HW interrupt.
;
; r12-r15 are saved in pt12-pt15. r12,r14-r15 can be used as scratch registers.
;
; OUTPUT REGISTERS:
;
;	Reg	Usage
;	r13	SCB vector value
;	r14	new value of r4 on exit
;	r15	new IPL
;
; FUNCTION DESCRIPTION:
;
;	Parse the HIRR value passed in r13 to handle the highest
;	priority pending interrupt.
;
;	IRQ1 - Non-Maskable interrupts (IPL 31)
;
;                1. Build a machine check log.
;                2. Build a stack frame.
;                3. Vector through offset ^x660 in the SCB 
;
;	IRQ2 - I/O Device interrupts (IPL 21)
;
;		 1. iAck the 82378IB PIC to detect the source.
;		 2. Dismiss specific interrupt.
;		 3. Build a stack frame.
;		 4. Restore r12 - r15.
;		 5. Vector through offset x^800 in the SCB.
;
;	       This interrupt supports all devices on ISA.
;
;		IR0	Interval timer
;		IR1	Keyboard
;		IR2	(chains interrupt from slave PIC)
;		IR3	8-bit ISA - National 87312 COM2
;		IR4	8-bit ISA - National 87312 COM1
;		IR5	8-bit ISA - National 87312 Parallel port (or IR7)
;		IR6	8-bit ISA - National 87312 floppy disk controller
;		IR7	8-bit ISA - National 87312 Parallel port (or IR5)
;		IR8	Unused (RTC internal to the SIO)
;		IR9	8-bit  ISA /PCI Ethernet/PCI SCSI
;		IR10	16-bit ISA /PCI Ethernet/PCI SCSI
;		IR11	16-bit ISA /PCI Ethernet/PCI SCSI
;		IR12	16-bit ISA Mouse 
;		IR13	Unused 
;		IR14	16-bit ISA
;		IR15	16-bit ISA /PCI Ethernet/PCI SCSI
;
;	IRQ0 - Real Time Clock interrupt (IPL 22)
;
;		 1. Dismiss interrupt.
;		 2. Build a stack frame.
;		 3. Restore r12 - r15.
;		 4. Vector through offset ^x600 in the SCB.
;
;	IRQ3 - IGNORED
;	IRQ4 - IGNORED
;	IRQ5 - IGNORED
;
;----------------------------------------------------------------------


devipl = 20

	;
	; Handle those interrupts which are always enabled.
	;
	lda	r12, hirrr$m_irq1(r31)	; Get NMI error mask
 	and	r12, r13, r12		; Was it the NMI error interrupt?
	bne	r12, hw_nmi_error	; Yes, handle it

	;
	; Handle the performance monitoring stuff.
	;
	perfmon_support1 == 1

	lda	r12, hirrr$m_pc0!hirrr$m_pc1(r31) ; Get PC bits
	and	r13, r12, r15		; Are any set?
	bne	r15, HW_PERF		; Yep, go look at them


	;
	; Handle those interrupts which are enabled if IPL < 22.
	;
	lda	r12, hirrr$m_irq0(r31)	; Get the timer mask
 	and	r12, r13, r12		; Was it the timer interrupt?
	bne	r12, hw_timer		; Yes, handle it

	;
	; Handle those interrupts which are enabled if IPL < 21.
	;
	lda	r12, hirrr$m_irq2(r31)	; Get the SIO mask
	and	r12, r13, r12		; Was it the SIO interrupt?
	bne	r12, hw_sio		; Yes, handle it

	br	r31, dismiss_interrupt	; Else, just dismiss this interrupt



.endc

	.if ne	mtu_system

.sbttl	Mustang/Noname Hardware Interrupt Handler
;----------------------------------------------------------------------
;
; Mustang/Noname Hardware Interrupt Handler
;
;	The order for parsing interrupts is IRQ2, IRQ0, and IRQ1.
;	IRQ3, IRQ4 and IRQ5 are ignored for now.
;
; INPUT PARAMETERS:
;
;	Reg	Usage
;	r13	HIRR masked with HIER.
;	r14	unchanged - 2 to denote we got a HW interrupt.
;
; r12-r15 are saved in pt12-pt15. r12,r14-r15 can be used as scratch registers.
;
; OUTPUT REGISTERS:
;
;	Reg	Usage
;	r13	SCB vector value
;	r14	new value of r4 on exit
;	r15	new IPL
;
; FUNCTION DESCRIPTION:
;
;	Parse the HIRR value passed in r13 to handle the highest
;	priority pending interrupt.
;
;	IRQ0 - Non-Maskable interrupts (IPL 31)
;
;                1. Build a machine check log.
;                2. Build a stack frame.
;                3. Vector through offset ^x660 in the SCB 
;
;	IRQ1 - I/O Device interrupts (IPL 21)
;
;	The information here appplies also to the mustang p1 riser.  With
;	the pass 2 riser the interrupts now go through a registers an get or'd
;	into this interrupt.  In order to determine if the pic is interrupting a
;	read of isa address 26(16) is done and bit 10 must be looked at.  If it
;	is set then the information here is exactly the same as it was before.
;	If bit 10 is not set then we enter a secondary parser to determine the
;	interrupt.
;
;	This information applies to mustang/noname for the pic.
;	
;		 1. iAck the 82378IB PIC to detect the source.
;		 2. Dismiss specific interrupt.
;		 3. Build a stack frame.
;		 4. Restore r12 - r15.
;		 5. Vector through offset ^x800 + (PIC_vector * 16) in the SCB
;
;	       This interrupt supports all devices on ISA.
;
;		IR0	Interval timer
;		IR1	Keyboard
;		IR2	(chains interrupt from slave PIC)
;		IR3	8-bit ISA - National 87312 COM2
;		IR4	8-bit ISA - National 87312 COM1
;		IR5	8-bit ISA - National 87312 Parallel port (or IR7)
;		IR6	8-bit ISA - National 87312 floppy disk controller
;		IR7	8-bit ISA - National 87312 Parallel port (or IR5)
;		IR8	Unused (RTC internal to the SIO)
;		IR9	8-bit  ISA /PCI Ethernet/PCI SCSI
;		IR10	16-bit ISA /PCI Ethernet/PCI SCSI
;		IR11	16-bit ISA /PCI Ethernet/PCI SCSI
;		IR12	16-bit ISA Mouse 
;		IR13	Unused 
;		IR14	16-bit ISA
;		IR15	16-bit ISA /PCI Ethernet/PCI SCSI
;
;	The following information is for mustang with a pass two riser card.
;
;		 1. Determine the source.
;		 2. Build a stack frame.
;		 3. Restore r12 - r15.
;		 4. Vector through offset ^x900 + (PCI_vector * 16) in the SCB
;
;	This interrupt supports the following interrupts on the PCI
;	
;		IRQ REG		VECTOR	Description
;		  bit		
;		   0		900	810 SCSI controller
;		   1		910	Tulip Network controller
;		   2		920	Slot 0 interrupt A
;		   3		930	Slot 0 interrupt B
;		   4		940	Slot 0 interrupt C
;		   5		950	Slot 0 interrupt D
;		   6		960	Slot 1 interrupt A
;		   7		970	Slot 1 interrupt B
;		   8		980	Slot 1 interrupt C
;		   9		990	Slot 1 interrupt D
;
;	IRQ2 - Real Time Clock interrupt (IPL 22)
;
;		 1. Dismiss interrupt.
;		 2. Build a stack frame.
;		 3. Restore r12 - r15.
;		 4. Vector through offset ^x600 in the SCB.
;
;	IRQ3 - IGNORED
;	IRQ4 - IGNORED
;	IRQ5 - IGNORED
;
;----------------------------------------------------------------------

devipl = 21
halt_irq = hirrr$v_irq0
	;
	; Handle those interrupts which are always enabled.
	;
	lda	r12, hirrr$m_irq0(r31)	; Get NMI error mask - halt button as
					; well
 	and	r12, r13, r12		; Was it the NMI error interrupt?
	bne	r12, hw_nmi_error	; Yes, handle it

	;
	; Handle the performance monitoring stuff.
	;
	perfmon_support1 == 1

	lda	r12, hirrr$m_pc0!hirrr$m_pc1(r31) ; Get PC bits
	and	r13, r12, r15		; Are any set?
	bne	r15, HW_PERF		; Yep, go look at them


	;
	; Handle those interrupts which are enabled if IPL < 22.
	;
	lda	r12, hirrr$m_irq2(r31)	; Get the timer mask
 	and	r12, r13, r12		; Was it the timer interrupt?
	bne	r12, hw_timer		; Yes, handle it

	;
	; Handle those interrupts which are enabled if IPL < 21.
	;
	lda	r12, hirrr$m_irq1(r31)	; Get the SIO mask
	and	r12, r13, r12		; Was it the SIO interrupt?
	bne	r12, hw_sio		; Yes, handle it

	br	r31, dismiss_interrupt	; Else, just dismiss this interrupt



.endc

	.if ne	avanti_system

.sbttl	Avanti Hardware Interrupt Handler
;----------------------------------------------------------------------
;
; Avanti Hardware Interrupt Handler
;
;	The order for parsing interrupts is IRQ4, IRQ3, IRQ2
;	and IRQ0.  IRQ1 and IRQ5 are ignored for now.
;
; INPUT PARAMETERS:
;
;	Reg	Usage
;	r13	HIRR masked with HIER.
;	r14	unchanged - 2 to denote we got a HW interrupt.
;
; r12-r15 are saved in pt12-pt15. r12,r14-r15 can be used as scratch registers.
;
; OUTPUT REGISTERS:
;
;	Reg	Usage
;	r13	SCB vector value
;	r14	new value of r4 on exit
;	r15	new IPL
;
; FUNCTION DESCRIPTION:
;
;	Parse the HIRR value passed in r13 to handle the highest
;	priority pending interrupt.
;
;	IRQ0 - AIO interrupts (IPL 31)
;		 Not sure what to do here, so for now ...
;
;		 1. Build a stack frame.
;		 2. Restore r12 - r15.
;		 3. Vector through offset 670 in the SCB.
;
;	IRQ1 - Not Used 
;
;	IRQ2 - I/O Device interrupts (IPL 21)
;
;		 1. iAck the 82378IB PIC to detect the source.
;		 2. Dismiss specific interrupt.
;		 3. Build a stack frame.
;		 4. Restore r12 - r15.
;		 5. Vector through offset x^800 in the SCB.
;
;	       This interrupt supports all devices on ISA.
;
;		IR0	Interval timer
;		IR1	Keyboard
;		IR2	(chains interrupt from slave PIC)
;		IR3	8-bit ISA - National 87312 COM2
;		IR4	8-bit ISA - National 87312 COM1
;		IR5	8-bit ISA - National 87312 Parallel port (or IR7)
;		IR6	8-bit ISA - National 87312 floppy disk controller
;		IR7	8-bit ISA - National 87312 Parallel port (or IR5)
;		IR8	Unused (RTC internal to the SIO)
;		IR9	8-bit  ISA /PCI Ethernet/PCI SCSI
;		IR10	16-bit ISA /PCI Ethernet/PCI SCSI
;		IR11	16-bit ISA /PCI Ethernet/PCI SCSI
;		IR12	16-bit ISA Mouse 
;		IR13	Unused 
;		IR14	16-bit ISA
;		IR15	16-bit ISA /PCI Ethernet/PCI SCSI
;
;	IRQ3 - Non-Maskable interrupts (IPL 31)
;
;                1. Build a machine check log.
;                2. Build a stack frame.
;                3. Vector through offset ^x660 in the SCB 
;
;	IRQ4 - Real Time Clock interrupt (IPL 22)
;
;		 1. Dismiss interrupt.
;		 2. Build a stack frame.
;		 3. Restore r12 - r15.
;		 4. Vector through offset ^x600 in the SCB.
;
;	IRQ5 - HALT 
;
;----------------------------------------------------------------------

devipl = 20
halt_irq = hirrr$v_irq5
	;
	; Handle those interrupts which are always enabled.
	;
	lda	r12, hirrr$m_irq5(r31)	; Get the system event mask
 	and	r12, r13, r12		; Was it the system event interrupt?
	bne	r12, hw_check_halt		; go process the the halt button

	;
	; Handle the performance monitoring stuff.
	;
	perfmon_support1 == 1

	lda	r12, hirrr$m_pc0!hirrr$m_pc1(r31) ; Get PC bits
	and	r13, r12, r15		; Are any set?
	bne	r15, HW_PERF		; Yep, go look at them

	;
	; Handle those interrupts which are always enabled.
	;
	lda	r12, hirrr$m_irq3(r31)	; Get NMI error mask
 	and	r12, r13, r12		; Was it the NMI error interrupt?
	bne	r12, hw_nmi_error	; Yes, handle it


	;
	; Handle those interrupts which are enabled if IPL < 31.
	;
	lda	r12, hirrr$m_irq0(r31)	; Get AIO error mask
 	and	r12, r13, r12		; Was it the AIO error interrupt?
	bne	r12, hw_error	; Yes, handle it

	;
	; Handle those interrupts which are enabled if IPL < 22.
	;
	lda	r12, hirrr$m_irq4(r31)	; Get the timer mask
 	and	r12, r13, r12		; Was it the timer interrupt?
	bne	r12, hw_timer		; Yes, handle it

	;
	; Handle those interrupts which are enabled if IPL < 20.
	;
	lda	r12, hirrr$m_irq2(r31)	; Get the SIO mask
	and	r12, r13, r12		; Was it the SIO interrupt?
	bne	r12, hw_sio		; Yes, handle it

	br	r31, dismiss_interrupt	; Else, just dismiss this interrupt

	.endc

	.if ne	k2_system

.sbttl	K2 Hardware Interrupt Handler
;----------------------------------------------------------------------
;
; K2 Hardware Interrupt Handler
;
;	The order for parsing interrupts is IRQ3, IRQ0, IRQ5,
;	performance counters, IRQ4, IRQ1 and IRQ2.
;
; INPUT PARAMETERS:
;
;	Reg	Usage
;	r13	HIRR masked with HIER.
;	r14	unchanged - 2 to denote we got a HW interrupt.
;
; r12-r15 are saved in pt12-pt15. r12,r14-r15 can be used as scratch registers.
;
; OUTPUT REGISTERS:
;
;	Reg	Usage
;	r13	SCB vector value
;	r14	new value of r4 on exit
;	r15	new IPL
;
; FUNCTION DESCRIPTION:
;
;	Parse the HIRR value passed in r13 to handle the highest
;	priority pending interrupt.
;
;	IRQ0 - EPIC interrupts (IPL 31)
;
;		 1. Check the EPIC DCSR for the error source and set ID.
;		 2. Build a machine check log.
;		 3. Build a stack frame.
;		 4. Vector through offset 670 in the SCB.
;
;	IRQ1 - PCI interrupt (accelerator mode) (IPL20)
;
;		1. Read cfg_reg<15:0>
;		2. If cfg_reg<15>=0 - fatal error
;		3. Locate PCI slot from cfg_reg<9:6>
;		4. Read int_reg and locate int source
;		5. vector through offsets 900 to CF0 in the SCB
;
;	IRQ2 - SIO ISA Device interrupts (IPL 20)
;
;		 1. iAck the 82378 PIC to detect the source.
;		 2. Dismiss specific interrupt.
;		 3. Build a stack frame.
;		 4. Restore r12 - r15.
;		 5. Vector through offsets 800 to 8F0 in the SCB.
;
;	       This interrupt supports all devices on ISA.
;
;		IRQ0	unused 
;		IRQ1	Keyboard
;		IRQ2	(chains interrupt from slave PIC)
;		IRQ3	National 87303 COM2
;		IRQ4	National 87303 COM1
;		IRQ5	ISA option interrupt
;		IRQ6	National 87303 floppy disk controller
;		IRQ7	National 87303 Parallel port
;		IRQ8	Unused 
;		IRQ9	ISA option interrupt
;		IRQ10	ISA option interrupt
;		IRQ11	ISA option interrupt
;		IRQ12	16-bit ISA Mouse 
;		IRQ13	Unused 
;		IRQ14	ISA option interrupt
;		IRQ15	ISA option interrupt
;
;	IRQ3 - SIO NMI/HALT/watchdog and server MCHKs (IPL 31)
;
;		 1. Check the server management regs, set ID.
;		 2. Check the SIO NMI regs, set ID.
;		 3. If neither then HALT.
;                4. Else, Build a machine check log.
;                5. Build a stack frame.
;                6. Vector through offset 670 in the SCB 
;
;	IRQ4 - Real Time Clock interrupt (IPL 22)
;
;		 1. Dismiss interrupt.
;		 2. Build a stack frame.
;		 3. Restore r12 - r15.
;		 4. Vector through offset 600 in the SCB.
;
;	IRQ5 - Watchdog and server interrupts (IPL 29)
;
;		 1. Check the watchdog reg interrupt.
;		 2. If set, clear interrupt and build stack frame.
;		 3. Vector through offset D00 in the SCB.
;		 4. Else, check the server management reg interrupts.
;                5. If either set, clear interrupt and build frame.
;		 6. Vector through D10 (temp fail), D20 (temp OK) or D30 (fan fail).
;		 7. Else, check the server management psu interrupts.
;                8. If either set, clear interrupt and build frame.
;		 9. Vector through D40 (psu1 fail) or D50 (psu2 fail).
;
;		10. If none of the above, dismiss interrupt.
;
;----------------------------------------------------------------------

devipl = 20
halt_irq = hirrr$v_irq3
	;
	; Handle those interrupts which are enabled if IPL<= 31.
	;
	lda	r12, hirrr$m_irq3(r31)	; Get the system event mask
 	and	r12, r13, r12		; Was it the system event interrupt?
	bne	r12, k2_check_nmi	; yes, go check the source

	;
	; Handle those interrupts which are enabled if IPL <= 31.
	;
	; CHECK THIS COMPLETES PROPERLY FOR K2.
	;
	lda	r12, hirrr$m_irq0(r31)	; Get AIO error mask
 	and	r12, r13, r12		; Was it the EPIC error interrupt?
	bne	r12, hw_error		; Yes, handle it

	;
	; Handle those interrupts which are always enabled if IPL < 31.
	;
	lda	r12, hirrr$m_irq5(r31)	; Get wdog/server error mask
 	and	r12, r13, r12		; Was it that interrupt?
	bne	r12, k2_wd_int		; Yes, handle it

	;
	; Handle the performance monitoring stuff.
	;
	perfmon_support1 == 1

	lda	r12, hirrr$m_pc0!hirrr$m_pc1(r31) ; Get PC bits
	and	r13, r12, r15		; Are any set?
	bne	r15, HW_PERF		; Yep, go look at them

	;
	; Handle those interrupts which are enabled if IPL < 22.
	;
	lda	r12, hirrr$m_irq4(r31)	; Get the timer mask
 	and	r12, r13, r12		; Was it the timer interrupt?
	bne	r12, hw_timer		; Yes, handle it

	;
	; Handle those interrupts which are enabled if IPL < 20.
	;
	lda	r12, hirrr$m_irq1(r31)	; Get the SIO mask
	and	r12, r13, r12		; Was it the SIO interrupt?
	bne	r12, k2_pci		; Yes, handle it

	;
	; Handle those interrupts which are enabled if IPL < 20.
	;
	lda	r12, hirrr$m_irq2(r31)	; Get the SIO mask
	and	r12, r13, r12		; Was it the SIO interrupt?
	bne	r12, hw_sio		; Yes, handle it
	br	r31, dismiss_interrupt	; Else, just dismiss this interrupt
;+
;
; PCI NMI service code for K2 CPU.
;
; algorithm :-
;
; 1. Check for CPU fan fail.
; 2. Check for system temp fail.
; 3. Check for SIO PCI/ISA bus NMIs, error id = 20D 
; 4. If none of the above, assume HALT.
;
; Entry point - First check the CPU fan fail.
;-
k2_check_nmi:
	in_word	<k2$w_management>, r14	;
	and	r14, ^x40, r15		; SNMIs masked ?
	bne	r15, k2_check_sio	; yes, try SIO NMIs
	and	r14, ^x10, r15		; CPU fan fail ?
	beq	r15, k2_check_temp	; no, try temperature fail
;
; CPU fan fail, mask NMIs, set ID and dispatch
;
	lda	r15, management_init(r31)
	and	r15, r14, r14		; Maintain ints, masks and POFF
	bis	r14, ^x40, r14		; Set NMI mask
	out_word <k2$w_management>, r14	; 
	lda	r15, mchk$c_Fan1Fail(r31); Load reason for MCHK.
        br      r31, build_log
k2_check_temp:
	and	r14, ^x08, r15		; Temperature fail ?
	beq	r15, k2_check_sio	; no, try SIO NMIs
;
; System temperature fail, mask NMIs, set ID and dispatch
;
	lda	r15, management_init(r31)
	and	r15, r14, r14		; Maintain ints, masks and POFF
	bis	r14, ^x40, r14		; Set NMI mask
	out_word <k2$w_management>, r14;
	lda	r15, mchk$c_TempFail(r31); Load reason for MCHK.
        br      r31, build_log
;
; Check the SIO NMI sources and dispatch to it's handler or HALT
; handler code.
;
k2_check_sio:
        in      <sio$b_nmisc>, r12	; Get the contents of the NMISC
	srl	r12, ^x06, r13		; IOCHK status bit in LSB
	blbc	r13, try_serr
	srl	r12, ^x03, r13		; IOCHK enable bit in LSB
	blbc	r13, hw_nmi_error
try_serr:
	srl	r12, ^x07, r13		; SERR status bit in LSB
	blbc	r13, k2_halt
	srl	r12, ^x02, r13		; SERR enable bit in LSB
	blbc	r13, hw_nmi_error
k2_halt:
	br	r31, hw_check_halt	; go process a HALT
;+
;
; Watchdog and server management interrupt service code for K2 CPU.
;
; algorithm :-
;
; 1. Check for Watchdog timer1 interrupt.
; 2. Check for CPU temp fail interrupt.
; 3. Check for system fan fail interrupt.
; 4. If none of the above, dismiss interrupt.
;
; Entry point - First check the Watchdog timer.
;
;-
k2_wd_int:
	in_word	<k2$w_watchdog>, r14	;
	and	r14, ^x40, r15		; Watchdog enable ?
	beq	r15, k2_check_man	; no, try server management ints
;
; Check the interrupt bit. If set, need to clear the interrupt source.
;
	lda	r15, ^x200(r31)
	and	r14, r15, r15		; Watchdog interrupt ?
	beq	r15, k2_check_man	; no, try server management ints
	lda	r13, ^x100(r31)		; yes, don't write 1 to wphas
	bic	r14, r13, r14
	out_word <k2$w_watchdog>, r14	; yes, write WINT bit with 1
	bic	r14, r15, r14		; clear WINT bit
	out_word <k2$w_watchdog>, r14	; write WINT again to clear interrupt
;
; Watchdog timer1 interrupt, set IPL and vector and dispatch
; through vector D00H. IPL is 29.
;
	lda	r15, 29(r31)		; IPL to 29 (?)
	lda	r13, ^xD00(r31)		; SCB vector to D00
        br      r31, complete_interrupt
;
; Not watchdog, try server management interrupt.
;
k2_check_man:
	in_word	<k2$w_management>, r14	;
	and	r14, ^x20, r15		; SINTs masked ?
	bne	r15, k2_check_psu	; yes, check PSU ints
	and	r14, ^x02, r15		; CPU temp fail int ?
	beq	r15, k2_check_tmpok	; no, try temp OK int.
;
; Cpu temperature interrupt, set IPL and vector and dispatch
; through vector D10H. IPL is 29
;
	lda	r15, management_init(r31)
	and	r15, r14, r14		; Maintain ints, masks and POFF 
	bis	r14, ^x02, r14		; Set SINT2 bit
	out_word <k2$w_management>, r14	; Write to reg
	bic	r14, ^x02, r14		; Clear SINT2 bit
	out_word <k2$w_management>, r14	; Write to clear interrupt
	lda	r15, 29(r31)		; IPL to 29 (?)
	lda	r13, ^xD10(r31)		; SCB vector to D10
        br      r31, complete_interrupt
k2_check_tmpok:
	and	r14, ^x01, r15		; CPU temp OK int ?
	beq	r15, k2_check_fan	; no, try fan fail int.
;
; Cpu temperature OK interrupt, set IPL and vector and dispatch
; through vector D20H. IPL is 29.
;
	lda	r15, management_init(r31)
	and	r15, r14, r14		; Maintain ints, masks and POFF 
	bis	r14, ^x01, r14		; Set SINT1 bit
	out_word <k2$w_management>, r14	; Write to reg
	bic	r14, ^x01, r14		; Clear SINT1 bit
	out_word <k2$w_management>, r14	; Write to clear interrupt
	lda	r15, 29(r31)		; IPL to 29 (?)
	lda	r13, ^xD20(r31)		; SCB vector to D20
        br      r31, complete_interrupt
k2_check_fan:
	and	r14, ^x04, r15		; System fan fail ?
	beq	r15, k2_check_psu	; no, try PSU interrupts
;
; System fan interrupt, set IPL and vector and dispatch
; through vector D30H. IPL is 29.
;
	lda	r15, management_init(r31)
	and	r15, r14, r14		; Maintain ints, masks and POFF 
	bis	r14, ^x04, r14		; Set SINT3 bit
	out_word <k2$w_management>, r14	; Write to reg
	bic	r14, ^x04, r14		; Clear SINT3 bit
	out_word <k2$w_management>, r14	; Write to clear interrupt
	lda	r15, 29(r31)		; IPL to 29 (?)
	lda	r13, ^xD30(r31)		; SCB vector to D30
        br      r31, complete_interrupt
;
; Check for one of the PSU fail interrupts.
;
k2_check_psu:
	lda	r15, ^x100(r31)
	and	r14, r15, r15		; PSU ints masked ?
	bne	r15, dismiss_interrupt	; yes, dismiss interrupt
	lda	r15, ^x200(r31)
	and	r14, r15, r15		; PSU1 fail int ?
	beq	r15, k2_check_psu2	; no, try PSU2 int.
;
; PSU one fail interrupt, set IPL and vector and dispatch
; through vector D40H. IPL is 29.
;
	lda	r15, management_init(r31)
	and	r15, r14, r14		; Maintain ints, masks and POFF 
	lda	r15, ^x200(r31)
	bis	r14, r15, r14		; Set PSU1 bit
	out_word <k2$w_management>, r14	; Write to reg
	bic	r14, r15, r14		; Clear PSU1 bit
	out_word <k2$w_management>, r14	; Write to clear interrupt
	lda	r15, 29(r31)		; IPL to 29 (?)
	lda	r13, ^xD40(r31)		; SCB vector to D40
        br      r31, complete_interrupt
k2_check_psu2:
	lda	r15, ^x400(r31)
	and	r14, r15, r15		; PSU2 fail int ?
	beq	r15, dismiss_interrupt	; no, dismiss int
;
; PSU two fail interrupt, set IPL and vector and dispatch
; through vector D50H. IPL is 29.
;
	lda	r15, management_init(r31)
	and	r15, r14, r14		; Maintain ints, masks and POFF 
	lda	r15, ^x400(r31)
	bis	r14, r15, r14		; Set PSU2 bit
	out_word <k2$w_management>, r14	; Write to reg
	bic	r14, r15, r14		; Clear PSU2 bit
	out_word <k2$w_management>, r14	; Write to clear interrupt
	lda	r15, 29(r31)		; IPL to 29 (?)
	lda	r13, ^xD50(r31)		; SCB vector
        br      r31, complete_interrupt
;
; PCI interrupt service code for K2 interrupt accelerator.
;
; assumptions :-
;
; 1. Int regs are at 0510 to 0540.
; 2. In MSKEN mode, ie all int status bits are masked.
; 3. Slot interrupt reg<15:4> read as zero.
; 4. PCI has device IPL.
;
; Entry point - First check the mode is accelerator.
;
; **********************************************************************
; **********************************************************************
; ***************** TAKE OUT MB INSTRUCTIONS DURING DEBUG **************
; **********************************************************************
; **********************************************************************
;
k2_pci:
	in_word	<k2$l_int_conf>, r14	; Read the interrupt config reg
	srl	r14, 15, r15		; Mode bit in LSB
	blbs	r15, accel_pci		; In accelerator mode, continue

	halt				; In PICMG mode - hardware error
;
; Now check if we have to manually mask the slot interrupt bits.
;
accel_pci:
	srl	r14, 13, r15		; MSKEN bit in LSB
	blbs	r15, unmsk_chk		; In msken mode, continue
;
; Require to manually mask the slot interrupts.
;
	srl	r14, 6, r15
	and	r15, ^xf, r15
	bic	r14, r15, r14
;
; Now check which slot has an active interrupt, start at slot 1.
; Create the reg address and base SCB vector for this slot.
;
unmsk_chk:
	lda	r15, ^x0510(r31)	; Slot 1 Int reg addr
	lda	r12, 4(r31)		; Bits to check
	lda	r13, ^x900(r31)		; Base vector for slot 1
next_int:
	blbs	r14, read_int		; Interrupt active for this slot
	lda	r15, 4(r15)		; increment interrupt reg addr
	lda	r13, ^x100(r13)		; increment base vector
	lda	r12, -1(r12)		; decrement bits to check
	srl	r14, 1, r14		; next bit
	bne	r12, next_int		; check for all bits done

	br	r31, dismiss_interrupt	; Done, dismiss this interrupt
;
; Before reading the interrupt register we need to check if manual
; masking is required. This is true if the MSKEN bit is clear.
;
read_int:
	addl	r12, #9, r12
	srl	r14, r12, r14
	blbc	r14, read_masked
;
; Need to work out if this device is a slot or a bridge.
; Check the CFG bit for this slot and set R12 to 4 (slot) or
; 16 (bridge) bits to check. The CFG bits are in the high LW of
; the config register. These bits never change. The reg is read
; once and saved here to lower interrupt latency.
;
	br	r14, chk_cfg
	.long	0
chk_cfg:
	ldl/p	r12, (r14)
	mb
	zapnot	r12, 3, r12
	bne	r12, do_cfg
;
; Need to read the config reg high word and save it.
;
	lda	r12, io_base(r31)
	sll	r12, <28-5>, r12
	lda	r12, ^x502(r12)
        sll     r12, 5, r12
	lda	r12, 8(r12)
        ldl/p   r12, (r12)
	mb
	srl	r12, 16, r12
	zapnot	r12, 3, r12
	stl/p	r12, (r14)
	mb
;
; Now check the CFG bit for the interrupting slot.
; First calculate whcih slot to read from it's interrupt
; register address.
;
do_cfg:
	srl	r15, 2, r14
	and	r14, ^x3, r14
;
; Now test the bit.
;
	srl	r12, r14, r12
	blbs	r12, k2_bridge
	lda	r12, 4(r31)
	br	r31, do_read
k2_bridge:
	lda	r12, 16(r31)
;
; The address of the interrupt register for the interrupting slot is
; in R15, read the status bits from this reg.
;
do_read:
	lda	r14, io_base(r31)	; Load I/O base address.
	sll	r14, <28-5>, r14
	bis	r14, r15, r14		; Add in port address
        sll     r14, 5, r14		; Shift it into correct position.
	lda	r14, ^x8(r14)		; make it a word operation
        ldl/p   r14, (r14)		; Read the data from the port.
	mb
	br	r31, next_bit		; Check for the interrupt source
;
; Had to include this code section twice due to lack of
; available registers.
; Need to work out if this device is a slot or a bridge.
; Check the CFG bit for this slot and set R12 to 4 (slot) or
; 16 (bridge) bits to check. The CFG bits are in the high LW of
; the config register. These bits never change. The reg is read
; once and saved here to lower interrupt latency.
;
read_masked:
	br	r14, msk_chk_cfg
	.long	0
msk_chk_cfg:
	ldl/p	r12, (r14)
	mb
	zapnot	r12, 3, r12
	bne	r12, msk_do_cfg
;
; Need to read the config reg high word and save it.
;
	lda	r12, io_base(r31)
	sll	r12, <28-5>, r12
	lda	r12, ^x502(r12)
        sll     r12, 5, r12
	lda	r12, 8(r12)
        ldl/p   r12, (r12)
	mb
	srl	r12, 16, r12
	zapnot	r12, 3, r12
	stl/p	r12, (r14)
	mb
;
; Now check the CFG bit for the interrupting slot.
; First calculate whcih slot to read from it's interrupt
; register address.
;
msk_do_cfg:
	srl	r15, 2, r14
	and	r14, ^x3, r14
;
; Now test the bit.
;
	srl	r12, r14, r12
	blbs	r12, msk_k2_bridge
	lda	r12, 4(r31)
	br	r31, msk_do_read
msk_k2_bridge:
	lda	r12, 16(r31)
;
; The address of the interrupt register for the interrupting slot is
; in R15, read all 32 bits of the interrupt reg.
;
msk_do_read:
	lda	r14, io_base(r31)	; Load I/O base address.
	sll	r14, <28-5>, r14
	bis	r14, r15, r14		; Add in port address
        sll     r14, 5, r14		; Shift it into correct position.
	lda	r14, ^x18(r14)		; make it a LW operation
        ldl/p   r14, (r14)		; Read the interrupt reg
	mb
;
; Now manually mask the status.
;
	srl	r14, #16, r15		; Put mask in r15 low word
	zap	r15, #3, r15		; clear r15[63:16]
	bic	r14, r15, r14		; Status = (status.~mask)
;
; Now check which slot source is active, start at slot1_inta.
; R12 contains number of bits to test.
;
next_bit:
	blbs	r14, pci_ipl		; Interrupt active
	lda	r13, ^x10(r13)		; increment SCB vector
	lda	r12, -1(r12)		; decrement bits to check
	srl	r14, 1, r14		; next bit
	bne	r12, next_bit		; check for all bits done

	br	r31, dismiss_interrupt	; Done, dismiss this interrupt
;
; SCB vector set up in R13. Set up IPL and dispatch
;
pci_ipl:
	bis	r31, #devipl, r15	; Set IPL to 20.
	br	r31, complete_interrupt ; Build stack frame and dispatch

	.endc


	.if ne	cortex_system

.sbttl	Cortex Hardware Interrupt Handler
;----------------------------------------------------------------------
;
; Cortex Hardware Interrupt Handler
;
;	The order for parsing interrupts is IRQ5 (ipl31), IRQ4 (ipl31), 
;	Performance counters (ipl29), IRQ3 (ipl23), IRQ2 (ipl22) IRQ1 (ipl21), 
;	and IRQ0 (ipl20).
;
; INPUT PARAMETERS:
;
;	Reg	Usage
;	r13	HIRR masked with HIER.
;	r14	unchanged - 2 to denote we got a HW interrupt.
;
; r12-r15 are saved in pt12-pt15. r12,r14-r15 can be used as scratch registers.
;
; OUTPUT REGISTERS:
;
;	Reg	Usage
;	r13	SCB vector value
;	r14	new value of r4 on exit
;	r15	new IPL
;
; FUNCTION DESCRIPTION:
;
;	Parse the HIRR value passed in r13 to handle the highest
;	priority pending interrupt.
;
;	IRQ5 - EPIC sys_irq interrupts (IPL 31)
;
;		 1. Check the EPIC DCSR for the error source and set mchk code.
;		 2. Build a machine check log.
;		 3. Build a stack frame.
;		 4. Vector through offset 670 in the SCB.
;
;	IRQ4 - SIO NMI/HALT/watchdog and server MCHKs (IPL 31)
;
;		 1. Check the SIO NMI regs whether mchk, set ID.
;		 2. If not mchk cause (serr) then HALT.
;                3. Else, Build a machine check log.
;                4. Build a stack frame.
;                5. Vector through offset 670 in the SCB 
;
;	IRQ3 - VME_RESET, VME_IRQ7, VIC_IPL0 (vic errors), TMR_IRQ (realtime
;		timers).  (IPL23)
;
;		1. Read ^x802, choose between VMERESET, VME_IPL6_INT, TMR_IRQ
;		2. If VME_IPL6_INT,then do vme iack to fetch vector.
;		3. otherwise, vector through ^x880 fro vmereset and ^x9A0 for
;		   interval timer.
;
;	IRQ2 - 1ms Real Time Clock interrupt, and VIP Status (IPL 22)
;
;		 1. Read ^x802, if VME_IPL5_INT then do vme iack to get vector.
;		 2. Otherwise check for heartbeat timer (vector = ^x600)
;		 3. Restore r12 - r15 and continue.
;
;	IRQ1 - VME_IRQ<6:4>, PCM SLOTS<1:0> IRQ<A> (IPL20)
;
;		1. Read ^x803, if VME_IPL4_INT, then fetch vector via vme iack.
;		2. Otherwise choose between PMC0_IRQA (^X980) and 
;		   PMC1_IRQA (^990)
;		3. Restore r12 - r15 and continue.
;
;	IRQ0 - SCSI, ETHERNET, PMC SLOTS<1:0> IRQ<D,C,B>, VME_IRQ<3:1>,
;		SIO ISA Device interrupts, and, VME IACK. (IPL 20)
;
;		 1. Read ^x804, if VME_IPL3_INT then fetch vector via vme iack.
;		 2. Else if SIO_INT then do pci_iack from SIO and vector 
;		    through ^x800-8F0. Note however that only a few of the
;		    vectors in this range are possible (COM2=^x830,COM1=^x840,
;		    PAR_PORT=^x850 or ^x870, keyboard=^x810, mouse= ^x8C0)
;		 2. Else loop through bits, and vector through ^x900-950.
;		 3. If no bits set, read ^x805 to check remaining ipl3 sources
;		    PMC0_IRQD (^x960), PMC1_IRQD (^x970)
;		 4. Build a stack frame.
;		 5. Restore r12 - r15.
;
;
;
;----------------------------------------------------------------------

devipl = 20
halt_irq = hirrr$v_irq4
	;
	; Handle those interrupts which are enabled if IPL<= 31.
	;
	lda	r12, hirrr$m_irq4(r31)	; Get the NMI interrupt mask
 	and	r12, r13, r12		; Was it the NMI interrupt?
	bne	r12, cortex_check_nmi	; yes, go check the source

	;
	; Handle those interrupts which are enabled if IPL <= 31.
	;
	; 
	;
	lda	r12, hirrr$m_irq5(r31)	; Get EPIC sysirq error mask
 	and	r12, r13, r12		; Was it the EPIC error interrupt?
	bne	r12, hw_error		; Yes, handle it

	;              
	; Handle the performance monitoring stuff.
	;
	perfmon_support1 == 1

	lda	r12, hirrr$m_pc0!hirrr$m_pc1(r31) ; Get PC bits
	and	r13, r12, r15		; Are any set?
	bne	r15, HW_PERF		; Yep, go look at them


	; Handle those interrupts which are always enabled if IPL < 23.
	;
	; IRQ3 - VME_RESET, VME_IRQ7, VIC_IPL0 (vic errors), TMR_IRQ (realtime
	; timers).  (IPL23)	
		;
	lda	r12, hirrr$m_irq3(r31)	; Get high-priority device int mask.
 	and	r12, r13, r12		; Was it that interrupt?
	bne	r12, cortex_ipl23_dev_int	; Yes, handle it


	;
	; Handle those interrupts which are enabled if IPL < 22.
	;
	lda	r12, hirrr$m_irq2(r31)	; Get ipl22 int line.
 	and	r12, r13, r12		; Was it an ipl22 interrupt?
	bne	r12, cortex_ipl22_dev_int ; Yes, handle it

	;
	; Handle those interrupts which are enabled if IPL < 21.
	;
	lda	r12, hirrr$m_irq1(r31)	; Get ipl21 int line.
	and	r12, r13, r12		; Was it an ipl21 interrupt?
	bne	r12, cortex_ipl21_dev_int ; Yes, handle it

	;
	; Handle those interrupts which are enabled if IPL < 20.
	;
	lda	r12, hirrr$m_irq0(r31)	; Get ipl20 int line.
	and	r12, r13, r12		; Was it an ipl20 interrupt?
	bne	r12, cortex_ipl20_dev_int ; Yes, handle it


	br	r31, dismiss_interrupt	; Else, just dismiss this interrupt

;+
;
; NMI service code for Cortex
;
; Note that this diverges from the EB platforms in that IOCHK is considered
; a HALT source on Cortex, but the EB platforms behave more like a PC and 
; consider IOCHK a hardware error and do a machine check.
; algorithm :-
;
; 1. Check for IOCHK (HALT switch or Watchdog).
;	disable IOCHK to avoid inf. loop, then 
; 2. Check for system temp fail.
; 3. Check for SIO PCI/ISA bus NMIs, error id = 20D 
; 4. If none of the above, assume HALT.
;
;-
cortex_check_nmi:
   ;-------------------------------------------
   ; NMI interrupt handler, stolen from Medulla. 
   ;-------------------------------------------
	;
	; Determine the interrupt source, either
	; a HALT switch, Watchdog timeout, or
	; PCI SERR.
	;
	medu$read_sio	SIO$B_NMI_CSR	; SERR/IOCHK status to r13
	and	r13, #^x40, r14		; IOCHK halt switch/wdog ints?
	beq	r14, 20$		; br if no
	;
	; HALT from switch or watchdog.  Disable
	; int so we don't get an infinite loop.
	; If wdog, reset-reason register tells the story.
	;
	medu$write_sio	<^x08>, SIO$B_NMI_CSR	; disable/clr IOCHK int
	medu$pci_addr	MEDU$MOD_RSTREASON_REG	; addr to r12
	ldq/p   r12, (r12) 			; reset reason reg
	srl	r12, <<MEDU$MOD_RSTREASON_REG & ^x3>*8>, r12
						; move to low byte lane.	
	blbc	r12, 10$			; br if not wdog
	;
	; Watchdog halt, we simply increment a count, then dismiss
	; the interrupt - for watchdog diagnostic support (the
	; console can't handle a true NMI).
	;
	sget_addr r12, pal$impure_base, r31		; Base of scratch area
	ldq/p	r13, medu$q_wdog_ints_count(r12) 	; get current count
	addq	r13, #^x1, r13				; increment
	stq/p	r13, medu$q_wdog_ints_count(r12) 	; store new count 
        br      r31, DISMISS_INTERRUPT		; Forget the interrupt ever
						; happened.
10$:
	;
	; Halt switch, we should halt the console
	;
	mf	r12, pt12		; restore regs saved at INT entry
	mf	r13, pt13
	mf	r14, pt14
	mf	r15, pt15
	lda	r0, HLT$C_HW_HALT(r31)		; Set halt code to hw halt
	br	r31, PAL$ENTER_CONSOLE		; Enter the console
20$:
	and	r13, #^x80, r14			; PCI SERR ints?
	beq	r14, 30$			; br if spurious interrupt
	;
	; Is a PCI SERR, so convert this to a MCHK
	;
	medu$read_sio	SIO$B_NMI_CSR		; SERR/IOCHK status to r13
	or	r13, #^x04, r13			; preserve IOCHK state
	medu$write_sio	r13, SIO$B_NMI_CSR	; clear PCI SERR int
	medu$read_sio	SIO$B_NMI_CSR		; SERR/IOCHK status to r13
	and	r13, #^x08, r13			; preserve IOCHK state
	medu$write_sio	r13, SIO$B_NMI_CSR	; reenable PCI SERR int
	; now emulate code to set up and go to mchk
	mf	r12, pt12		; restore regs saved at INT entry
	mf	r13, pt13
	mf	r14, pt14
	mf	r15, pt15
	mt	r31, alt_mode		; make sure altmode is KERNEL mode
	mt	r0, pt0				; save r0 per mchk path
	mt	r1, pt1				; save r1 per mchk path
	mt	r3, pt3				; save r3 per mchk path
	lda	r3, mchk$c_pciserr(r31)		; set error code
	br	r31, cortex_build_error_frame	; dispatch machine check
30$:
        ;
        ;       ... it should have been one of the interrupts above.
        ;
        ;
        ; Dismiss the interrupt.
        ;
        br      r31, DISMISS_INTERRUPT


;; Cortex Interrupt handler for hi priority device interrupts.  These include
;; VME_RESET, VME_IRQ7, VIC_IPL0 (vic errors), and TMR_IRQ (realtime timers). 
;; The general algorithm for these interrupts is to read the Xilinx register
;; corresponding to this ipl.  First check for VME subsystem interrupts and 
;; if so do an IRR read to the VIP and dispatch the vector ala Medulla.  
;; If not a vme interrupt, then check for VME_RESET, and then TMR_IRQ, 
;; and dispatch through the appropriate vector.

cortex_ipl23_dev_int:
	sget_addr r12, pal$impure_base, r31	; Get base of PAL scratch area.
	ldq/p	r13, cortex$q_enabled_ints_mask(r12)
					; Read the current PCI interrupt mask.
	srl	r13, #CORTEX$V_IRQ3_SHIFT, r13
					; Leaves VME_RESET in bit 0.

	in	<^x802>, r14		; Get a byte of pending int status.
	and	r14, #^xf, r14		; Clear all but ipl23 ints.
	and	r14, r13, r14		; Apply the current PCI interrupt mask.

	; R14 now contains 1's only where a true pending interrupt exists, as
	; follows:
	;    3 2 1 0       
	;   +-+-+-+-+   
	;   | | | | |   ^x802    (cpu_irq3) 
	;   +-+-+-+-+    
	;    ^ ^ ^ ^     
	;    | | | |     
	;    | | | `---  VME_RESET (directly wired to backplane) (^x880)
	;    | | `-----  VME_IPL6_INT (vmeirq7,vip/c err/sts) (do VME IACK) 
	;    | `-------  TMR_IRQ interval timer (^x9A0)     
	;    `---------  RT_PERIODIC  (^x9B0)        
      

	; Do we really have an interrupt?
	beq	r14, dismiss_interrupt	; If not, then passive release.

	; First test for VME_RESET
	blbc	r14, 10$		; Continue if not VME_RESET.
        ;
        ; We got a VME_RESET, so handle it here...
	; 	Mask lower level ints
	; 	Set the vector, IPL and then go complete the interrupt
	;
	lda	r13, ^x880(r31)	        	; Set SCB vector
	bis 	r31, #23, r15		        ; Set IPL
	br 	r31, COMPLETE_INTERRUPT 	; Go build stack frame and exit
	

; Check for VME subsystem interrupt at this ipl...
10$:
	srl	r14, #1, r14		; Check vme subsystem interrupt.
	blbs	r14, cortex_service_vme_int	; Service VME interrupt.

; Check for TMR_IRQ and the periodic rt interrupt.  

	srl	r14, #1, r14		; Check TMR IRQ.
	lda	r13, ^x9A0(r31)		; tmr_irq=9A0. 
	blbs	r14, 30$		; dispatch.

	srl	r14, #1, r14		; Check for periodic rt timer int
	addq	r13, #16, r13		; Bump vector to 0x9b0.	
	blbc	r14, dismiss_interrupt	; (passive release)

	bis	r13, r13, r15		; Save r13 (OUT uses r12, r13)
	out	<MEDU$MOD_CONFIG_REG>, 1; Clear down the interrupt.
	bis	r15, r15, r13		; restore vector.

30$:
	or 	r31, #23, r15		; Set IPL
	br 	r31, COMPLETE_INTERRUPT	; Go build stack frame and exit


;;
;; IRQ2 was pulled at the CPU.  Handle the IPL22 device interrupt, which was
;; either the 1ms heartbeat timer or else an IPL22 vme interrupt.
cortex_ipl22_dev_int:
	sget_addr r12, pal$impure_base, r31	; Get base of PAL scratch area.
	ldq/p	r13, cortex$q_enabled_ints_mask(r12)
					; Read the current PCI interrupt mask.
	srl	r13, #CORTEX$V_IRQ2_SHIFT, r13

	in	<^x802>, r14		; Get a byte of pending int status.
	srl	r14, #4, r14		; Shift the two int sources to bit 0.
	and	r14, #^x3, r14		; Clear all but the two ipl22 ints.
	and	r14, r13, r14		; Apply the current PCI interrupt mask.

	; R14 now contains 1's only where a true pending interrupt exists, as
	; follows:
	;  7 6 5 4 3 2 1 0                                                      
	; +-+-+-+-+-+-+-+-+                                                     
	; | | | | | | | | |   r14    (ipl22 interrupts)                         
	; +-+-+-+-+-+-+-+-+                                                     
	;              ^ ^                                                      
	;              | |                                                      
	;              | `---  VME_IPL5_INT (Location Monitor) (do VME IACK)
	;              `-----  1ms Heartbeat Timer
	;                                                                      
	;                                            
      
	; Do we really have an interrupt?
	beq	r14, dismiss_interrupt	; If not, then passive release.

	; Check whether it was a VME subsystem interrupt...
	blbs	r14, cortex_service_vme_int	; If so, then fetch vector and dispatch.

	srl	r14, #1, r14		; Check interval timer int.
	blbc	r14, dismiss_interrupt	; Passive release if nothing.

	; We have a 1ms heartbeat timer interrupt.  Update SCC and vector.
	;
	; 	Update the SCC
	;
	rpcc	r13			; get cycle counter
	 or	r31, #1, r14		; get a 1
	mf	r12, pt10		; get SCC
	 sll	r14, #32, r14		; now a 100000000

	zap	r13, ^xf0, r13		; get low long of pcc
	 zap	r12, ^xf0, r15		; get low long of pcc
	zap	r12, ^x0f, r12		; get high long of SCC

	 subq	r13, r15, r15		; if pcc<31:0> le scc<31:0>
	cmovge	r15, r31, r14		; zero wrap, if wrap did not happen

	 addq	r12, r14, r12		; add wrapper to SCC
	or	r12, r13, r12		; merge
	 mt	r12, PT10		; update scc
	;

	lda	r13, ^x600(r31)		; Vector for 1ms heartbeat timer.
	bis	r31, #22, r15		; New IPL
	br	r31, complete_interrupt	; ...and dispatch.


;;
;; IRQ1 was pulled at the CPU.  Handle the IPL21 device interrupt, which was
;; either PMC0_IRQA, PMC1_IRQA, or else an IPL21 vme interrupt.
cortex_ipl21_dev_int:
	sget_addr r12, pal$impure_base, r31	; Get base of PAL scratch area.
	ldq/p	r13, cortex$q_enabled_ints_mask(r12)
					; Read the current PCI interrupt mask.
	srl	r13, #CORTEX$V_IRQ1_SHIFT, r13

	in	<^x803>, r14		; Get a byte of pending int status.
	and	r14, #^x7, r14		; Clear all but the three ipl21 ints.
	and	r14, r13, r14		; Apply the current PCI interrupt mask.

	; R14 now contains 1's only where a true pending interrupt exists, as
	; follows:
	;  7 6 5 4 3 2 1 0                                                      
	; +-+-+-+-+-+-+-+-+                                                     
	; | | | | | | | | |   r14    (ipl22 interrupts)                         
	; +-+-+-+-+-+-+-+-+                                                     
	;            ^ ^ ^                                                      
	;            | | |                                                      
	;            | | `---  VME_IPL4_INT (Location Monitor) (do VME IACK)
	;            | `-----  PMC0_IRQA    (^x980)
	;            `-------  PMC1_IRQA    (^x990)                            
	;                                            
      
	; Do we really have an interrupt?
	beq	r14, dismiss_interrupt	; If not, then passive release.

	; Check whether it was a VME subsystem interrupt...
	blbs	r14, cortex_service_vme_int	; If so, then fetch vector and dispatch.

	lda	r13, ^x970(r31)		; PMC0_IRQA=980, PMC1_IRQA=990
10$:	srl	r14, #1, r14		; Check PMC0_IRQA, then PMC1_IRQA.
	addq	r13, #16, r13		; Bump vector to 9A0, 9B0.
	beq	r14, dismiss_interrupt	; (passive release)
	blbc	r14, 10$		; (Second pass is for PMC1_IRQA).

	or 	r31, #21, r15		; Set IPL
	br 	r31, COMPLETE_INTERRUPT	; Go build stack frame and exit

;;
;; IRQ0 was pulled at the CPU.  Handle the IPL20 device interrupt, which was
;; SIO, ETHER, SCSI, PMCxIRQ<D,C,B> or else an IPL20 vme interrupt.
cortex_ipl20_dev_int:
	sget_addr r12, pal$impure_base, r31	; Get base of PAL scratch area.
	ldq/p	r13, cortex$q_enabled_ints_mask(r12)
					; Read the current PCI interrupt mask.
	srl	r13, #CORTEX$V_IRQ0_SHIFT, r13
					; Leaves VME_RESET in bit 0.

	in_word	<^x804>, r14		; Get a byte of pending int status.
	lda	r12, ^x3ff(r31)		; Bits 9:0 are valid.
	and	r12, r14, r14		; Clear all but the ten ipl20 ints.
	and	r14, r13, r14		; Apply the current PCI interrupt mask.

	; R14 now contains 1's only where a true pending interrupt exists, as
	; follows:

	;  9 8 7 6 5 4 3 2 1 0                                           
        ; +-+-+-+-+-+-+-+-+-+-+                                          
        ; | | | | | | | | | | | ^x804    (cpu_irq0, interrupting at ipl3)
        ; +-+-+-+-+-+-+-+-+-+-+                                          
        ;  ^ ^ ^ ^ ^ ^ ^ ^ ^ ^                                           
        ;  | | | | | | | | | |                                           
        ;  | | | | | | | | | `--- VME_IPL3_INT (vmeirq<3:1>(do vme iack) 
        ;  | | | | | | | | `----- SIO_INT     (do pci iack)  (^x8??)     
        ;  | | | | | | | `------- ETHER_IRQ   (^x900)                    
        ;  | | | | | | `--------- SCSI_IRQ    (^x910)                    
        ;  | | | | | `----------- PMC0_IRQB   (^x920)                    
        ;  | | | | `------------- PMC1_IRQB   (^x930)                    
        ;  | | | `--------------- PMC0_IRQC   (^x940)                    
        ;  | | `----------------- PMC1_IRQC   (^x950)                    
        ;  | `------------------- PMC0_IRQD   (^x960)           
        ;  `--------------------- PMC1_IRQD   (^x970)                
        ;                                   
        ;

	; Do we really have an interrupt?
	beq	r14, dismiss_interrupt	; If not, then passive release.

	; Check whether it was a VME subsystem interrupt...
	blbs	r14, cortex_service_vme_int	; If so, then fetch vector and dispatch.

	; Check whether it was an SIO interrupt from combo-chip or kb/mouse.
	srl	r14, #1, r14		; Check SIO bit.
	blbs	r14, cortex$service_sio_int	; If so, do iack and dispatch.
	
	; Now dispatch on which of the remaining ints it is.
	
	lda	r13, ^x8F0(r31)		; Its are 900-970.
10$:	srl	r14, #1, r14		; Check PMC0_IRQA, then PMC1_IRQA.
	addq	r13, #16, r13		; Bump vector to 9A0, 9B0.
	beq	r14, dismiss_interrupt	; (passive release)
	blbc	r14, 10$		; Keep looking...

	or 	r31, #20, r15		; Set IPL
	br 	r31, COMPLETE_INTERRUPT	; Go build stack frame and exit



;; Routine to service a pending interrupt coming from the ISA subsystem via
;; the SIO's PIC.  The scheme is simply to do an iack, multiply the vector
;; from the SIO by 16 and add to ^x800.  Simple.
cortex$service_sio_int:
	iack				; Acknowledge the PIC.
					; Vector of highest priority pending
					; ISA interrupt is returned in r14.
	and	r14, ^xFF, r14		; Clean vector to 8 bits.
	cmpeq	r14, ^x07, r13		; Check for passive release.
	bne	r13, cortex$hw_release	; If so, dismiss non-specific interrupt.
;
; Determine which of the two controllers the ISA interrupt came in 
; on and dismiss it accordingly.  If the interrupt is coming in on
; the slave controller (INT1) then we need to dismiss both the 
; interrupt on the slave, and also IR2 on the master (INT0).
; IR2 is used to cascade the two controllers together and is not
; available as an external pin.
;
cortex$service_pic:
	sll	r14, #^x04, r14		; Multiply by 16 for SCB base vector.
	lda	r13, ^x800(r14)		; SCB base vector + offset.
	bis	r31, #devipl, r15		; Set IPL to 21.

	br	r31, complete_interrupt ; Go build stack frame and exit...
;
; Passive release - dismiss non-specific interrupt and return.
;
.align	quad
cortex$hw_release:


	out	<^x20>, <^x40>, r13, r15	; select ocw2 - This is really a
						; nop but forces the next
						; operation to ocw2.
	out	<pic1+ocw3>, <^x0B>, r13, r15	; OCW3 - ISR select 

	in	<pic1+ocw3>, r13		; Read the ISR 

	srl	r13, #^x07, r13			; Get ISR<7> into low bit
	blbs	r13, cortex$service_pic		; If set, service IR7 interrupt
;
; Send non-specific EOI command to INT1 and INT0.
;
	out	<pic2+ocw2>, <^x20>, r13, r15
	out	<pic1+ocw2>, <^x20>, r13, r15

	br	r31, dismiss_interrupt

;;
;; Build the machine check logout frame ...stolen from eb platforms
;; and included here from clarity.
;;

build_log:
	mt	r0, pt0			; MCHK handler expects r0, r1
	mt	r1, pt1			; to be saved in pt0, pt1 and
	mt	r3, pt3			; reason for MCHK to be in r3.
	bis	r31, r15, r3
	stall	2
	mf	r12, pt12		; Restore scratch registers.
	mf	r13, pt13
	mf	r14, pt14
	mf	r15, pt15
	br	r31, mchk_log_known	; Go to common MCHK handler.


;; Routine to service a pending VME subsystem interrupt.  All VME interrupts,
;; with the exception of the VME_RESET interrupt are serviced here.
;; The algorithm is as follows:
;; 
;;	1. Read the VIP IRR register, which causes a local bus IACK to the VIC,
;;	   and returns the vector in bits <7:0> of the resulting longword and 
;;	   the ipl of the interrupt in bits <10:8>.
;;	2. Mask off the IPL, add 1xx0 to the vector.
;;	3. Set new IPL based on the IPL from the VIC.
;;	4. Dispatch.

cortex_service_vme_int:
	; We have an interrupt from the VME subsystem, fetch the vector from
	; the vip and complete.
	;
	;
	;	IACK to VME via IRR register read, which also
	;	returns the vector to us.
	;
	medu$pci_vme_addr VIP$B_IRR	; addr to r12
	bis	r12, #^x18, r12		; Set sparce space length to longword. 
	ldl/p   r13, (r12)		; IACK the Int and get ipl/vector
	;
	;	form SCB vector as 1000H + vector<<4	(to r13)
	;
	bis	r13, r13, r12		; (r12<10:8> contains ipl)
	srl	r12, #8, r12		; 
	and 	r12, #7, r12		; r12<2:0> = ipl of this vector.

	zapnot	r13, 1, r13		; clear all but vector byte
	beq	r13, dismiss_interrupt	; passive release
	sll	r13, 4, r13		; x16 to get SCB vector
	lda	r13, ^x1000(r13)	; form complete vector ^x1XX0
	;
	;	calculate VMS IPL from VIC ipl	(to r15)
	;
	mf	r14, pal_base
     	get_addr r14, <medu$q_vic_to_vms_ipl-pal$start>, r14
	s4addq	r12, r14, r14			; VIC ipl is index to VMS IPL
	ldl/p	r15, (r14)			; get VMS IPL
	br 	r31, COMPLETE_INTERRUPT	; Go build stack frame and exit
	
	.endc


	.if ne	mikasa_system 

.sbttl	Mikasa Hardware Interrupt Handler
;----------------------------------------------------------------------
;
; mikasa Hardware Interrupt Handler
;
;	The order for parsing interrupts is IRQ4, IRQ3, IRQ2
;	and IRQ0.  IRQ1 and IRQ5 are ignored for now.
;
; INPUT PARAMETERS:
;
;	Reg	Usage
;	r13	HIRR masked with HIER.
;	r14	unchanged - 2 to denote we got a HW interrupt.
;
; r12-r15 are saved in pt12-pt15. r12,r14-r15 can be used as scratch registers.
;
; OUTPUT REGISTERS:
;
;	Reg	Usage
;	r13	SCB vector value
;	r14	new value of r4 on exit
;	r15	new IPL
;
; FUNCTION DESCRIPTION:
;
;	Parse the HIRR value passed in r13 to handle the highest
;	priority pending interrupt.
;
;	IRQ0 - AIO interrupts (IPL 20)
;		 Not sure what to do here, so for now ...
;
;		 1. Build a stack frame.
;		 2. Restore r12 - r15.
;		 3. Vector through offset ??? in the SCB.
;
;	IRQ1 - Eisa I/O Interrupt (IPL 21)
;
;		 1. iAck the 82378IB PIC to detect the source.
;		 2. Dismiss specific interrupt.
;		 3. Build a stack frame.
;		 4. Restore r12 - r15.
;		 5. Vector through offset x^800 in the SCB.
;
;	       This interrupt supports all devices on ISA.
;
;		IR0	Interval timer
;		IR1	Keyboard
;		IR2	(chains interrupt from slave PIC)
;		IR3	8-bit ISA - National 87312 COM2
;		IR4	8-bit ISA - National 87312 COM1
;		IR5	8-bit ISA - National 87312 Parallel port (or IR7)
;		IR6	8-bit ISA - National 87312 floppy disk controller
;		IR7	8-bit ISA - National 87312 Parallel port (or IR5)
;		IR8	Unused (RTC internal to the SIO)
;		IR9	8-bit  ISA /PCI Ethernet/PCI SCSI
;		IR10	16-bit ISA /PCI Ethernet/PCI SCSI
;		IR11	16-bit ISA /PCI Ethernet/PCI SCSI
;		IR12	16-bit ISA Mouse 
;		IR13	Unused 
;		IR14	16-bit ISA
;		IR15	16-bit ISA /PCI Ethernet/PCI SCSI
;
;	IRQ2 - PCI I/O Device interrupts (IPL 21)
;
; IRQ2 handler code - IPL 21
;
; check for a device interrupt from PCI slot. The PCI interrupt
; register is located at 1.C000.0026 and the mask register is 
; located at 1.C000.0028. I need to verify this address, it
; may be the eisa address(so <<5). I have no priority of the
; bits which I check, I start at slot 0 and go up to the 810
; Interrupt vector = 900+ slot*16 
;
;		IRQ REG		VECTOR	Description
;		  bit		
;		   0		900	Slot 0 interrupt A
;		   1		910	Slot 0 interrupt B
;		   2		920	Slot 0 interrupt C
;		   3		930	Slot 0 interrupt D
;		   4		940	Slot 1 interrupt A
;		   5		950	Slot 1 interrupt B
;		   6		960	Slot 1 interrupt C
;		   7		970	Slot 1 interrupt D
;		   8		980	Slot 2 interrupt A
;		   9		990	Slot 2 interrupt B
;		   10		9A0	Slot 2 interrupt C
;		   11		9B0	Slot 2 interrupt D
;		   12		9C0	810 SCSI controller
;		   13		9D0	Power Supply Interrupt
;		   14		9E0	Temperature Warning
;		   15  		9F0	Unused	
;
;	IRQ3 - Non-Maskable interrupts (IPL 31)
;
;                1. Build a machine check log.
;                2. Build a stack frame.
;                3. Vector through offset ^x660 in the SCB 
;
;	IRQ4 - Real Time Clock interrupt (IPL 22)
;
;		 1. Dismiss interrupt.
;		 2. Build a stack frame.
;		 3. Restore r12 - r15.
;		 4. Vector through offset ^x600 in the SCB.
;
;	IRQ5 - HALT 
;
;----------------------------------------------------------------------
devipl = 20
halt_irq = hirrr$v_irq5
	;
	; Handle those interrupts which are always enabled.
	;
	lda	r12, hirrr$m_irq5(r31)	; Get the NIM error mask
 	and	r12, r13, r12		; Was it the NMI interrupt?
	bne	r12, hw_nmi_error	; nmi or utility bus

	;
	; Handle the performance monitoring stuff.
	;
	perfmon_support1 == 1

	lda	r12, hirrr$m_pc0!hirrr$m_pc1(r31) ; Get PC bits
	and	r13, r12, r15		; Are any set?
	bne	r15, HW_PERF		; Yep, go look at them

	;
	; Handle those interrupts which are enabled if IPL < 31.
	;
	lda	r12, hirrr$m_irq0(r31)	; Get AIO error mask
 	and	r12, r13, r12		; Was it the AIO error interrupt?
	bne	r12, hw_error	; Yes, handle it

	;
	; Handle those interrupts which are enabled if IPL < 22.
	;
	lda	r12, hirrr$m_irq4(r31)	; Get the timer mask
 	and	r12, r13, r12		; Was it the timer interrupt?


	.if ne enable_fan_fault_check		
	beq	r12, not_timer		; we do it this way so we can insert
					; the fan fail and hi temp logic

	in_word	<utility>, r14		; Utility Bits
	and	r14, <util$m_fan1fail ! -
		util$m_fan2fail>, r15	; see if fan faults.  Has to
					; be done this way because of a hardware
					; problem

	xor	r15, <util$m_fan1fail ! -
                util$m_fan2fail>, r15
		
	bne	r15, 1$			; do what needs to be done if fan fail

	and	r14, util$m_hitemp, r15
	beq	r15, hw_timer

1$:	mf	r15, pt25		; get the fan fault indicator.

	srl	r15, pt25$v_inhibit_fan_fault, r12	; check to see if it is
					; the first time in

	bne	r12, hw_timer		; just process the timer normally.

	bis	r31, 1, r12
	sll	r12, pt25$v_inhibit_fan_fault, r12 ; inhibit further operations

	bis	r12, r15, r15
	mt	r15, pt25		; restore the value
	br	r31, fan_or_hitemp	; don't forget r14 has the original
					; value from util read
;
; We get here because there is no timer interrupt pending.  This is only mikasa
; code.
; 

not_timer:

.if_false
	bne	r12, hw_timer		; go process timer if need be
.endc
	;
	; Handle those interrupts which are enabled if IPL < 20.
	;
	lda	r12, hirrr$m_irq2(r31)	; Get the PIO mask
	and	r12, r13, r12		; Was it the PIO interrupt?
	bne	r12, hw_pio		; Yes, handle it

	lda	r12, hirrr$m_irq1(r31)	; Get the SIO mask
	and	r12, r13, r12		; Was it the SIO interrupt?
	bne	r12, hw_sio		; Yes, handle it

	br	r31, dismiss_interrupt	; Else, just dismiss this interrupt

;
; PCI interrupt service dispatcher.
;

hw_pio:
	in_word	<irr>, r14			; Read the interrupt request register
	zap	r14, ^xfc, r14
	in_word	<imr>, r15			; Read the interrupt mask register
	zap	r15, ^xfc, r15
	bic	r15,r14,r14			; r15 AND (NOT r14) 

	beq	r14, hwint_end			; dismiss the interrupt - it
						; really didn't happen.
						; 

	bis	r31,r31,r15			; Clear to make sure
	bis	r31,r31,r12			; Clear to make sure
	lda	r12, 15(r31)			; Check for interrupt from each bit
	lda	r15,  1(r31)			; Check each slot 
20$:
	and 	r14,r15,r13			; Check the bit -->r13 (1=assert)
	bne	r13,30$				; Interrupt Request found...dispatch
	sll	r15,1,r15			; Shift Mask Check to next  slot 
	subq	r12,#1,r12			; Next Slot
	bne	r12,20$				; Check for next interrupt request
	
	halt					; Should NEVER get here

30$:
	bis	r31,r31,r13			; Zero Out Initial r13
	lda	r13,15(r31)			; r13=15
	subq    r13,r12,r14			; Get bit number (0 to 15) ( we started at 15)
	sll	r14, #^x04, r14			; Multiply by 16 for SCB base vector.
	lda	r13, ^x900(r14)			; SCB base vector + offset.

	cmpeq	r14,#^xd0,r12			; Is this a power supply
	beq	r12,40$				; interrupt Skip if not

; first disable any further interrupts
	in_word	<imr>, r15			; Read the interrupt mask register
	lda	r14, imr$m_psi(r31)		; disable powersupply faults	
	bic	r15, r14, r15			; mask out the psi bit
	out_word	<imr>, r15

;
; Pick up the utility bus data.
; 
	in_word	<utility>, r14			; Utility Bits

;
; First we make sure there really is an error
;
	and	r14,<util$m_ps1fail ! util$m_ps2fail>,r15
	xor	r15,<util$m_ps1fail ! util$m_ps2fail>,r15
	bne	r15,32$				; one of them must be set of
						; there is a pretty bad error

	lda	r15,mchk$c_siounk(r31)		; If set then r15 is machine
	br	r31,build_log			; check code And build machine
						; check log
32$:
	and	r14,<util$m_ps1fail ! util$m_ps2fail>,r15
	bne	r15, 34$			; branch if at least one supply
						; is still up.

	lda	r15,mchk$c_PSFail(r31)		; If set then r15 is machine
	br	r31,build_log			; check code And build machine
						; check log

; one supply is still alive.  Determine what the failure is.
; 

34$:	and	r14,util$m_ps1fail,r15		; Check for ps1 failure
	bne	r15,36$
	lda	r15,mchk$c_PS1Fail(r31)		; If set then r15 is machine check code
	br	r31,build_log			; And build machine check log

;
; must be ps1 failure.
; 

36$:
	lda	r15,mchk$c_PS2Fail(r31)		; If set then r15 is machine check code
	br	r31,build_log			; And build machine check log

;
; not a power supply failure.  Check out the rest.
;

40$:
	cmpeq	r14,#^xe0,r12			; Is this a temperature warning
	beq	r12,50$				; Skip if not

; first disable any further interrupts
	in_word	<imr>, r15			; Read the interrupt mask register
	lda	r14, imr$m_temp_warn(R31)	; Disable further warnings
	bic	r15, r14, r15			; mask out the psi bit
	out_word	<imr>, r15

	lda	r15, mchk$c_TempWarn(r31)	; yes post a machine check frame	
        br      r31, build_log
50$:
	cmpeq	r14,#^xf0,r12			; Is this an unused indicator
	beq	r12,60$				; Skip if not
	lda	r15, mchk$c_unused(r31)	        ; yes post a machine check frame	
        br      r31, build_log
60$:						 
	bis	r31, #devipl, r15			; Set IPL to 20.
	br	r31, complete_interrupt 	; Go build stack frame and exit...
	.endc

.if ne	noritake_system 

.sbttl	Noritake Hardware Interrupt Handler
;----------------------------------------------------------------------
;
; Noritake Hardware Interrupt Handler
;
;	The order for parsing interrupts is IRQ4, IRQ3, IRQ2
;	and IRQ0.  IRQ1 and IRQ5 are ignored for now.
;
; INPUT PARAMETERS:
;
;	Reg	Usage
;	r13	HIRR masked with HIER.
;	r14	unchanged - 2 to denote we got a HW interrupt.
;
; r12-r15 are saved in pt12-pt15. r12,r14-r15 can be used as scratch registers.
;
; OUTPUT REGISTERS:
;
;	Reg	Usage
;	r13	SCB vector value
;	r14	new value of r4 on exit
;	r15	new IPL
;
; FUNCTION DESCRIPTION:
;
;	Parse the HIRR value passed in r13 to handle the highest
;	priority pending interrupt.
;
;	IRQ0 - AIO interrupts (IPL 20)
;		 Not sure what to do here, so for now ...
;
;		 1. Build a stack frame.
;		 2. Restore r12 - r15.
;		 3. Vector through offset ??? in the SCB.
;
;	IRQ1 - Eisa I/O Interrupt (IPL 21)
;
;		 1. iAck the 82378IB PIC to detect the source.
;		 2. Dismiss specific interrupt.
;		 3. Build a stack frame.
;		 4. Restore r12 - r15.
;		 5. Vector through offset x^800 in the SCB.
;
;	       This interrupt supports all devices on ISA.
;
;		IR0	Interval timer
;		IR1	Keyboard
;		IR2	(chains interrupt from slave PIC)
;		IR3	8-bit ISA - National 87312 COM2
;		IR4	8-bit ISA - National 87312 COM1
;		IR5	8-bit ISA - National 87312 Parallel port (or IR7)
;		IR6	8-bit ISA - National 87312 floppy disk controller
;		IR7	8-bit ISA - National 87312 Parallel port (or IR5)
;		IR8	Unused (RTC internal to the SIO)
;		IR9	8-bit  ISA /PCI Ethernet/PCI SCSI
;		IR10	16-bit ISA /PCI Ethernet/PCI SCSI
;		IR11	16-bit ISA /PCI Ethernet/PCI SCSI
;		IR12	16-bit ISA Mouse 
;		IR13	Unused 
;		IR14	16-bit ISA
;		IR15	16-bit ISA /PCI Ethernet/PCI SCSI
;
;	IRQ2 - PCI I/O Device interrupts (IPL 21)
;
; IRQ2 handler code - IPL 21
;
; check for a device interrupt from PCI slot. The PCI interrupt
; register is located at 1.C000.0026 and the mask register is 
; located at 1.C000.0028. I need to verify this address, it
; may be the eisa address(so <<5). I have no priority of the
; bits which I check, I start at slot 0 and go up to the 810
; Interrupt vector = 900+ slot*16 
;
;		IRQ REG		VECTOR	Description
;		  bit
;                  0                    Logical OR of PCI interrupt reg 2
;                  1                    Logical OR of PCI interrupt reg 3
;                  2                    Qlogic ISP1020A SCSI

;		   3		900	Slot 0 interrupt A
;		   4		910	Slot 0 interrupt B

;		   5		920	Slot 1 interrupt A
;		   6		930	Slot 1 interrupt B

;		   7		940	Slot 2 interrupt A
;		   8		950	Slot 2 interrupt B

;		   9		960	Slot 3 interrupt A
;		  10		970	Slot 3 interrupt B

;		  11		980	Slot 4 interrupt A
;		  12		990	Slot 4 interrupt B

;		  13		9A0	Slot 5 interrupt A
;		  14		9B0	Slot 5 interrupt B
;                 15                    reserved


;		   0		9C0	Slot 6 interrupt A
;		   1		9D0	Slot 6 interrupt B

;		   2		9E0	Slot 0 interrupt C
;		   3		9F0	Slot 0 interrupt D

;		   4		A00	Slot 1 interrupt C
;		   5		A10	Slot 1 interrupt D

;		   6		A20	Slot 2 interrupt C
;		   7		A30	Slot 2 interrupt D

;		   8		A40	Slot 3 interrupt C
;		   9		A50	Slot 3 interrupt D

;		  10		A60	Slot 4 interrupt C
;		  11		A70	Slot 4 interrupt D

;		  12		A80	Slot 5 interrupt C
;		  13		A90	Slot 5 interrupt D
;		  14		AA0	Slot 6 interrupt C
;		  15		AB0	Slot 6 interrupt D


;
;	IRQ3 - Non-Maskable interrupts (IPL 31)
;
;                1. Build a machine check log.
;                2. Build a stack frame.
;                3. Vector through offset ^x660 in the SCB 
;
;	IRQ4 - Real Time Clock interrupt (IPL 22)
;
;		 1. Dismiss interrupt.
;		 2. Build a stack frame.
;		 3. Restore r12 - r15.
;		 4. Vector through offset ^x600 in the SCB.
;
;	IRQ5 - HALT 
;
;----------------------------------------------------------------------
devipl = 20
halt_irq = hirrr$v_irq5

;Noritake_interrupts
	;
	; Handle those interrupts which are always enabled.
	;
	lda	r12, hirrr$m_irq5(r31)	; Get the NIM error mask
 	and	r12, r13, r12		; Was it the NMI interrupt?
	bne	r12, hw_nmi_error	; nmi or utility bus

	;
	; Handle the performance monitoring stuff.
	;
	perfmon_support1 == 1

	lda	r12, hirrr$m_pc0!hirrr$m_pc1(r31) ; Get PC bits
	and	r13, r12, r15		; Are any set?
	bne	r15, HW_PERF		; Yep, go look at them

	;
	; Handle those interrupts which are enabled if IPL < 31.
	;
	lda	r12, hirrr$m_irq0(r31)	; Get AIO error mask
 	and	r12, r13, r12		; Was it the AIO error interrupt?
	bne	r12, hw_error	; Yes, handle it

	;
	; Handle those interrupts which are enabled if IPL < 22.
	;
	lda	r12, hirrr$m_irq4(r31)	; Get the timer mask
 	and	r12, r13, r12		; Was it the timer interrupt?
	beq	r12, not_timer		; we do it this way so we can insert
					; the fan fail and hi temp logic
        br       r31,hw_timer           ; Should check theutility bits here
					; do a jump for now

;
; We get here because there is no timer interrupt pending.  This is only mikasa
; code.
; 

not_timer:
;	br  r31,nor_int  ;When VMS uses server management faults del line
	;
	; Handle those interrupts which are enabled if IPL < 20.
	;
        in_word <nor_irr3>, r14            ; Utility Bits
        and     r14, <nori$v_allbits> ,r15
        xor     r15, <nori$v_allbits> ,r15

        in_word <nor_imr3>, r12            ; Read in PCI int 3 mask reg
        and     r12, r15, r15

        and     r15, <nori$m_fan1fail>, r14
        beq     r14, 1$                    ; try next
        bic     r12, #nori$m_fan1fail,r12  ; Clear out mask bit
        lda     r15, mchk$c_fan1fail(r31)  ; load up machine check code
        br      r31, nori_build_log
1$:
        and     r15, #nori$m_fan2fail,r14  ; check fan 2
        beq     r14, 2$                    ; try next
        bic     r12, #nori$m_fan2fail,r12  ; clear out bit in mask
        lda     r15, mchk$c_fan2fail(r31)  ; load up machine check code
        br      r31, nori_build_log
2$:
        and     r15, #nori$m_ps1fail,r14   ; Power supply one  failue
        beq     r14, 3$                    ; try next
        bic     r12, #nori$m_ps1fail, r12
        lda     r15, mchk$c_ps1fail(r31)   ; load up machine check code
        br      r31, nori_build_log
3$:
        and     r15, #nori$m_ps2fail,r14   ; Power supply two  failue
        beq     r14, 4$                    ; try next
        bic     r12, #nori$m_ps2fail, r12
        lda     r15, mchk$c_ps2fail(r31)   ; load up machine check code
        br      r31, nori_build_log
4$:
        and     r15, #nori$m_tempfail,r14  ; Power supply one  failue
        beq     r14, 5$
        bic     r12, #nori$m_tempfail, r12
        lda     r15, mchk$c_tempfail(r31)  ; load up machine check code
        br      r31, nori_build_log
5$:
        and     r15, #nori$m_tempwarn,r14  ; Power supply one  failure
        beq     r14, nor_int		   ; try next
        bic     r12, #nori$m_tempwarn, r12
        lda     r15, mchk$c_tempwarn(r31)  ; load up machine check code

nori_build_log:
        out_word <nor_imr3>, r12        ; write new mask out
        br       r31, build_log

nor_int:
	lda	r12, hirrr$m_irq2(r31)	; Get the PIO mask
	and	r12, r13, r12		; Was it the PIO interrupt?
	bne	r12, hw_pio		; Yes, handle it

	lda	r12, hirrr$m_irq1(r31)	; Get the SIO mask
	and	r12, r13, r12		; Was it the SIO interrupt?
	bne	r12, hw_sio		; Yes, handle it

	br	r31, dismiss_interrupt	; Else, just dismiss this interrupt

;
; PCI interrupt service dispatcher.
;

hw_pio:
	in_word	<nor_irr1>, r14			; Read the interrupt request register
	zap	r14, ^xfc, r14
	in_word	<nor_imr1>, r15			; Read the interrupt mask register
	zap	r15, ^xfc, r15
;
; Last 2 bits of the mask and register is the "or" of reg 2/3
;
        srl     r14,#1,r14			; Line up the int reg
	srl	r15,#1,r15			; Line up the mask reg
	bic	r15,r14,r14			; r15 AND (NOT r14) 

	bne	r14, 12$			; got an interrupt check
						; which one it is
						; 
	in_word	<nor_irr2>, r14			; Read the interrupt request register
	zap	r14, ^xfc, r14
	in_word	<nor_imr2>, r15			; Read the interrupt mask register
	zap	r15, ^xfc, r15
; contiguous line values - we assume that the values for the anded interrupts
; are not enabled.
;	srl     r14,#2,r14			; Line up the int reg
;	srl	r15,#2,r15			; Line up the mask reg
	bic	r15,r14,r14			; r15 AND (NOT r14) 
        beq     r14,hwint_end			; dismiss the interrupt

	bis	r31,r31,r15			; Clear to make sure
	bis	r31,r31,r12			; Clear to make sure
	lda	r12, 16(r31)			; Check for interrupt from each bit
	lda	r15,  1(r31)			; Check each slot 
14$:
	and 	r14,r15,r13			; Check the bit -->r13 (1=assert)
	bne	r13,35$				; Interrupt Request found...dispatch
	sll	r15,1,r15			; Shift Mask Check to next  slot 
	subq	r12,#1,r12			; Next Slot
	bne	r12,14$				; Check for next interrupt request
	
	halt					; Should NEVER get here


12$:
	bis	r31,r31,r15			; Clear to make sure
	bis	r31,r31,r12			; Clear to make sure
	lda	r12, 16(r31)			; Check for interrupt from each bit
	lda	r15,  1(r31)			; Check each slot 
	br	r31, 21$			; ignore first shift - already done
20$:
	and 	r14,r15,r13			; Check the bit -->r13 (1=assert)
	bne	r13,30$				; Interrupt Request found...dispatch
	sll	r15,1,r15			; Shift Mask Check to next  slot 
21$:	subq	r12,#1,r12			; Next Slot
	bne	r12,20$				; Check for next interrupt request
	
	halt					; Should NEVER get here


30$:	addq	r12, 16, r12			; second array

35$:	bis	r31,r31,r13			; Zero Out Initial r13
	lda	r13,31(r31)			; r13=15
	subq    r13,r12,r14			; Get bit number (0 to 30) ( we started at 15)
	sll	r14, #^x04, r14			; Multiply by 16 for SCB base vector.
	lda	r13, ^x900(r14)			; SCB base vector + offset.
        bis	r31,#devipl,r15
        br	r31,complete_interrupt
  
.endc


.if	ne	avanti_system ! -
		mikasa_system ! -
		noritake_system ! -
		mtu_system ! - 
		k2_system ! -
		lean_system ! -
		cortex_system
;
; common code for performance counters.
;
	perfmon_support2 == 1

HW_PERF:
	addq	r31, #1, r13		; Get a 1
	subq	r31, #1, r14		; get a -1
	or	r31, #sl_clr$v_pc0, r12	; Get bit position for PC0 interrupts
	srl	r15, #hirrr$v_pc0, r15	; Get PC0 to <0>
	and	r15, #1, r15		; Isolate PC0
	cmovlbc	r15, #sl_clr$v_pc1, r12	; Get bit position for PC1 interrupts
	sll	r13, r12, r13		; Now get bit in position
	bic	r14, r13, r14		; Clear pending bit
	mt	r14, sl_clr		; Acknowledge the interrupt
	lda	r13, scb$v_perfmon(r31)	; Set SCB vector
	cmpeq	r15, r31, r14		; R4 = 1 if PC1, 0 if PC0
	or	r31, #29, r15		; Set IPL
	br	r31, complete_interrupt	; Go build trap
.endc


.if	ne	avanti_system ! -
		mikasa_system ! -
		noritake_system ! -
		mtu_system ! - 
		k2_system ! -
		lean_system
;
; The common hardware timer code will read the RTC register c, and dispatch off
; through the common clock handler
; 

hw_timer:
	out	<rtcadd>, <^x0C>	; Set up RTCADD to index register C.
	in	<rtcdat>, r14		; Dismiss interrupt by reading csr.

	lda	r13, ^x600(r31)		; Set vector.
	lda	r15, 22(r31)		; Set IPL
	br	r31, complete_interrupt	; Go build stack frame and exit...
.endc


.sbttl          Non-Maskable Interrupt Handler
.if	ne	avanti_system ! -
		mikasa_system ! -
		noritake_system ! -
		mtu_system ! - 
		k2_system ! -
		lean_system
;
; check for a non-maskable interrupt
;
; All NMI sources are handled as uncorrectable errors and dispatched
; through SCB vector 660.
;
.align	quad

hw_nmi_error:
        in      <sio$b_nmisc>, r12	; Get the contents of the NMISC

        srl     r12, nmisc$v_serr, r14  ; Get SERR status bit into lsb.
        blbc    r14, nmi_iochk		; Not SERR, go check for IOCHK.

        srl     r12, nmisc$v_serr_en, r14 ; Get the SERR enable bit into lsb.
        blbs    r14, nmi_iochk		; SERR is disabled, go try IOCHK.

        bis     r12, nmisc$m_serr_en, r14 ; Set the SERR enable bit.
        and     r14, #^x0F, r14         ; Clear status bits for write.

        out     <sio$b_nmisc>, r14, r14, r15	; Clear source of interrupt.

        bis     r31, r12, r14           ; Copy back original NMISC contents.
        and     r14, #^x0F, r14         ; Clear status bits for write.
        sll     r14, #8, r14            ; Shift it into the proper byte lane.
        stl/p   r14, (r15)              ; Write NMISC contents.
	lda	r15, mchk$c_serr(r31)	; Load reason for MCHK.
        br      r31, build_log

.align	quad
nmi_iochk:
.if	ne	mikasa_system ! noritake_system
;
; At one point only mikasa was part of this code but now that mustang I and the
; other lca platform are here, the utility check is now a condtional.  To add a
; new system add in the system name and the code later that checks the utility
; bus if there is one.  In some cases this will only be to check for halt.
; 
        srl     r12, nmisc$v_iochk, r14 ; Get IOCHK status bit into lsb.
        blbc    r14, check_utility	; Not IOCHK, go check utility register

        srl     r12, nmisc$v_iochk_en, r14 ; Get IOCHK enable bit into lsb.
        blbs    r14, check_utility	; Not IOCHK, go check utility register

.if_false
        srl     r12, nmisc$v_iochk, r14 ; Get IOCHK status bit into lsb.
        blbc    r14, hwint_end		; Not IOCHK, - ???

        srl     r12, nmisc$v_iochk_en, r14 ; Get IOCHK enable bit into lsb.
        blbc    r14, hwint_end		; Not IOCHK, - ???
.endc

        bis     r12, nmisc$m_iochk_en, r14 ; Set the IOCHK enable bit.
        and     r14, #^x0F, r14         ; Clear status bits for write.

        out     <sio$b_nmisc>, r14, r14, r15	; Clear source of interrupt.

        bis     r31, r12, r14           ; Copy back original contents of NMISC.
        and     r14, #^x0F, r14         ; Clear status bits for write.
        stl/p   r14, (r15)              ; Write NMISC contents.
	lda	r15, mchk$c_iochk(r31) ; Load reason for MCHK.
;
; Build the machine check logout frame ...
;

build_log:
	mt	r0, pt0			; MCHK handler expects r0, r1
	mt	r1, pt1			; to be saved in pt0, pt1 and
	mt	r3, pt3			; reason for MCHK to be in r3.
	bis	r31, r15, r3
	stall	2
	mf	r12, pt12		; Restore scratch registers.
	mf	r13, pt13
	mf	r14, pt14
	mf	r15, pt15
	br	r31, mchk_log_known	; Go to common MCHK handler.

.endc

;
; The following are the halt and error handlers.  Mikasa has a special bus on it
; that needs to be checked which includes the check for the halt line.
; Avanti/Mustang II handle halt inerrupts directly at the cpu.
; 

.if	ne	mikasa_system ! noritake_system
check_utility:		
.if ne enable_fan_fault_check		
	in_word	<utility>, r14			; Utility Bits

;
; Check for halt first
;	
	and	r14, util$m_halt, r15
	beq	r15, hw_check_halt		; see if halt needs to be
						; done.  Bit will be zero if
						; halt button has been
						; depressed.
.if	ne	mikasa_system
fan_or_hitemp:
	and	r14,#util$m_hitemp,r15		; Check for Hi temperature
	beq	r15,20$		
	lda	r15,mchk$c_TempFail(r31)		; If set then r15 is machine check code
	br	r31,build_log			; And build machine check log
20$:
	and	r14,#util$m_fan1fail,r15	; Check for fan 1 failure
	bne	r15,30$
	lda	r15,mchk$c_Fan1Fail(r31)	; If set then r15 is machine check code
	br	r31,build_log			; And build machine check log
30$:
	and	r14,#util$m_fan2fail,r15	; Check fo fan 2 failure
	bne	r15,50$
	lda	r15,mchk$c_Fan2Fail(r31)	; If set then r15 is machine check code
	br	r31,build_log			; And build machine check log
50$:
	lda	r15, mchk$c_siounk(r31)		; don't know what it is
	br	r31,build_log			; And build machine check log

.endc

.endc

.endc
.IF	DEFINED halt_irq
hw_check_halt:
	mf	r12, hirr			; get request
	mf	r14, hier			; get enables
	and	r12, r14, r12			; the enables
	srl	r12, halt_irq, r14		; Get HIRR<10> into lsb.
	blbs	r14, hw_check_halt		; stay here until it goes away

.if	ne	mikasa_system ! noritake_system
	ldq/p	r14, pal$halt_button_pressed(r31)
	addq	r14, #1, r14
	stq/p	r14, pal$halt_button_pressed(r31)
.endc

hw_enter_console:
	;
	; Enter console mode on a received halt.
	;
	mf	r12, pt28			; Fetch PTBR
	blbc	r12, 20$			; Branch if not in console mode
	ldq/p	r12, pal$callback(r31)		; Are we in a callback?
	beq	r12, dismiss_interrupt		; Nope, ignore this halt request
	lda	r12, 8(r31)			; Pend this halt request
	stq/p	r12, pal$callback(r31)		; Save flag for later
	br	r31, dismiss_interrupt		;  and don't bother now

20$:	mf	r12, pt27			; Only halt the primary!
	bne	r12, dismiss_interrupt		;
	mf	r12, pt12			; Restore R12
	mf	r13, pt13			; Restore R13
	mf	r14, pt14			; Restore R14
	mf	r15, pt15			; Restore R15
	mt	r0, pt0				; Save R0
	pvc$jsr 	updpcb, bsr=1
	bsr	r0, pal$update_pcb		; Update the PCB
	lda	r0, hlt$c_hw_halt(r31)		; Set halt code to hardware halt
	br	r31, pal$enter_console		; Enter the console
.endc


.if	ne	avanti_system ! mikasa_system ! noritake_system ! k2_system ! cortex_system
	; Check for DECchip 21071-CA (Commanche) errors
hw_error:	

        in_epic	 <epic_dcsr>, r12, r15	; Read the Diagnostic Control & Status.

	get_addr r15,<dcsr$m_iort>,r31	; Check for a retry timeout error.

	and	r12, r15, r15		; Isolate the DCSR<ioRT> bit.
	beq	r15, 10$		; Branch if not ioRT.
	lda	r15, mchk$c_iort(r31)	; If set then r15 is machine check code
	br	r31, build_log		; Go build machine check log ...
	
10$:	
	get_addr r15,<dcsr$m_ddpe>,r31	; Check for DMA data parity error.

	and	r12, r15, r15		; Isolate the DCSR<dDPE> bit.
	beq	r15, 20$		; Branch if not dDPE.
	lda	r15, mchk$c_ddpe(r31)	; If set then r15 is machine check code
	br	r31, build_log		; Go build machine check log ...
	
20$:	
	get_addr r15,<dcsr$m_iope>,r31	; Check for I/O parity error.

	and	r12, r15, r15		; Isolate the DCSR<iOPE> bit.
	beq	r15, 30$		; Branch if not iOPE.
	lda	r15, mchk$c_iope(r31)	; If set then r15 is machine check code
	br	r31, build_log		; Go build machine check log ...
	
30$:	
	get_addr r15,<dcsr$m_tabt>,r31	; Check for a target abort error.

	and	r12, r15, r15		; Isolate the DCSR<tAbt> bit.
	beq	r15, 40$		; Branch if not tAbt.
	lda	r15, mchk$c_tabt(r31)	; If set then r15 is machine check code
	br	r31, build_log		; Go build machine check log ...
	
40$:	
	get_addr r15,<dcsr$m_ndev>,r31	; Check for a no device error.

	and	r12, r15, r15		; Isolate the DCSR<nDev> bit.
	beq	r15, 50$		; Branch if not nDev.
	lda	r15, mchk$c_ndev(r31)	; If set then r15 is machine check code
	br	r31, build_log		; Go build machine check log ...
	
50$:	
	get_addr r15,<dcsr$m_cmrd>,r31	; Check for a correctable memory error.

	and	r12, r15, r15		; Isolate the DCSR<cMRD> bit.
	beq	r15, 60$		; Branch if not cMRD.
	lda	r15, mchk$c_cmrd(r31)	; If set then r15 is machine check code
	br	r31, build_log		; Go build machine check log ...
	
60$:	
	get_addr r15,<dcsr$m_umrd>,r31	; Check for uncorrectable memory error.

	and	r12, r15, r15		; Isolate the DCSR<uMRD> bit.
	beq	r15, 70$		; Branch if not uMRD.
	lda	r15, mchk$c_umrd(r31)	; If set then r15 is machine check code
	br	r31, build_log		; Go build machine check log ...
	
70$:	
	get_addr r15,<dcsr$m_iptl>,r31	; Check for an invalid page table lookup.

	and	r12, r15, r15		; Isolate the DCSR<iPTL> bit.
	beq	r15, 80$		; Branch if not iPTL.
	lda	r15, mchk$c_iptl(r31)	; If set then r15 is machine check code
	br	r31, build_log		; Go build machine check log ...
	
80$:	
	get_addr r15,<dcsr$m_merr>,r31	; Check for a memory error.

	and	r12, r15, r15		; Isolate the DCSR<mErr> bit.
	beq	r15, 90$		; Branch if not mErr.
	lda	r15, mchk$c_merr(r31)	; If set then r15 is machine check code
	br	r31, build_log		; Go build machine check log ...

90$:    
	lda	r15, mchk$c_pciunk(r31)	; Otherwise, unknown machine check code
	br      r31, build_log		; Go build machine check log ...

	.endc


.if	ne	avanti_system ! -
		mikasa_system ! -
		noritake_system ! -
		k2_system ! -
		mtu_system ! - 
		lean_system

hw_sio:

;
; normal sio processing.  This code performs and interrupt acknowledge cycle to
; determine the verctor in the pic.  If the vector is 7 then and additional
; check is made to see if it is a passive release or a real irq 7.  If it is a
; real irq 7 then normal servicing is done.  If it is not a real irq7 then
; passive release is indicated and the exit code executed.
; 

hw_sio_normal:
	iack				; Acknowledge the PIC.
					; Vector of highest priority pending
					; ISA interrupt is returned in r14.
	and	r14, ^xFF, r14		; Clean vector to 8 bits.
	cmpeq	r14, ^x07, r13		; Check for passive release.
	bne	r13, hw_release		; If so, dismiss non-specific interrupt.
;
; Determine which of the two controllers the ISA interrupt came in 
; on and dismiss it accordingly.  If the interrupt is coming in on
; the slave controller (INT1) then we need to dismiss both the 
; interrupt on the slave, and also IR2 on the master (INT0).
; IR2 is used to cascade the two controllers together and is not
; available as an external pin.
;
service_pic:
;
; Comment out this code - it doesn't do anything.
;
;	cmple	r14, #7, r13		; Check if interrupt is on INT0 or INT1.
;
;	bis	r14, r31, r12		; Save a copy of the vector.
;
;	bne	r13, int0_service	; If set, interrupt is on INT0.
;
; Service interrupt on INT1
;
;	and	r14, #7, r14		; Mask IR0-7 for specific EOI.
;	lda	r13, ^x0060(r31)	; Load specific EOI command.
;	bis	r13, r14, r13		; Add in the IR level to be acted upon.
;	
;
;	bis	r31, #2, r14		; Now dismiss IR2 on INT0.
;
; Service interrupt on INT0
;
;int0_service:
;	lda	r13, ^x0060(r31)	; Load specific EOI command.
;	bis	r13, r14, r13		; Add in the IR level to be acted upon.
;
;	bis	r12, r31, r14		; Restore original interrupt vector.
;
; End of commented code.
;
	sll	r14, #^x04, r14		; Multiply by 16 for SCB base vector.
	lda	r13, ^x800(r14)		; SCB base vector + offset.
	bis	r31, #devipl, r15		; Set IPL to 21.

	br	r31, complete_interrupt ; Go build stack frame and exit...
;
; Passive release - dismiss non-specific interrupt and return.
;
.align	quad
hw_release:


	out	<^x20>, <^x40>, r13, r15	; select ocw2 - This is really a
						; nop but forces the next
						; operation to ocw2.
	out	<pic1+ocw3>, <^x0B>, r13, r15	; OCW3 - ISR select 

	in	<pic1+ocw3>, r13		; Read the ISR 

	srl	r13, #^x07, r13			; Get ISR<7> into low bit
	blbs	r13, service_pic		; If set, service IR7 interrupt
;
; Send non-specific EOI command to INT1 and INT0.
;
	out	<pic2+ocw2>, <^x20>, r13, r15
	out	<pic1+ocw2>, <^x20>, r13, r15

;
; when all else fails.  
;
hwint_end:
	br	r31, dismiss_interrupt
.endc

	.if ne	medulla_system
.sbttl	Medulla Hardware Interrupt Handler
;----------------------------------------------------------------------
;
; Medulla System Hardware Interrupt Handler
;
;	The order for parsing interrupts is irq[0], irq[1], then irq[2].
;
; INPUT REGISTERS:
;
;	Reg	Usage
;	r12	HIRR 
;	r13	HIRR masked with HIER
;	r14	unchanged - 2 to denote we got a hardware interrupt
;	r15	VA
;
;   r12-r15 are saved in pt12-pt15. We can use r12,r14-15 as scratch registers.
;
; OUTPUT REGISTERS:
;
;	Reg	Usage
;	r13	unchanged - scb vector value
;	r15	new ipl
;	r14	new value of r4 on exit.
;	
; FUNCTION DESCRIPTION:
;
;	Medulla uses the three LCA IRQ pins for:
;
;  	  1) Nonmaskable system interrupts like a HALT
;  	  2) VIP (Connected to VIC64) chip
;  	  3) SIO chip
;
; 	The EV4 daughterboard emulates the three IRQ pins of LCA as
;	     LCA IRQ0 (unmaskable interrupt HALT) is LCADS: no connection
;	     LCA IRQ1 (SIO double PIC)            is LCADS: IRQ2
;	     LCA IRQ2 (VIP chip)                  is LCADS: no connection
;
; 	PIC base address is made up by the EV4 daughter card PCI
; 	base address  plus its offset in PCI base.
; 	20h 21h A0h A1h - All accesss are BYTE I/Os
;
; 	VIC base address is fixed in PCI I/O space and the registers
; 	are offsets from that.... - All accesss are BYTE I/Os
; 	Base Address is VIC$BASE_ADDRESS
;
; 	EV4 daughter card PCI I/O space base address is:
;   	   PCI I/O Byte   Adr33=1 Adr32=1 Adr6:5=00  ^X3.0000.0000 =b0
;                                                    ^X3.0000.0080 =b1
;                                                    ^X3.0000.0100 =b2
;                                                    ^X3.0000.0180 =b3
;                  Word   Adr33=1 Adr32=1 Adr6:5=01  ^X3.0000.0020 =w0
;                                                    ^X3.0000.00A0 =w1
;                                                    ^X3.0000.0120 =w2
;                  LW     Adr33=1 Adr32=1 Adr6:5=10  ^X3.0000.0040 =l0
;                  LclCSR Adr33=1 Adr32=1 Adr6:5=11  ^X3.0000.0060 =lclcsr
;
;          PCI Mem Byte   Adr33=1 Adr32=0 Adr6:5=00  ^X2.0000.0000 =b0
;                                                    ^X2.0000.0080 =b1
;                                                    ^X2.0000.0100 =b2
;                                                    ^X2.0000.0180 =b3
;                  Word   Adr33=1 Adr32=0 Adr6:5=01  ^X2.0000.0020 =w0
;                                                    ^X2.0000.00A0 =w1
;                  LW     Adr33=1 Adr32=0 Adr6:5=10  ^X2.0000.0040 =l0
;                  QW     Adr33=1 Adr32=0 Adr6:5=11  ^X2.0000.0060 =q0
;
; 	The PCI address is bit <31:7> of the EV4 address, where the
; 	the base address stuff has already been loaded in, the PCI address
; 	like A1h for example is shifted up 7 bits and or'ed in.
;
;-------------------------------------------------------------------------

        ;
        ; Flush Write Buffer to insure proper ordering of Writes and Reads
        ;
	mb

	.if ne medulla_int_cntrs
	;
	; Save some debug info, increment the "all interrupts" counter. 
	;
	ldah	r12, ^x0060(r31)		; 0.0060.0000

	;    Save a copy of the HIRR
	mf	r15, hirr			; Get a copy of HIRR
	stq/p	r15, ^x0000(r12)		;   Write it at offset 00H

	;    Save a copy of the HIER
	mf	r15, hier			; Get a copy of HIER
	stq/p	r15, ^x0010(r12)		;   Write it at offset 10H

	;    Increment the all ints counter. 
	ldq/p   r15, ^x0020(r12)                ; Read the memory location
	addq	r15, #1, r15			; Increment by 1
	stq/p   r15, ^x0020(r12)		; Write it back out
	.endc

        ;
        ; Check for HALT interrupt (IRQ0 on LCA).
        ;
	srl     r13, #hirrr$v_irq0, r12		; Was it an NMI?
	blbs    r12, medu$nmi_interrupt		; Handle the NMI if lb set

        ;
        ; Check for SIO interrupt (IRQ1 on the LCA, IRQ2 on the LCADS system)
        ;
	srl	r13, #hirrr$v_irq1, r12		; Is the SIO interrupting?
	blbc    r12, 10$			; No SIO if lb clr
        ;
        ; Check for also VIP/VIC interrupt (IRQ2 on LCA)
	; We will do a mix of interrupts if both SIO and VIC set.
        ;
	srl	r13, #hirrr$v_irq2, r12		; Is VIC interrupting?
	blbs	r12, medu$mix_interrupt		; Handle SIO&VIP/VIC if lb set
	;
	; We only have SIO interrupt
	br	r31, medu$sio_interrupt		; Handle the SIO
10$:
        ;
        ; Check for only VIP/VIC interrupt (IRQ2 on LCA)
        ;
	srl	r13, #hirrr$v_irq2, r12		; Is VIC interrupting?
	blbs	r12, medu$vic_interrupt		; Handle the VIP/VIC if lb set

	;
	; Handle the performance monitoring stuff.
	;
	perfmon_support1 == 1
        .if ne  lca4
	lda	r12, hirrr$m_pc0!hirrr$m_pc1(r31)	; Get PC bits
	and	r13, r12, r15				; Are any set?
        bne     r15, medu$perfmon_handler	; Handle the perfmon int
	.endc

        ;
        ; ... it should have been one of the three interrupts above. Enter the
	; console for now with a HW halt code since it was unexpected. 
        ;
	br	r31, medu$unknown_interrupt	; Handle bogus


   ;-------------------------------------------
   ; Mixed SIO & VIC interrupt handler. 
   ;-------------------------------------------
	align_branch_target		; no cache align, can flow from above

   medu$mix_interrupt:

	;
	; Read both PIC IRR registers, to see which
	; SIO interrupts are pending.  (IRR was setup for
	; read on the reset path).
	;
	medu$read_sio	SIO$B_PIC1_OCW3		; PIC1 to r13
	sget_addr r12, pal$impure_base, r31	; Base of scratch area
	ldq/p	r15, medu$q_last_masked(r12)	; mask of enabled ints this ipl
	or	r15, #4, r15			; leave on cascade
	and	r13, r15, r13			; leave only masked ints
	and	r13, #4, r14			; any PIC2 ints?
	beq	r14, 10$			; br if none
	medu$read_sio	SIO$B_PIC2_OCW3, r14	; pic2 to r14
	sget_addr r12, pal$impure_base, r31	; Base of scratch area
	ldq/p	r15, medu$q_last_masked(r12)	; mask of enabled ints this ipl
	srl	r15, #8, r15			; pic2 mask
	and	r14, r15, r14			; leave only masked ints
10$:
	;
	; Read VIP mask to see which VIC ipl is pending.
	;
        medu$pci_vme_addr       VIP$B_HWIPL     ; addr to r12
	ldl/p   r15, (r12)			; get mask register
	srl	r15, #4, r15			; move transient ipl to bit 0
	and	r15, #7, r15			; extract vic ipl level

	;
	; Determine which VIP/SIO interrupt to use:
	; We must check in priority order, to maintain
	; the interrupt prioirities.  We will mask out
	; the matching level, and all lower ints.
	; 
        ; 	Check for interval timer interrupt (PIC1, IRQ5)
        ;
	and	r13, #MEDU$M_IRQ_INTRVL_TMR, r12 ; Was it the interval timer?
	bne	r12, medu$sio_intrvl_tmr_int	 ; Handle it if so
	; 
	;	Check for VME reset (PIC2, IRQ8)
	;
	and	r14, #MEDU$M_IRQ_VME_RESET, r12	; Was it a VME reset?
	bne	r12, medu$sio_vme_reset_int	; Handle it if so
	;
	;	Check for VIP Errors (LIRQ7), VIC Errors,
	;	Periodic RT Timer (LIRQ3),
	;	IPC Local, and/or IPC Global (VIC IPL 7)
	;
	cmpeq	r15, #7, r12			; At VIC ipl 7?
	blbs	r12, medu$vic_interrupt		; Handle the VIP/VIC if lb set
	;
	;	Check for autovector VME IRQ 7 (PIC2, IRQ15)
	;
	and	r14, #MEDU$M_IRQ_VME_IRQ7, r12	; Was it VME IRQ 7?
	bne	r12, medu$sio_vme_irq_7_int	; Handle it if so
	;
	;	Check for VME IRQ 7 or DMA status (both at VIC IPL 6)
	;
	cmpeq	r15, #6, r12			; At VIC ipl 6?
	blbs	r12, medu$vic_interrupt		; Handle the VIP/VIC if lb set
	;
        ; 	Check for Heartbeat interrupt (PIC1, IRQ1)
        ;
	and	r13, #MEDU$M_IRQ_HEARTBEAT, r12	; Was it the heartbeat?
	bne	r12, medu$sio_heartbeat_int	; Handle it if so
	;
	;	Check for VIP Location Monitor (VIC IPL 5, LIRQ2)
	;
	cmpeq	r15, #5, r12			; At VIC ipl 5?
	blbs	r12, medu$vic_interrupt		; Handle the VIP/VIC if lb set
	; 
        ; 	Check for PCI option A interrupt (PIC1, IRQ3)
        ;
	and	r13, #MEDU$M_IRQ_PCI_OPT_A, r12	; Was it the PCI option A?
	bne	r12, medu$sio_pci_opt_A_int	; Handle it if so
	;
	;	Check for autovector VME IRQ 6 (PIC2, IRQ14)
	;
	and	r14, #MEDU$M_IRQ_VME_IRQ6, r12	; Was it VME IRQ 6?
	bne	r12, medu$sio_vme_irq_6_int	; Handle it if so
	;
	;	Check for autovector VME IRQ 5 (PIC2, IRQ13)
	;
	and	r14, #MEDU$M_IRQ_VME_IRQ5, r12	; Was it VME IRQ 5?
	bne	r12, medu$sio_vme_irq_5_int	; Handle it if so
	;
	;	Check for autovector VME IRQ 4 (PIC2, IRQ13)
	;
	and	r14, #MEDU$M_IRQ_VME_IRQ4, r12	; Was it VME IRQ 4?
	bne	r12, medu$sio_vme_irq_4_int	; Handle it if so
	;
	;	Check for VME IRQ 6, 5, or 4 (VIC IPL 4)
	;
	cmpeq	r15, #4, r12			; At VIC ipl 4?
	blbs	r12, medu$vic_interrupt		; Handle the VIP/VIC if lb set
	; 
        ; 	Check for UART interrupt (PIC1, IRQ 4)
        ;
	and	r13, #MEDU$M_IRQ_UART, r12	; Was it the UART?
	bne	r12, medu$sio_uart_int		; Handle it if so
	; 
        ; 	Check for NI interrupt (PIC1, IRQ6)
        ;
	and	r13, #MEDU$M_IRQ_NI, r12	; Was it the NI?
	bne	r12, medu$sio_ni_int		; Handle it if so
	; 
        ; 	Check for SCSI interrupt (PIC1, IRQ7)
        ;
	and	r13, #MEDU$M_IRQ_SCSI, r12	; Was it the SCSI?
	bne	r12, medu$sio_scsi_int		; Handle it if so
	;
	;	Check for autovector VME IRQ 3 or
        ; 	PCI option D interrupt (PIC2, IRQ11)
	;
	and	r14, #MEDU$M_IRQ_VME_IRQ3, r12	; Was it VME IRQ 3?
	bne	r12, medu$sio_vme_irq_3_int	; Handle it if so
	;
	;	Check for autovector VME IRQ 2 or
        ; 	PCI option C interrupt (PIC2, IRQ10)
	;
	and	r14, #MEDU$M_IRQ_VME_IRQ2, r12	; Was it VME IRQ 2?
	bne	r12, medu$sio_vme_irq_2_int	; Handle it if so
	;
	;	Check for autovector VME IRQ 1 or
        ; 	PCI option B interrupt (PIC2, IRQ9)
	;
	and	r14, #MEDU$M_IRQ_VME_IRQ1, r12	; Was it VME IRQ 1?
	bne	r12, medu$sio_vme_irq_1_int	; Handle it if so
	;
	;	Check for VME IRQ 3, 2, or 1, VME IACK (all at VIC IPL 3)
	;
	cmpeq	r15, #3, r12			; At VIC ipl 3?
	blbs	r12, medu$vic_interrupt		; Handle the VIP/VIC if lb set
	;
	;	Check for VIC IPL 2 just in case
	;
	cmpeq	r15, #2, r12			; At VIC ipl 2?
	blbs	r12, medu$vic_interrupt		; Handle the VIP/VIC if lb set
        ;
        ;       ... it should have been one of the interrupts above.
        ;
	;
	; ???MASK OUT THE INTERRUPT AT THE IMR and VIP???
	;

        ;
        ; Dismiss the interrupt.
        ;
        br      r31, DISMISS_INTERRUPT


   ;-------------------------------------------
   ; SIO interrupt handler. 
   ;-------------------------------------------
	align_to_double_cache_block	; align for branch target

   medu$sio_interrupt:

	;
	; Read both PIC IRR registers, to see which
	; interrupts are pending.  (IRR was setup for
	; read on the reset path).
	;
	medu$read_sio	SIO$B_PIC1_OCW3		; PIC1 to r13
	sget_addr r12, pal$impure_base, r31	; Base of scratch area
	ldq/p	r15, medu$q_last_masked(r12)	; mask of enabled ints this ipl
	or	r15, #4, r15			; leave on cascade
	and	r13, r15, r13			; leave only masked ints
	and	r13, #4, r14			; any PIC2 ints?
	beq	r14, 10$			; br if none
	medu$read_sio	SIO$B_PIC2_OCW3, r14	; pic2 to r14
	sget_addr r12, pal$impure_base, r31	; Base of scratch area
	ldq/p	r15, medu$q_last_masked(r12)	; mask of enabled ints this ipl
	srl	r15, #8, r15			; pic2 mask
	and	r14, r15, r14			; leave only masked ints
10$:
	;
	; Determine which SIO interrupt it was:
	; We must check in priority order, to maintain
	; the interrupt prioirities.  We will mask out
	; the matching level, and all lower ints.
	; 
        ; 	Check for interval timer interrupt (PIC1, IRQ5)
        ;
	and	r13, #MEDU$M_IRQ_INTRVL_TMR, r12  ; Was it the interval timer?
	bne	r12, medu$sio_intrvl_tmr_int	  ; Handle it if so
	; 
	;	Check for VME reset (PIC2, IRQ8)
	;
	and	r14, #MEDU$M_IRQ_VME_RESET, r12	; Was it a VME reset?
	bne	r12, medu$sio_vme_reset_int	; Handle it if so
	;
	;	Check for autovector VME IRQ 7 (PIC2, IRQ15)
	;
	and	r14, #MEDU$M_IRQ_VME_IRQ7, r12	; Was it VME IRQ 7?
	bne	r12, medu$sio_vme_irq_7_int	; Handle it if so
	;
        ; 	Check for Heartbeat interrupt (PIC1, IRQ1)
        ;
	and	r13, #MEDU$M_IRQ_HEARTBEAT, r12	; Was it the heartbeat?
	bne	r12, medu$sio_heartbeat_int	; Handle it if so
	; 
        ; 	Check for PCI option A interrupt (PIC1, IRQ3)
        ;
	and	r13, #MEDU$M_IRQ_PCI_OPT_A, r12	; Was it the PCI option A?
	bne	r12, medu$sio_pci_opt_A_int	; Handle it if so
	;
	;	Check for autovector VME IRQ 6 (PIC2, IRQ14)
	;
	and	r14, #MEDU$M_IRQ_VME_IRQ6, r12	; Was it VME IRQ 6?
	bne	r12, medu$sio_vme_irq_6_int	; Handle it if so
	;
	;	Check for autovector VME IRQ 5 (PIC2, IRQ13)
	;
	and	r14, #MEDU$M_IRQ_VME_IRQ5, r12	; Was it VME IRQ 5?
	bne	r12, medu$sio_vme_irq_5_int	; Handle it if so
	;
	;	Check for autovector VME IRQ 4 (PIC2, IRQ13)
	;
	and	r14, #MEDU$M_IRQ_VME_IRQ4, r12	; Was it VME IRQ 4?
	bne	r12, medu$sio_vme_irq_4_int	; Handle it if so
	; 
        ; 	Check for UART interrupt (PIC1, IRQ 4)
        ;
	and	r13, #MEDU$M_IRQ_UART, r12	; Was it the UART?
	bne	r12, medu$sio_uart_int		; Handle it if so
	; 
        ; 	Check for NI interrupt (PIC1, IRQ6)
        ;
	and	r13, #MEDU$M_IRQ_NI, r12	; Was it the NI?
	bne	r12, medu$sio_ni_int		; Handle it if so
	; 
        ; 	Check for SCSI interrupt (PIC1, IRQ7)
        ;
	and	r13, #MEDU$M_IRQ_SCSI, r12	; Was it the SCSI?
	bne	r12, medu$sio_scsi_int		; Handle it if so
	;
	;	Check for autovector VME IRQ 3 or
        ; 	PCI option D interrupt (PIC2, IRQ11)
	;
	and	r14, #MEDU$M_IRQ_VME_IRQ3, r12	; Was it VME IRQ 3?
	bne	r12, medu$sio_vme_irq_3_int	; Handle it if so
	;
	;	Check for autovector VME IRQ 2 or
        ; 	PCI option C interrupt (PIC2, IRQ10)
	;
	and	r14, #MEDU$M_IRQ_VME_IRQ2, r12	; Was it VME IRQ 2?
	bne	r12, medu$sio_vme_irq_2_int	; Handle it if so
	;
	;	Check for autovector VME IRQ 1 or
        ; 	PCI option B interrupt (PIC2, IRQ9)
	;
	and	r14, #MEDU$M_IRQ_VME_IRQ1, r12	; Was it VME IRQ 1?
	bne	r12, medu$sio_vme_irq_1_int	; Handle it if so
        ;
        ;       ... it should have been one of the interrupts above.
        ;
	;
	; ???MASK OUT THE INTERRUPT AT THE IMR???
	;
        ;
        ; Dismiss the interrupt.
        ;
        br      r31, DISMISS_INTERRUPT


   ;-------------------------------------------
   ; SIO interrupt routines
   ;-------------------------------------------

	align_to_cache_block

     medu$sio_vme_irq_1_int:
     medu$sio_pci_opt_B_int:
	;
	; Handle the autovector vme level 1 interrupt from the SIO:
	; Handle the PCI option B interrupt from the SIO:
	; Both have the same int source
        ;
	; 	Mask lower level ints
        ;
        .if ne  lca4
	or 	r31, #20, r15		        	; pass IPL
        pvc$jsr         medmskint5, bsr=1
        bsr     r13, medu$mask_ints_all            	; mask ints
        .endc

	;
	; 	Set the vector, IPL and then go complete the interrupt
	;
	lda	r13, ^x890(r31)	        	; Set SCB vector
	 or 	r31, #20, r15		        ; Set IPL
	br 	r31, COMPLETE_INTERRUPT 	; Go build stack frame and exit

	align_to_cache_block

     medu$sio_vme_irq_2_int:
     medu$sio_pci_opt_C_int:
	;
	; Handle the autovector vme level 2 interrupt from the SIO:
	; Handle the PCI option C interrupt from the SIO:
	; Both have the same int source
        ;
	; 	Mask lower level ints
        ;
        .if ne  lca4
	or 	r31, #20, r15		        	; pass IPL
        pvc$jsr         medmskint5, bsr=1
        bsr     r13, medu$mask_ints_all            	; mask ints
        .endc

	;
	; 	Set the vector, IPL and then go complete the interrupt
	;
	lda	r13, ^x8a0(r31)	        	; Set SCB vector
	 or 	r31, #20, r15		        ; Set IPL
	br 	r31, COMPLETE_INTERRUPT 	; Go build stack frame and exit

	align_to_cache_block

     medu$sio_vme_irq_3_int:
     medu$sio_pci_opt_D_int:
	;
	; Handle the autovector vme level 3 interrupt from the SIO:
	; Handle the PCI option D interrupt from the SIO:
	; Both have the same int source
        ;
	; 	Mask lower level ints
        ;
        .if ne  lca4
	or 	r31, #20, r15		        	; pass IPL
        pvc$jsr         medmskint5, bsr=1
        bsr     r13, medu$mask_ints_all            	; mask ints
        .endc

	;
	; 	Set the vector, IPL and then go complete the interrupt
	;
	lda	r13, ^x8b0(r31)	        	; Set SCB vector
	 or 	r31, #20, r15		        ; Set IPL
	br 	r31, COMPLETE_INTERRUPT 	; Go build stack frame and exit

	align_to_cache_block

     medu$sio_vme_irq_4_int:
        ;
	; Handle the autovector vme level 4 interrupt from the SIO:
        ;
	; 	Mask lower level ints
        ;
        .if ne  lca4
	or 	r31, #21, r15		        	; pass IPL
        pvc$jsr         medmskint5, bsr=1
        bsr     r13, medu$mask_ints_all            	; mask ints
        .endc

	;
	; 	Set the vector, IPL and then go complete the interrupt
	;
	lda	r13, ^x8c0(r31)	        	; Set SCB vector
	 or 	r31, #21, r15		        ; Set IPL
	br 	r31, COMPLETE_INTERRUPT 	; Go build stack frame and exit

	align_to_cache_block

     medu$sio_vme_irq_5_int:
        ;
	; Handle the autovector vme level 5 interrupt from the SIO:
        ;
	; 	Mask lower level ints
        ;
        .if ne  lca4
	or 	r31, #21, r15		        	; pass IPL
        pvc$jsr         medmskint5, bsr=1
        bsr     r13, medu$mask_ints_all            	; mask ints
        .endc

	;
	; 	Set the vector, IPL and then go complete the interrupt
	;
	lda	r13, ^x8d0(r31)	        	; Set SCB vector
	 or 	r31, #21, r15		        ; Set IPL
	br 	r31, COMPLETE_INTERRUPT 	; Go build stack frame and exit

	align_to_cache_block

     medu$sio_vme_irq_6_int:
        ;
	; Handle the autovector vme level 6 interrupt from the SIO:
        ;
	; 	Mask lower level ints
        ;
        .if ne  lca4
	or 	r31, #21, r15		        	; pass IPL
        pvc$jsr         medmskint5, bsr=1
        bsr     r13, medu$mask_ints_all            	; mask ints
        .endc

	;
	; 	Set the vector, IPL and then go complete the interrupt
	;
	lda	r13, ^x8e0(r31)	        	; Set SCB vector
	 or 	r31, #21, r15		        ; Set IPL
	br 	r31, COMPLETE_INTERRUPT 	; Go build stack frame and exit

	align_to_cache_block

     medu$sio_vme_irq_7_int:
        ;
	; Handle the autovector vme level 7 interrupt from the SIO:
        ;
	; 	Mask lower level ints
        ;
        .if ne  lca4
	or 	r31, #23, r15		        	; pass IPL
        pvc$jsr         medmskint5, bsr=1
        bsr     r13, medu$mask_ints_all            	; mask ints
        .endc

	;
	; 	Set the vector, IPL and then go complete the interrupt
	;

	lda	r13, ^x8f0(r31)	        	; Set SCB vector
	 or 	r31, #23, r15		        ; Set IPL
	br 	r31, COMPLETE_INTERRUPT 	; Go build stack frame and exit

	align_to_cache_block

     medu$sio_vme_reset_int:
        ;
	; Handle the vme reset interrupt from the SIO:
        ;
	; 	Mask lower level ints
        ;
        .if ne  lca4
	or 	r31, #23, r15		        	; pass IPL
        pvc$jsr         medmskint5, bsr=1
        bsr     r13, medu$mask_ints_all            	; mask ints
        .endc

	;
	; 	Set the vector, IPL and then go complete the interrupt
	;
	lda	r13, ^x880(r31)	        	; Set SCB vector
	 or 	r31, #23, r15		        ; Set IPL
	br 	r31, COMPLETE_INTERRUPT 	; Go build stack frame and exit

	align_to_cache_block

     medu$sio_heartbeat_int:
        ;
	; Handle the heartbeat interrupt from the SIO:
        ;
        ; 	The writing of the "Clear Heartbeat Register" as well as the
	;	   EOI write for the SIO is done by the ISR. 
	; 	Set vector and IPL, then go take the interrupt.
        ;
        .if ne  lca4
	or 	r31, #22, r15		        	; pass IPL
        pvc$jsr         medmskint5, bsr=1
        bsr     r13, medu$mask_ints_all            	; mask ints
        .endc

	;
	; 	Update the SCC
	;
	rpcc	r13			; get cycle counter
	 or	r31, #1, r14		; get a 1
	mf	r12, pt10		; get SCC
	 sll	r14, #32, r14		; now a 100000000

	zap	r13, ^xf0, r13		; get low long of pcc
	 zap	r12, ^xf0, r15		; get low long of pcc
	zap	r12, ^x0f, r12		; get high long of SCC

	 subq	r13, r15, r15		; if pcc<31:0> le scc<31:0>
	cmovge	r15, r31, r14		; zero wrap, if wrap did not happen

	 addq	r12, r14, r12		; add wrapper to SCC
	or	r12, r13, r12		; merge
	 mt	r12, PT10		; update scc
	;
	; 	Set the vector, IPL and then go complete the interrupt
	;
	lda	r13, SCB$V_CLOCK(r31)	        ; Set SCB vector
	 or 	r31, #22, r15		        ; Set IPL
	br 	r31, COMPLETE_INTERRUPT 	; Go build stack frame and exit

	align_to_cache_block

     medu$sio_pci_opt_A_int:
        ;
	; Handle the PCI option A interrupt from the SIO:
        ;
	; 	EOI write for the SIO is done by the ISR. 
	; 	Set the vector, IPL and then go complete the interrupt
	;
        .if ne  lca4
	or 	r31, #21, r15	        		; Pass IPL
        pvc$jsr         medmskint5, bsr=1
        bsr     r13, medu$mask_ints_all            	; mask ints
        .endc

	lda	r13, ^x830(r31)		; Set SCB vector
	.if ne medulla_lcads
	  or 	r31, #22, r15	        ; Set IPL
	.iff
	  or 	r31, #21, r15	        ; Set IPL
	.endc
	br 	r31, COMPLETE_INTERRUPT	; Go build stack frame and exit

	align_to_cache_block

     medu$sio_uart_int:
        ;
	; Handle the UART interrupt from the SIO:
	;
	; 	EOI write for the SIO is done by the ISR. 
	; 	Set the vector, IPL and then go complete the interrupt
	;
        .if ne  lca4
	or 	r31, #20, r15	        		; Pass IPL
        pvc$jsr         medmskint5, bsr=1
        bsr     r13, medu$mask_ints_all            	; mask ints
        .endc

	lda	r13, ^x840(r31)		; Set SCB vector
	.if ne medulla_lcads
	  or 	r31, #22, r15	        ; Set IPL
	.iff
	  or 	r31, #20, r15	        ; Set IPL
	.endc
	br 	r31, COMPLETE_INTERRUPT	; Go build stack frame and exit

	align_to_cache_block

     medu$sio_intrvl_tmr_int:
        ;
	; Handle interval timer interrupt from the SIO:
        ;
	; 	EOI write for the SIO is done by the ISR. 
	; 	Set vector and IPL, then go take the interrupt.
        ;
        .if ne  lca4
	or 	r31, #23, r15				; Pass IPL
        pvc$jsr         medmskint5, bsr=1
        bsr     r13, medu$mask_ints_all            	; mask ints 
        .endc

	lda	r13, ^x850(r31)		; Set SCB vector
	or 	r31, #23, r15		; Set IPL
	br 	r31, COMPLETE_INTERRUPT	; Go build stack frame and exit

	align_to_cache_block

     medu$sio_ni_int:
        ;
	; Handle NI interrupt from the SIO:
        ;
	; 	EOI write for the SIO is done by the ISR. 
        ;
        .if ne  lca4
	or 	r31, #20, r15	        		; Pass IPL
        pvc$jsr         medmskint5, bsr=1
        bsr     r13, medu$mask_ints_all            	; mask ints 
        .endc

	.if ne medulla_int_cntrs
	;
	; 	Increment the NI counter. 
	;
	ldah	r12, ^x0060(r31)	; 0.0060.0000
	ldq/p	r13, ^x0160(r12)	; Read the IRQ6 count
	addq	r13, #1, r13		; Increment by 1
	stq/p	r13, ^x0160(r12)	; Write it back out
	.endc
	;
	; 	Set the vector, IPL and then go complete the interrupt
	;
	lda	R13, ^x860(r31)		        ; Set SCB vector
	.if ne medulla_lcads
	  or 	r31, #22, r15	        ; Set IPL
	.iff
	  or 	r31, #20, r15	        ; Set IPL
	.endc
	br 	r31, COMPLETE_INTERRUPT 	; Go build stack frame and exit

	align_to_cache_block

     medu$sio_scsi_int:
        ;
	; Handle SCSI interrupt from the SIO:
        ;
	; 	EOI write for the SIO is done by the ISR. 
	; 	Set the vector, IPL and then go complete the interrupt
	;
        .if ne  lca4
	or 	r31, #20, r15	        		; Pass IPL
        pvc$jsr         medmskint5, bsr=1
        bsr     r13, medu$mask_ints_all            	; mask ints 
        .endc

	lda	R13, ^x870(r31)		; Set SCB vector
	.if ne medulla_lcads
	  or 	r31, #22, r15	        ; Set IPL
	.iff
	  or 	r31, #20, r15	        ; Set IPL
	.endc
	br 	r31, COMPLETE_INTERRUPT	; Go build stack frame and exit


   ;-------------------------------------------
   ; VIC interrupt handler. 
   ;-------------------------------------------
	align_to_double_cache_block	; align for branch target

   medu$vic_interrupt:

;
;	IACK to VME via IRR register read, which also
;	returns the vector to us.
;
	medu$pci_vme_addr	VIP$B_IRR	; addr to r12
	ldl/p   r13, (r12)			; IACK the Int and get vector
;
;	form SCB vector as 1000H + vector<<4	(to r13)
;
	zapnot	r13, 1, r13		; clear all but vector byte
	beq	r13, dismiss_interrupt	; passive release
	sll	r13, 4, r13		; x16 to get SCB vector
	lda	r13, ^x1000(r13)	; form complete vector ^x1XX0
;
;	calculate VMS IPL from VIC ipl	(to r15)
;
	mf	r14, pal_base
     	get_addr r14, <medu$q_vic_to_vms_ipl-pal$start>, r14
	medu$pci_vme_addr	VIP$B_HWIPL	; addr to r12
	ldl/p   r15, (r12)			; get mask register
	and	r15, #7, r15			; extract masked vic ipl level
	s4addq	r15, r14, r14			; VIC ipl is index to VMS IPL
	ldl/p	r15, (r14)			; get VMS IPL
;
;	mask out this and lower ints
;
        .if ne  lca4
	mt	r13, pt0			; save vector
	mt	r15, pt1			; save IPL
	pvc$jsr		medmskint5, bsr=1
	; we don't need to mask at VIP, since read of
	; IRR masked us at this IPL and below.
	bsr	r13, medu$mask_ints_sio_all	; mask ints at SIO
	mf	r13, pt0			; restore vector
	mf	r15, pt1			; restore IPL
        .endc

	br 	r31, COMPLETE_INTERRUPT	; Go build stack frame and exit


   ;-------------------------------------------
   ; NMI interrupt handler. 
   ;-------------------------------------------
	align_to_cache_block
   medu$nmi_interrupt:

	;
	; Determine the interrupt source, either
	; a HALT switch, Watchdog timeout, or
	; PCI SERR.
	;
	medu$read_sio	SIO$B_NMI_CSR	; SERR/IOCHK status to r13
	and	r13, #^x40, r14		; IOCHK halt switch/wdog ints?
	beq	r14, 20$		; br if no
	;
	; HALT from switch or watchdog.  Disable
	; int so we don't get an infinite loop.
	; If wdog, reset-reason register tells the story.
	;
	medu$write_sio	<^x08>, SIO$B_NMI_CSR	; disable/clr IOCHK int
	medu$pci_addr	MEDU$MOD_RSTREASON_REG	; addr to r12
	ldq/p   r12, (r12) 			; reset reason reg
	blbc	r12, 10$			; br if not wdog
	;
	; Watchdog halt, we simply increment a count, then dismiss
	; the interrupt - for watchdog diagnostic support (the
	; console can't handle a true NMI).
	;
	sget_addr r12, pal$impure_base, r31		; Base of scratch area
	ldq/p	r13, medu$q_wdog_ints_count(r12) 	; get current count
	addq	r13, #^x1, r13				; increment
	stq/p	r13, medu$q_wdog_ints_count(r12) 	; store new count 
        br      r31, DISMISS_INTERRUPT
10$:
	;
	; Halt switch, we should halt the console
	;
	mf	r12, pt12		; restore regs saved at INT entry
	mf	r13, pt13
	mf	r14, pt14
	mf	r15, pt15
	lda	r0, HLT$C_HW_HALT(r31)		; Set halt code to hw halt
	br	r31, PAL$ENTER_CONSOLE		; Enter the console
20$:
	and	r13, #^x80, r14			; PCI SERR ints?
	beq	r14, 30$			; br if spurious interrupt
	;
	; Is a PCI SERR, so convert this to a MCHK
	;
	medu$read_sio	SIO$B_NMI_CSR		; SERR/IOCHK status to r13
	or	r13, #^x04, r13			; preserve IOCHK state
	medu$write_sio	r13, SIO$B_NMI_CSR	; clear PCI SERR int
	medu$read_sio	SIO$B_NMI_CSR		; SERR/IOCHK status to r13
	and	r13, #^x08, r13			; preserve IOCHK state
	medu$write_sio	r13, SIO$B_NMI_CSR	; reenable PCI SERR int
	; now emulate code to set up and go to mchk
	mf	r12, pt12		; restore regs saved at INT entry
	mf	r13, pt13
	mf	r14, pt14
	mf	r15, pt15
	mt	r31, alt_mode		; make sure altmode is KERNEL mode
	mt	r0, pt0				; save r0 per mchk path
	mt	r1, pt1				; save r1 per mchk path
	mt	r3, pt3				; save r3 per mchk path
	lda	r3, mchk$c_pciserr(r31)		; set error code
	br	r31, medulla_build_error_frame	; dispatch machine check
30$:
        ;
        ;       ... it should have been one of the interrupts above.
        ;
        ;
        ; Dismiss the interrupt.
        ;
        br      r31, DISMISS_INTERRUPT

   ;-------------------------------------------
   ; Unexpected interrupt handler
   ;-------------------------------------------
	align_branch_target

medu$unknown_interrupt:

	.if ne medulla_system_debug
	medu$putc	<^a/?/>, AddrSetup=1
	medu$putc	<^a/?/>, AddrSetup=0
	medu$putc	<^a/H/>, AddrSetup=0
	medu$putc	<^a/I/>, AddrSetup=0
	medu$putc	<^a/R/>, AddrSetup=0
	medu$putc	<^a/R/>, AddrSetup=0
	medu$putc	<^a/=/>, AddrSetup=0
	or	r13, r13, r16
	medu$puth
	medu$putc	<^x0d>, AddrSetup=1
	medu$putc	<^x0a>, AddrSetup=0
	.endc

	lda	r0, HLT$C_HW_HALT(r31)		; Set the halt code to HW halt
	br	r31, PAL$ENTER_CONSOLE		; Enter the console

   ;-------------------------------------------
   ; Performance Monitor interrupt handler. 
   ;-------------------------------------------
	align_to_cache_block
   medu$perfmon_handler:
	perfmon_support2 == 1

	.if ne medulla_system_debug
	medu$write_led	Character=<^a/k/>
	.endc

	bis	r13, r31, r15		; copy hier for later use

	lda	r13, 1(r31)		; get a one
	subq	r31, #1, r14		; get a -1
	or	r31, #sl_clr$v_pc0, r12	; get bit pos for pc0 ints

	srl	r15, #hirrr$v_pc0, r15	; get pc0 to <0>
	and	r15, #1, r15		; isolate pc0
	cmovlbc	r15, #sl_clr$v_pc1, r12	; bit pos for pc1 ints
	sll	r13, r12, r13		; now is bit in pos
	bic	r14, r13, r14		; clear pending bit
	mt	r14, sl_clr		; ack the interrupt
	lda	r13, scb$v_perfmon(r31)	; set scb vector
	cmpeq	r15, r31, r14		; r14 = 1 if pc1, 0 if pc0
	or	r31, #29, r15		; set new ipl=29
	br	r31, complete_interrupt	; go build trap

   ;-------------------------------------------
   ; Interrupt Support routines.
   ;-------------------------------------------

	.if ne	lca4
;+
; medu$mask_ints_xxxx - Medulla support routine
;
; Entry:
;	r15 = new ipl
;	r13 = return pc
;
; Function:
;	Called from ISR's to mask interrupts
;	for the new interrupt priority level.
;	Multiple routines, one per interrupt
;	mask register, for efficiency, and
;	one that does all registers.
;
; Exit:
;	updated SIO/VIP mask registers
;	r12, r14, r15 trashed
;
	
	align_to_double_cache_block

     medu$mask_ints_sio_all:
	;
	; Mask interrupts for Medulla at the SIO, PIC 1 & PIC2
	; Unnecessary PIC2 accesses are optimized out, to minimize
	; PCI traffic.
	;
	;	We find the full mask for this granular interrupt
	;	level, then mask the mask with the enabled interrupts,
	;	then set the int enables at the SIO and VIP/VIC using
	;	this final mask.
	;
	mf	r14, pal_base
     	get_addr r14, <medu$q_level_int_masks-pal$start>, r14
	s8addq	r15, r14, r14				; index mask this level
	ldq/p	r15, (r14)				; get full int mask
	sget_addr r12, pal$impure_base, r31		; Base of scratch area
	ldq/p	r14, medu$q_enabled_ints_mask(r12)	; mask of enabled ints
	and	r15, r14, r15				; leave active bits
	stq/p	r15, medu$q_last_masked(r12)		; save for intr entry

	; lower byte is PIC1 bits
	bis	r15, #4, r15				; leave on IRQ2 cascade
	ornot	r31, r15, r15				; flip bits for PIC
	medu$write_sio	r15, SIO$B_PIC1_MASK, TempReg1=r15	; preserve r14

	; optimize away PIC2 access if possible, by assuming if no PIC2
	; ints are enabled we don't need to mask it here.
	extbl	r14, #1, r14				; keep only PIC2 bits
	bne	r14, 10$				; br if PIC2 activity
	ret	r31, (r13)				; exit to optimize
10$:
	; we must mask PIC2 also
	sget_addr r12, pal$impure_base, r31		; Base of scratch area
	ldq/p	r15, medu$q_last_masked(r12)		; re-get mask bits
	srl	r15, #8, r15				; 2nd byte is PIC2 bits
	ornot	r31, r15, r15				; flip bits for PIC
	medu$write_sio	r15, SIO$B_PIC2_MASK, TempReg1=r15

	ret	r31, (r13)				; go home

	align_to_double_cache_block

     medu$mask_ints_all:
	;
	; Mask interrupts for Medulla at the SIO, PIC 1 & PIC2, VIP & VIC
	;
	; 	We translate VMS IPL to VIP/VIC ipl, and
	;	set the VIP mask register.  We don't care
	;	if the interrupts are enabled or not.
	;
	mf	r14, pal_base
     	get_addr r14, <medu$q_vms_to_vic_ipl-pal$start>, r14
	s4addq	r15, r14, r14			; VMS IPL is index to VIC ipl
	ldl/p	r14, (r14)			; get VIC ipl
	; note, bit 3 (ipl update) is cleared (enabled)
        medu$pci_vme_addr       VIP$B_HWIPL     ; addr to r12
	stl/p   r14, (r12)			; set mask register to new ipl
	mb					; flush write buffer
	;
	;	We find the full mask for this granular interrupt
	;	level, then mask the mask with the enabled interrupts,
	;	then set the int enables at the SIO and VIP/VIC using
	;	this final mask.
	;
	mf	r14, pal_base
     	get_addr r14, <medu$q_level_int_masks-pal$start>, r14
	s8addq	r15, r14, r14				; index mask this level
	ldq/p	r15, (r14)				; get full int mask
	sget_addr r12, pal$impure_base, r31		; Base of scratch area
	ldq/p	r14, medu$q_enabled_ints_mask(r12)	; mask of enabled ints
	and	r15, r14, r15				; leave active bits
	stq/p	r15, medu$q_last_masked(r12)		; save for intr entry

	; lower byte is PIC1 bits
	bis	r15, #4, r15				; leave on IRQ2 cascade
	ornot	r31, r15, r15				; flip bits for PIC
	medu$write_sio	r15, SIO$B_PIC1_MASK, TempReg1=r15	; preserve r14

	; optimize away PIC2 access if possible, by assuming if no PIC2
	; ints are enabled we don't need to mask it here.
	extbl	r14, #1, r14				; keep only PIC2 bits
	bne	r14, 10$				; br if PIC2 activity
	ret	r31, (r13)				; exit to optimize
10$:
	; we must mask PIC2 also
	sget_addr r12, pal$impure_base, r31		; Base of scratch area
	ldq/p	r15, medu$q_last_masked(r12)		; re-get mask bits
	srl	r15, #8, r15				; 2nd byte is PIC2 bits
	ornot	r31, r15, r15				; flip bits for PIC
	medu$write_sio	r15, SIO$B_PIC2_MASK, TempReg1=r15

	ret	r31, (r13)				; go home

	align_to_double_cache_block

     medu$mask_ints_all_noopt:
	;
	; Mask interrupts for Medulla at the SIO, PIC 1 & PIC2, VIP & VIC
	; No optimization is done.
	;
	; 	We translate VMS IPL to VIP/VIC ipl, and
	;	set the VIP mask register.  We don't care
	;	if the interrupts are enabled or not.
	;
	mf	r14, pal_base
     	get_addr r14, <medu$q_vms_to_vic_ipl-pal$start>, r14
	s4addq	r15, r14, r14			; VMS IPL is index to VIC ipl
	ldl/p	r14, (r14)			; get VIC ipl
	; note, bit 3 (ipl update) is cleared (enabled)
        medu$pci_vme_addr       VIP$B_HWIPL     ; addr to r12
	stl/p   r14, (r12)			; set mask register to new ipl
	mb					; flush write buffer
	;
	;	We find the full mask for this granular interrupt
	;	level, then mask the mask with the enabled interrupts,
	;	then set the int enables at the SIO and VIP/VIC using
	;	this final mask.
	;
	mf	r14, pal_base
     	get_addr r14, <medu$q_level_int_masks-pal$start>, r14
	s8addq	r15, r14, r14				; index mask this level
	ldq/p	r15, (r14)				; get full int mask
	sget_addr r12, pal$impure_base, r31		; Base of scratch area
	ldq/p	r14, medu$q_enabled_ints_mask(r12)	; mask of enabled ints
	and	r15, r14, r15				; leave active bits
	stq/p	r15, medu$q_last_masked(r12)		; save for intr entry

	; lower byte is PIC1 bits
	bis	r15, #4, r14				; leave on IRQ2 cascade
	ornot	r31, r14, r14				; flip bits for PIC
	medu$write_sio	r14, SIO$B_PIC1_MASK

	; 2nd byte is PIC2 bits
	srl	r15, #8, r14
	ornot	r31, r14, r14				; flip bits for PIC
	medu$write_sio	r14, SIO$B_PIC2_MASK

	ret	r31, (r13)				; go home

	align_to_cache_block

	.align	quad
;
; Masks for each ipl level.
;
medu$q_level_int_masks:

	.long	^xfefefffe, ^x3e	; level 0
	.long	^xfefefffe, ^x3e	; level 1
	.long	^xfefefffe, ^x3e	; level 2
	.long	^xfefefffe, ^x3e	; level 3
	.long	^xfefefffe, ^x3e	; level 4
	.long	^xfefefffe, ^x3e	; level 5
	.long	^xfefefffe, ^x3e	; level 6
	.long	^xfefefffe, ^x3e	; level 7
	.long	^xfefefffe, ^x3e	; level 8
	.long	^xfefefffe, ^x3e	; level 9
	.long	^xfefefffe, ^x3e	; level 10
	.long	^xfefefffe, ^x3e	; level 11
	.long	^xfefefffe, ^x3e	; level 12
	.long	^xfefefffe, ^x3e	; level 13
	.long	^xfefefffe, ^x3e	; level 14
	.long	^xfefefffe, ^x3e	; level 15
	.long	^xfefefffe, ^x3e	; level 16
	.long	^xfefefffe, ^x3e	; level 17
	.long	^xfefefffe, ^x3e	; level 18
	.long	^xfefefffe, ^x3e	; level 19
        .long   ^xf084f12e, ^x0e        ; level 20	hw level
        .long   ^x80848126, ^x0e        ; level 21	hw level
        .long   ^x80808124, ^x0e        ; level 22	hw level
        .long   ^x00000004, ^x00        ; level 23	hw level
        .long   ^x00000004, ^x00        ; level 24
        .long   ^x00000004, ^x00        ; level 25
        .long   ^x00000004, ^x00        ; level 26
        .long   ^x00000004, ^x00        ; level 27
        .long   ^x00000004, ^x00        ; level 28
        .long   ^x00000004, ^x00        ; level 29
        .long   ^x00000004, ^x00        ; level 30
        .long   ^x00000004, ^x00        ; level 31

;
; Translate VMS IPL to VIC ipl
;
medu$q_vms_to_vic_ipl:

	.long	0	; level 0
	.long	0	; level 1
	.long	0	; level 2
	.long	0	; level 3
	.long	0	; level 4
	.long	0	; level 5
	.long	0	; level 6
	.long	0	; level 7
	.long	0	; level 8
	.long	0	; level 9
	.long	0	; level 10
	.long	0	; level 11
	.long	0	; level 12
	.long	0	; level 13
	.long	0	; level 14
	.long	0	; level 15
	.long	0	; level 16
	.long	0	; level 17
	.long	0	; level 18
	.long	0	; level 19
	.long	3	; level 20
	.long	4	; level 21
	.long	5	; level 22
	.long	7	; level 23
	.long	7	; level 24
	.long	7	; level 25
	.long	7	; level 26
	.long	7	; level 27
	.long	7	; level 28
	.long	7	; level 29
	.long	7	; level 30
	.long	7	; level 31

	align_branch_target
	.endc 	

;
;	End of Medulla-specific HW interrupt handling. 
;
     .endc     	

	.if ne <medulla_system & lca4> ! cortex_system
; Routines and tables shared between medulla and cortex

     medu$setup_ints_vic:
	;
	; Enable/disable interrupts for Medulla at the VIC
	;
	;	We set/clear the int enables at the VIC using
	;	the enabled mask bits.  This is only called from the
	;	IntEnable and IntDisable routines.
	;
	; Entry:
	;	R13 is return PC
	; Exit:
	;	VIC/VIP enables updated
	;
	sget_addr r12, pal$impure_base, r31		; Base of scratch area
	.if ne medulla_system
	ldq/p	r14, medu$q_enabled_ints_mask(r12)	; mask of enabled ints
        .iff
	ldq/p	r14, cortex$q_enabled_ints_mask(r12)	; mask of enabled ints
	.endc

	; setup VIC LIRQ 1-7
 	srl	r14, #IMASK$V_VIC_LIRQ2, r12	; VIP Location Monitor
	lda	r15, ^x95(r31)			; disable
	blbc	r12, 18$			; br if not to set
	lda	r15, ^x15(r31)			; enable, ipl 5
18$:	medu$pci_vme_addr       VIC$B_LICR2	; addr to r12
	stl/p   r15, (r12)			; setup int
	mb					; flush wb & stop merges

	.if ne	medulla_system
	srl	r14, #IMASK$V_VIC_LIRQ3, r12	; Periodic RT Timer
	lda	r15, ^xb7(r31)			; disable
	blbc	r12, 19$			; br if not to set
	lda	r15, ^x37(r31)			; enable, ipl 7
19$:	medu$pci_vme_addr       VIC$B_LICR3	; addr to r12
	stl/p   r15, (r12)			; setup int
	mb					; flush wb & stop merges
	.endc

	srl	r14, #IMASK$V_VIC_LIRQ7, r12	; VIP Errors
	lda	r15, ^x97(r31)			; disable
	blbc	r12, 23$			; br if not to set
	lda	r15, ^x17(r31)			; enable, ipl 7
23$:	medu$pci_vme_addr       VIC$B_LICR7	; addr to r12
	stl/p   r15, (r12)			; setup int
	mb					; flush wb & stop merges

	; setup VME IRQ 1-7
	srl	r14, #IMASK$V_VME_IRQ1, r12	; VME IRQ 1
	lda	r15, ^x83(r31)			; disable
	blbc	r12, 25$			; br if not to set
	lda	r15, ^x03(r31)			; enable, ipl 3
25$:	medu$pci_vme_addr       VIC$B_VICR1	; addr to r12
	stl/p   r15, (r12)			; setup int
	mb					; flush wb & stop merges

	srl	r14, #IMASK$V_VME_IRQ2, r12	; VME IRQ 2
	lda	r15, ^x83(r31)			; disable
	blbc	r12, 26$			; br if not to set
	lda	r15, ^x03(r31)			; enable, ipl 3
26$:	medu$pci_vme_addr       VIC$B_VICR2	; addr to r12
	stl/p   r15, (r12)			; setup int
	mb					; flush wb & stop merges

	srl	r14, #IMASK$V_VME_IRQ3, r12	; VME IRQ 3
	lda	r15, ^x83(r31)			; disable
	blbc	r12, 27$			; br if not to set
	lda	r15, ^x03(r31)			; enable, ipl 3
27$:	medu$pci_vme_addr       VIC$B_VICR3	; addr to r12
	stl/p   r15, (r12)			; setup int
	mb					; flush wb & stop merges

	srl	r14, #IMASK$V_VME_IRQ4, r12	; VME IRQ 4
	lda	r15, ^x84(r31)			; disable
	blbc	r12, 28$			; br if not to set
	lda	r15, ^x04(r31)			; enable, ipl 4
28$:	medu$pci_vme_addr       VIC$B_VICR4	; addr to r12
	stl/p   r15, (r12)			; setup int
	mb					; flush wb & stop merges

	srl	r14, #IMASK$V_VME_IRQ5, r12	; VME IRQ 5
	lda	r15, ^x84(r31)			; disable
	blbc	r12, 29$			; br if not to set
	lda	r15, ^x04(r31)			; enable, ipl 4
29$:	medu$pci_vme_addr       VIC$B_VICR5	; addr to r12
	stl/p   r15, (r12)			; setup int
	mb					; flush wb & stop merges

	srl	r14, #IMASK$V_VME_IRQ6, r12	; VME IRQ 6
	lda	r15, ^x84(r31)			; disable
	blbc	r12, 30$			; br if not to set
	lda	r15, ^x04(r31)			; enable, ipl 4
30$:	medu$pci_vme_addr       VIC$B_VICR6	; addr to r12
	stl/p   r15, (r12)			; setup int
	mb					; flush wb & stop merges

	srl	r14, #IMASK$V_VME_IRQ7, r12	; VME IRQ 7
	lda	r15, ^x86(r31)			; disable
	blbc	r12, 31$			; br if not to set
	lda	r15, ^x06(r31)			; enable, ipl 6
31$:	medu$pci_vme_addr       VIC$B_VICR7	; addr to r12
	stl/p   r15, (r12)			; setup int
	mb					; flush wb & stop merges

	; setup extra ints
	srl	r14, #IMASK$V_VIC_DMA_STAT, r12	; VIC DMA Status
	lda	r15, ^x87(r31)			; disable
	blbc	r12, 36$			; br if not to set
	lda	r15, ^x07(r31)			; enable, ipl 7
36$:	medu$pci_vme_addr       VIC$B_DMASICR	; addr to r12
	stl/p   r15, (r12)			; setup int
	mb					; flush wb & stop merges

	srl	r14, #IMASK$V_VIC_VME_IACK, r12	; VIC VME IACK
	lda	r15, ^x83(r31)			; disable
	blbc	r12, 37$			; br if not to set
	lda	r15, ^x03(r31)			; enable, ipl 3
37$:	medu$pci_vme_addr       VIC$B_IICR	; addr to r12
	stl/p   r15, (r12)			; setup int
	mb					; flush wb & stop merges

	;error group bits 40/SYSFAIL, 41/ARBTMO, 42/WRPOST, 43/ACFAIL
	srl	r14, #<IMASK$V_VIC_ERR_SYSFAIL-4>, r15 ; position bits for reg
	and	r15, #^xf0, r15			; keep only ERR bits
	xor	r15, #^xf7, r15			; flip ERR bits, add VIC-IPL 7
	medu$pci_vme_addr       VIC$B_EGICR	; addr to r12
	stl/p   r15, (r12)			; setup ints
	mb					; flush wb & stop merges

	;bits 44-47, IPC local 0-4
	srl	r14, #<IMASK$V_VIC_ICMS0-4>, r15 ; position bits for register
	and	r15, #^xf0, r15			; keep only ICMS bits
	xor	r15, #^xf7, r15			; flip ICMS bits, add VIC-IPL 7
	medu$pci_vme_addr       VIC$B_ICMSICR	; addr to r12
	stl/p   r15, (r12)			; setup ints
	mb					; flush wb & stop merges

	;bits 48-51, IPC Global 0-4
	srl	r14, #<IMASK$V_VIC_ICGS0-4>, r15 ; position bits for register
	and	r15, #^xf0, r15			; keep only ICGS bits
	xor	r15, #^xf7, r15			; flip ICGS bits, add VIC-IPL 7
	medu$pci_vme_addr       VIC$B_ICGSICR	; addr to r12
	stl/p   r15, (r12)			; setup ints
	mb					; flush wb & stop merges

	ret	r31, (r13)				; go home



;
; Translate VIC ipl to VMS IPL
;
medu$q_vic_to_vms_ipl:

	.long	0	; level 0
	.long	20	; level 1
	.long	20	; level 2
	.long	20	; level 3
	.long	21	; level 4
	.long	22	; level 5
	.long	23	; level 6
	.long	23	; level 7

	align_branch_target
	.endc
; End of routines and tables shared between medulla and Cortex



	.if ne	lean_system ! mtu_system
;
; Machine Check Frame builder for lca4 based products in the APS space.  These
; include Burns, Lean, and Noname.  This is cut and past of the
; main line code which does not get used unles it is an adu system.  I have
; removed all references to ADU and LCA for this code.  The main line code has
; also been changed so that r13 is not set up on entry and all registers here
; are as they appear in the main line code.  This cannot be used if you are
; using the sable/cobra handler.
;

lean_build_error_frame::
	mt	r31, alt_mode		; make sure altmode is KERNEL mode
	mf	r0, pt25		; go get mchk flag
	srl	r0, #pt25$v_mck, r1	; get mces to <0>
	blbc	r1, 10$			; continue, if no mchk's in progress

	lda	r0,<hlt$c_DBL_MCHK>(r31); set halt code
	mt	r3, pt5			; save old mchk code in pt5
	br	r31, pal$error_halt

10$:	ldah	r1, <1@<pt25$v_mck-16>>(r31); get new mces flag
	or	r0, r1, r0		; set mchk in progress flag
	mt	r0, pt25		; save it in the chip

	; fetch mchk impure area ptr
	get_addr r1, <pal$logout_base + laf$base>, r31; offset to logout area

	lda	r0, laf$exc_addr(r31) 	; cpu offset
	stl/p	r0, laf$off(r1) 	; set offset
	lda	r0, laf$plt0(r31) 	; sys offset
	stl/p	r0, <laf$off+4>(r1) 	; set offset

	lda	r0, laf$size(r31) 	; build flag
	stl/p	r0, laf$flag(r1) 	; set flag

	zapnot	r3, #^xf, r0		; get mchk code
	cmpeq	r0, #MCHK$C_ICPERR, r0	; was error i cache parity error?
	sll	r0, #31, r0		; retryable if ic parity error, pos it

	stl/p	r0, <laf$flag+4>(r1)	; set retry flag

	srl	r3, #32, r0		; get saved dc_stat (if any)
	stq/p	r0, <laf$dc_stat>(r1)	; save to logout area

	zap	r3, #^xf0, r3		; remove dc_stat from error code
	or	r31, #1, r0		; get a one
	sll	r0, #32, r0		; get an mchk rev level
	or	r3, r0, r3		; merge rev level and mchk code
	stq/p	r3, <laf$pt0>(r1)	; set error code into save pt0

	.macro	movr lax, reg n
	   .if nb "n"
	     mf	r0, 'reg''n'
	     stq/p r0, 'lax'$'reg''n'(r1)
	  .iff
	     mf	r0, 'reg'
	     stq/p r0, 'lax'$'reg'(r1)
	  .endc
	.endm

	.if ne lca4
	.macro	movcsr lax, cntlr, name
	  ldq/p	r13, <'cntlr'$q_'name'>(r14)
	  stq/p r13, 'lax'$q_'name'(r1)
	.endm
	.endc

	t = 1
	.repeat 31
	movr	laf, pt \t
	t = t + 1
	.endr
	

	; check for pending arith exceptions
	mt	r12, pt12
	mt	r13, pt13
	mt	r14, pt14
	mt	r15, pt15
	mt	r1,  pt4
	pvc$jsr	armc, bsr=1
	bsr	r12, arith_and_mchk	; go check for and deal with arith

	mf	r1,  pt4
	movr	laf, pt9		; propagate ps, from arith

	movr	laf, exc_addr
;	movr	laf, exc_sum
;	movr	laf, exc_msk
;	movr	laf, iccsr
	movr	laf, pal_base
	movr	laf, hier
	movr	laf, hirr
	movr	laf, mm_csr
	ldq/p	r0, <laf$dc_stat>(r1)	; fetch possibly saved dc_stat
	bne	r0, 15$			; skip save, if already saved
	movr	laf, dc_stat
15$:	movr	laf, dc_addr

	mf	r13, pt7		; address of impure

	;
	; Get the address to use to build the frame.
	;

	ldq/p	r0, cns$abox_ctl(r13)		; get current abox_ctl
	stq/p	r0, laf$abox_ctl(r1)		; pass it
	get_high_addr r14, mem$csr_base
	movcsr	laf, mem, ear
	movcsr	laf, mem, esr
	stq/p	r13, mem$q_esr(r14)
	movcsr	laf, mem, car
	get_high_addr r14, ioc$csr_base
	movcsr	laf, ioc, stat1
	movcsr	laf, ioc, stat0
	stq/p	r13, ioc$q_stat0(r14)
	assume	<cns$size-<las$size+laf$size>> gt 0 ; la size too big

.if ne lean_system
1555$:	 mf	r13, hirr		; get hardware interrupt mask's
	srl	r13, hirrr$v_ierr, r13
	blbs	r13, 1555$
.endc



	; set up the km trap, via interrupt completion

	lda	r14, laf$base(r31)	; LAOFF

	mf	r0, pt0
	mf	r1, pt1
	mf	r3, pt3
	mt	r31, pt3		; set not from rei flag

	lda	r13, scb$v_procmchk(r31); trap is mchk
	or	r31, #31, r15		; set new ipl to 31
	stall	1
	br	r31, complete_interrupt	; and go to post interrupt processor
	.endc


.if ne lca4
.sbttl ERROR_INT - LCA memory controller/IO controller interrupt
;+
;-
	align_to_cache_block
pal$error_interrupt:
	trace_pc	<error_interrupt_detected>
	srl	r13, #hirrr$v_ierr, r13	; put IERR in low bit
	get_high_addr r12, mem$csr_base
	ldq/p	r14, mem$q_esr(r12)	; load esr
	lda	r15, esr$m_err_not_cee(r31)	;
	and	r14, r15, r15		; correctable?...
	cmovlbs r13, r13, r15		; put non-zero in r15 if IOC int
	beq	r15, pal$crd_interrupt	; ...yes - CRD interrupt
	mf	r15, exc_addr		; Fixup the exc_addr so that it is...
	addq	r15, #4, r15		; ...correct after process_mchk...
	mt	r15, exc_addr		; ...decrements it
	mf	r12, pt12		; restore regs
	mf	r13, pt13
	mf	r14, pt14
	mf	r15, pt15
	; now set up to go to mchk
	mt	r31, alt_mode		; make sure altmode is KERNEL mode
	mt	r0, pt0			; save r0
	br	r31, pal$process_mchk	; go to machine check
.endc



.sbttl	CRD_INT	- CRD CACK_SOFT or CRD interrupt handler

;+
;
; A external soft error interrupt or CRD has been detected
; build the frame and post the interrupt
;
;-

	align_to_cache_block		; align for branch target
pal$crd_interrupt:
	trace_pc	<crd_interrupt_detected>
	.if ne	generic_system
	pvc$violate	1003
	halt				; Interrupts off, we never get here
	.endc
	.if ne	sable_system
	mf	r12, biu_stat		; Save BIU_STAT
	mt	r12, pt20		;
	mf	r12, biu_addr		; Save BIU_ADDR
	mt	r12, pt21		;
	.if ne	sable_system_debug
	mt	r16, pt16
	mt	r17, pt17
	mt	r18, pt18
	mt	r19, pt19
	combo_setup
	combo_lock
	combott_putc	<^x0d>
	combott_putc	<^x0a>
	combott_putc	<^x0d>
	combott_putc	<^x0a>
	combott_putc	<^x37>
	mf	r16, pt27
	addq	r16, #48, r16
	combott_putc	r16
	combott_putc	<^x3c>
	mf	r16, exc_addr
	combott_puth
	combott_putc	<^x2f>
	mf	r16, pt20
	combott_puth
	combott_putc	<^x2f>
	mf	r16, pt21
	combott_puth
	combott_putc	<^x2f>
	mf	r16, fill_syndrome
	combott_puth	4
	combott_putc	<^x2f>
	mf	r12, pt27
	lda	r12, ^x380(r12)
	sll	r12, #24, r12
	ldq/p	r16, ^x020(r12)
	combott_puth
	combott_putc	<^x3e>
	combott_putc	<^x0d>
	combott_putc	<^x0a>
	combo_unlock
	mf	r16, pt16
	mf	r17, pt17
	mf	r18, pt18
	mf	r19, pt19
	.endc

pal$crd_interrupt_from_mchk:
	;
	; For Sable, we can only get here if there was a correctable
	; ECC error (external soft error interrupts are not implemented).
	;
	mf	r12, pt25		; Get flags
	srl	r12, #pt25$v_pce, r12	; Get logging blocked flag
	blbc	r12, 10$		; It's clear
	mf	r13, fill_addr		; Not logging, so just get FILL_ADDR
	br	r31, 30$		;  and scrub the error

.macro	mchk$store	n
	mf	r14, 'n'
	stq/p	r14, mchk$pc_'n'(r15)
.endm

10$:	lda	r15, pal$logout_base(r31) ; Get logout base address
	lda	r14, pal$logout_specific_size(r31) ; Load CPU-specific size
	mf	r12, pt27		; Get WHAMI
	mulq	r12, r14, r12		;
	addq	r15, r12, r15		; Point to CPU-specific area

	;
	; Start building the frame.
	;
    	stq/p	r31, mchk$pc_byte_count(r15) ; Zero count just in case

	;
	; Store error code and revision.
	;
	lda	r12, 1(r31)		; Get revision
	sll	r12, #32, r12		;
	lda	r14, mchk$c_ecc_c(r12)	; Get error code
	stq/p	r14, mchk$pc_mchk_code(r15) ; Save it

	;
	; Store EV4 IPRs.
	;
	mf	r13, pt7		; Get impure area pointer
;;;	mchk$store  biu_stat		;
	mf	r14, pt20		; BIU_STAT is in PT20
	stq/p	r14, mchk$pc_biu_stat(r15) ;
;;;	mchk$store  biu_addr		; Unlocks BIU_STAT
	mf	r14, pt21		; BIU_ADDR is in PT21
	stq/p	r14, mchk$pc_biu_addr(r15) ;
;;;	mchk$store  biu_ctl		;
	ldq/p	r14, cns$biu_ctl(r13)	;
	stq/p	r14, mchk$pc_biu_ctl(r15) ;
	mchk$store  fill_syndrome	;
	mchk$store  fill_addr		; Unlocks FILL_SYNDROME

	;
	; Pull BC_TAG the hard way.
	;
	or	r31, r31, r14		; Clear BC_TAG-to-be
	or	r31, r31, r12		; Start with bit 0
20$:	mf	r13, bc_tag		; Read next bit of BC_TAG
	and	r13, #1, r13		; Make sure to keep just the lowest bit
	sll	r13, r12, r13		; Position that bit correctly
	bis	r14, r13, r14		; Add in the new bit
	addq	r12, #1, r12		; Count up one bit
	cmpeq	r12, #64, r13		; See if we've done all 64 bits
	beq	r13, 20$		; Branch back if not all done yet
	stq/p	r14, mchk$pc_bc_tag(r15) ; Store nice new BC_TAG value
	mt	r31, bc_tag		; Unlocks BC_TAG

	;
	; Set up byte count and offsets.
	;
	lda	r14, mchk$pc_cpu_offset(r31) ; Build the offsets
	stl/p	r14, mchk$pc_offsets+0(r15) ;
	lda 	r14, mchk$pc_sys_offset(r31) ;
	stl/p	r14, mchk$pc_offsets+4(r15) ;
	lda 	r14, mchk$pc_mchk_size(r31) ; Get machine check size
	lda	r12, 1(r31)		; Set retry flag
	sll	r12, #63, r12		;
	or	r14, r12, r14		;
	stq/p	r14, mchk$pc_byte_count(r15) ; Store byte count
	ldq/p	r13, mchk$pc_fill_addr(r15) ; Retrieve this for scrubbing

30$:	mt	r16, pt16		; Save R16 and R17
	mt	r17, pt17		;
	pvc$jsr 	vscrub, bsr=1
	bsr	r12, scrub_mem		; Scrub memory
	mf	r16, pt16		; Restore R16 and R17
	mf	r17, pt17		;

	ornot	r31, #1@sl_clr$v_crd, r13 ; Get acknowledge bit for CRDs
	mt	r13, sl_clr		; Clear it

	mf	r15, pt25		; Get flags
	ldah	r14, 1@<pt25$v_dpc-16>(r31) ; Get DPC
	and	r15, r14, r13		; Is logging enabled?
	bne	r13, dismiss_interrupt	; Nope
	ldah	r14, 1@<pt25$v_pce-16>(r31) ; Get PCE
	and	r15, r14, r13		; Is PCE in progress?
	bne	r13, dismiss_interrupt	; Nope
	or	r15, r14, r15		; Set PCE in progress
	mt	r15, pt25		;  and save it in the chip

	lda	r13, scb$v_procerr(r31)	; Get vector offset
	lda	r14, mchk$pc_byte_count(r31) ; Set offset for R4
	lda	r15, ^x1f(r31)		; Set IPL
	br	r31, complete_interrupt	; Go build trap
	.iff
	mt	r16, pt16		; get more scratch regs
	.if eq lca4
	mf	r16, biu_stat		; so, why are we here?
	srl	r16, #fill$v_ecc, r16	; get ECC bit to <0>
	and	r16, #1, r16		; isolate it
	.endc

	mf	r12, pt25		; go get mchk flag
	srl	r12, #pt25$v_sce, r12	; get logging blocked flag
	and	r12, #3, r12		; check for pce/sce
	.if ne lca4
	or	r31, #1, r16		; ecc error
	bne	r12, 30$		; log?
	.iff
	beq	r12, 10$		; nope, build frame
	mf	r13, fill_addr		; yes, get fill addr
	br	r31, 30$		; and scrub the error
	.endc

10$:	get_addr r12, <pal$logout_area+las$base>, r31; address of logout area
	lda	r13, las$biu_stat(r31) 	; cpu offset
	stl/p	r13, las$off(r12) 	; set offset
	subq	r31, #1, r13		; sys offset
	stl/p	r13, <las$off+4>(r12) 	; set offset


	lda	r13, las$size(r31) 	; build flag
	stl/p	r13, las$flag(r12) 	; set flag

	or	r31, #1, r13		; get retry flag
	sll	r13, #31, r13		; move to position
	stl/p	r13, <las$flag+4>(r12)	; set and retry flag


	or	r31, #1, r14		; get a one
	sll	r14, #32, r14		; make it an mchk rev level
	lda	r13, mchk$c_ecc_c(r14)	; get error code
	lda	r14, mchk$c_cacksoft(r14); get error code
	cmovlbc	r16, r14, r13		; select correct error code
	stq/p	r13, <las$mchk_code>(r12); set error code



	.macro	movr lax, reg
	   mf	r13, 'reg'
	   stq/p r13, 'lax'$'reg'(r12)
	.endm

	.if ne lca4
	.macro	movcsr lax, cntlr, name
	  ldq/p	r13, <'cntlr'$q_'name'>(r14)
	  stq/p r13, 'lax'$q_'name'(r12)
	.endm

	get_high_addr r14, mem$csr_base
	movcsr	las, mem, ear
	movcsr	las, mem, esr
	movr	las, dc_stat
	get_high_addr r14, ioc$csr_base
	movcsr	las, ioc, stat1
	movcsr	las, ioc, stat0
	.iff
	movr	las, biu_stat
	movr	las, biu_addr
	movr	las, dc_stat
	movr	las, fill_syndrome
	movr	las, fill_addr

	or	r31, r31, r14		; init counter
	or	r31, r31, r13		; start with no bits set
20$:	mf	r15, bc_tag		; get next bit of bc_tag
	sll	r15, r14, r15		; move current mask over by one
	or	r15, r13, r13		; set this bit in mask
	addq	r14, #1, r14		; inc counter
	cmplt	r14, #64, r15		; are we done?
	blbs	r15, 20$		; loop till done

	mt	r31, bc_tag		; unlock bc_tag
	stq/p	r13, las$bc_tag(r12)	; and salt it away

	ldq/p	r13, las$fill_addr(r12)	; get the fill addr
	.endc

30$:	.if ne lca4
	get_high_addr r13, mem$csr_base
	ldq/p	r12, mem$q_ear(r13)	; get address of memory error
	ldq/p	r14, mem$q_esr(r13)
	stq/p	r14, mem$q_esr(r13)	; unlock
	.if ne	medulla_system
	mb				; flush write buffer
	.endc
	sll	r12, <63 - ear$v_mux1>, r13 ; clean off perf count mux1 bits
 	srl	r13, <63 - ear$v_mux1>, r13
	.endc
	blbc	r16, 40$		; skip scrub if sce
	mt	r17, pt17		; save r17
	pvc$jsr vscrub, bsr=1
	bsr	r12, scrub_mem
	or	r31, #1, r16		; restore r16 (known, was 1)
	mf	r17, pt17

40$:	.if eq lca4
	subq	r31, #1, r12		; get a -1
	lda	r15, <1@sl_clr$v_crd>(r31); get ack bit for crd
	bic	r12, r15, r12		; set ack mask (write 0 to clear)
	mt	r12, sl_clr		; ack the crd interrupt
	.endc

	or	r16, r31, r12		; move ecc flag to r12
	mf	r16, pt16
	mf	r15, pt25		; go get mchk flag
	ldah	r14, <1@<pt25$v_dsc-16>>(r31); get dsc flag
	srl	r14, r12, r14		; move for dsc/dpc
	and	r15, r14, r14		; is loging enabled
	bne	r14, dismiss_interrupt	; no
	ldah	r14, <3@<pt25$v_sce-16>>(r31); get sce flag
	and	r15, r14, r13		; is loging blocked?
	bne	r13, dismiss_interrupt	; yes
	ldah	r14, <1@<pt25$v_sce-16>>(r31); get sce flag
	sll	r14, r12, r14		; move for pce/sce
	bis	r15, r14, r15		; set pce or sce error
	mt	r15, pt25		; save it in the chip

	lda	r13, scb$v_procerr(r31)	; set scb vector
	lda	r15, scb$v_syserr(r31)	; set scb vector
	cmovlbc	r12, r15, r13		; select sys vs proc
	or	r31, #20, r15		; set ipl
	or	r31, #31, r14		; set ipl
	cmovlbs	r12, r14, r15		; select sys vs proc ipl
	lda	r14, las$base(r31)	; LAOFF
	stall	1
	br	r31, complete_interrupt; go build trap

	.endc



.sbttl	NOINT	- Interrupt went away

;+
;
; for what ever reason, the interrupt went away...
; rei, and and forget that it ever happened.
; Hey, leave me along, ok.
;
;-
	.align	quad
dismiss_interrupt:			; 7 cycles
	trace_pc	<interrupt_dismissed>
	mf	r15, pt3		; check for flow from rei
	 mf	r12, pt12
	mf	r13, pt13
	 mf	r14, pt14
	bne	r15, 10$		; br if from rei
	 mf	r15, pt15
	hw_rei

10$:	 subq	r15, #1, r15		; get current ps back
	mt	r15, pt9_ps		; and set it back to the old
	 mf	r15, pt15
	br	r31, pal$rei		; retry the rei...

	END_HW_VECTOR	INTERRUPT



.sbttl	DTB_FAULT - Dstream MM Fault entry

;+
;addr	len	use
;----	---	------------------------------
;01E0	128	DTB_FAULT
;
; Entry:
;	Vectored into via hardware dispatch when d-stream fault occurs.
;
; Function:
;	Weed out reason for fault
;	ignore faults on FETCH, FETCH_M if called from non-pal
;	Weed out faults while in pal
;	Build stack frame
;	Dispatch through SCB
;
; regs:
; 	r20, mm_csr
;	r21, exc_addr
;	r22, scratch
;
;	KM stack builder wants:
;
;
;	pt12 has saved r12
;	pt13 has saved r13
;	pt14 has saved r14
;	pt15 has saved r15
;
;	r12 PC
;	r13 has SCB offset
;	r14 has new_R4 (VA)
;	r15 has new_R5 (MMF)
;
; If dfault while in pal, we exit to dfault_in_pal, with
; PT20,21 <- r20, 21
; R21 = exc_addr
; R20 = mm_csr
;
;
;
; If access was a fetch[m], we exit to dfetch_err, with
; PT20,21,12-15 <- r20,21,12-15
; R12 = exc_addr
;
;
;
;
;-

	START_HW_VECTOR	DTB_FAULT	; 21 cycles, normal flow
	mt	r21, pt21		;
	 mf	r21, exc_addr		; get addr of exception
	mt	r20, pt20		; Save reg
	 mf	r20, mm_csr		; get mmcsr <opc> <0> read=0, write=1
	blbs	r21, dfault_in_pal	; dfault, while in PAL
	 mt	r12, pt12		; save r12

	; at this point, we know we are not attempting to recover from a
	; fault while in pal, so there are more pt's available for our use
	; and we start getting ready for the call to the builder
	mt	r13, pt13		; save r13
	 srl	r20, #mmcsr$v_opc, r13	; shift opc to <0>
	or	r21, r31, r12		; set up faulting pc
	 mt	r14, pt14		; save r14
	mt	r15, pt15		; save r15
	 cmpeq	r13, #EVX$OPC_SYNC, r15	; is it FETCH/FETCH_M?
	or	r20, r31, r14		; move mmcsr to r14
	 blbs	r15, dfault_fetch_err	; yes

	; at this point we are commited to calling the stack frame builder
	; for an exception initiated by non-pal
	; so we switch over to useing regs that the stack builder is
	; allowd to user..


	lda	r13, SCB$V_ACV(r31)	; Assume ACV
	 and	r14, #mmcsr$m_acv, r20	; isolate ACV bit
	beq	r20, 10$		; was not ACV, go figure out FOR/FOW

	 sll	r14, #63, r15		; set mmf
	mf	r21, pt21
	 mf	r14, va			; get va
	mf	r20, pt20
	 mt	r14, pt16
	mf	r14, pt14
	 mt	r15, pt17
	mf	r15, pt15
	 br	r31, pal$post_km_trap	; go post the trap
	

	align_to_cache_block
10$:	lda	r13, SCB$V_FOW(r31)	; Assume FOW
	 and r14, #mmcsr$m_for, r20	; isolate FOR bit
	cmovne	r20, #SCB$V_FOR, r13	; was it FOR?
	 sll	r14, #63, r15		; set mmf
	mf	r21, pt21
	 mf	r14, va			; get va
	mf	r20, pt20

	 mt	r15, pt17
	mf	r15, pt15
	 mt	r14, pt16
	mt	r14, dtbis		; clear the tb, watch BYPASS into TBIS
	stall	1
	 mf	r14, pt14
	br	r31, pal$post_km_trap	; go post the trap



;+
;
; If dfault while in pal, we exit to dfault_in_pal, with
; PT20,21 <- r20, 21
; R20 = mm_csr
; R21 = exc_addr
;
; and dispatch to handle special exception with
;   pt0,1,20-23 <- r0,1,20-23
;
;	R20 = VA of current exception
;	R21 = junk with l3 marker set.
;	R22 = MMF
;	R23 = scb offset for this fault
;
;-

	align_to_cache_block		; align for branch target
dfault_in_pal:				; 10 cycles
	mt	r1,  pt1
	 or	r20, r31, r1		; get trap flags
	mt	r22, pt22
	 sll	r20, #63, r22		; set mmf
	mt	r23, pt23
	 ldah	r21, <<1@pte$v_soft>+32768>@-16(r31); get marker for level 3 errors
	mf	r20, va			; get va
	 lda	r23, SCB$V_ACV(r31)	; Assume we will take FOR
	mt	r0,  pt0
	 and	r1, #mmcsr$m_acv, r0	; Is it acv?
	bne	r0, pal$special_exception; handle the special exception
	 and	r1, #mmcsr$m_for, r0	; Is it for?
	cmovne	r0, #SCB$V_FOR, r23	; set if yes
	 and	r1, #mmcsr$m_fow, r0	; Is it for?
	cmovne	r0, #SCB$V_FOW, r23	; set if yes
	 mt	r20, dtbis		; clear the tb, watch BYPASS into TBIS
	br	r31, pal$special_exception; go handle special exception

	
	ASSUME MMCSR$V_WR EQ 0




.sbttl	SPECIAL_EXCEPTION - Special exception handler

;+
;
; PAL$SPECIAL_EXCEPTION
;
; We get here if we take a memory managment exception while in palcode
;
; Function:
; 	Scan for a special handler for this exception pc.
;	If found, dispatch to the special handler.
;	If none found, a fatal error has occured, and continuation is
;	not possible.
; on input
;   pt0,1,20-23 <- r0,1,20-23
;
;	R20 = VA (or PC) of current exception
;	R21 = pte or junk with l3 marker set.
;	R22 = MMF
;	R23 = scb offset for this fault
; exc_addr has pc of this fault
;

	align_to_cache_block	; align for branch target
PAL$SPECIAL_EXCEPTION::
	mf	r1, exc_addr		; get addr of exception
	 bic	r1, #3, r1		; clear bit 1
	mf	r0, pal_base		; get pal_base
	 subq	r0, r1, r1		; now is pal -offset
	sra	r1, #2, r1		; is pal - offset /4
	
	pal_special_handler  pal$itb_miss_ldq,	pal$itb_miss_ldq_error
	pal_special_handler  pal$ndtb_miss_ldq,	pal$ndtb_miss_ldq_error
	pal_special_handler  pal$rei_ldq,	pal$rei_ldq_error
	pal_special_handler  pal$prober_ldl1,	pal$prober_fault
	pal_special_handler  pal$probew_ldl1,	pal$probew_fault
	pal_special_handler  pal$post_xm_ps_trap_stq, pal$post_sp_not_valid
	pal_special_handler  pal$prober_ldl2,	pal$prober_fault
	pal_special_handler  pal$probew_ldl2,	pal$probew_fault
	pal_special_handler  pal$post_km_trap_stq, pal$post_kmsp_not_valid3
	pal_special_handler  pal$post_km_trap_nr45_stq, pal$post_kmsp_not_valid3
	pal_special_handler  pal$post_km_ps_trap_stq, pal$post_kmsp_not_valid2
	pal_special_handler  pal$post_chmk_trap_stq, pal$post_kmsp_not_valid4
	pal_special_handler  pal$post_chme_trap_stq, pal$post_chme_sp_not_valid

	get_addr r1, <pal$end-pal$start>, r31	; get max addr for quick check
	mf	r0, pt3				; get handler offset
	zap	r0, #^xF0, r0			; ignore upper 32b
	cmpule	r1, r0, r1			; is handler out of range?
	blbs	r1, pal$mchk_bugchk		; yup, die... pal bug

	mf	r1, pal_base
	addq	r0, r1, r0
	bic	r0, #3, r0			; clear pc<1:0> for mchks
	pvc$jsr	spec
	jmp	r31, (r0)			; and off to the specific handler



;+
;
; we come here if we are erring on a dfault, and the instr is a
; fetch or fetch_m
; the PC is incremented, and we return to the program.
; essentially ignoreing the instruction and error.
; If access was a fetch[m], we enter dfetch_err, with
; PT20,21,12-15 <- r20,21,12-15
; R12 = exc_addr
; R22 = mm_csr
;
;-

	.iif eq <ev4_pass3>, CONT_HW_VECTOR	 DTB_FAULT
	.align	quad
dfault_fetch_err:			; 9 cycles
	mf	r14, va			; unlock va/mmcsr
	 addq	r12, #4, r12		; bump pc to pc+4
	mf	r21, pt21		; restore the regs
	 mt	r12, exc_addr 		; store that pc to rei to
	mf	r12, pt12
	 mf	r13, pt13
	mf	r14, pt14
	 mf	r15, pt15
	mf	r20, pt20
	 hw_rei				; go back and try access



	END_HW_VECTOR	DTB_FAULT

.sbttl	NDTB_MISS - PALcode routine for native Data TB miss

;+
;
;addr	len	use
;----	---	------------------------------
;8E0	 64	NData TB miss
;
; Entry:
;	Vectored into via hardware dispatch when d-stream tb miss occurs.
;	This is only called by non-pal references
;
; Function:
;	Get PTE for VA being referenced. If valid then 
;	load into TB and continue. If not valid then
;	take TNV/ACV exception.
;
; Input's
;	PT29	= l3virt
;	VA
;	EXC_ADDR
;	MMCSR
;
; across ldl
;	R3, 4,5 saved in PT3, 4,5
;	PT6	<- va of this miss
;	R3	<- pc of this miss
;	R5	<- mmcsr of this miss
;
; error exit's
;	br l3_dpte_inv if ldl ok, but pte bad
;	with
;	R3, 4,5 saved in PT3, 4,5
;	R3	 = va
;	R4	 = pte
;	R5	 = mm_csr
;	exc_addr = pc
;
; Low level PDTB_miss routine, may also cause errors.
;
;-

	START_HW_VECTOR	NDTB_MISS,LONGFLOW=1; 22 cycles
	mt	r3, pt3			; Get some scratch space
	 mf	r3, va 			; Get va of reference that missed
	mt	r4, pt4
	 mf	r4, pt29
	mt	r3, pt6			; save va if error in ld of pte
	 sll	r3, #<64-43>, r3	; clean out sign extenion 
	mt	r5, pt5			
	 stall	1, mxpr=0		; stall for scheduling
	srl	r3, #<<64-43>+10>, r3	; make bits 32:0 of va of pte
	 .if eq enable_physical_console
	 stall	1
	 .iff
	 blbs	r4, pal$physical_ndtb	; go map va=pa if requested
	 .endc
	mf	r5, mm_csr		; Get mmcsr in case of error
	 or	r3, r4, r4		; form address
	mf	r3, exc_addr		; get execp address in case tb miss
pal$ndtb_miss_ldq::
	pvc$violate	1005		; This is one of the 2 that are legal
	 ldq/a	r4, (r4)		; get pte
	mt	r3, exc_addr		; restore excep address 

	.if ne virtualize_memory
	  mt	r0, pt0
	  mf	r0, pt8
	  srl	r4, #<20+32>, r3	; get IO space indicator from PFN
	  cmovne r3, R31, r0		; if IO space, don't virtualize
	  sll r0, #32-page_offset_size_bits, r0; turn virt mem offset into pfn addr
	  addq	r4, r0, r4		; bump the pfn
	  mf	r0, pt0
	.endc

	 mf	r3, pt6			; get va
	mt	r3, tb_tag		; Load TB TAG and clear TB valid bit
	 mt	r4, dtb_ctl		; sel large or small page tb
	blbc	r4, l3_ndpte_inv	; Third PTE invalid go sort out TNV/ACV
	 mt	r4, dtb_pte		; Load PTE and set TB valid bit
	mf	r3, pt3			; restore scratch regs
	 mf	r4, pt4
	mf	r5, pt5			
	 hw_rei				; go back and try access



.sbttl	NDTB_ERR - DTB error completion routines for misses from non-PAL
;+
;	come here on level three not valid. This can only happen on a call
;	from non-pal.
;	
;
; Function:
;	Weed out reason for fault, TNV vs ACV
;	ignore faults on FETCH, FETCH_M
;	Build stack frame
;	Dispatch through SCB
; call:
;	with
;	R3, 4,5 saved in PT3, 4,5
;	R3	 = va
;	R4	 = pte
;	R5	 = mm_csr
;	exc_addr = pc
;
;	stack builder wants:
;
;
;	pt12 has saved r12
;	pt13 has saved r13
;	pt14 has saved r14
;	pt15 has saved r15
;
;	r12 PC
;	r13 has SCB offset
;	r14 has new_R4 (VA)
;	r15 has new_R5 (MMF)
;
;
; If access was a fetch[m], we exit to dfetch_err, with
; PT3-5, 12-16 <- r3-5,12-16
;
;
;
;-
	.iif eq <ev4_pass3>, CONT_HW_VECTOR	 NDTB_MISS
	align_to_double_cache_block	; align for branch target
l3_ndpte_inv:				; 15 cycles
	mt	r12, pt12
	 mf	r12, pt9		; get users PS
	mt	r13, pt13
	 srl	r5, #mmcsr$v_opc, r13	; shift opc to <0>
	mt	r14, pt14
	 or	r3, r31, r14		; copy va for builder
	mt	r15, pt15
	 srl	r12, #PS$V_CM, r12	; shift to low bits
	cmpeq	r13, #EVX$OPC_SYNC, r13	; is it FETCH/FETCH_M?
	 and	r12, #<PS$M_CM@-PS$V_CM>, r3; Clean up ps bits
	blbs	r13, nmiss_fetch_err	; yes
	 addq	r3, #pte$V_KRE, r3	; add offset to kre bits
	and	r5, #mmcsr$m_wr, r12	; isolate write bit
	 s4addq	r12, r3, r3		; now offset to CMxe bits
	mf	r12, exc_addr		; failing PC
	 srl	r4, r3, r3		; Get cmxE to <0>
	sll	r5, #63, r15		; mmf
	 mf	r5, pt5
	mf	r4, pt4
	 lda	r13, scb$v_tnv(r31)	; Assume we will take TNV
	cmovlbc r3, #scb$v_acv, r13	; Xre is clear, convert TNV to ACV
	 mf	r3, pt3
	mt	r14, pt16
	 mf	r14, pt14
	mt	r15, pt17
	 mf	r15, pt15
	br	r31, pal$post_km_trap	; and go build the trap


	END_HW_VECTOR	NDTB_MISS


.sbttl	PDTB_MISS - PALcode routine for palcode Data TB miss

;+
;
;addr	len	use
;----	---	------------------------------
;9E0	 512	PData TB miss
;
; Entry:
;	Vectored into via hardware dispatch when d-stream tb miss occurs
;	from within pal
;
;
; Function:
;	Get PTE for VA being referenced. If valid then 
;	load into TB and continue. If not valid then
;	take TNV/ACV exception.

; Input's
;	PT28	= PTBR
;	VA
;	EXC_ADDR
;	MMCSR
;
; uses
;	pt20-23, r20-23
;
;
; error exit's
;	Exit's are to
;		l1_ppte_inv	if the l1 pte is bad
;		l2_ppte_inv	if the l2 pte is bad
;		l3_ppte_inv	if the l3 pte is bad
;
;	with
;	R20-22,[23] saved in PT20-22,[23]
;	R20	 = va
;	R21	 = pte
;	R22	 = junk
;	exc_addr = pc
;
;-

	START_HW_VECTOR	PDTB_MISS	; 34 cycles
	mt	r22, pt22
	 mf	r22, mm_csr		; see why were' here
	mt	r21, pt21
	 lda	r21, <<EVX$OPC_HW_LD@9> ! <4@4>>(r31) ; get id for vtb fills
	mt	r20, pt20		; Get some scratch space
	 stall	1, mxpr=0
	mf	r20, va 		; Get va of reference that missed
	 cmpeq	r22, r21, r21		; is it the vpte fill?
	blbc	r21, not_vpte_tbfill	; nop

	 mf	r21, pt28		; Get address of seg1 page table
	.iif ne virtualize_memory, mt r23, pt23



					; Fetch level 2 PTE
	sll	r20, #<64-<<2*page_seg_size_bits>+page_offset_size_bits>>, r22	; Clean off upper bits of VA
	 srl	r22, #<61-page_seg_size_bits>, r22; Get Va<seg1>*8
	addq	r21, r22, r21		; get address of seg two pte
	 sll	r20, #<64-<<1*page_seg_size_bits>+page_offset_size_bits>>, r22	; Clean off upper bits of VA
	ldq/p	r21, (r21)		; Get second PTE (addr<2:0> ignored)
	 srl	r22, #<61-page_seg_size_bits>, r22; Get Va<seg1>*8
	blbc	r21, l2_ppte_inv	; Second PTE invalid go sort out TNV/ACV


					; Fetch level 3 PTE
	 srl	r21, #32, r21		; extract PFN from pte

	sll	r21, #page_offset_size_bits, r21; get PFN * 2^13 for add to <seg3>*8
	 addq	r21, r22, r21		; get address of seg three pte
	 virtualize r21, r23
	ldq/p	r21, (r21)		; Get third PTE (addr<2:0> ignored)

	.if ne virtualize_memory
	  srl	r21, #<20+32>, r22	; get IO space indicator from PFN
	  cmovne r22, R31, r23		; if IO space, don't virtualize
	  sll r23, #32-page_offset_size_bits, r23; turn virt mem offset into pfn addr
	  addq	r23, r21, r21		; bump the pfn
	.endc

	 mt	r21, dtb_ctl		; sel large or small page tb
	blbc	r21, l3_ppte_inv	; Third PTE invalid go sort out TNV/ACV


					; All is well so far, so load the TB
	 mt	r20, tb_tag		; Load TB TAG and clear TB valid bit
	mt	r21, dtb_pte		; Load PTE and set TB valid bit

	 mf	r20, pt20		; restore scratch regs
	mf	r21, pt21		;
	 mf	r22, pt22		;
	.iif ne virtualize_memory, mf r23, pt23
	hw_rei				; go back and try access




; fill routine, for NON-virtual tb fills. I.e., not from the itb or ndtb miss


	align_to_double_cache_block	; align for branch target
not_vpte_tbfill:
	 mf	r21, pt28		; Get address of seg1 page table
	.iif ne virtualize_memory, mt r23, pt23

					; Fetch level 1 PTE
	 sll	r20, #<64-<<3*page_seg_size_bits>+page_offset_size_bits>>, r22	; Clean off upper bits of VA
	srl	r22, #<61-page_seg_size_bits>, r22; Get Va<seg1>*8
	 .if eq enable_physical_console
	 stall	1
	 .iff
	 blbs	r21, pal$physical_pdtb	; go map va=pa, if requested
	 .endc

	addq	r21, r22, r21		; get address of seg one pte
	 sll	r20, #<64-<<2*page_seg_size_bits>+page_offset_size_bits>>, r22	; Clean off upper bits of VA

	ldq/p	r21, (r21)		; Get first PTE (addr<2:0> ignored)
	 srl	r22, #<61-page_seg_size_bits>, r22; Get Va<seg1>*8
	blbc	r21, l1_ppte_inv 	; First PTE invalid go sort out TNV/ACV
ASSUME PTE$V_V EQ 0

					; Fetch level 2 PTE
	 srl	r21, #32, r21		; extract PFN from pte
	sll	r21, #page_offset_size_bits, r21; get PFN * 2^13 for add to <seg2>*8
	 addq	r21, r22, r21		; get address of seg two pte
	sll	r20, #<64-<<1*page_seg_size_bits>+page_offset_size_bits>>, r22	; Clean off upper bits of VA
	virtualize r21, r23

	 ldq/p	r21, (r21)		; Get second PTE (addr<2:0> ignored)
	srl	r22, #<61-page_seg_size_bits>, r22; Get Va<seg1>*8
	 blbc	r21, l2_ppte_inv	; Second PTE invalid go sort out TNV/ACV
	srl	r21, #32, r21		; extract PFN from pte
ASSUME PTE$V_V EQ 0
					; Fetch level 3 PTE
	 sll	r21, #page_offset_size_bits, r21; get PFN * 2^13 for add to <seg3>*8
	addq	r21, r22, r21		; get address of seg three pte
	 virtualize r21, r23,noload=1

	 ldq/p	r21, (r21)		; Get third PTE (addr<2:0> ignored)
	.if ne virtualize_memory
	  srl	r21, #<20+32>, r22	; get IO space indicator from PFN
	  cmovne r22, R31, r23		; if IO space, don't virtualize
	  sll r23, #32-page_offset_size_bits, r23; turn virt mem offset into pfn addr
	  addq	r23, r21, r21		; bump the pfn
	.endc

	mt	r21, dtb_ctl		; sel large or small page tb
	 blbc	r21, l3_ppte_inv	; Third PTE invalid go sort out TNV/ACV
ASSUME PTE$V_V EQ 0

					; All is well so far, so load the TB
	 mt	r20, tb_tag		; Load TB TAG and clear TB valid bit
	mt	r21, dtb_pte		; Load PTE and set TB valid bit

	 mf	r20, pt20		; restore scratch regs
	mf	r21, pt21		;
	 mf	r22, pt22		;
	.iif ne virtualize_memory, mf r23, pt23
	hw_rei				; go back and try access



.sbttl	PDTB_ERR - DTB error completion routines for misses from within PAL


;+
;
; First or second level PTE invalid.
; This can only be caused by a miss from within pal.
; We have to correctly determine acv/tnv and
; finally dispactch to the special exception handler
;
;called
;		l1_ppte_inv	if the l1 pte is bad
;		l2_ppte_inv	if the l2 pte is bad
;
;	with
;	R20-22,[23] saved in PT20-22,[23]
;	R20	 = va
;	R21	 = pte
;	R22	 = junk
;	[r23	 = junk]
;	exc_addr = pc
;
;
; Exit to the special exception handler with
;
;	R0,1,20-23 saved in PT0,1,20-23
;
;	R20 = VA
;	R21 = pte with l3 and recheck marker correct.
;	R22 = MMF
;	R23 = scb offset for this fault
;
;
;-

	align_to_cache_block		; align for branch target
l1_ppte_inv:				; 7 cycles
l2_ppte_inv:				; 7 cycles
	mt	r0, pt0
	 srl	r21, #PTE$V_KRE, r0	; Get the KRE bit
	.iif eq virtualize_memory, mt	r23, pt23
	 ldah	r23, <<1@pte$v_soft>+32768>@-16(r31); get marker for level 3 errors
	mf	r22, mm_csr		; get mmcsr
	 bic	r21, r23, r21		; clear l3 marker in pte
	mt	r1, pt1
	 lda	r23, SCB$V_TNV(r31)	; Assume we will take TNV
	cmovlbc r0, #SCB$V_ACV, r23	; Not set, so convert to ACV
	 sll	r22, #63, r22		; mmf
	br	r31, pal$special_exception; handle the special exception



;+
;
; Third level PTE invalid.
; This can only be caused by a miss from within pal.
; We have to correctly determine acv/tnv and
; finally dispactch to the special exception handler
;
;called
;		l3_ppte_inv	if the l3 pte is bad
;
;	with
;	R20-22,[23] saved in PT20-22,[23]
;	R20	 = va
;	R21	 = pte
;	R22	 = junk
;	[r23	 = junk]
;	exc_addr = pc
;
;
; Exit to the special exception handler with
;
;	R0,1,20-23 saved in PT0,1,20-23
;
;	R20 = VA
;	R21 = pte with l3 and recheck marker correct.
;	R22 = MMF
;	R23 = scb offset for this fault
;
;
;-

	align_to_double_cache_block	; align for branch target
l3_ppte_inv:				; 17 cycles
	mt	r1, pt1
	 mf	r1, pt9			; get users PS
	mf	r22, mm_csr		; get mmcsr
	 .iif eq virtualize_memory, mt	r23, pt23
	mt	r0, pt0
	 and	r1, #PS$M_CM, r1	; Clean up ps bits
	and	r22, #mmcsr$m_wr, r23	; isolate write bit
	 sll	r23, #2, r23		; get write * 4
	srl	r1, #PS$V_CM, r1	; shift to low bits
	 addq	r1, #PTE$V_KRE, r1	; add offset to kre bits
	addq	r1, r23, r1		; add offset to xxe bits
	srl	r21, r1, r1		; Get cmxE to <0>
	 sll	r22, #63, r22		; mmf
	ldah	r23, <<3@pte$v_soft>+32768>@-16(r31); get marker for level 3 errors
	 bis	r21, r23, r21		; set l3 markers in pte
	lda	r23, SCB$V_TNV(r31)	; Assume we will take TNV
	 cmovlbc r1, #SCB$V_ACV, r23	; Not set, so convert to ACV
	br	r31, pal$special_exception; handle the special exception

ASSUME MMCSR$V_WR EQ 0


.sbttl	NDTB_ERR - DTB error completion routines for misses from native



;+
;
; we come here if we are erring on a dtb_miss, and the instr is a
; fetch or fetch_m
; the PC is incremented, and we return to the program.
; essentially ignoreing the instruction and error.
; If access was a fetch[m], we enter dfetch_err, with
; PT3-5, 12-16 <- r3-5,12-16
;
;-
	align_to_cache_block		; align for branch target
nmiss_fetch_err:			; 10 cycles
	mf	r5, exc_addr 		; store that pc to rei to
	 mf	r12, pt12
	mf	r13, pt13
	 addq	r5, #4, r5		; bump pc to pc+4
	mf	r14, pt14
	 mt	r5, exc_addr 		; store that pc to rei to
	mf	r15, pt15
	 mf	r3, pt3
	mf	r4, pt4
	 mf	r5, pt5
	hw_rei				; go back



.sbttl	MCHK_CONT - More mchk code

	; Save the state of the chip, record an mchk in progress, and
	; if this is a double mchk, enter the console with that error.
	; In the case of a double mchk, the first error is lost.

pal$process_mchk::
;	mt	r0, pt0
	.if ne	sable_system
	mf	r0, biu_stat		; Save BIU_STAT
	mt	r0, pt20		;
	mf	r0, biu_addr		; Save BIU_ADDR
	mt	r0, pt21		;
	.if ne	sable_system_debug
	stall	1			; Stall due to MT above
	mt	r4, pt4			; Save R4
	mf	r4, pt20		; Get BIU_STAT
	mt	r5, pt5			; Save R5
	mf	r5, pt21		; Get BIU_ADDR
	mt	r12, pt20		; Save R12
	mt	r13, pt21		; Save R13
	mt	r14, pt22		; Save R14
	mt	r15, pt23		; Save R15
	CONT_HW_VECTOR	PDTB_MISS
	mt	r16, pt16
	mt	r17, pt17
	mt	r18, pt18
	mt	r19, pt19
	combo_setup
	combo_lock
	combott_putc	<^x0d>
	combott_putc	<^x0a>
	combott_putc	<^x0d>
	combott_putc	<^x0a>
	combott_putc	<^x39>
	mf	r16, pt27
	addq	r16, #48, r16
	combott_putc	r16
	combott_putc	<^x3c>
	mf	r16, exc_addr
	combott_puth
	combott_putc	<^x2f>
	lda	r16, (r4)
	combott_puth
	combott_putc	<^x2f>
	lda	r16, (r5)
	combott_puth
	combott_putc	<^x2f>
	mf	r12, pt27
	lda	r12, ^x380(r12)
	sll	r12, #24, r12
	ldq/p	r16, ^x0e0(r12)
	combott_puth
	combott_putc	<^x2f>
	mf	r12, pt27
	lda	r12, ^x380(r12)
	sll	r12, #24, r12
	ldq/p	r16, ^x000(r12)
	and	r16, #1, r16
	combott_puth	1
	combott_putc	<^x3e>
	combott_putc	<^x0d>
	combott_putc	<^x0a>
	combo_unlock
	mf	r16, pt16
	mf	r17, pt17
	mf	r18, pt18
	mf	r19, pt19
	mf	r12, pt20		; Restore R12
	mf	r13, pt21		; Restore R13
	mf	r14, pt22		; Restore R14
	mf	r15, pt23		; Restore R15
	mt	r4, pt20		; Save BIU_STAT
	mf	r4, pt4			; Restore R4
	mt	r5, pt21		; Save BIU_ADDR
	mf	r5, pt5			; Restore R5
	.endc
	.endc
	mt	r1, pt1
	mt	r3, pt3
	mf	r0, exc_addr
ev4_p2	<subq	r0, #2, r0		; dec pc, if needed>
ev4_p2	<bic	r0, #2, r0		; clean pc, if needed>
ev4_p2	<mt	r0, exc_addr		; store it back in the chip>

	blbc	r0, 10$			; continue, if not in PAL
	lda	r0,<hlt$c_MCHK_FROM_PAL>(r31); set halt code
	br	r31, pal$error_halt
;	MCHK	MCHK_FROM_PAL, halt=1	; else, halt

10$:	.if ne <ev4_pass1!ev4_pass2!disable_ecc>	; if pass1 or pass2 or we are in par mode
	; flush the dcache
	lda	r1, <1@abox$v_mchk>(r31) ; turn off the dcache, leave MCHKs on
	mt	r1, abox_ctl	
	stall	2
	mf	r1, pt7			; get addr of impure area
	ldq/p	r1, cns$abox_ctl(r1)	; get abox_ctl
	mt	r1, abox_ctl		; re-enable dcache
	stall	2
	.endc

	.if ne	lca4
	get_high_addr	r0, mem$csr_base; r0 <- 1.2000.0000
	ldq/p	r0, mem$q_esr(r0)	; Get Memory Controller error status.
	br	r31, mchk_log_unknown	
	.endc

	; weed out why we mchk'd
	.if ne lca4
	get_high_addr r0, mem$csr_base
	ldq/p	r0, mem$q_esr(r0)	; get mem controller ESR
	br	r31, mchk_log_unknown
	.endc

	.if ne	sable_system
	mf	r0, pt20		; get biu_stat at time of error
	.iff
	mf	r0, biu_stat		; get biu_stat at time of error
	.endc

	and	r0, #<bc$m_tperr ! bc$m_tcperr ! biu$m_herr>, r1 ; any bad errs
	bne	r1, mchk_log_unknown	; bad error located, go log it
	
; check for parity error here... if parity mode instead of ecc
	
	.if ne	avanti_system
	; Parity Error Detection Only--no Ecc Correction
	get_addr r1,<fill$m_dperr>,r31
	and	r0,r1,r1
	bne	r1, mchk_log_unknown	
	.endc

	; The mchk was not one of the hardware errors, the only thing
	; left is ecc errors, both correctable and uncorrectable, and
	; cache parity errors
	mf	r1, dc_stat		; get dc_stat at time of error
	lda	r3, mchk$c_ecc_nc(r31)	; assume uncorrectable
	blbc	r1, mchk_log_known	; chip does not support ECC/cache parity

	and	r1, #<<1@dc$v_ic_err>!<1@dc$v_dc_err>>, r3; cache parity error?
	bne	r3, 20$			; yup

	lda	r3, mchk$c_ecc_nc(r31)	; assume uncorrectable
	srl	r0, #fill$v_ecc, r1	; shift biu_stat down a bit
	blbc	r1, mchk_log_unknown	; Hmm.. something bad going on..

	and	r1, #1@<fill$v_seo-fill$v_ecc>, r0; were any second bad errors seen?
	bne	r0, mchk_log_known	; unable to correct, sorry
	and	r1, #1@<fill$v_crd-fill$v_ecc>, r0; was the error correctable?
	beq	r0, mchk_log_known	; unable to correct, sorry


	; We know that we are handling a correctable ECC error, that took a
	; MCHK. That implies that some where, at least one, two single bit
	; error cache block was sucked into the I-stream. We also know
	; that no uncorrectable errors were detected. All that remains
	; is to scrub the error, and log it. The Icache and stream buffer
	; have already been flushed.


	; convert to user frame builder in interrupt flow
	mt	r12, pt12
	mt	r13, pt13
	mt	r14, pt14
	mt	r15, pt15
	pvc$jsr	armc, bsr=1
	bsr	r12, arith_and_mchk	; go check for and deal with arith
	mf	r0, pt0
	mf	r1, pt1
	mf	r3, pt3
	mt	r31, pt3		; save zero value as flag of non-rei flow
	.if ne	sable_system
	stall	1
	br	r31, pal$crd_interrupt_from_mchk
	.iff
	br	r31, pal$crd_interrupt
	.endc



	; i or d cache parity error detected
20$:	srl	r0, #fill$v_ecc, r3	; shift biu_stat down a bit
	blbs	r3, mchk_log_unknown	; Hmm.. something bad going on..

	lda	r3, mchk$c_icperr(r31)	; assume ic parity error
	and	r1, #<1@dc$v_ic_err>, r0; i-cache parity error?
	cmoveq	r0, #mchk$c_dcperr, r3	; nope, convert to dc parity error
	sll	r1, #32, r1		; shift dc_stat to high long
	or	r1, r3, r3		; merge with the error code for now
	beq	r0, mchk_log_known	; and log it

	; if i-cache parity error, and a machine check is in progress 
	; i.e. (MCES MIP bit is set) or we are ignoring processor correctable
	; errors (MCES DPC bit set), then dismis the mchk and continue, 
	; else log it.

	mf	r0, pt25		; go get mchk flag
	srl	r0, #pt25$v_mck, r0	; get mces to <0>
	and	r0, 1!<1@<pt25$v_dpc-pt25$v_mck>>, r0 ; get MCES <MIP> <DPC>
	beq	r0, mchk_log_known	; continue, nothing blocking the error
	mf	r0, pt0			; else, unwind and dismis the mchk
	mf	r1, pt1
	mf	r3, pt3
	hw_rei				; and back we go



	.align	quad
mchk_log_unknown::
	lda	r3, mchk$c_unknown(r31)	; assume unknown error?
	.if ne lca4
	and	r0, #esr$m_cte, r1	; is error bcache tag parity error
	cmovne	r1, #mchk$c_tperr, r3	; yes, set error code
	and	r0, #esr$m_uee, r1	; is error uncorrectable ECC
	cmovne	r1, #mchk$c_ecc_nc, r3	; yes, set error code
	lda	r1, esr$m_nxm(r31)	; esr$m_nxm too large for literal
	and	r0, r1, r1		; is error non-existant memory
	cmovne	r1, #mchk$c_herr, r3	; yes, set error
	get_high_addr r1, ioc$csr_base
	ldq/p	r0, ioc$q_stat0(r1)	; get stat0
	and	r0, #stat0$m_err, r1	; is error IO controller
	cmovne	r1, #mchk$c_herr, r3	; yes, set error
	.iff
	and	r0, #bc$m_tperr, r1	; is error tag parity error
	cmovne	r1, #mchk$c_tperr, r3	; yes, so set error code
	and	r0, #bc$m_tcperr, r1	; is error tag control parity error
	cmovne	r1, #mchk$c_tcperr, r3	; yes, so set error code
	.if ne	0
	and	r0, #biu$m_herr, r1	; is error external hard error
	cmovne	r1, #mchk$c_herr, r3	; yes, so set error code
	.endc
	.if ne	sable_system
	mf	r0, pt0			; Restore registers
	mf	r1, pt1			;
	mt	r3, pt0			; (but save error code first)
	mf	r3, pt3			;
	mt	r12, pt12		; Save registers
	mt	r13, pt13		;
	mt	r14, pt14		;
	mt	r15, pt15		;
	mt	r31, pt3		; Say no frame is built yet
	stall	2			;
	;
	; Check for Bcache tag or tag control parity errors.  If we find
	; one, we start to panic...
	;
	mf	r15, pt27		; Get WHAMI
	.if ne	sable_system
	lda	r15, ^x380(r15)		; Read 38x00xxxx
	sll	r15, #24, r15		;
	.endc
	mf	r12, pt20		; Get BIU_STAT at time of error
	and	r12, #bc$m_tperr!bc$m_tcperr, r13 ; Check for parity errors
	bne	r13, 20$		; Yep, got one
	and	r12, #biu$m_herr, r13	; Otherwise, must be a hard error
	beq	r13, 30$		; Nope, it's not
	ldq/p	r12, ^x060(r15)		; Read BCUE
	srl	r12, #1, r12		; Check for parity error
	blbs	r12, 10$		; Yep, got one
	srl	r12, #32, r12		; Check for parity error
	blbc	r12, 30$		; Nope, didn't get one
10$:	lda	r12, mchk$c_c3_tag_par(r31) ; Say it's a tag parity error
	mt	r12, pt0		;
20$:	;
	; Okay, we have found a Bcache tag or tag control parity error.  We
	; will try to clean up the mess.  We turn off parity checking, and
	; turn allocation back on.  We also turn off the EV's probing of the
	; Bcache.  We then use "allocate invalid" space to flush the cache
	; entry which is bad (this will cause us to lose the data).  After all
	; that, we can put things back like they were:  probing on, parity
	; checking on, allocation off.
	;
	; Due to a bug in the C³, whenever the Bcache is disabled, the Dcache
	; must be disabled as well.  Bcache tag or tag control parity errors
	; cause the Bcache to be automatically disabled, so we must now disable
	; the Dcache as well.
	;
	mf	r12, pt7		; Get impure pointer
	ldq/p	r13, cns$abox_ctl(r12)	; Get ABOX_CTL
	lda	r14, 1@abox$v_dc(r31)	;
	bic	r13, r14, r13		;
	stq/p	r13, cns$abox_ctl(r12)	;
	mt	r13, abox_ctl		; Turn off the Dcache
	stall	3			;
	ldq/p	r14, ^x000(r15)		; Read BCC
	lda	r13, 4(r31)		; Clear bits 2 and 34
	sll	r13, #32, r13		;  (turn off parity checking)
	lda	r13, 4(r13)		;
	bic	r14, r13, r12		;
	lda	r13, 1(r31)		; Set bits 0 and 32
	sll	r13, #32, r13		;  (turn on Bcache allocation)
	lda	r13, 1(r13)		;
	bis	r12, r13, r12		;
	stq/p	r12, ^x000(r15)		; Write BCC
	mb				;
	mf	r12, pt7		; Get impure pointer
	ldq/p	r12, cns$biu_ctl(r12)	; Get BIU_CTL, so we can clear
	bic	r12, #1@bc$v_en, r12	;  Bcache enable
	mt	r12, biu_ctl		;
	stall	3			;
	mf	r12, pt21		; Get BIU_ADDR
	lda	r13, ^x001f(r31)	; Mask off some bits
	ldah	r13, ^xc000(r13)	;
	bic	r12, r13, r12		;
	lda	r13, ^x1(r31)		; Read 100000000 for either CPU
	sll	r13, #32, r13		;
	addq	r12, r13, r12		; Get an "allocate invalid" address
	ldq/p	r12, (r12)		; Read it
	mb				; Make sure it happens
	mf	r12, pt7		; Get impure pointer
	ldq/p	r12, cns$biu_ctl(r12)	; Restore BIU_CTL
	mt	r12, biu_ctl		;
	stall	3			;
	stq/p	r14, ^x000(r15)		; Restore BCC
	mb				;
30$:	;
	; Go build the error frame for the O/S.
	;
	lda	r13, scb$v_procmchk(r31) ; Get vector offset
	.if ne	sable_system
	br	r31, sable_build_error_frame ; Go log the error
	.endc
	.iff

	.if ne  avanti_system ! mikasa_system ! noritake_system ! k2_system ! cortex_system

	.if ne  avanti_system 
	get_addr	r1, <fill$m_dperr>, r31	; r1 <- parity error mask
	and	r0, r1, r1		; is error external data parity error
	beq	r1, 21$			; branch if not data parity
	lda	r3, mchk$c_dcperr(r31)	; yes, so set error code
	br	r31, mchk_log_known	; normal processing
21$:
	.endc


	; Check for DECchip 21071-CA (Comanche) Reported Errors First
	
        in_coma  <coma_edsr>, r1, r3	; Read the Error & Diagnostic Status 

	get_addr r3,<edsr$m_taperr>,r31	; Is it Bcache tag address parity error? 

	and	r1, r3, r3		; Isolate the EDSR<bc_TAPErr> bit
	beq	r3, 25$			; Branch if not bc_TAPErr
	lda	r3, mchk$c_ctaperr(r31)	; If set then r3 is machine check code
        br      r31, mchk_log_known	; Go build machine check log ...

25$:	
	get_addr r3,<edsr$m_tcperr>,r31	; Is it Bcache tag control parity error?

	and	r1, r3, r3		; Isolate the EDSR<bc_TCPErr> bit
	beq	r3, 30$			; Branch if not bc_TCPErr
	lda	r3, mchk$c_ctcperr(r31)	; If set then r3 is machine check code
        br      r31, mchk_log_known	; Go build machine check log ...

30$:	
	get_addr r3,<edsr$m_nxmerr>,r31	; Is it Nonexistent memory error?

	and	r1, r3, r3		; Isolate the EDSR<nxMErr> bit
	beq	r3, 40$			; Branch if not nxMErr
	lda	r3, mchk$c_nxmerr(r31)	; If set then r3 is machine check code
        br      r31, mchk_log_known	; Go build machine check log ...
40$:	
	; Check for DECchip 21071-DA (Epic) errors 

        in_epic <epic_dcsr>, r1, r3	; Read the Diagnostic Control & Status

	get_addr r3,<dcsr$m_iort>,r31	; Is it a retry timeout error?

	and	r1, r3, r3		; Isolate the DCSR<ioRT> bit
	beq	r3, 50$			; Branch if not ioRT
	lda	r3, mchk$c_iort(r31)	; If set then r3 is machine check code
	br	r31, mchk_log_known	; Go build machine check log ...
	
50$:	
	get_addr r3,<dcsr$m_ddpe>,r31	; Is it a DMA data parity error?

	and	r1, r3, r3		; Isolate the DCSR<dDPE> bit
	beq	r3, 60$			; Branch if not dDPE
	lda	r3, mchk$c_ddpe(r31)	; If set then r3 is machine check code
	br	r31, mchk_log_known	; Go build machine check log ...
	
60$:	
	get_addr r3,<dcsr$m_iope>,r31	; Is it an I/O parity error?

	and	r1, r3, r3		; Isolate the DCSR<iOPE> bit
	beq	r3, 70$			; Branch if note iOPE
	lda	r3, mchk$c_iope(r31)	; If set then r3 is machine check code
	br	r31, mchk_log_known	; Go build machine check log ...
	
70$:	
	get_addr r3,<dcsr$m_tabt>,r31	; Is it a target abort error?

	and	r1, r3, r3		; Isolate the DCSR<tAbt> bit
	beq	r3, 80$			; Branch if not tAbt
	lda	r3, mchk$c_tabt(r31)	; If set then r3 is machine check code
	br	r31, mchk_log_known	; Go build machine check log ...
	
80$:	
	get_addr r3,<dcsr$m_ndev>,r31	; Is it a no device error?

	and	r1, r3, r3		; Isolate the DCSR<nDev> bit
	beq	r3, 90$			; Branch if not nDev
	lda	r3, mchk$c_ndev(r31)	; If set then r3 is machine check code
	br	r31, mchk_log_known	; Go build machine check log ...
	
90$:	
	get_addr r3,<dcsr$m_cmrd>,r31	; Is it a correctable memory error?

	and	r1, r3, r3		; Isolate the DCSR<cMRD> bit
	beq	r3, 100$		; Branch if not cMRD
	lda	r3, mchk$c_cmrd(r31)	; If set then r3 is machine check code
	br	r31, mchk_log_known	; Go build machine check log ...
	
100$:	
	get_addr r3,<dcsr$m_umrd>,r31	; Is it an uncorrectable memory error?

	and	r1, r3, r3		; Isolate the DCSR<uMRD> bit
	beq	r3, 110$		; Branch if not uMRD
	lda	r3, mchk$c_umrd(r31)	; If set then r3 is machine check code
	br	r31, mchk_log_known	; Go build machine check log ...
	
110$:	
	get_addr r3,<dcsr$m_iptl>,r31	; Is it an invalid page table lookup?

	and	r1, r3, r3		; Isolate the DCSR<iPTL> bit
	beq	r3, 120$		; Branch if not iPTL
	lda	r3, mchk$c_iptl(r31)	; If set then r3 is machine check code
	br	r31, mchk_log_known	; Go build machine check log ...
	
120$:	
	get_addr r3,<dcsr$m_merr>,r31	; Is it a memory cycle error?

	and	r1, r3, r3		; Isolate the DCSR<mErr> bit
	beq	r3, 130$		; Branch if not mErr
	lda	r3, mchk$c_merr(r31)	; If set then r3 is machine check code
	br	r31, mchk_log_known	; Go build machine check log ...
;
; if we get here it's still unknown
;

130$:    
	.endc
	.endc
	.endc
	;
	; Build up the machine check log - R3 is the error code and has the
	; following definitions.
	;
	; r3 = 
	;     <bit 7:0> = the Error code for the logout
	;     <bit 8>   = 1 - set retry bit in the log
	;                 0 - clear the retry bit in the log
	;     <bit 9>  = 0 - vector is 660
	;                1 - Vector is 620
	;
	; NOTE : All Morgan NMI sources are uncorrectable errors, ie :
	;
	;	1. SCB vector = 660, R3<9> = 0.
	;	2. Retry is not possible, r3<8> = 0.
	; 


	; err code is in r3
mchk_log_known::
	.if ne	generic_system
	pvc$violate	1003
	halt				; Machine checks off, we never get here
	.endc
	.if ne	sable_system ! -
		avanti_system ! -
		mtu_system ! - 
		mikasa_system ! -
		noritake_system ! -
		k2_system ! -
		lean_system ! -
		cortex_system

	.if ne	sable_system
	mf	r0, pt0			; Restore registers
	mf	r1, pt1			;
	mt	r3, pt0			; (but save error code first)
	mf	r3, pt3			;
	mt	r12, pt12		; Save registers
	mt	r13, pt13		;
	mt	r14, pt14		;
	mt	r15, pt15		;
	mt	r31, pt3		; Say no frame is built yet
	.endc

	;
	; Go build the error frame for the O/S.
	;
	.if ne	sable_system
	lda	r13, scb$v_procmchk(r31) ; Get vector offset
	br	r31, sable_build_error_frame ; Go log the error
	.endc

	.if ne	avanti_system ! k2_system
	br	r31, avanti_build_error_frame
	.endc

	.if ne  mikasa_system ! noritake_system
	br	r31, mikasa_build_error_frame
	.endc

	.if ne	cortex_system
	br	r31, cortex_build_error_frame
	.endc

	.if ne	mtu_system
	br	r31, mustang_build_error_frame
	.endc

	.if ne	lean_system
	br	r31, lean_build_error_frame
	.endc

	.endc

	.if ne	medulla_system 
	lda	r13, scb$v_procmchk(r31) ; Get vector offset
	br	r31, medulla_build_error_frame
	.endc

	.if ne	cfw_system
	pvc$violate	1003
	halt				; We never get here, code is above
	.iff
	mt	r31, alt_mode		; make sure altmode is KERNEL mode
	mf	r0, pt25		; go get mchk flag
	srl	r0, #pt25$v_mck, r1	; get mces to <0>
	blbc	r1, 10$			; continue, if no mchk's in progress

;;;	MCHK	DBL_MCHK, halt=1	; else, halt
	lda	r0,<hlt$c_DBL_MCHK>(r31); set halt code
	mt	r3, pt5			; save old mchk code in pt5
	br	r31, pal$error_halt

10$:	ldah	r1, <1@<pt25$v_mck-16>>(r31); get new mces flag
	or	r0, r1, r0		; set mchk in progress flag
	mt	r0, pt25		; save it in the chip

	; fetch mchk impure area ptr
	mf	r1, pt7			; get addr of impure area
	get_addr r1, <pal$logout_area+laf$base>, r1; offset to logout area

	lda	r0, laf$exc_addr(r31) 	; cpu offset
	stl/p	r0, laf$off(r1) 	; set offset
	lda	r0, laf$plt0(r31) 	; sys offset
	stl/p	r0, <laf$off+4>(r1) 	; set offset

	lda	r0, laf$size(r31) 	; build flag
	stl/p	r0, laf$flag(r1) 	; set flag

	zapnot	r3, #^xf, r0		; get mchk code
	cmpeq	r0, #MCHK$C_ICPERR, r0	; was error i cache parity error?
	sll	r0, #31, r0		; retryable if ic parity error, pos it

	stl/p	r0, <laf$flag+4>(r1)	; set retry flag

	srl	r3, #32, r0		; get saved dc_stat (if any)
	stq/p	r0, <laf$dc_stat>(r1)	; save to logout area

	zap	r3, #^xf0, r3		; remove dc_stat from error code
	or	r31, #1, r0		; get a one
	sll	r0, #32, r0		; get an mchk rev level
	or	r3, r0, r3		; merge rev level and mchk code
	stq/p	r3, <laf$pt0>(r1)	; set error code into save pt0

	.macro	movr lax, reg n
	   .if nb "n"
	     mf	r0, 'reg''n'
	     stq/p r0, 'lax'$'reg''n'(r1)
	  .iff
	     mf	r0, 'reg'
	     stq/p r0, 'lax'$'reg'(r1)
	  .endc
	.endm

	.if ne lca4
	.macro	movcsr lax, cntlr, name
	  ldq/p	r13, <'cntlr'$q_'name'>(r14)
	  stq/p r13, 'lax'$q_'name'(r1)
	.endm
	.endc

	t = 1
	.repeat 31
	movr	laf, pt \t
	t = t + 1
	.endr
	

	; check for pending arith exceptions
	mt	r12, pt12
	mt	r13, pt13
	mt	r14, pt14
	mt	r15, pt15
	mt	r1,  pt4
	pvc$jsr	armc, bsr=1
	bsr	r12, arith_and_mchk	; go check for and deal with arith

	mf	r1,  pt4
	movr	laf, pt9		; propagate ps, from arith

	movr	laf, exc_addr
;	movr	laf, exc_sum
;	movr	laf, exc_msk
;	movr	laf, iccsr
	movr	laf, pal_base
	movr	laf, hier
	movr	laf, hirr
	movr	laf, mm_csr
	ldq/p	r0, <laf$dc_stat>(r1)	; fetch possibly saved dc_stat
	bne	r0, 15$			; skip save, if already saved
	movr	laf, dc_stat
15$:	movr	laf, dc_addr

	.if ne	adu_system
	get_addr r13, <-<pal$logout_area+laf$base>>, r1; offset to impure area
	.endc
	ldq/p	r0, cns$abox_ctl(r13)		; get current abox_ctl
	stq/p	r0, laf$abox_ctl(r1)		; pass it
	.if ne lca4
	get_high_addr r14, mem$csr_base
	movcsr	laf, mem, car
	movcsr	laf, mem, ear
	movcsr	laf, mem, esr
	stq/p	r13, mem$q_esr(r14)
	get_high_addr r14, ioc$csr_base
	movcsr	laf, ioc, stat1
	movcsr	laf, ioc, stat0
	stq/p	r13, ioc$q_stat0(r14)
	mb
	mb
	.iff
	ldq/p	r0, cns$biu_ctl(r13)		; get current biu_ctl
	stq/p	r0, laf$biu_ctl(r1)		; pass it

;	movr	laf, abox_ctl
	movr	laf, biu_stat
	movr	laf, biu_addr
;	movr	laf, biu_ctl
	movr	laf, fill_syndrome
	movr	laf, fill_addr
	movr	laf, va
;	movr	laf, bc_tag

	ornot	r31, #<1@sl_clr$v_crd>, r13; get ack bit for crd
	mt	r13, sl_clr		; ack any pending crds

	; read out and save bc_tag

	or	r31, r31, r13		; init counter
	or	r31, r31, r14		; start with no bits set
20$:	mf	r12, bc_tag		; get next bit of bc_tag
	sll	r12, r13, r12		; move current mask over by one
	or	r14, r12, r14		; set this bit in mask
	addq	r13, #1, r13		; inc counter
	cmplt	r13, #64, r12		; are we done?
	blbs	r12, 20$		; loop till done

	mt	r31, bc_tag		; unlock bc_tag
	stq/p	r14, laf$bc_tag(r1)	; and salt it away
	.endc
	assume	<cns$size-<las$size+laf$size>> gt 0 ; la size too big



	; set up the km trap, via interrupt completion

	lda	r14, laf$base(r31)	; LAOFF

	mf	r0, pt0
	mf	r1, pt1
	mf	r3, pt3
	mt	r31, pt3		; set not from rei flag

	lda	r13, scb$v_procmchk(r31); trap is mchk
	or	r31, #31, r15		; set new ipl to 31
	stall	1
	br	r31, complete_interrupt	; and go to post interrupt processor
	.endc



.sbttl	MCHK&ARITH - ARITH under MCHK code

	; called jsr, r12, arith_and_mchk
	; pt0,1,3,12-15 <- r*

	.align	quad
arith_and_mchk:
	mf	r14, exc_sum		; get exc sum
	 mt	r31, exc_sum		; clear error bits

	srl	r14, #exsum$v_swc, r1	; shift data to correct position
	 bne	r1, 5$			; skip arith fault unless needed
	pvc$jsr	armc, bsr=1, dest=1
	ret	r31, (r12)		; back we go if no arith under mchk

	.align	quad
5$:	get_addr r15, <pal$post_kmsp_not_valid5-pal$start>, r31	; mm err rtn
	mf	r3, pt3			; free up pt3
	 or	r31, r31, r14		; fr0, never gets errors
	mt	r15, pt3		; set error handler


	 or	r31, r31, r0		; start with no bits set
	or	r31, #63, r13		; get a counter


	align_branch_target
10$:	mf	r15, exc_sum		; get next bit
	 sll	r0, #1, r0		; move current mask over by one
	cmplt	r31, r14, r14		; set bit<0> if MSK was set
	 or	r0, r14, r0		; set this bit in mask
	sll	r0, #1, r0		; move current mask over by one
	 mf	r14, exc_sum		; get next bit

	cmplt	r31, r15, r15		; set bit<0> if MSK was set
	 subq	r13, #2, r13		; dec counter
	or	r0, r15, r0		; set this bit in mask
	 bge	r13, 10$		; loop till done



	; now build the KM ARITH stack frame
	; but do not dispatch the exception

	mf	r14, pt9		; get current ps
	mf	r15, pt31		; get pcbb
	and	r14, #PS$M_CM, r14	; Get PS<cm>*8
	beq	r14, 30$		; skip stack swap if KM from KM

	addq	r15, r14, r14		; get addr of cmSP
	mf	r15, pt26		; get new KM mode sp
	stq/p	sp, pcb$q_ksp(r14)	; update current mode SP
	or	r15, r31, sp		; move sp to sp

	; allocate new stack frame
30$:	or	sp, r31, r15		; move sp to sp
	bic	sp, #63, sp		; round down stack
	subq	sp, #64, sp		; allocate frame


; r15 = new sp with low bits intact
; sp  = new sp
; r0  has mask
; r1  has exc_sum

	mf	r13, exc_addr		; fetch pc, incase we trap on stq/a
pal$post_arith_km_trap_stq::
	stq/a	r2,  FRM$V_R2(sp)	; save r2
	stq/a	r3,  FRM$V_R3(sp)	; save r3
	stq/a	r4,  FRM$V_R4(sp)	; save r4
	stq/a	r5,  FRM$V_R5(sp)	; save r5
	stq/a	r6,  FRM$V_R6(sp)	; save r6
	stq/a	r7,  FRM$V_R7(sp)	; save r7

	bic	r13, #3, r13		; clear low 2 bits of old pc
	stq/a	r13, FRM$V_PC(sp)	; save PC

	and	r15, #63, r15		; get stack alignment
	sll	r15, #PS$V_SP, r15	; shift to correct position for PS
	mf	r13, pt9		; get current ps
	or	r15, r13, r15		; insert sp-align field in old PS
	stq/a	r15, FRM$V_PS(sp)	; save old PS

	mf	r14, pt30		; get scbb
	ldq/p	r2, SCB$V_ARITH(r14)	; get scbv
	ldq/p	r3, <SCB$V_ARITH+8>(r14); get scbp


	bic	r2, #3, r2		; clean low bits of new pc
	mt	r2, exc_addr		; set new pc

	or	r0, r31, r4		; set new r4
	
	bic	r15, #<<3@PS$v_SW>!PS$M_CM>, r15; Zap sw/cm field, pass int
	mt	r15, PT9_PS		; set new ps

	or	r1, r31, r5		; set new r5

	mt	r3, pt3			; update saved r3
	stall	1			; required to make the ret safe
	pvc$jsr	armc, bsr=1, dest=1
	ret	r31, (r12)		; now that the arith is recorded
					; go handle the mchk.

.sbttl	scrub_mem

	;+
	;
	; scrub_mem
	;	called
	;	jsr r12, srub_mem
	;	r13 = addr within cache block
	;	scratches r12-17
	;
	;
	;-

	; note, alignment is critical, as mchk's will be turned off during
	; the scrub, we must make sure that the istream is safely in the icache
	; prior to turning off mchk's. Else, we could suck garbage into the
	; istream and not be able to detect it.
	
	align_to_cache_block	; align for branch target
scrub_mem::
	; turn off mchk's in abox_ctl
	stall	1
	mf	r14, pt7		; get addr of impure area

	ldq/p	r17, cns$abox_ctl(r14)	; get abox_ctl
	lda	r15, <1@abox$v_mchk>(r31); get clr mchk flag
	bic	r17, r15, r15		; clear mchk enable
	br	r31, 100$		; fetch cache block


	.if ne	lca4
;+++ Cache Block 00 +++++++++++++++++++++
	align_to_cache_block
100$:	br	r31, 110$		; fetch cache block
;++++++++++++++++++++++++++++++++++++++++
200$:	mt	r15, abox_ctl		; disable mchk
	stall	5
	br	r31, 210$		; continue in next cache block

;+++ Cache Block 10 +++++++++++++++++++++
	align_to_cache_block
110$:	br	r31, 120$		; fetch cache block
;++++++++++++++++++++++++++++++++++++++++
210$:	stall	1
;
; Find the error in memory and attempt to scrub cache block
;
10$:	ldq/pl	r15, (r13)		; attempt to read (locked) bad memory
	or	r15, r31, r15		; let the load complete
;
; Since MCHK is disabled, the ESR will be checked to make sure
; we did not get any non-recoverable errors on the load locked
; physical of the bad memory address.  If a non-recoverable
; error had occured on the I-fetch it would would have caused
; a MCHK since the abox_ctrl had not yet been written with
; MCHK_EN off.
;
; Note that a DMA access could also cause an error during this 
; time and set the ESR bits.  In either case, if there are any
; additional memory errors the scrub will be skipped.  Normal
; interrrupt processing will then handle those errors.  At
; that point, error recovery may no longer be possible.
;
	get_high_addr	r14, mem$csr_base ; r14 <- 1.2000.0000
	ldq/p	r16, mem$q_esr(r14)	; Read the ESR and check for errors.
	br	r31, 220$		; Continue in next cache block

;+++ Cache Block 20 +++++++++++++++++++++
	align_to_cache_block
120$:	br	r31, 130$		; fetch cache block
;++++++++++++++++++++++++++++++++++++++++
220$:	lda	r14, <esr$m_nxm!esr$m_cte!esr$m_uee>(r31)
	and	r16, r14, r14		; Check for fatal errors on the load.
	bne	r14, 20$		; Don't scrub if fatal error.
;
; At this point, memory is correctable so store the scrubbed
; data into memory.  The load locked/store conditional sequence
; must be repeated until it succeeds to insure that the store
; worked (i.e. lock flag was not cleared by DMA device writing
; to the error location during the load locked/store conditional
; sequence.
;
	stq/pc	r15, (r13)		; Do the store.
	stall	1
	blbc	r15, 10$		; Spin waiting for store to succeed.
20$:	mt	r17, abox_ctl		; reenable mchk's
	br	r31, 230$		; continue in next cache block

;+++ Cache Block 30 +++++++++++++++++++++
	align_to_cache_block
130$:	br	r31, 200$		; Start the real flow ...
;++++++++++++++++++++++++++++++++++++++++
230$:	br	r31, 240$
;
; This is a dead cache block.. It is never executed, but
; is here in case the stream buffer, brings it in while we
; are pre-fetching data into the I-cache. If this were not
; here, we could possibly execute garbage code if we managed to
; have multple ecc errors on THIS cache block. The odds of that
; happening are pretty slim, but with this here, we are safe
; from that failure.
;
	align_to_cache_block
	stall	8			; dead cache block
;
; Instructions after this point do not need to be pre-filled into
; the I-cache since they are fetched after MCHK has been re-enabled.
;
	align_to_cache_block
240$:
	mf	r14, dc_addr		; unlock.
	get_high_addr	r14, mem$csr_base ; r14 <- 1.2000.0000
	stq/p	r16, mem$q_esr(r14)	; clear the error status.
	; make sure lock flag gets cleared (from the error flows)	
	.if ne	low_core_ipl
	 stq/pc	r15, Pal$BitBucket(r31)	; clear Lock flag
	.iff
	 mf	r15, pal_base
	 sget_addr r15, <Pal$BitBucketHi-pal$start>,r15,verify=0; get addr of bit bucket
	 stq/pc	r15, (r15)		; clear lock flag
	.endc

	pvc$jsr vscrub, bsr=1, dest=1
	ret	r31, (r12)		; and back we go

	.iff
	align_to_cache_block
100$:	br	r31, 110$		; fetch cache block
200$:	mt	r15, abox_ctl		; disable mchk
	stall	5
	br	r31, 210$		; continue in next cache block

	align_to_cache_block
110$:	br	r31, 120$		; fetch cache block
210$:	stall	1
	; now find error in memory, and attempt to scrub that cache block
	bic	r13, #31, r13		; get addr of top of cache block
	srl	r13, #33, r15		; get high bit of bad pa
	blbs	r15, 20$		; don't attempt fixup on IO space addrs


10$:	ldq/pl	r15, (r13)		; attempt to read the bad memory
	or	r15, r31, r15		; let the load complete
	br	r31, 220$		; continue in next cache block

	align_to_cache_block
120$:	br	r31, 130$		; fetch cache block
220$:	.if ne lca4
	get_high_addr r14, mem$csr_base ; 2 instructions
	ldq/p	r16, mem$q_esr(r14)	; read ESR
	t = <esr$m_nxm ! esr$m_cte ! esr$m_uee>
	.iff
	mf	r16, biu_stat		; get info for new error
	mf	r14, fill_addr		; unlock biu_stat
	mf	r14, biu_addr		; unlock biu_stat
	; Now we have to make sure that this error, is still only an
	; correctable ecc error
	t = <biu$m_herr ! biu$m_serr ! bc$m_tperr ! bc$m_tcperr ! fill$m_seo>
	.endc
	lda	r14, t(r31)		; get biu error flags
	and	r16, r14, r14		; any wierd errors on the load?
	bne	r14, 20$
	br	r31, 230$		; continue in next cache block
	
	; and if we see the ecc error again, make sure it was correctable.
	align_to_cache_block
130$:	br	r31, 140$		; fetch cache block
230$:	.if ne lca4
	get_high_addr r14, mem$csr_base
	stq/p	r16, mem$q_esr(r14)	; clear error status
	.iff
	lda	r14, <fill$m_ecc>(r31)	; see if we got an error this time 
	and	r16, r14, r14
	beq	r14, 240$		; no, that's ok.. continue

	lda	r14, <fill$m_crd>(r31)	; make sure error was correctable
	and	r16, r14, r14
	beq	r14, 20$		; no, that's bad too.
	.endc
	br	r31, 240$		; continue in next cache block


	; memory is corectable , store the scrubed data into memory
	; scrub could be done by us, or someone else.
	align_to_cache_block
140$:	br	r31, 150$		; fetch next cache block
240$:	stq/pc	r15, (r13)		; scrub error.
	addq	r13, #9, r13		; bump pointer (yes, that's a 9
					; is is the ptr, and loop count)
	and	r13, #4, r15		; have we done 4 store's
	beq	r15, 10$		; no, go back and do next
	; re-enable mchk's
20$:	mt	r17, abox_ctl		; reenable mchk's
	.if eq lca4
	mf	r14, biu_stat		; get info for new error
	.endc
	br	r31, 250$		; continue in next cache block


	align_to_cache_block
150$:	br	r31, 200$		; now start the real flow

	; make sure everything is unlocked	
250$:	.if ne lca4
	mf	r14, dc_addr
	get_high_addr r14, mem$csr_base
	ldq/p	r16, mem$q_esr(r14)
	stq/p	r16, mem$q_esr(r14)	; clear error status
	.iff
	mf	r14, fill_syndrome	; get info for new error
	mf	r14, fill_addr		; get info for new error
	mf	r14, dc_addr		; get info for new error
	mt	r31, bc_tag		; unlock bc_tag
	.endc
	br	r31, 260$		; continue, in next+1 cache block

	align_to_cache_block
	; this is a dead cache block.. It is never executed, but
	; is here in case the stream buffer, brings it in while we
	; are pre-fetching data into the I-cache. If this were not
	; here, we could possibly execute garbage code if we managed to
	; have multple ecc errors on THIS cache block. The odds of that
	; happening are pretty slim, but with this here, we are safe
	; from that failure.
	stall	8			; dead cache block
	


	align_to_cache_block
260$:
	; make sure lock flag gets cleared (from the error flows)	
	.if ne	low_core_ipl
	 stq/pc	r15, Pal$BitBucket(r31)	; clear Lock flag
	.iff
	 mf	r15, pal_base
	 sget_addr r15, <Pal$BitBucketHi-pal$start>,r15,verify=0; get addr of bit bucket
	 stq/pc	r15, (r15)		; clear lock flag
	.endc

	pvc$jsr vscrub, bsr=1, dest=1
	ret	r31, (r12)		; and back we go
	.endc


	END_HW_VECTOR	PDTB_MISS


.sbttl	ITB_ACV - Istream ACV entry

;+
; PAL$HW_VEC_ITB_ACV
;addr	len	use
;----	---	------------------------------
;07E0	 64	Istream acv
;
; Entry:
;	Vectored into via hardware dispatch when i-stream acv occurs.
;
; Function:
;	Build stack frame
;	Dispatch through SCB
;
;-

	START_HW_VECTOR	ITB_ACV		; 6 cycles
	mt	r12, pt12		; Save r12
	 mf	r12, exc_addr		; get address of instruction
	mt	r13, pt13		; Save r13
	 lda	r13,1(r31)		; set mmf for I stream
	mt	r13, pt17		; save va as new r5
	 lda	r13, scb$v_acv(r31)	; set scb vector to use
	mt	r12, pt16		; save va as new r4
	 br	r31, pal$post_km_trap	; go build trap
	END_HW_VECTOR	ITB_ACV


.sbttl	ITB_MISS - Istream TB miss

;+
;addr	len	use
;----	---	------------------------------
;3E0	256	Istream TB miss
;
; Entry:
;	Vectored into via hardware dispatch when i-stream tb miss occurs.
;	This can only happen as a result of a non-pal access.
;
; Function:
;	Get PTE for VA being referenced. If valid then 
;	load into TB and continue. If not valid then
;	take TNV/ACV/FOE exception.
;
; Input's
;	PT29	= l3virt
;	EXC_ADDR
;
; across ldl
;	R3	<- pc of this miss
;
; error exit's
;
;	br l3_ipte_inv if ldl ok, but pte<valid> = 0
;	br l3_ipte_foe if ldl ok, but pte<foe>
;	with
;	R3, 4 saved in PT3, 4
;	R3	 = PC for INVALID only
;	R4	 = pte
;	exc_addr = pc
;
;
;
; Low level PDTB_miss routine, may also cause errors.
;-


	START_HW_VECTOR	ITB_MISS	; 21 cycles
	mt	r3, pt3			; save a reg
	 mf	r3, exc_addr		; Get va of reference that missed
	mt	r4, pt4
	 mf	r4, pt29
	mt	r5, pt5
	 sll	r3, #<64-43>, r5	; clean out sign extenion 
	.if eq enable_physical_console
	stall	1
	.iff
	blbs	r4, pal$physical_itb	; go map va=pa, if requested
	.endc
	 srl	r5, #<<64-43>+10>, r5	; make bits 32:0 of va of pte
	or	r5, r4, r4		; form address
pal$itb_miss_ldq::
	pvc$violate	1005		; This is one of the 2 that are legal
	 ldq/a	r4, (r4)		; get pte
	.if ne virtualize_memory
	  mf	r5, pt8
	  sll r5, #32-page_offset_size_bits, r5; turn virt mem offset into pfn addr
	  addq	r4, r5, r4		; bump the pfn
	.endc

	mt	r3, exc_addr		; restore execp address 
	 mt	r3, tb_tag		; Load TB TAG and clear TB valid bit
	mf	r5, pt5			;
	 blbc	r4, l3_ipte_inv		; Third PTE invalid go sort out TNV/ACV
	and	r4, #PTE$M_FOE, r3	; Get the FOE bit
	 mt	r4, dtb_ctl		; sel large or small page tb
	bne	r3, l3_ipte_foe		; FOE is set, go set up the exception
	 mt	r4, itb_pte		; Load PTE and set TB valid bit
	mf	r3, pt3			; restore scratch regs
	 mf	r4, pt4			;
	hw_rei				; go back and try access



;+
;
;l3_ipte_inv:
;l3_ipte_foe:
; IFOE detected on level 3 pte, sort out FOE v.s. ACV
; INVALID detected on level 3 pte, sort out TNV v.s. ACV
;
; on entry:
;	with
;	R3, 4 saved in PT3, 4
;	R3	 = PC for INVALID only
;	R4	 = pte
;	exc_addr = pc
;
;
; Function
;	Unwind registers, from itb_miss, determine xxx vs ACV.
;	Setup call to stack builder
;
;
;	stack builder wants:
;
;
;	pt12 has saved r12
;	pt13 has saved r13
;
;	r12 PC
;	r13 has SCB offset
;	pt16 has new_R4 (VA)
;	pt17 has new_R5 (MMF)
;
; 
;
;-
	align_to_cache_block		; align for branch target
l3_ipte_inv:				; 16 cycles
l3_ipte_foe:
	mt	r12, pt12
	 mf	r12, exc_addr		; get users PS
	mt	r13, pt13
	 mf	r3, pt9			; get users PS
	lda	r13, scb$v_foe(r31)	; Assume we will take FOE
	 mt	r12, pt16		; set newr4=va
	srl	r3, #PS$V_CM, r3	; shift cm to low bits
	 cmovlbc r4, #scb$v_tnv, r13	; Xre is clear, convert to TNV
	and	r3, #<PS$M_CM@-PS$V_CM>, r3; Clean up ps bits
	 addq	r3, #pte$V_KRE, r3	; add offset to kre bits
	srl	r4, r3, r4		; Get cmRE to <0>
	 mf	r3, pt3
	cmovlbc r4, #scb$v_acv, r13	; Xre is clear, convert to ACV
	 lda	r4, 1(r31)		; set newr5 mmf (i stream)
	mt	r4, pt17		; save new r5
	 mf	r4, pt4
	br	r31, pal$post_km_trap	; and go build the trap



.sbttl	SP_NOT_VALID - MM_ERROR while building stack frame
;
; If we are on the Kernel stack, we are in big trouble,
; other wise we need to unwind the mess, post the MM error, and restart
; the current instruction.
; also need to re-calculate the reason for the dfault. As the ACV/TNV check
; was performed in PSmode, not ALTmode.
;
; Inputs:
;	pt0 has saved r0
;	pt1 has saved r1
;
;	pt12 has saved r12 [if not from chme]
;	pt13 has saved r13 [if not from chme]
;	pt14 has saved r14 [if not from chme]
;	pt15 has saved r15 [if not from chme]
;
;	pt16 has saved r16 [if not from chme]
;	pt17 has saved r17 [if not from chme]
;	pt18 has saved r18 [if not from chme]
;	pt19 has saved r19 [if not from chme]
;
;	pt20 has saved r20
;	pt21 has saved r21
;	pt22 has saved r22
;	pt23 has saved r23
;
;	pt3 has altmode (mode of attempted access)
;
;	r12 has PC of original exception  [if not from chme]
;	r27 has PC of original exception  [if from chme]
;
;	r20 has VA of current exception
;	r21 has PTE (soft<0> =1 for L3 fault)
;	r22 has MMF
;	r23 has SCB offset for this fault (ps_mode)
;	EXC_ADDR has PC of current exception
;-

	.align	quad
pal$post_chme_sp_not_valid::
	mt	r12, pt12
	mt	r13, pt13
	mt	r14, pt14
	mt	r15, pt15
	mt	r16, pt16
	mt	r17, pt17
	mt	r18, pt18
	mt	r19, pt19
	or	r27, r31, r12
	br	r31, pal$post_sp_not_valid

	align_to_cache_block	; align for branch target
pal$post_sp_not_valid::

	mt	r31, alt_mode		; clear alt_mode hw
	mf	r15, pt3		; get destination PS **ALTMODE**
	and	r15, #ps$m_cm, r15	; isolate mode
	beq	r15, pal$post_kmsp_not_valid1; check for KSP not valid

	srl	r21, #pte$v_soft, r13	; get l3 marker from pte_soft
	blbc	r13, 10$		; if set, is level 3 and we need to
					; redo the acv/tnv check, based
					; on altmode, not mode.

					; check for FOW
	lda	r14, SCB$V_FOW(r31)	; load FOW constant
	cmpeq	r23, r14, r14		; was it FOW
	bne	r14, 10$		; yes, so report it as such

	srl	r22, #63-2, r14		; get write *4
	srl	r21, r14, r14		; shift write enables down to read pos

	srl	r15, #PS$V_CM, r15	; shift to low bits
	addq	r15, #PTE$V_KRE, r15	; add offset to kre bits
	srl	r14, r15, r15		; Get cmRE to <0>
	lda	r23, SCB$V_TNV(r31)	; Assume we will take TNV
	BLBS	r15, 10$		; Kre is set, take the TNV
	lda	r23, SCB$V_ACV(r31)	; Not set, so convert to ACV

10$:	subq	r12, #4, r12		; original pc must have been "next"
	mt	r12, exc_addr		; convert to "current" and put it back


	mf	r0,  pt0
	 or	r23, r31, r13
	mf	r1,  pt1
	 or	r20, r31, r14
	mf	r17, pt17
	 or	r22, r31, r15
	mf	r16, pt16
	mf	r18, pt18
	mf	r19, pt19
	mf	r20, pt20
	mf	r21, pt21
	mf	r22, pt22
	mf	r23, pt23

	mt	r14, pt16
	 mf	r14, pt14
	mt	r15, pt17
	 mf	r15, pt15
	br	r31, pal$post_km_trap	; and go build the Kernel trap



;
; ksp is not valid, so halt
;
; but first, unwind the register file, and restore the PC
; the SP should be ok.. and be pointing the the errant ksp.
;

	.align	quad
	pvc$jsr	spec, dest=1
pal$post_kmsp_not_valid1::
	mf	r19, pt19
pal$post_kmsp_not_valid2::
	mf	r16, pt16
	mf	r17, pt17
	mf	r18, pt18
pal$post_kmsp_not_valid3::
	mt	r20, pt16
	 mf	r20, pt20
	mt	r21, pt17
	 mf	r21, pt21
	mt	r22, pt18
	 mf	r22, pt22
	mt	r23, pt19
	 mf	r23, pt23
	mt	r12, exc_addr		; reset old pc
	mf	r15, pt15
	mf	r14, pt14
	mf	r13, pt13
	mf	r12, pt12
pal$ksp_invalid_halt::
	mf	r1,  pt1
;	mf	r0,  pt0
	mf	r0, pt9			; get current ps
	bic	r0, #<<3@PS$v_SW>!PS$M_CM>, r0; Zap sw/cm field, pass int
	mt	r0, PT9_PS		; make sure we are in kernel mode
	pvc$jsr updpcb, bsr=1
	bsr	r0, pal$update_pcb	; update the pcb
	MCHK	KSP_INVAL, halt=1	; and halt


	.align	quad
pal$error_halt::
	or	r0, r31, r1		; save halt code
	pvc$jsr updpcb, bsr=1
	bsr	r0, pal$update_pcb	; update the pcb
	or	r1, r31, r0		; restore halt code
	mf	r1, pt1
	mf	r3, pt3
	br	r31, pal$enter_console	; enter the console



	.align	quad
pal$post_kmsp_not_valid4::
	mt	r22, exc_addr		; reset old pc
pal$post_kmsp_not_valid_cont::
	 mt	r20, pt16
	mf	r20, pt20
	 mt	r21, pt17
	mf	r21, pt21
	 mt	r22, pt18
	mf	r22, pt22
	 mt	r23, pt19
	mf	r23, pt23
	 br	r31,pal$ksp_invalid_halt


	.align	quad
	pvc$jsr	spec, dest=1
pal$post_kmsp_not_valid5::
	mt	r13, exc_addr		; reset old pc
	mf	r3,  pt3
	br	r31,pal$post_kmsp_not_valid_cont



pal$update_pcb:
	mt	r12, pt12
	mt	r13, pt13
	mt	r14, pt14
	stall	2

	mf	r13, pt9		; get ps
	mf	r12, pt31		; get pcbb
	and	r13, #PS$M_CM, r13	; Get PS<cm>*8
	bne	r13, 10$		; save ksp in pt, if we are kern
	mt	sp, pt26		; save ksp
10$:	addq	r12, r13, r13		; get addr of cmSP
	stq/p	sp, pcb$q_ksp(r13)	; update current mode SP

	mf	r13, astrr		; Get astrr
	srl	r13, #hirrr$v_astrr-4, r13; shift astrr to spot
	bic	r13, #^xf, r13		; clean astrr

	mf	r14, aster		; Get aster
	srl	r14, #hirrr$v_astrr, r14; shift astrr to zero

	or	r14, r13, r13		; merge asten, astrr
	stq/p	r13, pcb$q_ast(r12)	; store asten/astrr

	rpcc	r13			; get old cycle counter
	srl	r13, #32, r14		; get old cc<63:32>

	addl	r13, r14, r14		; old cc<31:0> + cc<63:32>
	stl/p	r14, pcb$q_cc(r12)	; store old cc in old pcb

	mf	r12, pt12
	mf	r13, pt13
	mf	r14, pt14

	pvc$jsr updpcb, bsr=1, dest=1
	ret	r31, (r0)		; back we go



.sbttl	IPLTBL - IPL table

;+
;
;	Pal$IplTblHi
; This table of 32 quadwords, is indexed into by IPL, to obtain the HIER and
; SIER bits to load into the chip. These bits directly control the interrupt
; enables of the chip. For all implimentations, the SIER portion should
; be the same. The HIER portion, will be re-worked depending on the meaning
; of the IRQ pins of the chip. On the ADU, these bits are as follows:
;
;	IRQ<0>	= HALT non-maskable interrupt
;	IRQ<1>	= device ipl 20
;	IRQ<2>	= device ipl 21
;	IRQ<3>	= device ipl 22
;	IRQ<4>	= device ipl 23
;	IRQ<5>	= clock  ipl 22
;
; For LCA, only IRQ<2:0> have external pins.  The remaining bits 
; are as follows:
;	IRQ<3>  = I/O controller error interrupt
;	IRQ<4>  = memory controller error interrupt
;	IRQ<5>  = IGN/RAZ
; The error interrupts (irq<4:3>) should be enabled at all times because
; fatal errors come in on them.
;-


Pal$IplTblHi::
	.if ne	adu_system
	.if ne lca4
	nhier  = <<^b011111@hierw$v_hier> ! <1@hierw$v_cre>> ; nominal hier ipl < 20
	nhierh = <^b011001@hierw$v_hier> ; nominal hier ipl >= 20
	.iff
	nhier  = <<^b111111@hierw$v_hier> ! <1@hierw$v_cre>> ; nominal hier ipl < 20
	nhierh = <^b000001@hierw$v_hier> ; nominal hier ipl >= 20
	.endc

	.long	nhier,	<^b111111111111111@<hierw$v_sier&^x1f>>	; ipl 0
	.long	nhier,	<^b111111111111110@<hierw$v_sier&^x1f>>
	.long	nhier,	<^b111111111111100@<hierw$v_sier&^x1f>>	; ipl 2
	.long	nhier,	<^b111111111111000@<hierw$v_sier&^x1f>>


	.long	nhier,	<^b111111111110000@<hierw$v_sier&^x1f>>	; ipl 4
	.long	nhier,	<^b111111111100000@<hierw$v_sier&^x1f>>
	.long	nhier,	<^b111111111000000@<hierw$v_sier&^x1f>>
	.long	nhier,	<^b111111110000000@<hierw$v_sier&^x1f>>


	.long	nhier,	<^b111111100000000@<hierw$v_sier&^x1f>>	; ipl 8
	.long	nhier,	<^b111111000000000@<hierw$v_sier&^x1f>>
	.long	nhier,	<^b111110000000000@<hierw$v_sier&^x1f>>
	.long	nhier,	<^b111100000000000@<hierw$v_sier&^x1f>>


	.long	nhier,	<^b111000000000000@<hierw$v_sier&^x1f>>	; ipl 12
	.long	nhier,	<^b110000000000000@<hierw$v_sier&^x1f>>
	.long	nhier,	<^b100000000000000@<hierw$v_sier&^x1f>>
	.long	nhier,	<^b000000000000000@<hierw$v_sier&^x1f>>	; ipl 15


	.long	nhier,	<^b000000000000000@<hierw$v_sier&^x1f>>	; ipl 16
	.long	nhier,	<^b000000000000000@<hierw$v_sier&^x1f>>
	.long	nhier,	<^b000000000000000@<hierw$v_sier&^x1f>>
	.long	nhier,	<^b000000000000000@<hierw$v_sier&^x1f>>	; ipl 19


	.if ne lca4
	.long	<nhierh ! <^b100@hierw$v_hier>>,0 		; ipl 20
	.long	<nhierh ! <^b000@hierw$v_hier>>,0		; ipl 21
	.long	<nhierh ! <^b000@hierw$v_hier>>,0		; ipl 22
	.long	<nhierh ! <^b000@hierw$v_hier>>,0		; ipl 23
	.iff
	.long	<nhierh ! <^b111100@hierw$v_hier>>,0 		; ipl 20
	.long	<nhierh ! <^b111000@hierw$v_hier>>,0		; ipl 21
	.long	<nhierh ! <^b010000@hierw$v_hier>>,0		; ipl 22
	.long	<nhierh ! <^b000000@hierw$v_hier>>,0		; ipl 23
	.endc
	
	.long	nhierh,	0					; ipl 24
	.long	nhierh,	0
	.long	nhierh,	0
	.long	nhierh,	0
	

	.long	nhierh,	0					; ipl 28
	.long	nhierh,	0
	.long	nhierh,	0
	.long	nhierh,	0					; ipl 31
	.endc

	.if ne	generic_system
	genipltbl
	.endc

	.if ne	sable_system
;;;	genipltbl	irq0=31, irq1=20, irq2=20, irq3=22, irq4=22, irq5=32
	.endc

	.if ne	avanti_system
	;
	;       IRQ pin 0       (1) IOB enabled at ipl <= 3 (APECS Chip Set Errors)
	;       IRQ pin 1       (0) Not Used 
	;       IRQ pin 2       (1) SIO enabled at ipl <= 2 (SIO device errors)
	;       IRQ pin 3       (1) NMI enabled at ipl <= 6 (SIO IOCHECK)
	;       IRQ pin 4       (1) RTC enabled at ipl <= 4 (RTC)
	;       IRQ pin 5       (1) Halt enabled
	;
	genipltbl	irq0=20, irq2=20, irq3=20, irq4=22, irq5=32
	.endc

	.if ne	k2_system
	;
	;       IRQ pin 0  -  enabled at ipl <= 31 - APECS Chip Set Errors
	;       IRQ pin 1  -  enabled at ipl <= 20 - PCI device interrupt
	;       IRQ pin 2  -  enabled at ipl <= 20 - SIO ISA device interrupt
	;       IRQ pin 3  -  enabled at ipl <= 31 - watchdog-server-NMI/HALT
	;       IRQ pin 4  -  enabled at ipl <= 22 - RTC interrupt
	;       IRQ pin 5  -  enabled at ipl <= 29 - watchdog/server warning
	;
	genipltbl	irq0=32, irq1=20, irq2=20, irq3=32, irq4=22, irq5=29
	.endc

	.if ne	mikasa_system ! noritake_system
	;
	;       IRQ pin 0       (1) IOB enabled at ipl <= 3 (APECS Chip Set Errors)
	;       IRQ pin 1       (1) Eisa IO 
	;       IRQ pin 2       (1) PCI IO
	;       IRQ pin 3       (1) NMI enabled at ipl <= 6 (SIO IOCHECK)
	;       IRQ pin 4       (1) RTC enabled at ipl <= 4 (RTC)
	;       IRQ pin 5       (1) Halt enabled
	;
	genipltbl	irq0=20, irq4=22, irq2=20, irq1=20, irq5=32
	.endc

	.if ne	mtu_system
	genipltbl	irq2=22, irq1=16, irq3=31, irq4=31, irq0=32
;	genipltbl	irq2=22, irq1=16
	.endc

	.if ne	lean_system
	genipltbl	irq0=22, irq1=32, irq2=20, irq3=32, irq4=32
	.endc

	.if ne	medulla_system
	.if ne	medulla_lcads
	; IPL Table for the Medulla LCADS board
	genipltbl	irq0=31, irq1=31, irq2=22
	.iff
	; IPL Table for the Medulla LCA board.
	; Note, IRQ0 int is at 32 so it is a
	; non-maskable Watchdog/Halt-switch.
	; IOC/MEM ints must be masked at 31 so
	; machine checks can be handled without
	; a double error.
	genipltbl	irq0=32, irq1=24, irq2=24, irq3=31, irq4=31
	.endc
	.endc

	.if ne	cortex_system
	;
	;       IRQ pin 5  -  serviced at ipl 31   - APECS Chip Set Errors
	;       IRQ pin 4  -  always enabled  (32) - Halt line, Wdog timeout
	;       IRQ pin 3  -  serviced at ipl 23   - vme reset, VME_IRQ7, VIC errors, VIC errors, IPC, DMA status, RT timer
	;       IRQ pin 2  -  serviced at ipl 22   - 1ms timer, VIP loc monitor
	;       IRQ pin 1  -  serviced at ipl 21   - VME_IRQ<6:4>, PMCx_IRQA
	;       IRQ pin 0  -  serviced at ipl 20   - SCSI,TULIP, PMCx_IRQ<D,C,B>, VME_IRQ<3:1>, VME_IAK, SIO ISA device interrupts
	;
	genipltbl	irq0=20, irq1=21, irq2=22, irq3=23, irq4=32, irq5=31
	.endc

Pal$BitBucketHi::
	.quad	0						; Pal$BitBucketHi

pal$IplTblHiEnd::
	assume <. - pal$start> lt <^x8000>			; assumes ipl tbl is in low 32kb

	.if ne	cfw_system
	.if eq	sable_system
	assume	<pal$ipltblhiend-pal$ipltblhi> eq <^x108>
	.endc
	.endc


.sbttl	PALUNATBL - PALmode UNA table

	.align	quad
pal$pal_una_ld_tbl:
	pvc$jsr	pult, dest=1
	or	r16, r31, r13	; move data to r13
	br	r31, pal_una_fin; now go finish up

	pvc$jsr	pult, dest=1
	or	r16, r31, r14	; move data to r14
	br	r31, pal_una_fin; now go finish up

	pvc$jsr	pult, dest=1
	or	r16, r31, r15	; move data to r15
	br	r31, pal_una_fin; now go finish up


	.align	quad
pal$pal_una_st_tbl:
	pvc$jsr	pust,dest=1
	or	r13, r31, r16	; move data from r13
	pvc$jsr	pustr1
	ret	r31, (r17)	; and back we go


	pvc$jsr	pust,dest=1
	or	r14, r31, r16	; move data from r14
	pvc$jsr	pustr2
	ret	r31, (r17)	; and back we go


	pvc$jsr	pust,dest=1
	or	r15, r31, r16	; move data from r15
	pvc$jsr	pustr3
	ret	r31, (r17)	; and back we go


	pvc$jsr	pust,dest=1
	mf	r16, pt16	; move data from r16
	pvc$jsr	pustr4
	ret	r31, (r17)	; and back we go


	pvc$jsr	pust,dest=1
	mf	r16, pt17	; move data from r17
	pvc$jsr	pustr5
	ret	r31, (r17)	; and back we go

	END_HW_VECTOR	ITB_MISS


.sbttl	FEN	- FEN faults

;+
; PAL$HW_VEC_FEN
;addr	len	use
;----	----	------------------------------
;17E0	 520 	Floating point disabled
;
; Entry:
;	Vectored into via hardware dispatch when fp instr executed with FEN off
;
; Function:
;	if fpu is not present, convert to OPCDEC, else generate FEN fault
;	Build stack frame
;	Dispatch through SCB
;
;-

	START_HW_VECTOR	FEN		; 9 cycles fen off
	mt	r14, pt14
	 mf	r14, pt2		; get iccsr
	mt	r12, pt12
	 mf	r12, exc_addr		; get address of instruction
	srl	r14, #iccsrw$v_fpe, r14	; shift for fpu spot
	 mt	r13, pt13
	lda	r13, scb$v_fen(r31)	; set scb vector to use
	 blbs	r12, pal$mchk_bugchk	; br if FEN within PAL
	blbs	r14, 10$		; br if fen on, and convert to opcdec
	 mf	r14, pt14
	br	r31, pal$post_km_trap_nr45; go build trap

	.align	quad
10$:	addq	r12, #4, r12		; pc = pc+4
	 lda	r13, scb$v_opcdec(r31)	; set scb vector to use
	mf	r14, pt14
	 br	r31, pal$post_km_trap_nr45; go build trap



.sbttl POST_TRAP - POST a trap


;+
;
; pal$post_km_trap[_nr45]
;
; Build a stack frame on kernel mode stack called from any mode.
; IPL is NOT changed. 
; DTB_MISS may be taken along the way
; Inputs:
;
;	 pt12 has saved r12
;	 pt13 has saved r13
;	[pt16 has new r4 unless _nr45]
;	[pt17 has new r5 unless _nr45]
;
;	r12 savedPC
;	r13 has SCB offset
;-

	align_to_double_cache_block	; align for branch target
pal$post_km_trap_nr45::			; 32 cycles
	mt	r14, pt14
	 bic	r12, #3, r12		; clear low 2 bits of old pc
	mf	r14, pt9		; get current ps
	 mt	r15, pt15
	mf	r15, pt31		; get pcbb
	 and	r14, #PS$M_CM, r14	; Get PS<cm>*8
	stall	1, mxpr=0
	 beq	r14, 10$		; skip stack swap if KM from KM

	addq	r15, r14, r14		; get addr of cmSP
	 mf	r15, pt26		; get new KM mode sp
	stq/p	sp, pcb$q_ksp(r14)	; update current mode SP
	 or	r15, r31, sp		; move sp to sp
10$:

	; allocate new stack frame
	or	sp, r31, r15		; move sp to sp
	 mf	r14, pt30		; get scbb
	bic	sp, #63, sp		; round down stack
	 subq	sp, #64, sp		; allocate frame


; r12 = current pc clean
; r13 = scb offset
; r14 = scbb
; r15 = new sp with low bits intact
; sp  = new sp

pal$post_km_trap_nr45_stq::
	stq/a	r2,  FRM$V_R2(sp)	; save r2
	 addq	r13, r14, r14		; get addr of our vector addr
	stq/a	r3,  FRM$V_R3(sp)	; save r3
	 and	r15, #63, r15		; get stack alignment
	stq/a	r4,  FRM$V_R4(sp)	; save r4
	 sll	r15, #PS$V_SP, r15	; shift to correct position for PS
	ldq/p	r2, 0(r14)		; get scbv
	 ldq/p	r3, 8(r14)		; get scbp
	stq/a	r5,  FRM$V_R5(sp)	; save r5
	 mf	r5, pt9			; get current ps
	stq/a	r6,  FRM$V_R6(sp)	; save r6
	 or	r15, r5, r15		; insert sp-align field in old PS

	stq/a	r7,  FRM$V_R7(sp)	; save r7
	 bic	R5, #<<3@PS$v_SW>!PS$M_CM>, r14; Zap sw/cm field, pass int
	stq/a	r12, FRM$V_PC(sp)	; save PC

	 mt	r14, PT9_PS		; set new ps
	mf	r12, pt12
	 bic	r2, #3, r2		; clean low bits of new pc
	stq/a	r15, FRM$V_PS(sp)	; save old PS
	 mf	r13, pt13
	mt	r2, exc_addr		; set new pc
	 mf	r14, pt14
	
.if ne enable_sstep
	mf	r15, pt25		; get the misc bits
	 srl	r15, #pt25$v_ss, r15	; get single step bit
	blbs	r15, 100$		; br if we are single steping
.endc
	mf	r15, pt15
	 hw_rei				; Now dispatch through scb to new vector




.if ne enable_sstep
; single step request
	.align	quad
100$:	mf	r15, exc_addr		; get new pc
	 addq	r15, #4, r15		; make it pc+4 for halt flow
	mt	r15, exc_addr		; put back in chip
	 mf	r15, pt15
	br	r31, PAL$ENTRY_HALT	; take the halt
.endc


	align_to_double_cache_block	; align for branch target
pal$post_km_trap::			; 35 cycles
	mt	r14, pt14
	 bic	r12, #3, r12		; clear low 2 bits of old pc
	mf	r14, pt9		; get current ps
	 mt	r15, pt15
	mf	r15, pt31		; get pcbb
	 and	r14, #PS$M_CM, r14	; Get PS<cm>*8
	beq	r14, 10$		; skip stack swap if KM from KM

	 addq	r15, r14, r14		; get addr of cmSP
	mf	r15, pt26		; get new KM mode sp
	 stq/p	sp, pcb$q_ksp(r14)	; update current mode SP
	or	r15, r31, sp		; move sp to sp
10$:

	; allocate new stack frame
	or	sp, r31, r15		; move sp to sp
	 mf	r14, pt30		; get scbb
	bic	sp, #63, sp		; round down stack
	 subq	sp, #64, sp		; allocate frame


; r12 = current pc clean
; r13 = scb offset
; r14 = scbb
; r15 = new sp with low bits intact
; sp  = new sp

pal$post_km_trap_stq::
	stq/a	r2,  FRM$V_R2(sp)	; save r2
	 addq	r13, r14, r14		; get addr of our vector addr
	stq/a	r3,  FRM$V_R3(sp)	; save r3
	 and	r15, #63, r15		; get stack alignment
	stq/a	r4,  FRM$V_R4(sp)	; save r4
	 sll	r15, #PS$V_SP, r15	; shift to correct position for PS
	ldq/p	r2, 0(r14)		; get scbv
	 ldq/p	r3, 8(r14)		; get scbp
	stq/a	r5,  FRM$V_R5(sp)	; save r5
	 mf	r5, pt9			; get current ps
	stq/a	r6,  FRM$V_R6(sp)	; save r6
	 or	r15, r5, r15		; insert sp-align field in old PS

	stq/a	r7,  FRM$V_R7(sp)	; save r7
	 stq/a	r12, FRM$V_PC(sp)	; save PC
	bic	R5, #<<3@PS$v_SW>!PS$M_CM>, r14; Zap sw/cm field, pass int

	 stq/a	r15, FRM$V_PS(sp)	; save old PS
	mf	r12, pt12
	 mt	r14, PT9_PS		; set new ps
	bic	r2, #3, r2		; clean low bits of new pc
	 mf	r13, pt13
	mt	r2, exc_addr		; set new pc
	 mf	r14, pt14
	mf	r4, pt16		; get new r4
	 mf	r5, pt17		; get new r5
	
.if ne enable_sstep
	mf	r15, pt25		; get the misc bits
	 srl	r15, #pt25$v_ss, r15	; get single step bit
	blbs	r15, 100$		; br if we are single steping
.endc
	mf	r15, pt15
	 hw_rei				; Now dispatch through scb to new vector




.if ne enable_sstep
; single step request
	.align	quad
100$:	 mf	r15, exc_addr		; get new pc
	addq	r15, #4, r15		; make it pc+4 for halt flow
	 mt	r15, exc_addr		; put back in chip
	mf	r15, pt15
	 br	r31, PAL$ENTRY_HALT	; take the halt
.endc
	



;+
;
; pal$post_km_ps_trap
;
; Build a stack frame on kernel mode stack called from any mode.
; IPL is NOT changed, but a new ps may be provided
; DTB_MISS may be taken along the way
; Inputs:
;
;	pt0  has new PS (note it may get trashed by a tb miss)
;	pt12 has saved r12
;	pt13 has saved r13
;	pt14 has saved r14
;	pt15 has saved r15
;
;	r12 savedPC
;	r13 has SCB offset
;	r14 has new_R4
;	r15 has new_R5
;-

	align_to_double_cache_block	; align for branch target
pal$post_km_ps_trap::			; 38 cycles
	mt	r16, pt16
	 mf	r16, pt9		; get ps
	mt	r17, pt17
	 mf	r17, pt31		; get pcbb
	mt	r18, pt18
	 and	r16, #PS$M_CM, r18	; Get PS<cm>*8

	beq	r18, 10$		; skip stack swap if KM from KM
	 addq	r18, r17, r18		; get addr of cmSP
	stq/p	sp, pcb$q_ksp(r18)	; update current mode SP
	 mf	sp, pt26		; get new KM mode sp
10$:
	ASSUME pcb$q_ksp EQ <0*8>
	ASSUME pcb$q_esp EQ <1*8>
	ASSUME pcb$q_ssp EQ <2*8>
	ASSUME pcb$q_usp EQ <3*8>

	; build old ps to be put on stack
	and	sp, #63, r17		; get stack alignment
	 sll	r17, #PS$V_SP, r17	; shift to correct position for PS
	mf	r18, pt30		; get scbb
	 bic	sp, #63, sp		; round down stack
	or	r16, r17, r17		; insert sp-align field in old PS

	 subq	sp, #64, sp		; allocate frame

	; build new ps
	mf	r16, pt0		; fetch new ps


; stack frame is allocated, now start to load the frame
; note that if a MM exception is to occure it WILL occure on the first
; reference to the stack (frame can not cross a page boundary)
;
; thus the following may be trashed by the dtb load on the next instruction
;	VA
;	EXC_ADDR
;	pt20
;	pt21
;	pt22

pal$post_km_ps_trap_stq::
	 stq/a	r2,  FRM$V_R2(sp)	; save r2
	stq/a	r3,  FRM$V_R3(sp)	; save r3
	 addq	r13, r18, r18		; get addr of our vector addr
	mt	r16, PT9_PS		; set new ps
	 bic	r12, #3, r12		; clear low 2 bits of pc
	ldq/p	r2, 0(r18)		; get scbv
	 ldq/p	r3, 8(r18)		; get scbp
	stq/a	r4,  FRM$V_R4(sp)	; save r4
	 or	r31, r14, r4		; r4=newR4
	stq/a	r5,  FRM$V_R5(sp)	; save r5
	 or	r31, r15, r5		; r5=newR5
	stq/a	r6,  FRM$V_R6(sp)	; save r6
	 bic	r2, #3, r2		; clean low bits of new pc
	stq/a	r7,  FRM$V_R7(sp)	; save r7
	 stq/a	r12, FRM$V_PC(sp)	; save PC
	stq/a	r17, FRM$V_PS(sp)	; save PS

	 mt	r2, exc_addr		; set new pc
	
	mf	r12, pt12
	 mf	r13, pt13
	mf	r14, pt14
	 mf	r15, pt15
	mf	r16, pt16
	 mf	r17, pt17
;.if ne enable_sstep
;	mf	r18, pt25		; get the misc bits
;	srl	r18, #pt25$v_ss, r18	; get single step bit
;	blbs	r18, 100$		; br if we are single steping
;.endc
	mf	r18, pt18
	 hw_rei				; Now dispatch through scb to new vector


;.if ne enable_sstep
;; single step request
;	.align	quad
;100$:	mf	r18, exc_addr		; get new pc
;	addq	r18, #4, r18		; make it pc+4 for halt flow
;	mt	r18, exc_addr		; put back in chip
;	mf	r18, pt18		; 
;	br	r31, PAL$ENTRY_HALT	; take the halt
;.endc


;+
;
; pal$post_xm_ps_trap
;
; Build a stack frame on kernel mode stack called from any mode.
; IPL is NOT changed, but a new ps may be provided
; DTB_MISS may be taken along the way
; Inputs:
;
;	pt0  has new PS (note it may get trashed by a tb miss)
;	pt12 has saved r12
;	pt13 has saved r13
;	pt14 has saved r14
;	pt15 has saved r15
;
;	r12 savedPC
;	r13 has SCB offset
;	r14 has new_R4
;	r15 has new_R5
;-

	align_to_double_cache_block	; align for branch target
pal$post_xm_ps_trap::			; 38 cycles
	mt	r16, pt16
	 mf	r16, pt9		; get ps
	mt	r17, pt17
	 mf	r17, pt31		; get pcbb
	mt	r19, pt19
	 mf	r19, pt0		; get new ps
	mt	r18, pt18
	 and	r16, #PS$M_CM, r18	; Get PS<cm>*8
	mt	r19, pt3
	 mt	r19, alt_mode
	and	r19, #ps$m_cm, r19	; get new mode
	 bne	r18, 10$		; save ksp in pt, if we are kern
	mt	sp, pt26		; save ksp if was old
10$:	 addq	r18, r17, r18		; get addr of cmSP
	
	stq/p	sp, pcb$q_ksp(r18)	; update current mode SP
	 addq	r19, r17, r17		; get addr of newSP
	stall	1
	 mf	r18, pt26		; fetch ksp if going to kern
	beq	r19, 20$		; get ksp from pt, if going to kern
	 ldq/p	r18, pcb$q_ksp(r17)	; get new newSP
20$:

	; build old ps to be put on stack
	mf	r19, pt30		; get scbb
	 and	r18, #63, r17		; get stack alignment
	sll	r17, #PS$V_SP, r17	; shift to correct position for PS
	 bic	r18, #63, r18		; round down stack
	or	r16, r17, r17		; insert sp-align field in old PS

	 subq	r18, #64, r18		; allocate frame
	mf	r16, pt0		; fetch the new ps


; stack frame is allocated, now start to load the frame
; note that if a MM exception is to occure it WILL occure on the first
; reference to the stack (frame can not cross a page boundary)
;
; thus the following may be trashed by the dtb load on the next instruction
;	VA
;	EXC_ADDR
;	pt20
;	pt21
;	pt22

pal$post_xm_ps_trap_stq::
	 stq/a	r2,  FRM$V_R2(r18)	; save r2
	addq	r13, r19, r19		; get addr of our vector addr
	 stq/a	r7,  FRM$V_R7(r18)	; save r7
	bic	r12, #3, r12		; clear low 2 bits of pc
	 stq/a	r3,  FRM$V_R3(r18)	; save r3
	ldq/p	r2, 0(r19)		; get scbv
	 ldq/p	r3, 8(r19)		; get scbp
	stq/a	r4,  FRM$V_R4(r18)	; save r4
	 or	r31, r14, r4		; r4=newR4
	stq/a	r5,  FRM$V_R5(r18)	; save r5
	 or	r31, r15, r5		; r5=newR5
	stq/a	r6,  FRM$V_R6(r18)	; save r6
	 bic	r2, #3, r2		; clean low bits of new pc
	stq/a	r12, FRM$V_PC(r18)	; save PC
	 mt	r16, PT9_PS		; set new ps
	or	r18, r31, sp		; update the sp
	 stq/a	r17, FRM$V_PS(r18)	; save PS

	mt	r2, exc_addr		; set new pc
	
	 mf	r12, pt12
	mf	r13, pt13
	 mf	r14, pt14
	mf	r15, pt15
	 mf	r16, pt16
	mf	r17, pt17
	 mf	r19, pt19		; restore r19
	mt	r31, alt_mode		; clear alt_mode hw
.if ne enable_sstep
	 mf	r18, pt25		; get the misc bits
	srl	r18, #pt25$v_ss, r18	; get single step bit
	 blbs	r18, 100$		; br if we are single steping
.endc
	 mf	r18, pt18
	hw_rei				; Now dispatch through scb to new vector




.if ne enable_sstep
; single step request
	.align	quad
100$:	mf	r18, exc_addr		; get new pc
	addq	r18, #4, r18		; make it pc+4 for halt flow
	mt	r18, exc_addr		; put back in chip
	mf	r18, pt18		; 
	br	r31, PAL$ENTRY_HALT	; take the halt
.endc


	
	.if ne <enable_debug_pctrace ! enable_debug_pcevent>
	
	.sbttl	TRACE_PC	debugging trace code
	
	; +
	; called jsr, r0, pal$trace_pc
	; writes a single quad word @pt11 with
	; <31:0>= callers pc, <63:32>=exc_addr<31:0>
	; wraps pt11, at 8 bits.
	;-

	align_to_double_cache_block	; align for branch target
pal$trace_pc::
	.if eq enable_debug_pcevent
;      mf	r1, pt28		; ptbr
;      stq/p	r1, <3*8>(r31)	
	
	stall	1
	mf	r1, pt11		; fetch base/limit
	sll	r0, #32, r0		; move trap pc to high long
	zap	r1, #^xf0, r1		; remove limit from addr
	or	r0, r1, r0		; r0= retpc/dataaddr
	mf	r1, pt11		; fetch base/limit
	srl	r1, #32, r1		; move bic mask to low long
	bic	r0, r1, r1		; r1=junk/clean_dataaddr
					; r0=retpc/junk
	addl	r1, #0, r1		; r1=clean_dataaddr
	zap	r0, #^x0f, r0		; r0=retpc/zero
	or	r0, r1, r0		; r0=retpc/dataaddr
	mf	r1, pt11		; get unmunged version
	zap	r1, #^x0f, r1		; remove old addr
	xor	r0, r1, r1		; insert new addr
	zap	r0, #^x0f, r0		; remove new addr
	xor	r0, r1, r1		; restore bit mask
					; r1, mask/newaddr
					; r0 retpc/zero
	mt	r1, pt11		; resave the new copy
	srl	r0, #32, r0		; r0=retpc
	



	mf	r1, exc_addr		; get trap pc
;      stq/p	r1, <1*8>(r31)		; pc
;      stq/p	sp, <2*8>(r31)		; sp
	sll	r1, #32, r1		; move trap pc to high long
	or	r1, r0, r0		; merge data, low long caller, hi, traper
	mf	r1, pt11		; get ram pointer
;     stq/p	r1, <0*8>(r31)		; ptbr
;     stq/p	r16, <4*8>(r31)		; r16
;     stq/p	r17, <5*8>(r31)		; r17
;     stq/p	r18, <6*8>(r31)		; r18
	blbs	r1, 5$			; don't log if paused
	addl	r1, #0, r1		; clean data pointer (high half is limit)
	stq/p	r0, (r1)		; store the quad in memory

	.iif ne enable_debug_astentrace,mf	r0, aster	; get aster
	.iif ne enable_debug_astentrace,stl/p	r0, 8(r1)	; store aster
	.iif ne enable_debug_astentrace,mf	r0, pt31	; get pcb
	.iif ne enable_debug_astentrace,stl/p	r0, 12(r1)	; store pcb

	.iif ne enable_debug_pstrace,mf	r0, pt9			; get ps
	.iif ne enable_debug_pstrace,stq/p	r0, 8(r1)	; store the ps in memory

	.iif ne enable_debug_sptrace,stl/p	sp, 12(r1)	; save low half of sp

	.iif ne enable_debug_trace2reg, stq/p	r16, <8*2>(r1)	; store r16
	.iif ne enable_debug_trace2reg, stq/p	r17, <8*3>(r1)	; store r17

	ldl/p	r0, (r1)		; restore callers pc

	; note, tbump_size must be a power of 2, or the wrapper, will screw up.
	tbump_size = 8
	.iif ne <enable_debug_sptrace! enable_debug_pstrace ! enable_debug_astentrace>, tbump_size = 16
	.iif ne <enable_debug_trace2reg>, tbump_size = 32

	mf	r1, pt11		; stash away new pointer
	addq	r1, #tbump_size, r1	; bump pointer
	mt	r1, pt11		; stash away new pointer

	;+
	; this code is used to watch for memory corruptions at known PA's
	; on every entry it looks for the data cell of interest to go to zero
	; if it does we halt, else we continue
	;
;	get_addr r1, <^x012780>, r31	; get an addr
;	ldq/p r1, (r1)			; fetch the data
;	bne	r1, 5$			; continue if not a zero, else
;	get_addr r1, <^x012780>, r31	; get an addr
;	stl/p r1, (r1)			; change data to no, zero
;	pvc$violate	1002
;	.long ^xbf			;  halt
	;-

	stall	1
5$:	addl	r0, #0, r0		; clean data pointer (high half is limit)
	pvc$jsr	tracev, bsr=4001, dest=1
	ret	r31, (r0)		; no, so back we go

	.iff
	
; r0 <31:0> has pal ret addr
; r1 <31:0> has offset to our scratch cell

	sll	r0, #32, r0		; move ret addr up
	or	r0, r1, r0		; save offset in low part of pc

	mf	r1, pt11		; get base of data section
	blbs	r1, 10$			; pt11<0> is a disable counter flag

	zap	r1, #^xf0, r1		; remove limit from addr
	or	r1, r0, r1		; now have merged the whole mess
	zap	r1, #^xf0, r1		; remove junk from addr

	zap	r0, #^x0f, r0		; remove offset from r0
	or	r0, r1, r0		; save addr in low part of ret addr


	stq/p	r0, 8(r1)		; save pc and addr in memory
	ldq/p	r0, (r1)		; get incr data cell
	addq	r0, #1, r0		; inc the cell
	stq/p	r0, (r1)		; save updated cell
	ldq/p	r0, 8(r1)		; restore save pc from memory
10$:	srl	r0, #32, r0		; restore ret addr
	pvc$jsr	tracev, bsr=4001, dest=1
	ret	r31, (r0)		; no, so back we go
	
	.endc
	.endc


	END_HW_VECTOR	FEN


.sbttl	OPCDEC	- Opcode reserved to DEC

;+
; PAL$HW_VEC_OPCDEC
;addr	len	use
;----	----	------------------------------
;13E0	256 	Opcode dec
;
; Entry:
;	Vectored into via hardware dispatch when illegal instr executed
;
; Function:
;	Build stack frame
;	Dispatch through SCB
;
;-

	START_HW_VECTOR	OPCDEC		; 6 cycles
	mt	r12, pt12		; Save r12
	 mf	r12, exc_addr		; get address of instruction
	mt	r13, pt13		; Save r13
	.if ne	cfw_system
	blbs	r12, 2$			; Branch if in PALmode
	mf	r13, pt28		; Get PTBR
	blbc	r13, 2$			; Branch if not in console mode
	ldl	r13, (r12)		; Get faulting instruction
	mt	r14, pt14		; Save registers
	mt	r15, pt15		;
	srl	r13, #26, r14		; Extract opcode
	and	r14, #63, r14		;
	subq	r14, #10, r15		; Check for LDBU
	beq	r15, bw_ldbu		; Branch if so
	subq	r14, #14, r15		; Check for STB
	beq	r15, bw_stb		; Branch if so
	subq	r14, #12, r15		; Check for LDWU
	beq	r15, bw_ldwu		; Branch if so
	subq	r14, #13, r15		; Check for STW
	beq	r15, bw_stw		; Branch if so
	subq	r14, #28, r15		; Check for SEXTx
	bne	r15, 1$			; Branch if not
	srl	r13, #5, r14		; Extract function
	and	r14, #127, r14		;
	subq	r14, #0, r15		; Check for SEXTB
	beq	r15, bw_sextb		; Branch if so
	subq	r14, #1, r15		; Check for SEXTW
	beq	r15, bw_sextw		; Branch if so
1$:	mf	r14, pt15		; Restore registers
	mf	r15, pt15		;
2$:	mt	r12, exc_addr		; Restore EXC_ADDR
	.endc
	 lda	r13, scb$v_opcdec(r31)	; set scb vector to use
	addq	r12, #4, r12		; make err pc be "next"
	 blbs	r12, pal$mchk_bugchk	; br if opcdec within PAL
	br	r31, pal$post_km_trap_nr45; and go build the trap

	.if ne	cfw_system
bw_ldbu:
	sget_addr r15, bw_dfault-pal$start, r31, verify=0 ; Get fault routine
	mt	r15, pt3		;  address, and save it
	mt	r16, pt16		; Save more registers
	mt	r17, pt17		;
	addq	r12, #4, r17		; Set next PC
	srl	r13, #16, r14		; Extract Rb
	and	r14, #31, r14		;
	pvc$jsr		rr, bsr=1
	bsr	r16, bw_read_register	; Read Rb (to R15)
	sll	r13, #48, r14		; Extract offset (sign-extended)
	sra	r14, #48, r14		;
	addq	r14, r15, r14		; Compute source address
	ldq_u	r12, (r14)		; Read the byte
	extbl	r12, r14, r15		;
	srl	r13, #21, r14		; Extract Ra
	and	r14, #31, r14		;
	pvc$jsr		wr, bsr=1
	bsr	r16, bw_write_register	; Write Ra (from R15)
	br	r31, bw_exit		;

bw_stb:
	sget_addr r15, bw_dfault-pal$start, r31, verify=0 ; Get fault routine
	mt	r15, pt3		;  address, and save it
	mt	r16, pt16		; Save more registers
	mt	r17, pt17		;
	addq	r12, #4, r17		; Set next PC
	srl	r13, #16, r14		; Extract Rb
	and	r14, #31, r14		;
	pvc$jsr		rr, bsr=1
	bsr	r16, bw_read_register	; Read Rb (to R15)
	sll	r13, #48, r14		; Extract offset (sign-extended)
	sra	r14, #48, r14		;
	addq	r14, r15, r12		; Compute destination address
	srl	r13, #21, r14		; Extract Ra
	and	r14, #31, r14		;
	pvc$jsr		rr, bsr=1
	bsr	r16, bw_read_register	; Read Ra (to R15)
	ldq_u	r14, (r12)		; Write the byte
	insbl	r15, r12, r16		;
	mskbl	r14, r12, r14		;
	or	r14, r16, r14		;
	stq_u	r14, (r12)		;
	br	r31, bw_exit		;

bw_ldwu:
	sget_addr r15, bw_dfault-pal$start, r31, verify=0 ; Get fault routine
	mt	r15, pt3		;  address, and save it
	mt	r16, pt16		; Save more registers
	mt	r17, pt17		;
	addq	r12, #4, r17		; Set next PC
	srl	r13, #16, r14		; Extract Rb
	and	r14, #31, r14		;
	pvc$jsr		rr, bsr=1
	bsr	r16, bw_read_register	; Read Rb (to R15)
	sll	r13, #48, r14		; Extract offset (sign-extended)
	sra	r14, #48, r14		;
	addq	r14, r15, r14		; Compute source address
	ldq_u	r12, (r14)		; Read the word
	ldq_u	r15, 1(r14)		;
	extwl	r12, r14, r12		;
	extwh	r15, r14, r15		;
	or	r15, r12, r15		;
	srl	r13, #21, r14		; Extract Ra
	and	r14, #31, r14		;
	pvc$jsr		wr, bsr=1
	bsr	r16, bw_write_register	; Write Ra (from R15)
	br	r31, bw_exit		;

bw_stw:
	sget_addr r15, bw_dfault-pal$start, r31, verify=0 ; Get fault routine
	mt	r15, pt3		;  address, and save it
	mt	r16, pt16		; Save more registers
	mt	r17, pt17		;
	addq	r12, #4, r17		; Set next PC
	srl	r13, #16, r14		; Extract Rb
	and	r14, #31, r14		;
	pvc$jsr		rr, bsr=1
	bsr	r16, bw_read_register	; Read Rb (to R15)
	sll	r13, #48, r14		; Extract offset (sign-extended)
	sra	r14, #48, r14		;
	addq	r14, r15, r12		; Compute destination address
	srl	r13, #21, r14		; Extract Ra
	and	r14, #31, r14		;
	pvc$jsr		rr, bsr=1
	bsr	r16, bw_read_register	; Read Ra (to R15)
	ldq_u	r13, 1(r12)		; Write the word
	ldq_u	r14, (r12)		;
	inswh	r15, r12, r16		;
	mskwh	r13, r12, r13		;
	or	r13, r16, r13		;
	inswl	r15, r12, r16		;
	mskwl	r14, r12, r14		;
	or	r14, r16, r14		;
	stq_u	r13, 1(r12)		;
	stq_u	r14, (r12)		;
	br	r31, bw_exit		;

bw_sextb:
	sget_addr r15, bw_dfault-pal$start, r31, verify=0 ; Get fault routine
	mt	r15, pt3		;  address, and save it
	mt	r16, pt16		; Save more registers
	mt	r17, pt17		;
	addq	r12, #4, r17		; Set next PC
	srl	r13, #12, r14		; Check format
	blbs	r14, 1$			; Branch if literal
	srl	r13, #16, r14		; Extract Rb
	and	r14, #31, r14		;
	pvc$jsr		rr, bsr=1
	bsr	r16, bw_read_register	; Read Rb (to R15)
	br	r31, 2$			;
1$:	srl	r13, #13, r14		; Extract literal
	and	r14, #255, r14		;
2$:	sll	r15, #56, r15		; Sign-extend the byte
	sra	r15, #56, r15		;
	and	r13, #31, r14		; Extract Rc
	pvc$jsr		wr, bsr=1
	bsr	r16, bw_write_register	; Write Rc (from R15)
	br	r31, bw_exit		;

bw_sextw:
	sget_addr r15, bw_dfault-pal$start, r31, verify=0 ; Get fault routine
	mt	r15, pt3		;  address, and save it
	mt	r16, pt16		; Save more registers
	mt	r17, pt17		;
	addq	r12, #4, r17		; Set next PC
	srl	r13, #12, r14		; Check format
	blbs	r14, 1$			; Branch if literal
	srl	r13, #16, r14		; Extract Rb
	and	r14, #31, r14		;
	pvc$jsr		rr, bsr=1
	bsr	r16, bw_read_register	; Read Rb (to R15)
	br	r31, 2$			;
1$:	srl	r13, #13, r14		; Extract literal
	and	r14, #255, r14		;
2$:	sll	r15, #48, r15		; Sign-extend the word
	sra	r15, #48, r15		;
	and	r13, #31, r14		; Extract Rc
	pvc$jsr		wr, bsr=1
	bsr	r16, bw_write_register	; Write Rc (from R15)
;;;	br	r31, bw_exit		;

bw_exit:
	mt	r17, exc_addr		; Restore EXC_ADDR
	mf	r12, pt12		; Restore all registers
	mf	r13, pt13		;
	mf	r14, pt14		;
	mf	r15, pt15		;
	mf	r16, pt16		;
	mf	r17, pt17		;
	hw_rei				; Return to next instruction

	pvc$jsr		spec, dest=1
bw_dfault:
	subq	r17, #4, r12		; Get original PC
	or	r23, r31, r13		;  and set SCB offset
	mf	r14, pt14		; Restore some registers
	mf	r15, pt15		;
	mf	r16, pt16		;
	mf	r17, pt17		;
	mt 	r20, pt16		; Set new R4 (faulting VA)
	mt	r22, pt17		; Set new R5 (fault code)
	stall	2			; Stall for MT above
	mf	r0, pt0			; Restore remaining registers
	mf	r1, pt1			;
	mf	r20, pt20		;
	mf	r21, pt21		;
	mf	r22, pt22		;
	mf	r23, pt23		;
	br	r31, pal$post_km_trap	; Go post the trap

	CONT_HW_VECTOR	OPCDEC

.macro	bw_read_reg	n, pal=0
.if ne	pal
	mf	r15, pt'n'
.iff
	bis	r'n', r31, r15
.endc
	pvc$jsr		rr, bsr=1, dest=1
	ret	r31, (r16)
.endm

bw_read_register:
	br	r15, 1$
	pvc$jsr		rrm, dest=1
	bw_read_reg	0
	bw_read_reg	1
	bw_read_reg	2
	bw_read_reg	3
	bw_read_reg	4
	bw_read_reg	5
	bw_read_reg	6
	bw_read_reg	7
	bw_read_reg	8
	bw_read_reg	9
	bw_read_reg	10
	bw_read_reg	11
	bw_read_reg	12, pal=1
	bw_read_reg	13, pal=1
	bw_read_reg	14, pal=1
	bw_read_reg	15, pal=1
	bw_read_reg	16, pal=1
	bw_read_reg	17, pal=1
	bw_read_reg	18
	bw_read_reg	19
	bw_read_reg	20
	bw_read_reg	21
	bw_read_reg	22
	bw_read_reg	23
	bw_read_reg	24
	bw_read_reg	25
	bw_read_reg	26
	bw_read_reg	27
	bw_read_reg	28
	bw_read_reg	29
	bw_read_reg	30
	bw_read_reg	31
1$:	s8addq	r14, r15, r14
	pvc$jsr		rrm
	jmp	r31, (r14)

.macro	bw_write_reg	n, pal=0
.if ne	pal
	mt	r15, pt'n'
.iff
	bis	r15, r31, r'n'
.endc
	pvc$jsr		wr, bsr=1, dest=1
	ret	r31, (r16)
.endm

bw_write_register:
	br	r13, 1$
	pvc$jsr		wrm, dest=1
	bw_write_reg	0
	bw_write_reg	1
	bw_write_reg	2
	bw_write_reg	3
	bw_write_reg	4
	bw_write_reg	5
	bw_write_reg	6
	bw_write_reg	7
	bw_write_reg	8
	bw_write_reg	9
	bw_write_reg	10
	bw_write_reg	11
	bw_write_reg	12, pal=1
	bw_write_reg	13, pal=1
	bw_write_reg	14, pal=1
	bw_write_reg	15, pal=1
	bw_write_reg	16, pal=1
	bw_write_reg	17, pal=1
	bw_write_reg	18
	bw_write_reg	19
	bw_write_reg	20
	bw_write_reg	21
	bw_write_reg	22
	bw_write_reg	23
	bw_write_reg	24
	bw_write_reg	25
	bw_write_reg	26
	bw_write_reg	27
	bw_write_reg	28
	bw_write_reg	29
	bw_write_reg	30
	bw_write_reg	31
1$:	s8addq	r14, r13, r14
	pvc$jsr		wrm
	jmp	r31, (r14)
	.endc

pal$mchk_bugchk:
	 MCHK	BUGCHECK, save_pt=1	; and mchk

	.align	quad
pal$calpal_opcdec::			; 5 cycles
	mt	r12, pt12		; Save r12
	 mf	r12, exc_addr		; get address of instruction
	mt	r13, pt13		; Save r13
	 lda	r13, scb$v_opcdec(r31)	; set scb vector to use
ev4_p1	 <addq	r12, #4, r12>		; make err pc be "next"
	or	r12, r12, r12		; make the br be pvc safe
	 pvc$violate	1008		; Hush up PVC
	 br	r31, pal$post_km_trap_nr45; and go build the trap



.sbttl QUEUE_ERROR	- QUEUE instruction error routines

;+
;
; These routines are used by the queue instructions to handle error cases
; They are used by both the long and quad word queue instructions.
; For the quadword queues, this means that a STL[/C] is used instead of the
; normal STQ[/C], this works, because we are trying to clear the lock
; (either secondary or primary) and the only bits we are attempting to
; change are ALWAYS in the low 32 bits on a little endian machine.
;
;-


;+
;
; pal$queue_fault_setup
;
; while doing a QUEUE probe we have encountered a mm error
;	memory management error. Our function, is to unscramble the
;	register state, and transition into the stack builder.
;
;
; Regs' on entry...
;
;	From the queue instr routine
;	pt12-13 (or 14) <- r12-13 (or 14)
;	r12 = pc of queue instr, with <1:0> clear
;
;
;	From the special handler
;	pt0,1,20-23 <- r0,1,20-23
;	R20 = VA
;	R21 = pte with l3 and recheck marker correct.
;	R22 = MMF
;	R23 = scb offset for this fault
;
;
;	The stack builder is expecting
;	pt12-16	<- r12-16
;	r12 PC
;	r13 has SCB offset
;	r14 has new_R4 (VA)
;	r15 has new_R5 (MMF)
;	r16 has new mode, ipl (if <63> set)
;
;
;
;-

	align_to_cache_block
	pvc$jsr	spec, dest=1
pal$queue_fault_setup2::		; case where r14 has been saved
	mf	r14, pt14
	pvc$jsr	spec, dest=1
pal$queue_fault_setup1::
	 mf	r22, mm_csr		; get mmcsr
	lda	r13, scb$v_illpal(r31)	; get illpal code
	 mt	r20, pt16		; get new r4
	cmpeq	r23, r13, r13		; was err illpalop?
	 xor	r13, #1, r13		; flip it
	cmovlbs r13, #4, r13		; is no, make pc=pc+4, not pc
	 subq	r12, r13,  r12		; make pc=pc, not pc+4

	srl	r22, #mmcsr$v_opc, r20	; shift opc to <0>
	 mf	r0,  pt0
	or	r23, r31, r13		; get scb offset
	 mf	r1,  pt1

	cmpeq	r20, #EVX$OPC_HW_LD, r20; is it hw ldx/?
	 or	r22, r20, r22		; set write if hw_ld, or was write

	cmpeq	r13, #scb$v_for, r21	; was it just FOR
	 mf	r20, pt20
	mf	r23, pt23
	 bic	r22, r21, r22		; set mmf to read if FOR
	mf	r21, pt21
	 sll	r22, #63, r22		; set up mmc
	mt	r22, pt17
	 mf	r22, pt22
	mt	r14, pt14
	 and	r12, #2, r14		; get lock flag indicator
	beq	r14, 10$		; skip clear of lock flag if not locked


	; we have not gone beyone the point of no return on this queue
	; instruction, but we have completed the probe of the queue header
	; essentially, we are beyond the point of no return for the header
	; so we reset the fault hander to reflect that we are in a do
	; or die situation.
	 sget_addr r14, <pal$queue_fault2-pal$start>, r31,verify=0; get address
	mt	r14, pt3		; set recovery address
	 stl	r0, (r16)		; clear lock flag in header
10$:	stall	1
	 mf	r14, pt14
	br	r31, pal$post_km_trap	; go post the trap


	.align	quad
	pvc$jsr	spec, dest=1
pal$queue_fault_setup3nl::		; case where r14 has been saved
	mf	r15, pt15
	mf	r18, pt18

	pvc$jsr	spec, dest=1
pal$queue_fault_setup2nl::		; case where r14 has been saved
	mf	r14, pt14
	pvc$jsr	spec, dest=1
pal$queue_fault_setup1nl::
	bic	r12, #2, r12		; ensure lock flag indicator is clear
	br	r31, pal$queue_fault_setup1 ; join common flow




;+
;
; pal$queue_fault
;
;	while doing a QUEUE access we have encountered a mm error
;	memory management error. ; The only expected error is TNV
;	on level 3 pte's. In that case the TB is loaded with the
;	invalid pte, and we continue. Otherwise we MCHK.
;
;
; Regs' on entry...
;
;	From the queue instr routine
;	pt12-13 or 14 <- r12-13 or 14
;	r12 = pc of queue instr, with <1:0> clear
;
;
;	From the special handler
;	pt0,1,20-23 <- r0,1,20-23
;	R20 = VA
;	R21 = pte with l3 and recheck marker correct.
;	R22 = MMF
;	R23 = scb offset for this fault
;
;
;
;-
	align_to_cache_block
	pvc$jsr	spec, dest=1
pal$queue_fault3::
	addq	r0, #1, r0		; set r0<1:0> to 2 if from fault3
	pvc$jsr	spec, dest=1
pal$queue_fault2::
	addq	r0, #1, r0		; set r0<1:0> to 1 if from fault2
	pvc$jsr	spec, dest=1
pal$queue_fault1::
					; set r0<1:0> to 0 if from fault1
	mt	r21, dtb_ctl		; Jam in gran hints
	srl	r21, #pte$v_soft, r1	; Get SW field (is really level check)
	cmpeq	r23, #SCB$V_TNV, r23	; Check for TNV
	and	r23, r1, r23		; Is it both level 3, and TNV?
	mf	r1,  pt1
	blbc	r23, 30$		; nope, take an MCHK
	mf	r0,  pt0
	mt	r20, tb_tag		; Load TB TAG and clear TB valid bit
	mt	r21, dtb_pte		; Load PTE and set TB valid bit
	mf	r20, pt20
	mf	r21, pt21
	mf	r22, pt22
	mf	r23, pt23
	hw_rei				; go back and re-try access

	.align	quad
30$:	and	r0, #3, r0		; isolate flag bits
	beq	r0, 31$			; br if queue_fault1
	blbs	r0, 32$			; br if queue_fault2
33$:	mf	r18, pt18
	mf	r15, pt15
32$:	mf	r14, pt14
31$:	mf	r13, pt13
	mt	r12, exc_addr		; set pc
	mf	r12, pt12

	mf	r0,  pt0
	mf	r20, pt20
	mf	r21, pt21
	mf	r22, pt22
	mf	r23, pt23
	MCHK	OS_BUGCHECK 		; and mchk


;+
;
; pal$queue_fault_resident
;
; While executing a Resident queue instruction we have encountered a
;	mm error.  In this case we abandon the queue leaving it in whatever
;	partial state it may be in, and transition into the stack builder
;	to post a invalid operand trap.
;
; Registers on entry...
;
;	From the queue instr routine
;	pt12-15,18 <- r12-15,18
;	r12 = pc of queue instr
;
;	From the special handler
;	pt0,1,20-23 <- r0,1,20-23
;	r20 =va
;	r21 = pte with l3 and recheck marker correct
;	r22 = mmf
;	r23 = scb offset for this fault
;
;	The stack builder expects:
;	pt12-16 <-r12-16
;	r12 pc
;	r13 has scb offset
;
;-
	
	align_to_cache_block
	pvc$jsr	spec, dest=1
pal$queue_fault_resident2::
	stall	1
	mf	r14, pt14
	pvc$jsr	spec, dest=1
pal$queue_fault_resident1::
	stall	1
	mf	r0, pt0
	mf	r1, pt1
	mf	r20, pt20
	mf	r23, pt23

	lda	r13, scb$v_illpal(r31)	; set scb vector to use
	mf	r21, pt21
	mf	r22, pt22
	br	r31, pal$post_km_trap_nr45	; go post the trap

.if eq	disable_probe
.sbttl PROBE_ERROR	- PROBE[w] instruction error routines
;+
;
; pal$probe_fault
;
; while doing a PROBE[w] probe we have encountered an mm error
;	memory management error. Our function, is  to determine
;	why the fault happend, and to take action accordingly
;	as below:
;
;	1. TNV,FOR,FOW, dismiss the error, continue with the probe
;	2. ACV the probe is terminated, and failure is returned
;	3. Level 1 or 2 TNV, build stack frame, generate trap
;
;
;
; Regs' on entry...
;
;	From the probe instr routine
;	pt12,13 <- r12,13
;	pt15	= alt_mode
;	R12	= pc of probe instr
;	exc_addr, addr of ldx that traped
;
;
;	From the special handler
;	pt0,1,20-23 <- r0,1,20-23
;	R20 = VA
;	R21 = pte with l3 and recheck marker correct.
;	R22 = MMF
;	R23 = scb offset for this fault
;
;
;	The stack builder is expecting
;	pt12,13	<- r12,13
;	r12 PC
;	r13 has SCB offset
;	pt16 has new_R4 (VA)
;	pt17 has new_R5 (MMF)
;
;
;
;-

	align_to_cache_block		; align for branch target
pal$probew_fault::			
	xor	r0, #1, r0		; r0, now equals 1
pal$prober_fault::			
	cmpeq	r23, #SCB$V_FOR, r1	; Check for FOR
	bne	r1, 100$		; Yes, so we have succeded
	cmpeq	r23, #SCB$V_FOW, r1	; Check for FOW
	bne	r1, 100$		; Yes, so we have succeded

	sll	r0, #63, r22		; set correct mmf in case we TNV
	srl	r21, #pte$v_soft+1, r0	; do we need to recheck the acv/tnv?
	blbs	r0, 30$			; yes
	cmpeq	r23, #SCB$V_ACV, r0	; Check for L12, REAL L3 ACV
	bne	r0, 200$		; Yes, so we have failed
	br	r31, 300$		; No, must be a L12 TNV, so report TNV

	.align	quad
30$:	; we now have a level 3 ACV/TNV from dtb_miss
	; so we have to hand recheck the access

	srl	r22, #63-2, r22		; Now Read=0, Write = 4
	lda	r0, <1@pte$v_kre>(r31)	; get a KRE bit

	mf	r13, pt15		; get correct access mode
	srl	r13, #ps$v_cm, r13	; now is mode counter
	sll	r0, r13, r0		; now is xRE (where x=mode)
	sll	r0, r22, r0		; now is xaE (where a=R/W)
	and	r21, r0, r0		; is xae set
	beq	r0, 200$		; not set, ACV, we fail
;	.br	r31, 100$		;     set ,TNV, Success


;+
;
; This part of the PROBE[w] has succeded
; un-scramble the registers, and continue with the probe
;
;-

	align_branch_target		; align for branch target
100$:	mf	r13, exc_addr		; get exec addr
	mf	r0,  pt0		; restore Reg
	mf	r1,  pt1		; restore Reg
	addq	r13, #4, r13		; continuation addr is ldx+4
	mf	r20, pt20		; restore Reg
	mf	r21, pt21		; restore Reg
	mf	r22, pt22		; restore Reg
	mf	r23, pt23		; restore Reg
	pvc$jsr	prbokr
	jmp	r31, (r13), pal$prober_ldl2; continue




;+
;
; This part of the PROBE[w] has failed
; un-scramble the registers, and terminate the probe
;
;-
	.align	quad
200$:	mt	r31, alt_mode		; clear alt_mode hw
	or	r31, r31, r0		; flag no access
	mt	r12, exc_addr		; set return address
;	mf	r0,  pt0		; restore Reg
	mf	r1,  pt1		; restore Reg
	mf	r20, pt20		; restore Reg
	mf	r21, pt21		; restore Reg
	mf	r22, pt22		; restore Reg
	mf	r23, pt23		; restore Reg
	mf	r12, pt12		; restore r12
	mf	r13, pt13		; restore r13
	hw_rei				; back to user

;+
;
; while doing a PROBE[w] we have encountered a level 1 or 2 PTE that is
; not valid. We will un-scramble the registers, and generate a TNV trap
; useing the PC of the PROBE[w] instruction, and the VA that the probe[w]
; failed on.
;
;-
	.align	quad
300$:	mt	r31, alt_mode		; clear alt_mode hw
;	mf	r12, exc_addr		; get faulting pc
	subq	r12, #4, r12		; make pc=pc, not pc+4
	mf	r0,  pt0
	or	r23, r31, r13		; get scb offset
	mf	r1,  pt1
	mf	r23, pt23
	mf	r21, pt21
	mt	r20, pt16		; set new r4
	mf	r20, pt20
	mt	r22, pt17		; set new r5
	mf	r22, pt22
	br	r31, pal$post_km_trap	; go post the trap

.endc

.sbttl	DTB_ERR - More TB error completion routines for misses from non-PAL


;+
;
; pal$ndtb_miss_ldq_error
;
;	We get here, if the virtual pte load fails due to some sort of
;	memory management error. Our function, is to unscramble the
;	register state, and transition into the stack builder.
;
;	Unless of course the instr was a fetch[m], in which case
;	we dismiss the error and continue.
;
; Regs' on entry...
;
;	From the ndtb_miss routine
;	R3, 4,5 saved in PT3, 4,5
;	PT6 = va of this miss
;	R3  = pc of this miss
;	R5  = mmcsr of this miss
;
;
;	From the special handler
;	pt0,1,20-23 <- r0,1,20-23
;	R20 = VA
;	R21 = pte with l3 and recheck marker correct.
;	R22 = MMF
;	R23 = scb offset for this fault
;
;
;	The stack builder is expecting
;	pt12-16	<- r12-16
;	r12 PC
;	r13 has SCB offset
;	r14 has new_R4 (VA)
;	r15 has new_R5 (MMF)
;
;
;
	align_to_cache_block	; align for branch target
pal$ndtb_miss_ldq_error::		; 17 cycles
	srl	r21, #PTE$V_KRE, r21	; get kre bit
	 mt	r14, pt14
	mf	r14, pt6		; set up va
	 srl	r5, #mmcsr$v_opc, r4	; shift opc to <0>
	mt	r12, pt12
	 cmovlbs r21, #SCB$V_TNV, r23	; recheck l2 access
	mt	r13, pt13
	 cmpeq	r4, #EVX$OPC_SYNC, r4	; is it FETCH/FETCH_M?
	mt	r15, pt15
	 or	r3, r31, r12		; set up pc
	blbs	r4, vpte_fetch_err	; yup,was fetch... bag the trap
	 or	r23, r31, r13		; set up scb offset
	stall	1
	 sll	r5,  #63, r15		; set up mmf flags
	mf	r20, pt20
	 mf	r21, pt21
	mf	r22, pt22
	 mf	r23, pt23
	mf	r0,  pt0
	 mf	r1,  pt1
	mf	r3,  pt3
	 mf	r4,  pt4
	mf	r5,  pt5
	 mt	r14, pt16
	mf	r14, pt14
	 mt	r15, pt17
	mf	r15, pt15
	 br	r31, pal$post_km_trap	; and go build the trap


;+
;
; vpte_fetch_err
;
;	We get here, if was have taken a fault while fetching a dsteam
;	virtual pte and the original instruction was a fetch[m]
;
;	We unwind the register mess, and bump the pc, and return.
;	No stack frame is built, no trap is taken.
;
;-
	align_to_cache_block		; align for branch target
vpte_fetch_err::			; 16 cycles
	stall	1
	 addq	r3, #4, r3		; pc+4
	mf	r20, pt20
	 mt	r3, exc_addr
	mf	r21, pt21
	 mf	r22, pt22
	mf	r23, pt23
	 mf	r0,  pt0
	mf	r1,  pt1
	 mf	r3,  pt3
	mf	r4,  pt4
	 mf	r5,  pt5
	mf	r12,  pt12
	 mf	r13,  pt13
	mf	r14,  pt14
	 mf	r15,  pt15
	hw_rei				; go back and try access






;+
;
; pal$itb_miss_ldq_error
;
;	We get here, if the virtual pte load fails due to some sort of
;	memory management error. Our function, is to unscramble the
;	register state, and transition into the stack builder.
;
;	The MMF flag, is changed to be an Istream reference
;
; Regs' on entry...
;
;	From the ndtb_miss routine
;	R3, 4,5 saved in PT3, 4,5
;	R3  = pc of this miss
;
;
;	From the special handler
;	pt0,1,20-23 <- r0,1,20-23
;	R20 = VA
;	R21 = pte with l3 and recheck marker correct.
;	R22 = MMF
;	R23 = scb offset for this fault
;
;
;	The stack builder is expecting
;	pt12,13	<- r12,13
;	r12 PC
;	r13 has SCB offset
;	pt16 has new_R4 (VA)
;	pt17 has new_R5 (MMF)
;
;
;
;+
	align_to_double_cache_block	; align for branch target
pal$itb_miss_ldq_error::		; 15 cycles
	mt	r12, pt12
	 mf	r0, pt0
	or	r3, r31, r12		; get pc into r12
	 mt	r13, pt13
	mf	r1, pt1
	 lda	r13, scb$v_acv(r31)	; Assume we will take ACV
	mt	r12, pt16		; set newr4=va
	 srl	r21, #PTE$V_KRE, r21	; get kre bit
	mf	r3, pt3
	 lda	r4, 1(r31)		; set newr5 mmf (i stream)
	mt	r4, pt17
	 cmovlbs r21, #SCB$V_TNV, r13	; recheck l2 access
	mf	r4, pt4
	 stall	1
	mf	r5, pt5
	 mf	r20, pt20
	mf	r21, pt21
	 mf	r22, pt22
	mf	r23, pt23
	 br	r31, pal$post_km_trap	; and go build the trap




	END_HW_VECTOR	OPCDEC


.sbttl	UNALIGN	- Unaligned access fault

;+
; PAL$HW_VEC_UNALIGN
;addr	len	use
;----	----	------------------------------
;11E0	 128 	Unaligned data access fault
;
; Entry:
;	Vectored into via hardware dispatch when un-aligned LD/ST is executed
;
; Function:
;	Build stack frame
;	Dispatch through SCB
;
;-

	START_HW_VECTOR	UNALIGN		; ? cycles (a bunch...)
	.enable	lsb
	mt	r4, pt4			; get a reg
	 mf	r4, exc_addr		; get pc
	blbs	r4, una_from_pal	; br if una from pal

	 mt	r18, pt18		; save r18
	mf	r18, mm_csr
	 mt	r19, pt19		; save r19
	mf	r19, va
	 mt	r17, pt17		; save r17
	addq	r4, #4, r17		; inc pc
	 mf	r4, pt4
	mt	r12, pt12		; Save r12
	 srl	r18, #mmcsr$v_opc, r12	; get opcode
	mt	r13, pt13		; Save r13
	 get_addr r13, <pal$unaligned_recover-pal$start>, r31; get address
	mt	r14, pt14		; save r14
	 mt	r13, pt3		; set recovery address
	and	r12, #^b1010, r13	; see if integer _C or _L
	 mt	r15, pt15		; save r15
	cmpeq	r13, #^b1010, r13	; and do the test

	
	bne	r13, 700$		; go log the ill pal op if INT_L/C
	blbs	r18, 500$		; br if access was a STx
	blbc	r12, 10$		; br if access was LDL


	; access was LD/Q
	ldq_u	r15, (r19)
	ldq_u 	r14, 7(r19)
	extql	r15, r19, r15
	extqh	r14, r19, r14
	or	r14, r15, r15
	br	r31, 20$		; join common load code


	.align	quad
	; access was long
10$:	ldq_u	r15, (r19)
	ldq_u	r14, 3(r19)
	extll	r15, r19, r15
	extlh	r14, r19, r14
	or	r14, r15, r15
	addl	r15, r31, r15

	; load has completed, data is in r15
20$:	and	r12, #1@3, r14		; see if op is integer
	cmpeq	r14, r31, r14		; r14= 0 is integer, 1 is fp
	beq	r14, 30$		; br if integer data

	and	r12, #3@0, r14		; get IEEE and QUAD flags
	addq	r14, #1, r14		; plus 1

	; data is fp, store aligned data in intermediate buffer
	lda	r13, -8(sp)		; allocate a quad word buffer
	bic	r13, #7, r13		; align it
	stq	r15, (r13)		; store data onto the stack
	or	r13, r31, r15		; pass addr of data in r15


	; now move the data into the register file
	align_branch_target
30$:	srl	r18, #mmcsr$v_ra-3, r12; get ra*8
	and	r12, #<^x1f@3>, r12	; and clean it
	sll	r12, #2, r13		; get ra*32
	s8addq	r14, r12, r12		; add dt*8
	addq	r13, r12, r13		; now have ra*40

	mf	r14, pal_base		; get the pal base
	get_addr r14, <pal$ld_tbl-pal$start>, r14 ; get addr of load table
	addq	r14, r13, r14		; now is addr of code to load data

	bic	sp, #63, r12		; get addr of new stack frame+64
	stq	r31, -64(r12)		; probe the stack, to ensure that
					; we can build a stack frame in case
					; we have an acv/tnv problem on the sp.
					; this must be done prior to commiting
					; the load.
	pvc$jsr	plt
	jsr	r14, (r14), pal$ld_tbl	; go load the rf
	t = 0
	.repeat 32
	.iif eq t, pvc$jsr	pltr1, dest=1, bonus=\t
	.iif eq t, pvc$jsr	pltr2, dest=1, bonus=\t
	.iif eq t, pvc$jsr	pltr3, dest=1, bonus=\t
	.iif eq t, pvc$jsr	pltr4, dest=1, bonus=\t
	.iif eq t, pvc$jsr	pltr5, dest=1, bonus=\t
	t = t + 1
	.endr
	
	; all done
	stall	1			; required stall
	mf	r12, pt2		; get iccsr
	srl	r12, #46, r12		; get datafx
	blbc	r12, 600$		; go log the unaligned access if reqstd
	mf	r12, pt12
	mf	r13, pt13
	mf	r14, pt14
	mf	r15, pt15
	mt	r17, exc_addr		; update the pc
	mf	r17, pt17
	mf	r18, pt18
	mf	r19, pt19
	hw_rei




; access was for a store instruction
	align_to_cache_block		; align for branch target
500$:	and	r12, #1@3, r14		; see if op is integer
	cmpeq	r14, r31, r14		; r14= 0 is integer, 1 is fp
	beq	r14, 530$		; br if integer data
	
	and	r12, #3@0, r14		; get IEEE and QUAD flags
	addq	r14, #1, r14		; plus 1


	; data is fp, get addr of intermediate buffer
	lda	r13, -8(sp)		; allocate a quad word buffer
	bic	r13, #7, r15		; align it

530$:	srl	r18, #mmcsr$v_ra-3, r12	; get ra*8
	and	r12, #<^x1f@3>, r12	; and clean it
	sll	r12, #2, r13		; get ra*32
	s8addq	r14, r12, r12		; add dt*8
	addq	r13, r12, r13		; now have ra*40

	mf	r14, pal_base		; get the pal base
	get_addr r14, <pal$st_tbl-pal$start>, r14 ; get addr of store table
	addq	r14, r13, r14		; now is addr of code to load data
	pvc$jsr	pst
	jmp	r14, (r14), pal$st_tbl	; go load the rf
fr_load_ret:
	ldq	r15, (r15)		; now fetch the fp data from mem if fp
sr_load_ret:


	srl	r18, #mmcsr$v_opc, r13	; get opcode
	blbc	r13, 510$		; br if access was LONGword

	ldq_u	r13, (r19)
	insql	r15, r19, r14
	mskql	r13, r19, r13
	or	r13, r14, r13
	stq_u	r13, (r19)

	ldq_u	r13, 7(r19)
	insqh	r15, r19, r14
	mskqh	r13, r19, r13
	or	r13, r14, r13
	stq_u	r13, 7(r19)


	; all done
	mf	r12, pt2		; get iccsr
	srl	r12, #46, r12		; get datafx
	blbc	r12, 610$		; go log the unaligned access if reqstd
	mf	r12, pt12
	mf	r13, pt13
	mf	r14, pt14
	mf	r15, pt15
	mt	r17, exc_addr		; update the pc
	mf	r17, pt17
	mf	r18, pt18
	mf	r19, pt19
	hw_rei


	CONT_HW_VECTOR	UNALIGN, ibr=0


	align_to_cache_block		; align for branch target
510$:	ldq_u	r13, (r19)
	insll	r15, r19, r14
	mskll	r13, r19, r13
	or	r13, r14, r13
	stq_u	r13, (r19)

	ldq_u	r13, 3(r19)
	inslh	r15, r19, r14
	msklh	r13, r19, r13
	or	r13, r14, r13
	stq_u	r13, 3(r19)


	; all done
	mf	r12, pt2		; get iccsr
	srl	r12, #46, r12		; get datafx
	blbc	r12, 610$		; go log the unaligned access if reqstd
	mf	r12, pt12
	mf	r13, pt13
	mf	r14, pt14
	mf	r15, pt15
	mt	r17, exc_addr		; update the pc
	mf	r17, pt17
	mf	r18, pt18
	mf	r19, pt19
	hw_rei



; log the data alignment trap
	align_to_cache_block		; align for branch target
610$:	bis	r12, #1, r12		; set STORE flag
600$:	 and	r12, #1, r15		; isolate LOAD/store flag for new R5
	lda	r13, scb$v_unalign(r31)	; set scb vector to use
	 mf	r18, pt18
	or	r17, r31, r12		; set pc
	 mf	r17, pt17
	mf	r14, pt14
	 mt	r19, pt16		; va, New R4
	mf	r19, pt19
	 mt	r15, pt17		; load/store flag, New R5
	mf	r15, pt15
	 br	r31, pal$post_km_trap	; go build trap



; log the illegal pal op
	.align 	quad
700$:	stall	1
	or	r17, r31, r12		; get pc
	mf	r14, pt14
	lda	r13, scb$v_illpal(r31)	; set scb vector to use
	mf	r15, pt15
	mf	r17, pt17
	mf	r18, pt18
	mf	r19, pt19
	br	r31, pal$post_km_trap_nr45; go post the trap




	.macro inst opc, arga, argb, argc, pal=0, store=0, norc=0, fpu=0
	  .if eq    norc
	    .iif ne store, 'opc'	'arga', 'argb', r'argc'
	    .iif eq store, 'opc'	r'arga', 'argb', 'argc'
	  .iff
	    .if eq pal
	      .iif ne fpu,   'opc'	f'arga', 'argb'
	      .iif eq fpu,   'opc'	r'arga', 'argb'
	    .endc
	    .iif ne pal,   'opc'	'arga',  pt'argb'
	  .endc
	.endm


	pt_mask = <<1@12> !<1@13> !<1@14> !<1@15> !<1@17> !<1@18>! <1@19>>



	.align	quad
pal$ld_tbl:; load data into register file
	; offsets set as
	; 0*2i	integer Quad data
	; 1*2i	FP vax  F
	; 2*2i	FP vax  G
	; 3*2i	FP ieee S
	; 4*2i	FP ieee T

	t = 0
	.repeat	32
	  .iif eq t, pvc$jsr	plt, dest=1
	  .if eq <<pt_mask@-t> & 1>
	    inst or r15, r31, \t , store=1
	    .iif eq t, pvc$jsr	pltr1, bonus=\t
	    ret	r31, (r14)
	  .iff
	    inst mt r15, \t, pal=1, norc=1
	    .iif eq t, pvc$jsr	pltr1, bonus=\t
	    ret	r31, (r14)
	  .endc

	  .iif eq t, pvc$jsr	plt, dest=1
	  inst ldf \t, (r15), norc=1, fpu=1
	  .iif eq t, pvc$jsr	pltr2, bonus=\t
	  ret	r31, (r14)

	  .iif eq t, pvc$jsr	plt, dest=1
	  inst ldg \t, (r15), norc=1, fpu=1
	  .iif eq t, pvc$jsr	pltr3, bonus=\t
	  ret	r31, (r14)

	  .iif eq t, pvc$jsr	plt, dest=1
	  inst lds \t, (r15), norc=1, fpu=1
	  .iif eq t, pvc$jsr	pltr4, bonus=\t
	  ret	r31, (r14)

	  .iif eq t, pvc$jsr	plt, dest=1
	  inst ldt \t, (r15), norc=1, fpu=1
	  .iif eq t, pvc$jsr	pltr5, bonus=\t
	  ret	r31, (r14)
	  t = t + 1
	.endr


	.align	quad
pal$st_tbl:; get data from register file
	; offsets set as
	; offsets set as
	; 0*2i	integer Quad data
	; 1*2i	FP vax  F
	; 2*2i	FP vax  G
	; 3*2i	FP ieee S
	; 4*2i	FP ieee T

	t = 0
	.repeat	32
	  .iif eq t, pvc$jsr	pst, dest=1
	  .if eq <<pt_mask@-t> & 1>
	    inst or \t, r31, r15
	    br	r31, sr_load_ret
	  .iff
	    inst mf r15, \t, pal=1,norc=1
	    br	r31, sr_load_ret
	  .endc

	  .iif eq t, pvc$jsr	pst, dest=1
	  inst stf \t, (r15), norc=1, fpu=1
	  br	r31, fr_load_ret

	  .iif eq t, pvc$jsr	pst, dest=1
	  inst stg \t, (r15), norc=1, fpu=1
	  br	r31, fr_load_ret

	  .iif eq t, pvc$jsr	pst, dest=1
	  inst sts \t, (r15), norc=1, fpu=1
	  br	r31, fr_load_ret

	  .iif eq t, pvc$jsr	pst, dest=1
	  inst stt \t, (r15), norc=1, fpu=1
	  br	r31, fr_load_ret
	  t = t + 1
	.endr



;+
;
; pal$unaligned_recover::
;
; while doing an unaligned load/store we took a mm error.
;	Our function, is to unscramble the
;	register state, and transition into the stack builder.
;
;
; Regs' on entry...
;
;	From the unaligned op
;	pt12-15, 17-19 <- r12-15, 17-19
;	r17 = pc of unaligned+4
;
;
;	From the special handler
;	pt0,1,20-23 <- r0,1,20-23
;	R20 = VA
;	R21 = pte with l3 and recheck marker correct.
;	R22 = MMF
;	R23 = scb offset for this fault
;
;
;	The stack builder is expecting
;	 pt12 has saved r12
;	 pt13 has saved r13
;	[pt16 has new r4 unless _nr45]
;	[pt17 has new r5 unless _nr45]
;
;	r12 savedPC
;	r13 has SCB offset
;	
;	
;
;-

	align_to_cache_block		; align for branch target
	pvc$jsr	spec, dest=1
pal$unaligned_recover::
	subq	r17, #4, r12		; get pc (not +4)
	or	r23, r31, r13		; get scb offset

	mf	r17, pt17
	mt	r22, pt17		; set up mmc
	mf	r18, pt18
	mt 	r20, pt16		; get new r4
	mf	r19, pt19
	stall	1

	mf	r0,  pt0
	mf	r1,  pt1

	mf	r20, pt20
	mf	r21, pt21
	mf	r22, pt22
	mf	r23, pt23

	mf	r14, pt14
	mf	r15, pt15
	br	r31, pal$post_km_trap	; go post the trap


	.sbttl	una_from_pal	unaligend trap from pal

	;+
	; this code is used in a very limited environment to fix up
	; unaligned d-stream access from within pal.
	; The environment is extreamly limited, and is targeted to
	; explicitly handle the QUEUE instructions only.
	;
	; The situation is that the queue instructions want to be written
	; so as to assume that the queue elements and headers are naturally
	; alligend, and to not bother checking the alignment as the process
	; the queue request. So, they make that assumption, and trap to here
	; if it's not true. This code handles those unaligned access by
	; fixing up the reference. This can result in a few unfortunate events.
	; For example, either half of the load/store can generate one a dmm
	; error. And in the queue instructions, once we get past the point of
	; no return, we need to auto-magically fix up TNV's, Prior to that
	; point we need to generate the errors. Also, on some of the queue
	; instructions we need to generate illpalop's if we get any alignment
	; error, others we fix up.
	; In short this is a nasty bit of code, but it allows the main line
	; queue instructions to be as fast as possible,at the expense of
	; the unaligned cases (life is hard).
	;-

	; r4 saved in pt4
	; pc in r4
	; mmcsr in r5
	; va in r6
	; junk in 


	align_to_cache_block	; align for branch target
una_from_pal:
	trace_pc	<unaligned_from_pal>
	mt	r5, pt5
	mf	r5, pt3		; get recover address
	mt	r6, pt6
	mt	r16, pt16
	mt	r17, pt17

	blbc	r5, pal_ill_runa; go generate the illpalop if unexpected err


	sll	r5, #32, r5	; shift it out of the way
	get_addr r6, <pal_ill_una-pal$start>, r31 ; get addr of recovery rtn
	or	r5, r6, r5	; merge in our recover routine
	mt	r5, pt3		; put addr back in hw.
				; sure is nice haveing 64b regs... can keep
				; 2 32b quantities there at one..yikes

	mf	r5, mm_csr	; get mmcsr
	mf	r6, va		; get va
	srl	r5, #mmcsr$v_opc, r16	; get opcode
;	and	r16, #^x1f, r17	; get opcode
	and	r16, #^b1010, r17	; isolate int and lock bits
	cmpeq	r17, #^b1000, r17	; make sure no bonus bits are set
	blbc	r17, 1015$		; ooopps.
	blbs	r5, 1500$		; br if access was a STx

	blbc	r16, 1100$	; br if access was LDL

	; access is LDQ
	; do access, and probes
	ldq_u	r16, (r6)
	ldq_u	r17, 7(r6)
	extql	r16, r6, r16
	extqh	r17, r6, r17
	or	r17, r16, r16
1010$:	
	srl	r5, #mmcsr$v_ra-3, r17	; get ra
	and	r17, #^x1f@3, r17	; isolate
	subq	r17, #13@3, r17		; offset from r13
	cmpule	r17, #<15-13>@3, r6	; within range?
	blbc	r6, 1015$		; nop pal bug.
	mf	r6, pal_base		; get pal base
	sget_addr r6, <pal$pal_una_ld_tbl-pal$start>, r6 ; base of tbl
	addq	r6, r17, r17		; get addr of our code
	pvc$jsr	pult
	jmp	r31, (r17), pal$pal_una_ld_tbl ; go update the reg file

	
1015$:	MCHK	BUGCHECK, save_pt=1	; and mchk



	; access is LDL
	align_to_cache_block
1100$:
	; perform the probe
	; do access, and probes
	ldq_u	r16, (r6)
	ldq_u r17, 3(r6)
	extll	r16, r6, r16
	extlh	r17, r6, r17
	or	r17, r16, r16
	addl	r16, r31, r16
	br	r31, 1010$	; go join common ldq case



	align_to_cache_block
1500$:	; access is store
	srl	r5, #mmcsr$v_ra-3, r17	; get ra
	and	r17, #^x1f@3, r17		; isolate
	subq	r17, #13@3, r17		; offset from r13
	cmpule	r17, #<17-13>@3, r16	; within range?
	blbc	r16, 1015$		; nop pal bug.
	mf	r16, pal_base		; get pal base
	sget_addr r16, <pal$pal_una_st_tbl-pal$start>, r16 ; base of tbl
	addq	r16, r17, r17		; get addr of our code
	srl	r5, #mmcsr$v_opc, r5	; get opcode
	pvc$jsr	pust
	jsr	r17, (r17), pal$pal_una_st_tbl ; go update the reg file
	pvc$jsr	pustr1, dest=1
	pvc$jsr	pustr2, dest=1
	pvc$jsr	pustr3, dest=1
	pvc$jsr	pustr4, dest=1
	pvc$jsr	pustr5, dest=1
	blbc	r5, 1600$		; br if access was STL

	; access is STQ
	; perform the probe
	ldq/w	r17, (r6)	; access first half
	ldq/w	r17, 7(r6)	; access second
	; probe has completed, now do unaliged access
	ldq_u	r17, (r6)
	insql	r16, r6, r5
	mskql	r17, r6, r17
	or	r17, r5, r17
	stq_u	r17, (r6)

	ldq_u	r17, 7(r6)
	insqh	r16, r6, r5
	mskqh	r17, r6, r17
	or	r17, r5, r17
	stq_u	r17, 7(r6)

	; unaligned ld/st has completed, clean up and back out
	align_branch_target
pal_una_fin:
	stall	1
	mf	r5, pt3		; recover address
	srl	r5, #32, r5	; put it back the way it was
	mt	r5, pt3		; put back in chip
	addq	r4, #4, r4	; bump pc
	mt	r4, exc_addr	; and back in chip
	stall	1
	mf	r4, pt4
	mf	r5, pt5
	mf	r6, pt6
	mf	r16, pt16
	mf	r17, pt17
	hw_rei			; and away we go



	align_to_cache_block
1600$:	; access is STL
	; perform the probe
	ldl/w	r17, (r6)	; access first half
	ldl/w	r17, 3(r6)	; access second
	; probe has completed, now do unaliged access
	ldq_u	r17, (r6)
	insll	r16, r6, r5
	mskll	r17, r6, r17
	or	r17, r5, r17
	stq_u	r17, (r6)

	ldq_u	r17, 3(r6)
	inslh	r16, r6, r5
	msklh	r17, r6, r17
	or	r17, r5, r17
	stq_u	r17, 3(r6)
	br	r31, pal_una_fin	; and go finish up



	; error detected while doing unaligned resident queue
	.align	quad
pal_ill_runa:
	mf	r16, va		; unlock va/mmcsr
	mt	r0, pt0
	mf	r0, pt3
	mt	r1, pt1
	mf	r1, pal_base
	addq	r0, r1, r0
	mf	r4, pt4
	mf	r5, pt5
	mf	r6, pt6
	mf	r16, pt16
	mf	r17, pt17
	mt	r20, pt20
	mt	r21, pt21
	mt	r22, pt22
	mt	r23, pt23
	stall	1			; make sure we have a safe landing
	lda	r23, scb$v_illpal(r31)	; scb vector
	pvc$violate	1007		; disable rule checker on computed goto
	jmp	r31, (r0)


	; error detected while doing probe for unaligned access
	.align	quad
	pvc$jsr	spec, dest=1
pal_ill_una:
	mf	r17, pt3		;get pt3
	srl	r17, #<32+1>, r17	; get stuffer bit
	blbs	r17, 1710$		; go to stuffer

	mf	r4, pt4
	mf	r5, pt5
	mf	r6, pt6
	mf	r16, pt16
	mf	r17, pt17

	mf	r0, pt3
	mf	r1, pal_base
	srl	r0, #32, r0
	addq	r0, r1, r0
	bic	r0, #3, r0
	pvc$violate	1007			; disable rule checker on computed goto
	jmp	r31, (r0)			; and off to the specific handler



	.align	quad
1710$:	mt	r21, dtb_ctl		; Jam in gran hints
	 srl	r21, #pte$v_soft, r1	; Get SW field (is really level check)
	mf	r22, pt22		;
	 cmpeq	r23, #SCB$V_TNV, r0	; Check for TNV
	and	r0, r1, r0		; Is it both level 3, and TNV?
	 mf	r1,  pt1
	blbc	r1, 1730$		; nope, take an MCHK
	 mf	r0,  pt0
	mt	r20, tb_tag		; Load TB TAG and clear TB valid bit
	 mt	r21, dtb_pte		; Load PTE and set TB valid bit
	mf	r20, pt20		;
	 mf	r21, pt21		;
	mf	r23, pt23		;
	 hw_rei				; go back and re-try access


	.align	quad
1730$:	MCHK	OS_BUGCHECK		; and mchk





	.disable lsb
	END_HW_VECTOR	UNALIGN


.sbttl	CALPAL	- CALLpal entry points

;+
; PAL dispatches
;
;	All call pal instuctions dispatch directly to their routines
;	the new PC of a call pal is 
;			<63:14>		<13:5>	    <4:0>
;		PC = PAL_BASE<63:14> ! INSTR<7:0> ! 0<4:0>
;
;	The hardware dispatch also vectors all CALPAL instructions with INSTR<7>=0
;	when PS<CM> <> 0 to illeg opc, as well as any CALPAL instructions
;	with any of the high function bits set.
;
;	This code is placed into every call pal code point
;	to make all call pals illeg opc. Later if the instruction
;	code point is used this code it replaced.
;
;	Calpal over head and timeing.
;	Each callpal lists it's approximate cycle time
;	To arrive at a more realistic number you need to add some over
;	head. So assumeing a callpal that "says" that it takes 13 cycles
;	you actually get...
;
;	  7 cycles, Worst case "normal" drain prior to pal entry
;	 13 cycles, the callpal function
;	  1 cycle,  nop after the hwrei
;      ----
;	 21 cycles
;
; 	This assumes that the pal function was in the cache.
;	
;-

	START_HW_VECTOR	CALLPAL,no_trace=1,noshift=1	; 2 cycles

;+
;	Note, the caned code below, is a 2 instr br to a common routine
;	to generate the opcdec. This "wastes" one cache block miss, on
;	what should be a seldome occurance... Use of an undefined calpal.
;	In return of this "loss" we only use 2 of instruction slots at each
;	of the unused callpal entries. Thus, in the event that any one
;	attempts to compress palcode, these "unused" entries will squish
;	very nicely.
;-


	repc = 256
	.iif ne <ev4_pass2!ev4_pass3>, repc = 128


	.nlist
	.rept	repc
t = .
	stall	1			; required stall
	 br	r31, pal$calpal_opcdec
	
	  assume	<.> le <t+<pfunc_size*4>>; must be < 8/16 instrs in loop
	. = t + <pfunc_size*4>
	.endr
	.list

	END_HW_VECTOR	CALLPAL

.sbttl BPT	- PALcode for BPT instruction

;+
; BPT
;
; Entry:
;	Vectored into via hardware PALcode instruction dispatch
;	PALcode enviornment set up.
;
; Function:
;	Build interface to comon frame builder, and post the exception
;-
	START_PAL_ROUTINE	BPT	; 4 cycles
	mt	r12, pt12		; Save r12
	 mf	r12, exc_addr		; get address of PAL call
	mt	r13, pt13		; Save r13
	 lda	r13, scb$v_bpt(r31)	; set scb vector to use
	br	r31, pal$post_km_trap_nr45; go build trap
	END_PAL_ROUTINE		BPT


.sbttl TRAP	- PALcode for TRAP instruction

;+
; TRAP
;
; Entry:
;	Vectored into via hardware PALcode instruction dispatch
;	PALcode enviornment set up.
;
; Function:
;	Build interface to comon frame builder, and post the exception
;-
	START_PAL_ROUTINE	TRAP	; 4 cycles
	mt	r12, pt12		; Save r12
	 mf	r12, exc_addr		; get address of PAL call
	mt	r13, pt13		; Save r13
	 lda	r13, scb$v_trap(r31)	; set scb vector to use
	br	r31, pal$post_km_trap_nr45; go build trap
	END_PAL_ROUTINE		TRAP


.sbttl RSCC	- PALcode for RSCC instruction

;+
; RSCC
;
; Entry:
;	Vectored into via hardware PALcode instruction dispatch
;	PALcode enviornment set up.
;
; Function:
;	Once again check for PCC overflows, build and return the SCC
;
;-
	START_PAL_ROUTINE	RSCC, longflow=1	; 16 cycles
	mf	r0, pt10		; get SCC
	 mt	r12, pt12
	rpcc	r12			; get cycle counter
	 mt	r13, pt13
	or	r31, #1, r13		; get a 1
	 mt	r14, pt14
	sll	r13, #32, r13		; now a 100000000

	 zap	r12,^xf0, r12		; get low long of pcc
	zap	r0,^xf0, r14		; get low long of SCC
	 zap	r0,^x0f, r0		; get high long of SCC

	subq	r12, r14, r14		; if pcc<31:0> le scc<31:0>
	 cmovge r14, r31, r13		; zero wrap, if wrap did not happen
	mf r14, pt14

	 addq	r0, r13, r0		; add wrapper to SCC
	mf r13, pt13
	 CONT_PAL_ROUTINE	RSCC

	or	r0, r12, r0		; merge
	 mf r12, pt12
	mt	r0, pt10		; update scc
	 hw_rei				; back to user
	END_PAL_ROUTINE		RSCC


.sbttl READ/WRITE_UNQ - Read/Write UNQ

;+
; READ/WRITE
;
; Entry:
;	Vectored into via hardware PALcode instruction dispatch
;	PALcode enviornment set up.
;
;	r16 -> new UNQ
;
; Function:
;	READ - return UNQ
;	WRITE - set new UNQ
;	
; Returns:
;	UNQ in R0
;-
	START_PAL_ROUTINE	READ_UNQ; 2 cycles
	.if eq <enable_debug_pctrace ! enable_debug_special! enable_debug_pcevent>
	mf	r0, pt11		; get UNQ
	 hw_rei				; back to user
	.iff
	mf	r0, pt31		; get pcbb
	 ldq/p	r0, pcb$q_unq(r0)	; get UNQ
	hw_rei				; back to user
	.endc
	END_PAL_ROUTINE		READ_UNQ



	START_PAL_ROUTINE	WRITE_UNQ; 7 cycles
	mt	r12, pt12		; Save r12
	 mf	r12, pt31		; get pcbb
	.iif eq <enable_debug_pctrace ! enable_debug_special ! enable_debug_pcevent>, mt r16, pt11 ; set UNQ
	 stq/p	r16, pcb$q_unq(r12)	; set UNQ
	mf	r12, pt12		; Restore r12
	 hw_rei				; back to user
	END_PAL_ROUTINE		WRITE_UNQ




.sbttl BUGCHK	- PALcode for BUGCHK instruction

;+
; BUGCHK
;
; Entry:
;	Vectored into via hardware PALcode instruction dispatch
;	PALcode enviornment set up.
;
; Function:
;	Build interface to comon frame builder, and post the exception
;-
	START_PAL_ROUTINE	BUGCHK	; 4 cycles
	mt	r12, pt12		; Save r12
	 mf	r12, exc_addr		; get address of PAL call
	mt	r13, pt13		; Save r13
	 lda	r13, scb$v_bugchk(r31)	; set scb vector to use
	br	r31, pal$post_km_trap_nr45; go build trap
	END_PAL_ROUTINE		BUGCHK


.sbttl CHMx	- PALcode for the CHMx instructions

.if eq disable_chmx
;+
; CHMx
;
; Entry:
;	Vectored into via PALcode instruction dispatch routine.
;	PALcode enviornment set up.
;
;
; Function:
;	Build interface to comon frame builder, and post the exception
;	
; Returns:	
;-

.if eq disable_chmk

	START_PAL_ROUTINE	CHMK, longflow=1
	mf	r22, exc_addr		; get address of PAL call
	 mf	r24, pt9		; get current ps
	mf	r27, pt31		; get pcbb
	 bic	r22, #3, r22		; clear low 2 bits of old pc

	and	r24, #PS$M_CM, r24	; Get PS<cm>*8
	 beq	r24, 10$		; skip stack swap if KM from KM

	addq	r27, r24, r24		; get addr of cmSP
	 mf	r27, pt26		; get new KM mode sp
	stq/p	sp, pcb$q_ksp(r24)	; update current mode SP
	 or	r27, r31, sp		; move sp to sp
10$:

	; allocate new stack frame
	or	sp, r31, r27		; move sp to sp
	 mf	r24, pt30		; get scbb
	bic	sp, #63, sp		; round down stack
	 subq	sp, #64, sp		; allocate frame


; r22 = current pc clean
; r24 = scbb
; r27 = new sp with low bits intact
; sp  = new sp

	lda	r24, scb$v_chmk(r24)	; set scb vector to use
	 CONT_PAL_ROUTINE	CHMK, DOUBLE=1
pal$post_chmk_trap_stq::
	stq/a	r2,  FRM$V_R2(sp)	; save r2
	 and	r27, #63, r27		; get stack alignment
	stq/a	r3,  FRM$V_R3(sp)	; save r3
	 sll	r27, #PS$V_SP, r27	; shift to correct position for PS
	stq/a	r5,  FRM$V_R5(sp)	; save r5
	 mf	r5, pt9			; get current ps
	stq/a	r4,  FRM$V_R4(sp)	; save r4
	 ldq/p	r2, 0(r24)		; get scbv
	ldq/p	r3, 8(r24)		; get scbp
	 bic	R5, #<<3@PS$v_SW>!PS$M_CM>, r24; Zap sw/cm field, pass int
	mt	r24, PT9_PS		; set new ps
	 or	r27, r5, r27		; insert sp-align field in old PS
	stq/a	r6,  FRM$V_R6(sp)	; save r6
	 stq/a	r7,  FRM$V_R7(sp)	; save r7
	stq/a	r22, FRM$V_PC(sp)	; save PC
	 bic	r2, #3, r2		; clean low bits of new pc
	mt	r2, exc_addr		; set new pc
	 stq/a	r27, FRM$V_PS(sp)	; save old PS
	
.if ne enable_sstep
	stall	1
	 mf	r27, pt25		; get the misc bits
	srl	r27, #pt25$v_ss, r27	; get single step bit
	 blbs	r27, 100$		; br if we are single steping
.endc
	 hw_rei				; Now dispatch through scb to new vector




.if ne enable_sstep
; single step request
	.align	quad
100$:	mf	r27, exc_addr		; get new pc
	 addq	r27, #4, r27		; make it pc+4 for halt flow
	mt	r27, exc_addr		; put back in chip
	 br	r31, PAL$ENTRY_HALT	; take the halt
.endc

	END_PAL_ROUTINE	CHMK


.endc



.if eq disable_chme

	START_PAL_ROUTINE	CHME, longflow=1	; ? cycles
	mf	r22, pt9		; get ps
	 lda	r24, <ps$m_cm!ps$m_ipl>(r31); get mode/ipl mask
	and	r22, r24, r23		; isolate ps mode/ipl
	 cmpbge r23, #ps$c_exec, r27	; see if in higher mode
	or	sp, r31, r24		; use stack, if km, or exec mode
	 cmovlbs r27, #ps$c_exec, r23	; use exec mode if in higher mode
	blbc	r27, 10$		; skip, stack swap if Kern or Exec

; r22 = old ps
; r23 = new ps
; r24, r27 = scratch

	 mf	r24, pt31		; get pcbb
	and	r22, #ps$m_cm, r27	; Get PS<cm>*8
	 addq	r24, r27, r27		; get addr of cmSP
	stq/p	sp, pcb$q_ksp(r27)	; update current mode SP

	 and	r23, #ps$m_cm, r27	; get new mode
	addq	r24, r27, r27		; get addr of newSP
	 ldq/p	r24, pcb$q_ksp(r27)	; get new newSP


	; stack swap is complete (or skipped), set alt mode and build frame
10$:	mt	r23, alt_mode

	; build old ps to be put on stack
 	 CONT_PAL_ROUTINE	CHME, DOUBLE=1
	mt	r23, pt3
	 and	r24, #63, r27		; get stack alignment
	sll	r27, #PS$V_SP, r27	; shift to correct position for PS
	 bic	r24, #63, r24		; round down stack
	or	r22, r27, r22		; insert sp-align field in old PS

	 subq	r24, #64, r24		; allocate frame
	mf	r27, exc_addr		; get address of PAL call

; r22 = old ps
; r23 = new ps
; r24 = new sp
; r27 = pc

; stack frame is allocated, now start to load the frame
; note that if a MM exception is to occure it WILL occure on the first
; reference to the stack (frame can not cross a page boundary)
;
; thus the following may be trashed by the dtb load on the next instruction
;	VA
;	EXC_ADDR
;	pt20
;	pt21
;	pt22

pal$post_chme_trap_stq::
	 stq/a	r2,  FRM$V_R2(r24)	; save r2
	mf	r2, pt30		; get scbb
	 stq/a	r7,  FRM$V_R7(r24)	; save r7
	bic	r27, #3, r27		; clear low 2 bits of pc
	 stq/a	r3,  FRM$V_R3(r24)	; save r3
	lda	r2, scb$v_chme(r2)	; set chme scb vector 
	 ldq/p	r3, 8(r2)		; get scbp
	ldq/p	r2, 0(r2)		; get scbv
	 stq/a	r4,  FRM$V_R4(r24)	; save r4
	stq/a	r5,  FRM$V_R5(r24)	; save r5
	 mt	r23, PT9_PS		; set new ps
	stq/a	r6,  FRM$V_R6(r24)	; save r6
	 bic	r2, #3, r2		; clean low bits of new pc
	stq/a	r27, FRM$V_PC(r24)	; save PC
	 or	r24, r31, sp		; update the sp
	stq/a	r22, FRM$V_PS(r24)	; save PS
	 mt	r2, exc_addr		; set new pc
	mt	r31, alt_mode		; clear alt_mode hw
.if ne enable_sstep
	 mf	r22, pt25		; get the misc bits
	srl	r22, #pt25$v_ss, r22	; get single step bit
	 blbs	r22, 100$		; br if we are single steping
.endc
	 hw_rei				; Now dispatch through scb to new vector



.if ne enable_sstep
; single step request
	.align	quad
100$:	mf	r22, exc_addr		; get new pc
	addq	r22, #4, r22		; make it pc+4 for halt flow
	mt	r22, exc_addr		; put back in chip
	br	r31, PAL$ENTRY_HALT	; take the halt
.endc

	END_PAL_ROUTINE	CHME
.endc


.if eq disable_chms
	START_PAL_ROUTINE	CHMS, longflow=1	; 9 cycles
	mt	r14, pt14		; save r14
	 mf	r14, pt9		; get ps
	mt	r12, pt12		; Save r12
	 lda	r12, <ps$m_cm!ps$m_ipl>(r31); get mode/ipl mask
	mt	r13, pt13		; Save r13
	 lda	r13, scb$v_chms(r31)	; set scb vector to use
	mt	r15, pt15		; save r15
	 and	r14, r12, r14		; isolate ps mode/ipl
	mf	r12, exc_addr		; get address of PAL call
	 cmpbge	r14, #ps$c_supr, r15	; see if in higher mode
	cmovlbs r15, #ps$c_supr, r14	; use exec mode if in higher mode
	 mt	r14, pt0		; set ps
	br	r31, pal$post_xm_ps_trap; build call
	END_PAL_ROUTINE	CHMS
.endc

.if eq disable_chmu
	START_PAL_ROUTINE	CHMU	; 8 cycles
	mt	r15, pt15		; save r15
	 mf	r15, pt9		; get ps
	mt	r12, pt12		; Save r12
	 mf	r12, exc_addr		; get address of PAL call
	mt	r13, pt13		; Save r13
	 lda	r13, scb$v_chmu(r31)	; set scb vector to use
	mt	r14, pt14		; save r14
	 bic	r15, #<3@ps$v_sw>, r15
	mt	r15, pt0		; set the build
	 br	r31, pal$post_xm_ps_trap; go build trap
	END_PAL_ROUTINE	CHMU
.endc
.endc

.sbttl CLRFEN	- PALcode for CLRFEN instruction

;+
; CLRFEN
;
; Entry:
;	Hardware dispatch on CLRFEN instruction
;
; Function:
;	Clears FEN
;
;-
	START_PAL_ROUTINE	CLRFEN, longflow=1
	mt	r0, pt0			; get scratch regs
	mt	r1, pt1
	
	bis	r0, #1, r0		; get a one
	sll	r0, #iccsrw$v_fpe, r0	; shift it into position

	mf	r1, pt31		; get pcbb
	stq/p	r31, pcb$q_fen(r1)	; set new fen

	mf	r1, pt2			; get iccsr
	bic	r1, r0, r1		; clear fen
	mt	r1, pt2_iccsr		; make it real

	and	r1, r1, r1		; stall...
	mf 	r1, pt2			; ...
	and	r1, r1, r1		; ...
	mf 	r1, pt2			; ...
	and	r1, r1, r1		; ...parts

	CONT_PAL_ROUTINE	CLRFEN
	mf	r0, pt0			; restore regs
	mf	r1, pt1
	hw_rei
	END_PAL_ROUTINE		CLRFEN


.sbttl IMB	- PALcode for IMB instruction

;+
; IMB
;
; Entry:
;	Vectored into via hardware PALcode instruction dispatch
;	PALcode enviornment set up.
;
; Function:
;	
; Returns:
;
; Notes:
;
;	This is a nasty call...
;	We must ensure that the dsteam is written out of the write buffer
;	before going back, we must also ensure that the stream buffer
;	gets invalidated by invalidateing the cache, and makeing sure
;	that we take a cache miss on the hwrei...
;
;
;-
	START_PAL_ROUTINE	IMB, longflow=1	; 12 cycles, but cache is toast...
	mt	r31, flush_ic		; flush the icache
	 mb				; start forceing d stream out
	stall	<9-2>			; Give icache time to drain
					; and ensure that we take a miss on
					; the rei... thus clearing the stream
					; buffer.
	 mb				; Wait till the previous MB completes
	hw_rei				; back to user
	END_PAL_ROUTINE		IMB



.if eq disable_queue

;+
;
; For all the queue instructions:
;	H refers to the address of the header
;	N refers to the address of the next entry
;	P refers to the address of the previous entry
;	E refers to our entry (for inserts)
;
;	NN refers to N's next entry
;	NP refers to N's previous entry
;	PN refers to P's next entry
;	PP refers to P's previous entry
;
;-



.sbttl	INSQHIL	- PALcode for INSQHIL instruction

;+
; INSQHIL
;
; Entry:
;	Vectored into via hardware PALcode instruction dispatch
;	PALcode enviornment set up.
;	R16	= addr of queue header
;	R17	= addr of new entry
;
; Function:
; 	1 Alignment and address checks are performed on all arguments and
;	  the queue header.
;	2 Hardware interlock is taken on queue header.
;	3 Secondary interlock is taken on queue header.
;	4 All addresses are probed.
;	5 Entry is inserted into the queue.
;	6 Status is returned.
;
;	If a memory management error occurs prior to step 5, a trap
;	is generated useing the PC of the queue instruction.
;
;	If a memory managment error occurs during step 5, it is checked
;	to make sure it is the a TNV on the level 3 pte. If it is the
;	invalid pte is used and the queue instruction is continued.
;	Otherwise a machine check is generated.
;
; Returns:
;	R0 =
;		-1	if secondary interlock was set
;		 0	if queue was not empty
;		 1	if was empty
;-

	START_PAL_ROUTINE	INSQHIL, longflow=1
	mt	r12, pt12		; get working regs
  	 mf	r12, exc_addr		; save pc
	mt	r13, pt13
	 or	r16, r17, r13		; merge H & E for align check
	mt	r14, pt14
	 and	r13, #^x7, r14		; check H & E alignment
	bic	r12, #3, r12		; clear <1:0> of pc
	 bne	r14, queue_addr_error2	; br if H/E alignment error
	xor	r16, r17, r13		; check H = E
	 addl	r16, r31, r14		; sext H
	xor	r16, r14, r14		; check H = sext(H)
	 beq	r13, queue_addr_error2	; br if H = E
	addl	r17, r31, r13		; sext E
	 bne	r14, queue_addr_error2	; br if bad sext H
	xor	r17, r13, r13		; check sext E
	 CONT_PAL_ROUTINE	INSQHIL, DOUBLE=1
	bne	r13, queue_addr_error2	; br if bad sext E


	; if we get any mm errors, on the virtual access(s) below, we want
	; to report the mm error on the PC of the queue instruction,
	; not the pc of the ld/st the caused the error.
	; Note that bit 0 of PT3 is clear => alignment errors will trap...
 
	 sget_addr r13, <pal$queue_fault_setup2-pal$start>, r31 ; get address
	mt	r13, pt3		; set recovery address
	 lda	r14, ldxl_stxc_retry_count(r31) ; set retry count

lock_insqhil:
	ldl_l	r0, (r16)		; try to get H, interlocked
	 blbs	r0, queue_busy2		; entry already locked => return -1
	or	r0, #1, r13		; attempt to set lock flag
	 stl_c	r13, (r16)		; try to set secondary lock in H
	blbc	r13, retry_lock_insqhil	; abort if stx/c failed
	 or	r12, #2, r12		; set flag indicating we own lock

	;mb				; mb, implied on ev4 by stx/c

	; check all remaining addrs for read write accessability and alignment
	ldl/w	r14, (r17)		; check E (protection)
	 and	r0, #^x7, r13		; check N (alignment)
	addq	r16, r0, r14		; get N
	 bne	r13, queue_addr_error2l	; br if bad alignment of N
	ldl/w	r13, (r14)		; check N (protection)

	; now we are committed to the instruction - the only possible error
	; is a TNV, in which case we reload the TB with the no longer valid pte
	; (if it was level 3) and continue - otherwise MCHK...
	 sget_addr r13, <pal$queue_fault2-pal$start>, r31; get address
	mt	r13, pt3		; set recovery address

	; Do the queue operation
	debug_mp_queue			; if mp queue debug, zap dtb's
	 subl	r16, r17, r13		; H - E
	stl	r13, 4(r17)		; (E+4) <- H-E
	 addl	r13, r0, r13		; N - E
	stl	r13, (r17)		; (E) <- N-E

	 subl	r31, r13, r13		; E-N
	stl	r13, 4(r14)		; (N+4) <- E-N

	 mb

	subl	r17, r16, r13		; E-H
	 stl	r13, (r16)		; (H) <- E-H

	mt	r12, exc_addr		; set the rei address
	 cmpeq	r0, r31, r0		; queue was empty if N-H == 0
	mf	r12, pt12
	 mf	r13, pt13
	mf	r14, pt14
	 hw_rei




	END_PAL_ROUTINE		INSQHIL

.sbttl	INSQHIQ	- PALcode for INSQHIQ instruction

;+
; INSQHIQ
;
; Entry:
;	Vectored into via hardware PALcode instruction dispatch
;	PALcode enviornment set up.
;	R16	= addr of queue header
;	R17	= addr of new entry
;
; Function:
; 	1 Alignment and address checks are performed on all arguments and
;	  the queue header.
;	2 Hardware interlock is taken on queue header.
;	3 Secondary interlock is taken on queue header.
;	4 All addresses are probed.
;	5 Entry is inserted into the queue.
;	6 Status is returned.
;
;	If a memory management error occurs prior to step 5, a trap
;	is generated useing the PC of the queue instruction.
;
;	If a memory managment error occurs during step 5, it is checked
;	to make sure it is the a TNV on the level 3 pte. If it is the
;	invalid pte is used and the queue instruction is continued.
;	Otherwise a machine check is generated.
;
; Returns:
;	R0 =
;		-1	if secondary interlock was set
;		 0	if queue was not empty
;		 1	if was empty
;-

	START_PAL_ROUTINE	INSQHIQ, longflow=1
	mt	r12, pt12		; get working regs
	 mf	r12, exc_addr		; save pc
	mt	r13, pt13
	 or	r16, r17, r13		; merge H & E for for align check
	mt	r14, pt14
	 and	r13, #^xf, r14		; check H & E alignment
	bic	r12, #3, r12		; clear <1:0>
	 bne	r14, queue_addr_error2	; br if bad H/E alignment
	xor	r16, r17, r13		; check  H = E
	 beq	r13, queue_addr_error2	; br if H = E

	; if we get any mm errors, on the virtual access(s) below, we want
	; to report the mm error on the PC of the queue instruction,
	; not the pc of the ld/st the caused the error.
	; Note that bit 0 of PT3 is clear => alignment errors will trap...
 
	sget_addr r13, <pal$queue_fault_setup2-pal$start>, r31 ; get address
	 mt	r13, pt3		; set recovery address
	lda	r14, ldxl_stxc_retry_count(r31) ; set retry count

lock_insqhiq:
	 ldq_l	r0, (r16)		; try to get H, interlocked
	blbs	r0, queue_busy2		; entry already locked => return -1
	 CONT_PAL_ROUTINE	INSQHIQ, DOUBLE=1
	or	r0, #1, r13		; attempt to set lock flag
	 stq_c	r13, (r16)		; try to set secondary lock in H
	blbc	r13, retry_lock_insqhiq	; abort if stx/c failed
	 or	r12, #2, r12		; set flag indicating we own lock

	;mb				; mb, implied on ev4 by stx/c

	; check all remaining addrs for read write accessability and alignment
	ldq/w	r14, (r17)		; check E (protection)
	 and	r0, #^xf, r13		; check N alignment
	addq	r16, r0, r14		; get addr of N
	 bne	r13, queue_addr_error2l	; br if bad N alignment
	ldq/w	r13, (r14)		; check N (protection)

	; now we are committed to the instruction - the only possible error
	; is a TNV, in which case we reload the TB with the no longer valid pte
	; (if it was level 3) and continue - otherwise MCHK...
	 sget_addr r13, <pal$queue_fault2-pal$start>, r31; get address
	mt	r13, pt3		; set recovery address

	; Do the queue operation
	debug_mp_queue			; if mp queue debug, zap dtb's
	 subq	r16, r17, r13		; H-E
	stq	r13, 8(r17)		; (E+8) <- H-E
	 addq	r13, r0, r13		; N-E
	stq	r13, (r17)		; (E) <- N-E

	 subq	r31, r13, r13		; E-N
	stq	r13, 8(r14)		; (N+8) <- E-N

	 mb

	subq	r17, r16, r13		; E-H
	 stq	r13, (r16)		; (H) <- E-H

	mt	r12, exc_addr		; set the rei address
	 cmpeq	r0, r31, r0		; queue was empty if N-H == 0
	mf	r12, pt12
	 mf	r13, pt13
	mf	r14, pt14
	 hw_rei


	END_PAL_ROUTINE		INSQHIQ

.sbttl	INSQTIL	- PALcode for INSQTIL instruction

;+
; INSQTIL
;
; Entry:
;	Vectored into via hardware PALcode instruction dispatch
;	PALcode enviornment set up.
;	R16	= addr of queue header
;	R17	= addr of new entry
;
; Function:
;	1 Alignment and address checks are performed on all arguments and
;	  the queue header.
;	2 Hardware interlock is taken on queue header.
;	3 Secondary interlock is taken on queue header.
;	4 All addresses are probed.
;	5 Entry is inserted into the queue.
;	6 Status is returned.
;
;	If a memory management error occurs prior to step 5, a trap
;	is generated useing the PC of the queue instruction.
;
;	If a memory managment error occurs during step 5, it is checked
;	to make sure it is the a TNV on the level 3 pte. If it is the
;	invalid pte is used and the queue instruction is continued.
;	Otherwise a machine check is generated.
;
; Returns:
;	R0 =
;		-1	if secondary interlock was set
;		 0	if queue was not empty
;		 1	if was empty
;-

	START_PAL_ROUTINE	INSQTIL, longflow=1
	mt	r12, pt12		; get working regs
  	 mf	r12, exc_addr		; save pc
	mt	r13, pt13
	 or	r16, r17, r13		; merge H & E for align check
	mt	r14, pt14
	 and	r13, #^x7, r14		; check H & E alignment
	bic	r12, #3, r12		; clear <1:0>
	 bne	r14, queue_addr_error2	; br if bad H/E alignment
	xor	r16, r17, r13		; check H = E
	 addl	r16, r31, r14		; sext H
	xor	r16, r14, r14		; check H = sext H?
	 beq	r13, queue_addr_error2	; br if H = E
	addl	r17, r31, r13		; sext E
	 bne	r14, queue_addr_error2	; br if bad H sext
	xor	r17, r13, r13		; check sext E
	 CONT_PAL_ROUTINE	INSQTIL, DOUBLE=1
	bne	r13, queue_addr_error2	; br if bad sext E


	; if we get any mm errors, on the virtual access(s) below, we want
	; to report the mm error on the PC of the queue instruction,
	; not the pc of the ld/st the caused the error.
	; Note that bit 0 of PT3 is clear => alignment errors will trap...
 
	 sget_addr r13, <pal$queue_fault_setup2-pal$start>, r31 ; get address
	mt	r13, pt3		; set recovery address
	 lda	r14, ldxl_stxc_retry_count(r31) ; set retry count

lock_insqtil:
	ldq_l	r0, (r16)		; try to get queue H, interlocked
	 blbs	r0, queue_busy2		; entry already locked => return -1
	or	r0, #1, r13		; attempt to set lock flag
	 stl_c	r13, (r16)		; try to set secondary lock in H
	blbc	r13, retry_lock_insqtil	; abort if stx/c failed
	 or	r12, #2, r12		; set flag indicating we own lock

	;mb				; mb, implied on ev4 by stx/c

	; check all remaining addrs for read write accessability and alignment
	sra	r0, #32, r14		; P-H
	 or	r0, r14, r13		; merge N-H, P-H for alignment check
	and	r13, #^x7, r13		; check N, P alignment
	 bne	r13, queue_addr_error2l	; br if bad N/P alignment


	ldl/w	r13, (r17)		; check E (protection)
	 beq	r0, insqtil_empty	; br if if queue empty
	addl	r16, r14, r14		; P
	 stall	1, mxpr=0		; stall for code alignment
	ldl/w	r13, (r14)		; check P (protection)

	; now we are committed to the instruction - the only possible error
	; is a TNV, in which case we reload the TB with the no longer valid pte
	; (if it was level 3) and continue - otherwise MCHK...
	 sget_addr r13, <pal$queue_fault2-pal$start>, r31; get address
	mt	r13, pt3		; set recovery address

	; Do the queue operation
	debug_mp_queue			; if mp queue debug, zap dtb's
	 subl	r16, r17, r13		; H-E
	stl	r13, (r17)		; (E) <- H-E
	 subl	r14, r17, r13		; P-E
	stl	r13, 4(r17)		; (E+4) <- P-E
	 subl	r31, r13, r13		; E-P
	stl	r13, (r14)		; (P) <- E-P
	 subl	r17, r16, r13		; E-H
	stl	r13, 4(r16)		; (H+4) <- E-H

	 mb
	stl	r0, (r16)		; (H) <- orig (H)

	 mt	r12, exc_addr		; set the rei address
	or	R31, #0, r0		; queue was NOT empty
	 mf	r12, pt12
	mf	r13, pt13
	 mf	r14, pt14
	hw_rei

	

	align_to_double_cache_block
insqtil_empty:
	sget_addr r13, <pal$queue_fault2-pal$start>, r31; get address
	 stall	1
	mt	r13, pt3		; set recovery address
insqtilr_empty:
	; Do the queue operation
	debug_mp_queue			; if mp queue debug, zap dtb's
	 subl	r16, r17, r13		; H - E
	stl	r13, 4(r17)		; (E+4) <- H-E
	 subl	r17, r16, r14		; E-H
	stl	r13, (r17)		; (E) <- H-E

	 stl	r14, 4(r16)		; (H+4) <- E-H
	mb
	 stl	r14, (r16)		; (H) <- E-H
	mt	r12, exc_addr		; set the rei address
	 or	r31, #1, r0		; queue was empty
	mf	r12, pt12
	 mf	r13, pt13
	mf	r14, pt14
	 hw_rei



	END_PAL_ROUTINE	 INSQTIL


.sbttl	INSQTIQ	- PALcode for INSQTIQ instruction

;+
; INSQTIQ
;
; Entry:
;	Vectored into via hardware PALcode instruction dispatch
;	PALcode enviornment set up.
;	R16	= addr of queue header
;	R17	= addr of new entry
;
; Function:
;	1 Alignment and address checks are performed on all arguments and
;	  the queue header.
;	2 Hardware interlock is taken on queue header.
;	3 Secondary interlock is taken on queue header.
;	4 All addresses are probed.
;	5 Entry is inserted into the queue.
;	6 Status is returned.
;
;	If a memory management error occurs prior to step 5, a trap
;	is generated useing the PC of the queue instruction.
;
;	If a memory managment error occurs during step 5, it is checked
;	to make sure it is the a TNV on the level 3 pte. If it is the
;	invalid pte is used and the queue instruction is continued.
;	Otherwise a machine check is generated.
;
; Returns:
;	R0 =
;		-1	if secondary interlock was set
;		 0	if queue was not empty
;		 1	if was empty
;-

	START_PAL_ROUTINE	INSQTIQ, longflow=1
	mt	r12, pt12		; get working regs
  	 mf	r12, exc_addr		; save pc
	mt	r13, pt13
	 or	r16, r17, r13		; merge H & E for align check
	mt	r14, pt14
	 and	r13, #^xF, r14		; check H & E alignment
	bic	r12, #3, r12		; clear <1:0>
	 bne	r14, queue_addr_error2	; br if bad H/E alignment
	xor	r16, r17, r13		; check H = E
	 beq	r13, queue_addr_error2	; br if H = E


	; if we get any mm errors, on the virtual access(s) below, we want
	; to report the mm error on the PC of the queue instruction,
	; not the pc of the ld/st the caused the error.
	; Note that bit 0 of PT3 is clear => alignment errors will trap...
 
	sget_addr r13, <pal$queue_fault_setup2-pal$start>, r31 ; get address
	 mt	r13, pt3		; set recovery address
	lda	r14, ldxl_stxc_retry_count(r31) ; set retry count

lock_insqtiq:
	 ldq_l	r0, (r16)		; try to get queue H, interlocked
	blbs	r0, queue_busy2		; entry already locked => return -1
	 CONT_PAL_ROUTINE	INSQTIQ, DOUBLE=1
	or	r0, #1, r13		; attempt to set lock flag
	 stq_c	r13, (r16)		; try to set secondary lock in H
	blbc	r13, retry_lock_insqtiq	; abort if stx/c failed
	 or	r12, #2, r12		; set flag indicating we own lock

	;mb				; mb, implied on ev4 by stx/c

	; check all remaining addrs for read write accessability and alignment
	ldq	r14, 8(r16)		; P-H
	 or	r0, r14, r13		; merge N-H & P-H for alignment check
	and	r13, #^xf, r13		; check N & P alignment
	 bne	r13, queue_addr_error2l	; br if bad N/P alignment


	ldq/w	r13, (r17)		; check E (protection)
	 addq	r16, r14, r14		; P
	beq	r0, insqtiq_empty	; br if queue empty
	 stall	1, mxpr=0		; stall for code alignment
	ldq/w	r13, (r14)		; check P (protection)

	; now we are committed to the instruction - the only possible error
	; is a TNV, in which case we reload the TB with the no longer valid pte
	; (if it was level 3) and continue - otherwise MCHK...
	 sget_addr r13, <pal$queue_fault2-pal$start>, r31; get address
	mt	r13, pt3		; set recovery address

	; Do the queue operation
	debug_mp_queue			; if mp queue debug, zap dtb's
	 subq	r16, r17, r13		; H-E
	stq	r13, (r17)		; (E) <- H-E
	 subq	r14, r17, r13		; P-E
	stq	r13, 8(r17)		; (E+8) <- P-E
	 subq	r31, r13, r13		; E-P
	stq	r13, (r14)		; (P) <- E-P
	 subq	r17, r16, r13		; E-H
	stq	r13, 8(r16)		; (H+8) <- E-H

	 mb

	stq	r0, (r16)		; (H) <- Orig (H)
	 mt	r12, exc_addr		; set the rei address
	or	r31, #0, r0		; queue was NOT empty
	 mf	r12, pt12
	mf	r13, pt13
	 mf	r14, pt14
	hw_rei



	align_to_double_cache_block
insqtiq_empty:
	sget_addr r13, <pal$queue_fault2-pal$start>, r31; get address
	 stall	1
	mt	r13, pt3		; set recovery address
	; Do the queue operation
insqtiqr_empty:
	debug_mp_queue			; if mp queue debug, zap dtb's
	 subq	r16, r17, r13		; H - E
	stq	r13, 8(r17)		; (E+8) <- H-E
	 subq	r17, r16, r14		; E-H
	stq	r13, (r17)		; (E) <- H-E

	 stq	r14, 8(r16)		; (H+8) <- E-H
	mb
	 stq	r14, (r16)		; (H) <- E-H
	mt	r12, exc_addr		; set the rei address
	 or	r31, #1, r0		; queue was empty
	mf	r12, pt12
	 mf	r13, pt13
	mf	r14, pt14
	 hw_rei


	END_PAL_ROUTINE	 INSQTIQ

   
.sbttl	REMQHIL	- PALcode for REMQHIL instruction

;+
; REMQHIL
;
; Entry:
;	Vectored into via hardware PALcode instruction dispatch
;	PALcode enviornment set up.
;	R16	= addr of queue header
;
; Function:
;	1 Alignment and address checks are performed on all arguments and
;	  the queue header.
;	2 Hardware interlock is taken on queue header.
;	3 Secondary interlock is taken on queue header.
;	4 All addresses are probed.
;	5 Entry is inserted into the queue.
;	6 Status is returned.
;
;	If a memory management error occurs prior to step 5, a trap
;	is generated useing the PC of the queue instruction.
;
;	If a memory managment error occurs during step 5, it is checked
;	to make sure it is the a TNV on the level 3 pte. If it is the
;	invalid pte is used and the queue instruction is continued.
;	Otherwise a machine check is generated.
;
; Returns:
;	R0 =
;		-1	if secondary interlock was set
;		 0	if queue was empty
;		 1	 if entry removed, and queue still not empty
;		 2	 if entry removed, and queue empty
;
;	R1 = 	addr of entry removed
;-

	START_PAL_ROUTINE	REMQHIL, longflow=1
	mt	r12, pt12		; get working regs
  	 mf	r12, exc_addr		; save pc
	mt	r13, pt13
	 addl	r16, r31, r13		; sign extend H
	xor	r16, r13, r1		; check H = sext H
	 bic	r12, #3, r12		; clear <1:0>
	and	r16, #^x7, r13		; check H alignment
	 bne	r1, queue_addr_error1	; br if bad sext H
	bne	r13, queue_addr_error1	; br if bad alignment H



	; if we get any mm errors, on the virtual access(s) below, we want
	; to report the mm error on the PC of the queue instruction,
	; not the pc of the ld/st the caused the error.
	; Note that bit 0 of PT3 is clear => alignment errors will trap...
 
	 sget_addr r13, <pal$queue_fault_setup1-pal$start>, r31 ; get address
	mt	r13, pt3		; set recovery address
	 lda	r1, ldxl_stxc_retry_count(r31) ; set retry count

lock_remqhil:
	ldl_l   r0, (r16)		; try to get H, interlocked
	 beq	r0, queue_empty1	; all done, if queue is already empty
	or	r0, #1, r13		; attempt to set lock flag
	 CONT_PAL_ROUTINE	REMQHIL, DOUBLE=1
	blbs	r0, queue_busy1		; entry already locked => return -1
	 stl_c   r13, (r16)		; try to set secondary lock in H
	blbc	r13, retry_lock_remqhil	; abort if stx/c failed
	 or	r12, #2, r12		; set flag indicating we own lock

	;mb				; mb, implied on ev4 by stx/c

	; check all remaining addrs for read write accessability and alignment
	addl	r16, r0, r1		; N
	 ldq	r13, (r1)		; check N (protection+alignment)
	addl	r13, r1, r1		; NN 
	 and	r1, #^x7, r13		; check NN (alignment)
	bne	r13, queue_addr_error1l	; br if bad NN alignment
	 ldl/w	r13, (r1)		; check NN (protection)

	; now we are committed to the instruction - the only possible error
	; is a TNV, in which case we reload the TB with the no longer valid pte
	; (if it was level 3) and continue - otherwise MCHK...
	sget_addr r13, <pal$queue_fault1-pal$start>, r31; get address
	 mt	r13, pt3		; set recovery address

	; Do the queue operation
	debug_mp_queue			; if mp queue debug, zap dtb's
	subl	r16, r1, r13		; H-NN
	 stl	r13, 4(r1)		; (NN+4) <- H-NN

	mb

	 subl	r31, r13, r13		; NN-H
	stl	r13, (r16)		; (H) <- NN-H
	 addl	r16, r0, r1		; r1 <- N

	mt	r12, exc_addr		; set the rei address
	 cmpeq	r13, r31, r0		; r0 = 1 if now empty, 0 if not yet empty
	mf	r12, pt12
	 mf	r13, pt13
	addq	r0, #1, r0		; r0 = 2 if now empty, 1 if not yet empty
	 hw_rei

	END_PAL_ROUTINE	 REMQHIL

   
.sbttl	REMQHIQ	- PALcode for REMQHIQ instruction

;+
; REMQHIQ
;
; Entry:
;	Vectored into via hardware PALcode instruction dispatch
;	PALcode enviornment set up.
;	R16	= addr of queue header
;
; Function:
;	1 Alignment and address checks are performed on all arguments and
;	  the queue header.
;	2 Hardware interlock is taken on queue header.
;	3 Secondary interlock is taken on queue header.
;	4 All addresses are probed.
;	5 Entry is inserted into the queue.
;	6 Status is returned.
;
;	If a memory management error occurs prior to step 5, a trap
;	is generated useing the PC of the queue instruction.
;
;	If a memory managment error occurs during step 5, it is checked
;	to make sure it is the a TNV on the level 3 pte. If it is the
;	invalid pte is used and the queue instruction is continued.
;	Otherwise a machine check is generated.
;
; Returns:
;	R0 =
;		-1	if secondary interlock was set
;		 0	if queue was empty
;		 1	 if entry removed, and queue still not empty
;		 2	 if entry removed, and queue empty
;
;	R1 = 	addr of entry removed
;-

	START_PAL_ROUTINE	REMQHIQ, longflow=1
	mt	r12, pt12		; get working regs
	 and	r16, #^xF, r1		; check H alignment
  	mf	r12, exc_addr		; save pc
	 mt	r13, pt13
	bic	r12, #3, r12		; clear <1:0>

	 bne	r1, queue_addr_error1	; br if bad H alignment



	; if we get any mm errors, on the virtual access(s) below, we want
	; to report the mm error on the PC of the queue instruction,
	; not the pc of the ld/st the caused the error.
	; Note that bit 0 of PT3 is clear => alignment errors will trap...
 
	sget_addr r13, <pal$queue_fault_setup1-pal$start>, r31 ; get address
	 mt	r13, pt3		; set recovery address
	lda	r1, ldxl_stxc_retry_count(r31) ; set retry count

lock_remqhiq:
	 ldq_l   r0, (r16)		; try to get queue H, interlocked
	beq	r0, queue_empty1	; all done, if queue is already empty
	 or	r0, #1, r13		; attempt to set lock flag
	blbs	r0, queue_busy1		; entry already locked => return -1
	 stq_c   r13, (r16)		; try to set secondary lock in H
	blbc	r13, retry_lock_remqhiq	; abort if stx/c failed
	 CONT_PAL_ROUTINE	REMQHIQ, DOUBLE=1
	or	r12, #2, r12		; set flag indicating we own lock

	;mb				; mb, implied on ev4 by stx/c

	; check all remaining addrs for read write accessability and alignment
	 addq	r16, r0, r1		; N
	and	r1, #^xf, r13		; check N (alignment)
	 bne	r13, queue_addr_error1l	; br if bad N alignment
	ldq 	r13, (r1)		; check N (protection+alignment)
	 addq	r13, r1, r1		; NN
	and	r1, #^xf, r13		; check NN (alignment)
	 bne	r13, queue_addr_error1l
	ldq/w	r13, (r1)		; check NN (protection)

	; now we are committed to the instruction - the only possible error
	; is a TNV, in which case we reload the TB with the no longer valid pte
	; (if it was level 3) and continue - otherwise MCHK...
	 sget_addr r13, <pal$queue_fault1-pal$start>, r31; get address
	mt	r13, pt3		; set recovery address

	; Do the queue operation
	debug_mp_queue			; if mp queue debug, zap dtb's
	 subq	r16, r1, r13		; H-NN
	stq	r13, 8(r1)		; (H+8) <- H-NN

	 mb

	subq	r31, r13, r13		; NN-H
	 stq	r13, (r16)		; (H) <- NN-H

	mt	r12, exc_addr		; set the rei address
	 addq	r16, r0, r1		; r1 <- N
	mf	r12, pt12
	 cmpeq	r13, r31, r0		; r0 = 1 if empty, 0 if not yet empty
	mf	r13, pt13
	 stall	1, mxpr=0
	addq	r0, #1, r0		; r0 = 2 if empty, 1 if not yet empty
	 hw_rei

	END_PAL_ROUTINE	 REMQHIQ


.sbttl	REMQTIL	- PALcode for REMQTIL instruction

;+
; REMQTIL
;
; Entry:
;	Vectored into via hardware PALcode instruction dispatch
;	PALcode enviornment set up.
;	R16	= addr of queue header
;
; Function:
;	1 Alignment and address checks are performed on all arguments and
;	  the queue header.
;	2 Hardware interlock is taken on queue header.
;	3 Secondary interlock is taken on queue header.
;	4 All addresses are probed.
;	5 Entry is inserted into the queue.
;	6 Status is returned.
;
;	If a memory management error occurs prior to step 5, a trap
;	is generated useing the PC of the queue instruction.
;
;	If a memory managment error occurs during step 5, it is checked
;	to make sure it is the a TNV on the level 3 pte. If it is the
;	invalid pte is used and the queue instruction is continued.
;	Otherwise a machine check is generated.
;
; Returns:
;	R0 =
;		-1	if secondary interlock was set
;		 0	if queue was empty
;		 1	 if entry removed, and queue still not empty
;		 2	 if entry removed, and queue empty
;
;	R1 = 	addr of entry removed
;-

	START_PAL_ROUTINE	REMQTIL, longflow=1
	mt	r12, pt12		; get working regs
	 mf	r12, exc_addr		; save pc
	mt	r13, pt13
	 addl	r16, r31, r13		; sext H
	mt	r14, pt14
	 xor	r16, r13, r1		; check H = sext H
	bic	r12, #3, r12		; clear <1:0>
	 bne	r1, queue_addr_error2	; br if bad sext H
	and	r16, #^x7, r13		; check header alignment
	 bne	r13, queue_addr_error2	; br if bad alignment H


	; if we get any mm errors, on the virtual access(s) below, we want
	; to report the mm error on the PC of the queue instruction,
	; not the pc of the ld/st the caused the error.
	; Note that bit 0 of PT3 is clear => alignment errors will trap...
 
	sget_addr r13, <pal$queue_fault_setup2-pal$start>, r31 ; get address
	 mt	r13, pt3		; set recovery address
	lda	r14, ldxl_stxc_retry_count(r31) ; set retry count

lock_remqtil:
	 ldq_l   r0, (r16)		; try to get H, interlocked
	beq	r0, queue_empty2	; all done, if queue is already empty
	 CONT_PAL_ROUTINE	REMQTIL, DOUBLE=1
	blbs	r0, queue_busy2		; entry already locked => return -1
	 or	r0, #1, r13		; attempt to set lock flag
	stl_c   r13, (r16)		; try to set secondary lock in H
	 blbc	r13, retry_lock_remqtil	; abort if stx/c failed
	or	r12, #2, r12		; set flag indicating we own lock

	;mb				; mb, implied on ev4 by stx/c

	; check all remaining addrs for read write accessability and alignment
	 sra	r0, #32, r13		; P-H
	addl	r16, r13, r1		; P
	 ldl	r14, 4(r1)		; check P (access)
	addl	r1, r14, r13		; PP
	 ldl/w	r14, (r13)		; check PP (access)
	or	r13, r1, r14		; merge PP, P for align check
	 and	r14, #^x7, r14		; do align check
	bne	r14, queue_addr_error2

	; now we are committed to the instruction - the only possible error
	; is a TNV, in which case we reload the TB with the no longer valid pte
	; (if it was level 3) and continue - otherwise MCHK...

	 sget_addr r14, <pal$queue_fault2-pal$start>, r31; get address
	mt	r14, pt3		; set recovery address

	; Do the queue operation
	debug_mp_queue			; if mp queue debug, zap dtb's
	 subl	r13, r16, r14		; PP-H
	stl	r14, 4(r16)		; (H+4) <- PP-H

	 subl	r16, r13, r14		; H-PP
	stl	r14, (r13)		; (PP) <- H-PP

	 beq	r14, 10$		; br if queue empty H-PP = 0
	mb
	 stl	r0, (r16)		; (r16) <- N-H
10$:	mt	r12, exc_addr		; set the rei address
	 cmpeq	r14, r31, r0		; r0 = 1 if empty, 0 if not yet empty
	mf	r12, pt12
	 addq	r0, #1, r0		; r0 = 2 if empty, 1 if not yet empty
	mf	r13, pt13
	 mf	r14, pt14
	hw_rei
   
	END_PAL_ROUTINE	 REMQTIL


.sbttl	REMQTIQ	- PALcode for REMQTIQ instruction

;+
; REMQTIQ
;
; Entry:
;	Vectored into via hardware PALcode instruction dispatch
;	PALcode enviornment set up.
;	R16	= addr of queue header
;
; Function:
;	1 Alignment and address checks are performed on all arguments and
;	  the queue header.
;	2 Hardware interlock is taken on queue header.
;	3 Secondary interlock is taken on queue header.
;	4 All addresses are probed.
;	5 Entry is inserted into the queue.
;	6 Status is returned.
;
;	If a memory management error occurs prior to step 5, a trap
;	is generated useing the PC of the queue instruction.
;
;	If a memory managment error occurs during step 5, it is checked
;	to make sure it is the a TNV on the level 3 pte. If it is the
;	invalid pte is used and the queue instruction is continued.
;	Otherwise a machine check is generated.
;
; Returns:
;	R0 =
;		-1	if secondary interlock was set
;		 0	if queue was empty
;		 1	 if entry removed, and queue still not empty
;		 2	 if entry removed, and queue empty
;
;	R1 = 	addr of entry removed
;-

	START_PAL_ROUTINE	REMQTIQ, longflow=1
	mt	r12, pt12		; get working regs
	 and	r16, #^xf, r0		; check H alignment
  	mf	r12, exc_addr		; save pc
	 mt	r13, pt13
	mt	r14, pt14
	 bic	r12, #3, r12		; clear <1:0>

	bne	r0, queue_addr_error2	; br if bad H alignment



	; if we get any mm errors, on the virtual access(s) below, we want
	; to report the mm error on the PC of the queue instruction,
	; not the pc of the ld/st the caused the error.
	; Note that bit 0 of PT3 is clear => alignment errors will trap...
 
	 sget_addr r13, <pal$queue_fault_setup2-pal$start>, r31 ; get address
	mt	r13, pt3		; set recovery address
	 lda	r14, ldxl_stxc_retry_count(r31) ; set retry count

lock_remqtiq:
	ldq_l   r0, (r16)		; try to get H, interlocked
	 beq	r0, queue_empty2	; all done, if queue is already empty
	blbs	r0, queue_busy2		; entry already locked => return -1
	 or	r0, #1, r13		; attempt to set lock flag
	stq_c   r13, (r16)		; try to set secondary lock in H
	 CONT_PAL_ROUTINE	REMQTIQ, DOUBLE=1
	blbc	r13, retry_lock_remqtiq	; abort if stx/c failed
	 or	r12, #2, r12		; set flag indicating we own lock

	;mb				; mb, implied on ev4 by stx/c

	; check all remaining addrs for read write accessability and alignment
	ldq	r13, 8(r16)		; P-H
	 addq	r16, r13, r1		; P
	ldq	r14, 8(r1)		; check P (access)
	 addq	r1, r14, r13		; PP
	ldq/w	r14, (r13)		; check PP (access)
	 or	r13, r1, r14		; merge PP, P for align check
	and	r14, #^xf, r14		; do align check
	 stall	1, mxpr=0
	bne	r14, queue_addr_error2	; br if bad P or PP alignment

	; now we are committed to the instruction - the only possible error
	; is a TNV, in which case we reload the TB with the no longer valid pte
	; (if it was level 3) and continue - otherwise MCHK...

	 sget_addr r14, <pal$queue_fault2-pal$start>, r31; get address
	mt	r14, pt3		; set recovery address

	; Do the queue operation
	debug_mp_queue			; if mp queue debug, zap dtb's
	 subl	r13, r16, r14		; PP-H
	stq	r14, 8(r16)		; (H+8) <- PP-H

	 subq	r16, r13, r14		; H-PP
	stq	r14, (r13)		; (PP) <- H-PP
	 beq	r14, 10$		; br if queue now empty
	mb				;
	 stq	r0, (r16)		; (H) <- N-H
10$:	mt	r12, exc_addr		; set the rei address
	 cmpeq	r14, r31, r0		; r0 = 1 if empty, 0 if not yet empty
	mf	r12, pt12
	 addq	r0, #1, r0		; r0 = 2 if empty, 1 if not yet empty
	mf	r13, pt13
	 mf	r14, pt14
	hw_rei
   
	END_PAL_ROUTINE	 REMQTIQ

   
.sbttl	INSQUEL	- PALcode for INSQUEL instruction

;+
; INSQUEL
;
; Entry:
;	Vectored into via hardware PALcode instruction dispatch
;	PALcode enviornment set up.
;	R16	= addr of queue header
;	R17	= addr of new entry
;
; Function:
;	1 All addresses are probed.
;	2 Entry is inserted into the queue.
;	3 Status is returned.
;
;	If a memory management error occurs prior to step 2, a trap
;	is generated useing the PC of the queue instruction.
;
;	If a memory managment error occurs during step 2, it is checked
;	to make sure it is the a TNV on the level 3 pte. If it is the
;	invalid pte is used and the queue instruction is continued.
;	Otherwise a machine check is generated.
;
; Returns:
;	R0 =
;		0	if queue was not empty
;		1	if was empty
;-

	START_PAL_ROUTINE	INSQUEL, longflow=1
   	mt	r12, pt12		; get working regs
	 mf	r12, exc_addr		; get address of Pal call
	mt	r13, pt13
	
	 sget_addr r0, <<pal$queue_fault_setup1nl-pal$start>!1>, r31 ; get address
	mt	r0, pt3			; set recovery address

	; have to probe for access
	; check all remaining addrs for read write accessability
	 ldl/w   r13,  (r16)		; probe first part of H
	ldl/w   r0,   (r17)		; probe first part of E
	 ldl/w   r13, 3(r16)		; probe second part of H
	ldl/w   r0,  7(r17)		; probe second part of E
  
	 ldl	r13, (r16)		; fetch H, will fixup if unaligned

	ldl/w	r0, 4(r13)		; probe first part of N
	 ldl/w	r0, 7(r13)		; probe second part of N

	; access check passed
	; this is the point of no return
	; The only possible mm errors now are TNV, if we encounter these
	; we reload the TB with the no longer valid pte (if it was level 3)
	; and continue. Else MCHK.
	.iif ne enable_debug_mp, CONT_PAL_ROUTINE	INSQUEL
	sget_addr r0, <<pal$queue_fault1-pal$start>!1>, r31; get address
	 mt	r0, pt3			; set recovery address

	; do the queue instruction assuming it is aligned
	debug_mp_queue			; if mp queue debug, zap dtb's
	stl	r13, (r17)		; (E) <- N
	 CONT_PAL_ROUTINE 	INSQUEL, DOUBLE=1
	stl	r16, 4(r17)		; (E+4) <- H
	 stl	r17, 4(r13)		; (N+4) <- E
	stl	r17, (r16)		; (H)   <- E

	 cmpeq	r16, r13, r0		; set queue empty flag

	mt	r12, exc_addr
	 mf	r12, pt12
	mf	r13, pt13
  	hw_rei

	END_PAL_ROUTINE	 INSQUEL
 
   
.sbttl	INSQUELD - PALcode for INSQUELD instruction

;+
; INSQUELD
;
; Entry:
;	Vectored into via hardware PALcode instruction dispatch
;	PALcode enviornment set up.
;	R16	= addr of addr of queue header
;	R17	= addr of new entry
;
; Function:
;	1 All addresses are probed.
;	2 Entry is inserted into the queue.
;	3 Status is returned.
;
;	If a memory management error occurs prior to step 2, a trap
;	is generated useing the PC of the queue instruction.
;
;	If a memory managment error occurs during step 2, it is checked
;	to make sure it is the a TNV on the level 3 pte. If it is the
;	invalid pte is used and the queue instruction is continued.
;	Otherwise a machine check is generated.
;
; Returns:
;	R0 =
;		0	if queue was not empty
;		1	if was empty
;-

	START_PAL_ROUTINE	INSQUELD, longflow=1
   	mt	r12, pt12		; get working regs
	 mf	r12, exc_addr		; get address of Pal call
	mt	r13, pt13
	 sget_addr r0, <<pal$queue_fault_setup2nl-pal$start>!1>, r31 ; get address
	mt	r14, pt14

	 mt	r0, pt3			; set recovery address

	; have to probe for access
	; check all remaining addrs for read write accessability
	ldl	r14,  (r16)		; get H
	 ldl/w   r13,  (r14)		; probe first part of H
	ldl/w   r0,   (r17)		; probe first part of E
	 ldl/w   r13, 3(r14)		; probe second part of H
	ldl/w   r0,  7(r17)		; probe second part of E
  
	 ldl	r13, (r14)		; get N, fixup if unaligned

	ldl/w	r0, 4(r13)		; probe first part of N
	 ldl/w	r0, 7(r13)		; probe second part of N

	; access check passed
	; this is the point of no return
	; The only possible mm errors now are TNV, if we encounter these
	; we reload the TB with the no longer valid pte (if it was level 3)
	; and continue. Else MCHK.
  
	sget_addr r0, <<pal$queue_fault2-pal$start>!1>, r31; get address
	 CONT_PAL_ROUTINE 	INSQUELD, DOUBLE=1
	mt	r0, pt3		; set recovery address

	; do the queue instruction assuming it is aligned
	debug_mp_queue			; if mp queue debug, zap dtb's
	 stl	r13, (r17)		; (E) <- N
	stl	r14, 4(r17)		; (E+4) <- H
	 stl	r17, 4(r13)		; (N+4) <- E
	stl	r17, (r14)		; (H)   <- E

	 cmpeq	r13, r14, r0		; set queue empty flag

	mt	r12, exc_addr
	 mf	r12, pt12
	mf	r13, pt13
	 mf	r14, pt14
 	hw_rei

	END_PAL_ROUTINE	 INSQUELD

   
.sbttl	INSQUEQ	- PALcode for INSQUEQ instruction

;+
; INSQUEQ
;
; Entry:
;	Vectored into via hardware PALcode instruction dispatch
;	PALcode enviornment set up.
;	R16	= addr of queue header
;	R17	= addr of new entry
;
; Function:
;	1 All addresses are probed.
;	2 Entry is inserted into the queue.
;	3 Status is returned.
;
;	If a memory management error occurs prior to step 2, a trap
;	is generated useing the PC of the queue instruction.
;
;	If a memory managment error occurs during step 2, it is checked
;	to make sure it is the a TNV on the level 3 pte. If it is the
;	invalid pte is used and the queue instruction is continued.
;	Otherwise a machine check is generated.
;
; Returns:
;	R0 =
;		0	if queue was not empty
;		1	if was empty
;-

	START_PAL_ROUTINE	INSQUEQ, longflow=1
   	mt	r12, pt12		; get working regs
	 mf	r12, exc_addr		; get address of Pal call
	mt	r13, pt13


	; Validate header and entry address.
	; Report an illpalop if any violations are found.
	 or	r16, r17, r13		; merge H & E for align check
	and	r13, #^xf, r13		; check H/E alignment
	 bne	r13, queue_addr_error1	; br if bad H/E alignment

	sget_addr r13, <pal$queue_fault_setup1nl-pal$start>, r31 ; get address
	 mt	r13, pt3		; set recovery address

	; have to probe for access
	; check all remaining addrs for read write accessability
	ldq/w   r13, (r16)		; probe H, and fetch N
	 ldq/w   r0, (r17)		; probe E
  
	and	r13, #^xf, r0		; check N alignment
	 bne	r0, queue_addr_error1	; br if bad N alignment
	ldq/w	r0, 8(r13)		; probe N

	; access check passed
	; this is the point of no return
	; The only possible mm errors now are TNV, if we encounter these
	; we reload the TB with the no longer valid pte (if it was level 3)
	; and continue. Else MCHK.
  
	 sget_addr r0, <pal$queue_fault1-pal$start>, r31; get address
	mt	r0, pt3			; set recovery address
	 CONT_PAL_ROUTINE 	INSQUEQ, DOUBLE=1

	; do the queue instruction assuming it is aligned
	debug_mp_queue			; if mp queue debug, zap dtb's
	stq	r13, (r17)		; (E)   <- N
	 stq	r16, 8(r17)		; (E+8) <- H
	stq	r17, 8(r13)		; (N+8) <- E
	 stq	r17, (r16)		; (H)   <- E

	cmpeq	r13, r16, r0		; queue empty if N = H

	 mt	r12, exc_addr
	mf	r12, pt12
	 mf	r13, pt13
 	hw_rei

	END_PAL_ROUTINE	 INSQUEQ
 
   
.sbttl	INSQUEQD - PALcode for INSQUEQD instruction

;+
; INSQUEQD
;
; Entry:
;	Vectored into via hardware PALcode instruction dispatch
;	PALcode enviornment set up.
;	R16	= addr of addr of queue header
;	R17	= addr of new entry
;
; Function:
;	1 All addresses are probed.
;	2 Entry is inserted into the queue.
;	3 Status is returned.
;
;	If a memory management error occurs prior to step 2, a trap
;	is generated useing the PC of the queue instruction.
;
;	If a memory managment error occurs during step 2, it is checked
;	to make sure it is the a TNV on the level 3 pte. If it is the
;	invalid pte is used and the queue instruction is continued.
;	Otherwise a machine check is generated.
;
; Returns:
;	R0 =
;		0	if queue was not empty
;		1	if was empty
;-

	START_PAL_ROUTINE	INSQUEQD, longflow=1
   	mt	r12, pt12		; get working regs
	 mf	r12, exc_addr		; get address of Pal call
	mt	r13, pt13
	 or	r16, r17, r13		; merge H & E for align check
	mt	r14, pt14

	 and	r13, #^xf, r13		; check H/E alignment
	bne	r13, queue_addr_error2	; br if bad H/E alignment

	 sget_addr r13, <pal$queue_fault_setup2nl-pal$start>, r31 ; get address
	mt	r13, pt3		; set recovery address

	; have to probe for access
	; check all remaining addrs for read write accessability
	 ldq	r14, (r16)		; get H
	ldq/w   r13, (r14)		; probe H, and fetch N
	 ldq/w   r0, (r17)		; probe E
  
	or	r13, r14, r0		; merge N and H for alignment
	 and	r0, #^xf, r0		; check N/H alignment
	bne	r0, queue_addr_error2	; br if bad N/H alignment

	 CONT_PAL_ROUTINE 	INSQUEQD, DOUBLE=1
	ldq/w	r0, 8(r13)		; probe N

	; access check passed
	; this is the point of no return
	; The only possible mm errors now are TNV, if we encounter these
	; we reload the TB with the no longer valid pte (if it was level 3)
	; and continue. Else MCHK.
  

	sget_addr r0, <pal$queue_fault2-pal$start>, r31; get address
	 mt	r0, pt3			; set recovery address

	; do the queue instruction assuming it is aligned
	debug_mp_queue			; if mp queue debug, zap dtb's
	stq	r13, (r17)		; (E)   <- N
	 stq	r14, 8(r17)		; (E+8) <- H
	stq	r17, 8(r13)		; (N+8) <- E
	 stq	r17, (r14)		; (H)   <- E

	cmpeq	r13, r14, r0		; queue empty if N = H

	 mt	r12, exc_addr
	mf	r12, pt12
	 mf	r13, pt13
	mf	r14, pt14
 	 hw_rei

	END_PAL_ROUTINE	 INSQUEQD
 

.sbttl	REMQUEL	- PALcode for REMQUEL instruction

;+
; REMQUEL
;
; Entry:
;	Vectored into via hardware PALcode instruction dispatch
;	PALcode enviornment set up.
;	R16	= addr of queue entry
;
;
; Function:
;	1 All addresses are probed.
;	2 Entry is removed from queue.
;	3 Status is returned.
;
;	If a memory management error occurs prior to step 2, a trap
;	is generated useing the PC of the queue instruction.
;
;	If a memory managment error occurs during step 2, it is checked
;	to make sure it is the a TNV on the level 3 pte. If it is the
;	invalid pte is used and the queue instruction is continued.
;	Otherwise a machine check is generated.
;
; Returns:
;	R0 =
;		-1	if queue was empty
;		 0	if queue is now empty
;		 1	if queue still not empty
;
;	R1 =	addr of entry removed
;-

	START_PAL_ROUTINE	REMQUEL, longflow=1
	mt	r12, pt12		; get working regs
	 mf	r12, exc_addr		; get address of PAL call
	mt	r13, pt13
	 sget_addr r0, <<pal$queue_fault_setup2nl-pal$start>!1>, r31; get address
	mt	r14, pt14

	 mt	r0, pt3			; set recovery address


	ldl	r13, (r16)		; N
	 ldl	r14, 4(r16)		; P


	ldl/w   r0, 4(r13)		; probe first part of N
	 ldl/w   r1,  (r14)		; probe first part of P
	ldl/w   r0, 7(r13)		; probe second part of N
	 ldl/w   r1, 3(r14)		; probe second part of P
	or  r16, r31, r1		; return addr of entry
   
	; access check passed
	; this is the point of no return
	; The only possible mm errors now are TNV, if we encounter these
	; we reload the TB with the no longer valid pte (if it was level 3)
	; and continue. Else MCHK.
 
	 sget_addr r0, <<pal$queue_fault2-pal$start>!1>, r31 ; get address
	mt	r0, pt3			; set recovery address
  
	; do the queue instruction assuming it is aligned
	.iif ne enable_debug_mp, CONT_PAL_ROUTINE	REMQUEL
	debug_mp_queue			; if mp queue debug, zap dtb's
	 CONT_PAL_ROUTINE	REMQUEL, DOUBLE=1
	stl	r13, (r14)		; (P) <- N
	 or	r31, #1, r0		; assume queue not yet empty	
	stl	r14, 4(r13)		; (N+4) <- P
	 cmpeq	r13, r14, r14		; 1 queue is now empty, 0 if not
	mt	r12, exc_addr
	 cmpeq	r13, r1, r13		; 1 if N = E queue WAS empty
	mf	r12, pt12		; restore workings regs
	 subq	r0, r14, r0		; sub by 1 if now empty
	mf	r14, pt14
	 subq	r0, r13, r0		; sub by 1 if was empty
	mf	r13, pt13
	 hw_rei
	END_PAL_ROUTINE		REMQUEL



.sbttl	REMQUELD - PALcode for REMQUELD instruction

;+
; REMQUELD
;
; Entry:
;	Vectored into via hardware PALcode instruction dispatch
;	PALcode enviornment set up.
;	R16	= addr of queue entry
;
;
; Function:
;	1 All addresses are probed.
;	2 Entry is removed from queue.
;	3 Status is returned.
;
;	If a memory management error occurs prior to step 2, a trap
;	is generated useing the PC of the queue instruction.
;
;	If a memory managment error occurs during step 2, it is checked
;	to make sure it is the a TNV on the level 3 pte. If it is the
;	invalid pte is used and the queue instruction is continued.
;	Otherwise a machine check is generated.
;
; Returns:
;	R0 =
;		-1	if queue was empty
;		 0	if queue is now empty
;		 1	if queue still not empty
;
;	R1 =	addr of entry removed
;-

	START_PAL_ROUTINE	REMQUELD, longflow=1
	mt	r12, pt12		; get working regs
	 mf	r12, exc_addr		; get address of PAL call
	mt	r13, pt13
	 sget_addr r0, <<pal$queue_fault_setup2nl-pal$start>!1>, r31 ; get address
	mt	r14, pt14

	 mt	r0, pt3			; set recovery address

	ldl	r13, (r16)		; get queue entry addr
					; note, una rtn, won't do r0, use r13
	 or	r13, r31, r1		; return addr of entry

	ldl	r13, (r1)		; N
	 ldl/w   r14, 4(r13)		; probe first part of N
	ldl/w   r14, 7(r13)		; probe second part of N

	 ldl	r14, 4(r1)		; P
	ldl/w   r0,  (r14)		; probe first part of P
	 ldl/w   r0, 3(r14)		; probe second part of P

   
	; access check passed
	; this is the point of no return
	; The only possible mm errors now are TNV, if we encounter these
	; we reload the TB with the no longer valid pte (if it was level 3)
	; and continue. Else MCHK.
 
	sget_addr r0, <<pal$queue_fault2-pal$start>!1>, r31 ; get address
	 CONT_PAL_ROUTINE	REMQUELD, DOUBLE=1
	mt	r0, pt3			; set recovery address
	 stall	1, mxpr=0
  
	; do the queue instruction assuming it is aligned
	stl	r13, (r14)		; (P) <- N
	 or	r31, #1, r0		; assume queue not yet empty	
	stl	r14, 4(r13)		; (N+4) <- P
	 cmpeq	r13, r14, r14		; 1 queue is now empty, 0 if not
	mt	r12, exc_addr
	 cmpeq	r13, r1, r13		; 1 if N = E queue WAS empty
	mf	r12, pt12		; restore workings regs
	 subq	r0, r14, r0		; sub by 1 if now empty
	mf	r14, pt14
	 subq	r0, r13, r0		; sub by 1 if was empty
	mf	r13, pt13
	 hw_rei

	END_PAL_ROUTINE		REMQUELD


.sbttl	REMQUEQ	- PALcode for REMQUEQ instruction

;+
; REMQUEQ
;
; Entry:
;	Vectored into via hardware PALcode instruction dispatch
;	PALcode enviornment set up.
;	R16	= addr of queue entry
;
;
; Function:
;	1 All addresses are probed.
;	2 Entry is removed from queue.
;	3 Status is returned.
;
;	If a memory management error occurs prior to step 2, a trap
;	is generated useing the PC of the queue instruction.
;
;	If a memory managment error occurs during step 2, it is checked
;	to make sure it is the a TNV on the level 3 pte. If it is the
;	invalid pte is used and the queue instruction is continued.
;	Otherwise a machine check is generated.
;
; Returns:
;	R0 =
;		-1	if queue was empty
;		 0	if queue is now empty
;		 1	if queue still not empty
;
;	R1 =	addr of entry removed
;-

	START_PAL_ROUTINE	REMQUEQ, longflow=1
	mt	r12, pt12		; get working regs
	 mf	r12, exc_addr		; get address of PAL call
	mt	r13, pt13
	 sget_addr r0, <pal$queue_fault_setup2nl-pal$start>, r31; get address
	mt	r14, pt14

	 mt	r0, pt3			; set recovery address

	or  r16, r31, r1		; return addr of entry

	 ldq	r13, (r1)		; N
	ldq	r14, 8(r1)		; P

	 or	r13, r14, r0		; merge N & P for align check
	or	r0, r1, r0		; merge in E
	 and	r0, #^xf, r0		; do align check on N/P/E
	bne	r0, queue_addr_error2	; br if bad align on N/P/E

	 ldq/w   r0, (r13)		; probe N
	ldq/w   r0, (r14)		; probe P
   
	; access check passed
	; this is the point of no return
	; The only possible mm errors now are TNV, if we encounter these
	; we reload the TB with the no longer valid pte (if it was level 3)
	; and continue. Else MCHK.
 
	 CONT_PAL_ROUTINE	REMQUEQ, DOUBLE=1
	sget_addr r0, <pal$queue_fault2-pal$start>, r31; get address
	 mt	r0, pt3		; set recovery address
  
	; do the queue instr
	debug_mp_queue			; if mp queue debug, zap dtb's
	stq	r13, (r14)		; (P)   <- N
	 or	r31, #1, r0		; assume queue not yet empty	
	stq	r14, 8(r13)		; (N+4) <- P
	 cmpeq	r13, r14, r14		; 1 queue is now empty, 0 if not
	mt	r12, exc_addr
	 cmpeq	r13, r1, r13		; 1 if N = E queue WAS empty
	mf	r12, pt12		; restore workings regs
	 subq	r0, r14, r0		; sub by 1 if now empty
	mf	r14, pt14
	 subq	r0, r13, r0		; sub by 1 if was empty
	mf	r13, pt13
	 hw_rei
	END_PAL_ROUTINE		REMQUEQ



.sbttl	REMQUEQD - PALcode for REMQUEQD instruction

;+
; REMQUEQD
;
; Entry:
;	Vectored into via hardware PALcode instruction dispatch
;	PALcode enviornment set up.
;	R16	= addr of queue entry
;
;
; Function:
;	1 All addresses are probed.
;	2 Entry is removed from queue.
;	3 Status is returned.
;
;	If a memory management error occurs prior to step 2, a trap
;	is generated useing the PC of the queue instruction.
;
;	If a memory managment error occurs during step 2, it is checked
;	to make sure it is the a TNV on the level 3 pte. If it is the
;	invalid pte is used and the queue instruction is continued.
;	Otherwise a machine check is generated.
;
; Returns:
;	R0 =
;		-1	if queue was empty
;		 0	if queue is now empty
;		 1	if queue still not empty
;
;	R1 =	addr of entry removed
;-

	START_PAL_ROUTINE	REMQUEQD, longflow=1
	mt	r12, pt12		; get working regs
	 mf	r12, exc_addr		; get address of PAL call
	mt	r13, pt13
	 sget_addr r0, <pal$queue_fault_setup2nl-pal$start>, r31 ; get address
	mt	r14, pt14

	 mt	r0, pt3			; set recovery address

	ldq	r1, (r16)		; E

	 ldq	r13, (r1)		; N
	ldq	r14, 8(r1)		; P

	 or	r13, r14, r0		; merge N & E for align check
	or	r0, r16, r0		; merge in H
	 or	r0, r1, r0		; merge in E
	and	r0, #^xf, r0		; do align check on H/E/N/P
	 bne	r0, queue_addr_error2	; br if alignment errors

	ldq/w   r0, (r13)		; probe N
	 CONT_PAL_ROUTINE	REMQUEQD, DOUBLE=1
	ldq/w   r0, (r14)		; probe P

   
	; access check passed
	; this is the point of no return
	; The only possible mm errors now are TNV, if we encounter these
	; we reload the TB with the no longer valid pte (if it was level 3)
	; and continue. Else MCHK.
 
	 sget_addr r0, <pal$queue_fault2-pal$start>, r31; get address
	mt	r0, pt3			; set recovery address
	 stall	1, mxpr=0
  
	; do the queue instr
	debug_mp_queue			; if mp queue debug, zap dtb's
	stq	r13, (r14)		; (P)   <- N
	 or	r31, #1, r0		; assume queue not yet empty	
	stq	r14, 8(r13)		; (N+4) <- P
	 cmpeq	r13, r14, r14		; 1 queue is now empty, 0 if not
	mt	r12, exc_addr
	 cmpeq	r13, r1, r13		; 1 if N = E queue WAS empty
	mf	r12, pt12		; restore workings regs
	 subq	r0, r14, r0		; sub by 1 if now empty
	mf	r14, pt14
	 subq	r0, r13, r0		; sub by 1 if was empty
	mf	r13, pt13
	 hw_rei

	END_PAL_ROUTINE		REMQUEQD


.sbttl INSQHILR - Palcode for INSQHILR instruction
;+
;
; INSQHILR
;
; Entry:
;	Vectored into via hardware PALcode instruction dispatch
;	PALcode environment set up.
;	r16	= addr of queue header
;	r17	= addr of new entry
;
; Function:
;	1 Hardware interlock is taken on queue header
;	2 Secondary interlock is taken on queue header
;	3 Entry is inserted into queue.
;	4 Status is returned.
;
; If any memory management errors occur along the way, we generate
; an INVALID OPERAND trap using the PC of the queue instruction.  The
; state of the queue is unpredictable if we take any kind of exception and
; therefore we don't need to worry about unlocking the queue header if
; an exception occurs.
;
; Returns:
;	R0 =
;		-1 if secondary interlock was set
;		 0 if queue was not empty
;		 1 if queue was empty
;
; Uses:
;	r12
;	r13	
;-

	START_PAL_ROUTINE	INSQHILR, longflow=1
	mt	r12, pt12		; get some scratch registers
	 mf	r12, exc_addr		; save address of call pal
	mt	r13, pt13
	 sget_addr	r13,<pal$queue_fault_resident2-pal$start>, r31	; get address
	mt	r14, pt14


	 lda	r14, ldxl_stxc_retry_count(r31) ; set retry count
	mt	r13, pt3			; save away error recovery address

lock_insqhilr:
	 ldl_l	r0, (r16)		; try to get H, interlocked
	blbs	r0, queue_busy2		; entry already locked => return -1
	 or	r0, #1, r13		; attempt to set lock flag
	stl_c	r13, (r16)		; try to set secondary lock in H
	 blbc	r13, retry_lock_insqhilr	; abort if stx/c failed

	subl	r16, r17, r13		; H-E
	 stl	r13, 4(r17)		; (E+4) <- H-E
	addl	r13, r0, r13		; N-E
	 CONT_PAL_ROUTINE	INSQHILR, DOUBLE=1
	addq	r16, r0, r14		; get N
	 stl	r13, (r17)		; (E)   <- N-E
	subl	r31, r13, r13		; E-N
	 stl	r13, 4(r14)		; (N+4) <- E-N
	mb
	 subl	r17, r16, r13		; E-H
	stl	r13, (r16)		; (H) <- E-H

	 mt	r12, exc_addr		; set the rei address

	cmpeq	r0, r31, r0		; queue was empty if N-H == 0

	 mf	r12, pt12
	mf	r13, pt13
	 mf	r14, pt14
	hw_rei

	END_PAL_ROUTINE		INSQHILR


.sbttl INSQHIQR - Palcode for INSQHIQR instruction
;+
;
; INSQHIQR
;
; Entry:
;	Vectored into via hardware PALcode instruction dispatch
;	PALcode environment set up.
;	r16	= addr of queue header
;	r17	= addr of new entry
;
; Function:
;	1 Hardware interlock is taken on queue header
;	2 Secondary interlock is taken on queue header
;	3 Entry is inserted into queue.
;	4 Status is returned.
;
; If any memory management errors occur along the way, we generate
; an INVALID OPERAND trap using the PC of the queue instruction.  The
; state of the queue is unpredictable if we take any kind of exception and
; therefore we don't need to worry about unlocking the queue header if
; an exception occurs.
;
; Returns:
;	R0 =
;		-1 if secondary interlock was set
;		 0 if queue was not empty
;		 1 if queue was empty
;
; Uses:
;	r12
;	r13	
;-

	START_PAL_ROUTINE	INSQHIQR, longflow=1
	mt	r12, pt12		; get some scratch registers
	 mf	r12, exc_addr		; save address of call pal
	mt	r13, pt13
	 sget_addr	r13,<pal$queue_fault_resident2-pal$start>, r31	; get address
	mt	r14, pt14

	 lda	r14, ldxl_stxc_retry_count(r31) ; set retry count
	mt	r13, pt3			; save away error recovery address
lock_insqhiqr:
	 ldq_l	r0, (r16)		; try to get H, interlocked
	blbs	r0, queue_busy2		; entry already locked => return -1
	 or	r0, #1, r13		; attempt to set lock flag
	stq_c	r13, (r16)		; try to set secondary lock in H
	 blbc	r13, retry_lock_insqhiqr; abort if stx/c failed

	subq	r16, r17, r13		; H-E
	 stq	r13, 8(r17)		; (E+8) <- H-E
	addq	r13, r0, r13		; N-E
	 CONT_PAL_ROUTINE	INSQHIQR, DOUBLE=1

	addq	r16, r0, r14		; N
	 stq	r13, (r17)		; (E) <- N-E

	subq	r31, r13, r13		; E-N
	 stq	r13, 8(r14)		; (N+8) <- E-N
	mb
	 subq	r17, r16, r13		; E-H
	stq	r13, (r16)		; (H) <- E-H

	 mt	r12, exc_addr		; set the rei address

	cmpeq	r0, #0, r0

	 mf	r12, pt12
	mf	r13, pt13
	 mf	r14, pt14
	hw_rei

	END_PAL_ROUTINE		INSQHIQR


.sbttl INSQTILR - Palcode for INSQTILR instruction
;+
;
; INSQTILR
;
; Entry:
;	Vectored into via hardware PALcode instruction dispatch
;	PALcode environment set up.
;	r16	= addr of queue header
;	r17	= addr of new entry
;
; Function:
;	1 Hardware interlock is taken on queue header
;	2 Secondary interlock is taken on queue header
;	3 Entry is inserted into queue.
;	4 Status is returned.
;
; If any memory management errors occur along the way, we generate
; an INVALID OPERAND trap using the PC of the queue instruction.  The
; state of the queue is unpredictable if we take any kind of exception and
; therefore we don't need to worry about unlocking the queue header if
; an exception occurs.
;
; Returns:
;	R0 =
;		-1 if secondary interlock was set
;		 0 if queue was not empty
;		 1 if queue was empty
;
; Uses:
;	r12
;	r13	
;-

	START_PAL_ROUTINE	INSQTILR, longflow=1
	mt	r12, pt12		; get some scratch registers
	 mf	r12, exc_addr		; save address of call pal
	mt	r13, pt13
	 sget_addr	r13,<pal$queue_fault_resident2-pal$start>, r31	; get address
	mt	r14, pt14

	 lda	r14, ldxl_stxc_retry_count(r31)
	mt	r13, pt3			; save away error recovery address
lock_insqtilr:
	 ldq_l	r0, (r16)		; try to get H, interlocked
	blbs	r0, queue_busy2		; entry already locked => return -1
	 or	r0, #1, r13		; attempt to set lock flag
	stl_c	r13, (r16)		; try to set secondary lock in header
	 blbc	r13, retry_lock_insqtilr; abort if stx/c failed

	sra	r0, #32, r14		; P-H
	 beq	r0, insqtilr_empty	; br if queue empty
	subl	r16, r17, r13		; H-E
	 CONT_PAL_ROUTINE	INSQTILR, DOUBLE=1
	stl	r13, (r17)		; (E)  <- H-E
	 addl	r14, r13, r13		; P-E
	stl	r13, 4(r17)		; (E+4) <- P-E
	 addl	r16, r14, r14		; P
	subl	r31, r13, r13		; E-P
	 stl	r13, (r14)		; (P) <- E-P
	subl	r17, r16, r13		; E-H
	 stl	r13, 4(r16)		; (H+4) <- E-H
	mb
	 stl	r0, (r16)		; (H)   <- H
	mt	r12, exc_addr		; set the rei address

	 or	r31, #0, r0		; R0 = 0, queue was not empty

	mf	r12, pt12
	 mf	r13, pt13
	mf	r14, pt14
	 hw_rei

	END_PAL_ROUTINE		INSQTILR


.sbttl INSQTIQR - Palcode for INSQTIQR instruction
;+
;
; INSQTIQR
;
; Entry:
;	Vectored into via hardware PALcode instruction dispatch
;	PALcode environment set up.
;	r16	= addr of queue header
;	r17	= addr of new entry
;
; Function:
;	1 Hardware interlock is taken on queue header
;	2 Secondary interlock is taken on queue header
;	3 Entry is inserted into queue.
;	4 Status is returned.
;
; If any memory management errors occur along the way, we generate
; an INVALID OPERAND trap using the PC of the queue instruction.  The
; state of the queue is unpredictable if we take any kind of exception and
; therefore we don't need to worry about unlocking the queue header if
; an exception occurs.
;
; Returns:
;	R0 =
;		-1 if secondary interlock was set
;		 0 if queue was not empty
;		 1 if queue was empty
;
; Uses:
;	r12
;	r13	
;-

	START_PAL_ROUTINE	INSQTIQR, longflow=1
	mt	r12, pt12		; get some scratch registers
	 mf	r12, exc_addr		; save address of call pal
	mt	r13, pt13
	 sget_addr	r13,<pal$queue_fault_resident2-pal$start>, r31	; get address
	mt	r14, pt14

	 lda	r14, ldxl_stxc_retry_count(r31) ; set retry count
	mt	r13, pt3		; save away error recovery address
lock_insqtiqr:
	 ldq_l	r0, (r16)		; try to get queue header, interlocked
	blbs	r0, queue_busy2		; entry already locked => return -1
	 or	r0, #1, r13		; attempt to set lock flag
	stq_c	r13, (r16)		; try to set secondary lock in header
	 blbc	r13, retry_lock_insqtiqr; abort if stx/c failed

	beq	r0, insqtiqr_empty	; br if queue empty
	 ldq	r14, 8(r16)		; P-H
	subq	r16, r17, r13		; H-E
	 CONT_PAL_ROUTINE	INSQTIQR, DOUBLE=1
	stq	r13, (r17)		; (E)  <- H-E
	 addq	r14, r13, r13		; P-E
	stq	r13, 8(r17)		; (E+8) -> P-E
	 subq	r31, r13, r13		; E-P
	addl	r16, r14, r14		; P
	 stq	r13, (r14)		; (P) <- E-P

	subq	r17, r16, r13		; E-H
	 stq	r13, 8(r16)		; (H+8) <- E-H
	mb
	 stq	r0, (r16)		; (r16) <- H
	mt	r12, exc_addr		; set the rei address

	 or	r31, #0, r0		; r0 = 0, queue was not empty
		
	mf	r12, pt12
	 mf	r13, pt13
	mf	r14, pt14
	 hw_rei

	END_PAL_ROUTINE		INSQTIQR


.sbttl REMQHILR - Palcode for REMQHILR instruction
;+
;
; REMQHILR
;
; Entry:
;	Vectored into via hardware PALcode instruction dispatch
;	PALcode environment set up.
;	r16	= addr of queue header
;	r17	= addr of new entry
;
; Function:
;	1 Hardware interlock is taken on queue header
;	2 Secondary interlock is taken on queue header
;	3 Entry is inserted into queue.
;	4 Status is returned.
;
; If any memory management errors occur along the way, we generate
; an INVALID OPERAND trap using the PC of the queue instruction.  The
; state of the queue is unpredictable if we take any kind of exception and
; therefore we don't need to worry about unlocking the queue header if
; an exception occurs.
;
; Returns:
;	R0 =
;		-1 if secondary interlock was set
;		0  if queue was empty
;		1  if queue was queue still not empty
;		2 if entry removed and queue empty
;	R1 = 
;		Address of the removed entry
; Uses:
;	r12
;	r13	
;-

	START_PAL_ROUTINE	REMQHILR, longflow=1
	mt	r12, pt12		; get some scratch registers
	 mf	r12, exc_addr		; save address of call pal
	mt	r13, pt13

	 sget_addr	r13,<pal$queue_fault_resident1-pal$start>, r31	; get address
	mt	r13, pt3			; save away error recovery address

	lda	r1, ldxl_stxc_retry_count(r31) ; set retry count
lock_remqhilr:
	ldl_l	r0, (r16)		; try to get H, interlocked
	 beq	r0, queue_empty1	; all done, if queue is already empty
	blbs	r0, queue_busy1		; entry already locked => return -1
	 or	r0, #1, r13		; attempt to set lock flag
	stl_c	r13, (r16)		; try to set secondary lock in H
	 blbc	r13, retry_lock_remqhilr; abort if stx/c failed

	addl	r16, r0, r1		; N
	 ldl	r13, (r1)		; NN-N
	addl	r13, r1, r13		; NN
	 CONT_PAL_ROUTINE	REMQHILR, DOUBLE=1

	subl	r16, r13, r1		; H-NN
	 stl	r1, 4(r13)		; (NN+4) <- H-NN
	mb
	 subl	r13, r16, r13		; NN-H
	stl	r13, (r16)		; (H) <- NN-H
	 addl	r16, r0, r1		; r1 <- N
	mt	r12, exc_addr		; set the rei address

	 cmpeq	r13, r31, r0		; r0 = 1 if now empty, 0 if not yet empty
	mf	r12, pt12
	 mf	r13, pt13
	addq	r0, #1, r0		; r0 = 2 if now empty, 1 if not yet empty
	 hw_rei


	END_PAL_ROUTINE		REMQHILR



.sbttl REMQHIQR - Palcode for REMQHIQR instruction
;+
;
; REMQHIQR
;
; Entry:
;	Vectored into via hardware PALcode instruction dispatch
;	PALcode environment set up.
;	r16	= addr of queue header
;	r17	= addr of new entry
;
; Function:
;	1 Hardware interlock is taken on queue header
;	2 Secondary interlock is taken on queue header
;	3 Entry is inserted into queue.
;	4 Status is returned.
;
; If any memory management errors occur along the way, we generate
; an INVALID OPERAND trap using the PC of the queue instruction.  The
; state of the queue is unpredictable if we take any kind of exception and
; therefore we don't need to worry about unlocking the queue header if
; an exception occurs.
;
; Returns:
;	R0 =
;		-1 if secondary interlock was set
;		 0 if queue was empty
;		 1 if queue was queue still not empty
;		 2 if entry removed and queue empty
;	R1 = 
;		Address of the removed entry
; Uses:
;	r12
;	r13	
;-

	START_PAL_ROUTINE	REMQHIQR, longflow=1
	mt	r12, pt12		; get some scratch registers
	 mf	r12, exc_addr		; save address of call pal
	mt	r13, pt13

	 sget_addr	r13,<pal$queue_fault_resident1-pal$start>, r31	; get address
	mt	r13, pt3			; save away error recovery address

	 lda	r1, ldxl_stxc_retry_count(r31) ; set retry count
lock_remqhiqr:
	ldq_l	r0, (r16)		; try to get H, interlocked
	 beq	r0, queue_empty1	; all done, if queue is already empty
	blbs	r0, queue_busy1		; entry already locked => return -1
	 or	r0, #1, r13		; attempt to set lock flag
	stq_c	r13, (r16)		; try to set secondary lock in H
	 blbc	r13, retry_lock_remqhiqr; abort if stx/c failed

	addq	r16, r0, r1		; N
	 ldq	r13, (r1)		; NN-N
	addq	r13, r1, r13		; NN
	 CONT_PAL_ROUTINE	REMQHIQR, DOUBLE=1

	subq	r16, r13, r1		; H-NN
	 stq	r1, 8(r13)		; (NN+4) <- H-NN
	mb
	 subq	r13, r16, r13		; NN-H
	stq	r13, (r16)		; (H) <- NN-H

	 addq	r16, r0, r1		; r1 <- N
	mt	r12, exc_addr		; set the rei address

	 cmpeq	r13, r31, r0		; r0 = 1 if now empty, 0 if not yet empty
	mf	r12, pt12
	 mf	r13, pt13
	addq	r0, #1, r0		; r0 = 2 if now empty, 1 if not yet empty
	 hw_rei

	END_PAL_ROUTINE		REMQHIQR



.sbttl REMQTILR - Palcode for REMQTILR instruction
;+
;
; REMQTILR
;
; Entry:
;	Vectored into via hardware PALcode instruction dispatch
;	PALcode environment set up.
;	r16	= addr of queue header
;	r17	= addr of new entry
;
; Function:
;	1 Hardware interlock is taken on queue header
;	2 Secondary interlock is taken on queue header
;	3 Entry is inserted into queue.
;	4 Status is returned.
;
; If any memory management errors occur along the way, we generate
; an INVALID OPERAND trap using the PC of the queue instruction.  The
; state of the queue is unpredictable if we take any kind of exception and
; therefore we don't need to worry about unlocking the queue header if
; an exception occurs.
;
; Returns:
;	R0 =
;		-1 if secondary interlock was set
;		0  if queue was empty
;		1  if queue was queue still not empty
;		2 if entry removed and queue empty
;	R1 = 
;		Address of the removed entry
; Uses:
;	r12
;	r13	
;-

	START_PAL_ROUTINE	REMQTILR, longflow=1
	mt	r12, pt12		; get some scratch registers
	 mf	r12, exc_addr		; save address of call pal
	mt	r13, pt13
	 sget_addr	r13,<pal$queue_fault_resident2-pal$start>, r31	; get address
	mt	r14, pt14

	 lda	r14, ldxl_stxc_retry_count(r31) ; set retry count
	mt	r13, pt3		; set recovery address

lock_remqtilr:
	 ldl_l	r0, (r16)		; try to get H, interlocked
	beq	r0, queue_empty2	; all done, if queue is already empty
	 or	r0, #1, r13		; attempt to set lock flag
	blbs	r0, queue_busy2		; entry already locked => return -1
	 stl_c	r13, (r16)		; try to set secondary lock in H
	blbc	r13, retry_lock_remqtilr; abort if stx/c failed

	 ldl	r13, 4(r16)		; P-H
	addl	r16, r13, r1		; P
	 CONT_PAL_ROUTINE	REMQTILR, DOUBLE=1

	ldl	r13, 4(r1)		; PP-P
	 addl	r13, r1, r13		; PP
	subl	r13, r16, r14		; PP-H
	 stl	r14, 4(r16)		; (H+4) <- PP-H

	
	subl	r16, r13, r14		; H-PP
	 stl	r14, (r13)		; (PP) <- H-PP
	beq	r14, 10$		; br if queue empty H-PP = 0
	 mb				;
	stl	r0, (r16)		; (H) <- N-H
10$:	 mt	r12, exc_addr		; set the rei address

	cmpeq	r14, r31, r0		; r0 = 1 if empty, 0 if not yet empty
	 mf	r12, pt12
	mf	r13, pt13
	 mf	r14, pt14
	addq	r0, #1, r0		; r0 = 2 if empty, 1 if not yet empty
	 hw_rei

	END_PAL_ROUTINE		REMQTILR


.sbttl REMQTIQR - Palcode for REMQTIQR instruction
;+
;
; REMQTIQR
;
; Entry:
;	Vectored into via hardware PALcode instruction dispatch
;	PALcode environment set up.
;	r16	= addr of queue header
;	r17	= addr of new entry
;
; Function:
;	1 Hardware interlock is taken on queue header
;	2 Secondary interlock is taken on queue header
;	3 Entry is inserted into queue.
;	4 Status is returned.
;
; If any memory management errors occur along the way, we generate
; an INVALID OPERAND trap using the PC of the queue instruction.  The
; state of the queue is unpredictable if we take any kind of exception and
; therefore we don't need to worry about unlocking the queue header if
; an exception occurs.
;
; Returns:
;	R0 =
;		-1 if secondary interlock was set
;		 0 if queue was empty
;		 1 if queue was queue still not empty
;		 2 if entry removed and queue empty
;	R1 = 
;		Address of the removed entry
; Uses:
;	r12
;	r13	
;-

	START_PAL_ROUTINE	REMQTIQR, longflow=1
	mt	r12, pt12		; get some scratch registers
	 mf	r12, exc_addr		; save address of call pal
	mt	r13, pt13
	 sget_addr	r13,<pal$queue_fault_resident2-pal$start>, r31	; get address
	mt	r14, pt14

	 lda	r14, ldxl_stxc_retry_count(r31) ; set retry count
	mt	r13, pt3		; set recovery address

lock_remqtiqr:
	 ldq_l	r0, (r16)		; try to get H, interlocked
	beq	r0, queue_empty2	; all done, if queue is already empty
	 or	r0, #1, r13		; attempt to set lock flag
	blbs	r0, queue_busy2		; entry already locked => return -1
	 stq_c	r13, (r16)		; try to set secondary lock in H
	blbc	r13, retry_lock_remqtiqr; abort if stx/c failed

	 ldq	r13, 8(r16)		; P-H
	addq	r16, r13, r1		; P
	 CONT_PAL_ROUTINE	REMQTIQR, DOUBLE=1

	ldq	r13, 8(r1)		; PP-P
	 addq	r13, r1, r13		; PP
	subq	r13, r16, r14		; PP-H
	 stq	r14, 8(r16)		; (H+8) <- PP-H

	subq	r16, r13, r14		; H-PP
	 stq	r14, (r13)		; (PP) H-PP

	beq	r14, 10$		; br if queue empty H-PP = 0
	 mb				;
	stq	r0, (r16)		; (H) <- N-H

10$:	 mt	r12, exc_addr		; set the rei address

	cmpeq	r14, r31, r0		; r0 = 1 if empty, 0 if not yet empty
	 mf	r12, pt12
	mf	r13, pt13
	 mf	r14, pt14
	addq	r0, #1, r0		; r0 = 2 if empty, 1 if not yet empty
	 hw_rei




.sbttl queue error catchers
;+
;  Error handlers for the queue instructions.
;  If we fail to acquire the hardware lock, we vector to an error handler
;  for the appropriate queue instruction, which increments the try count
;  and retries unless the maximum retry count is exceeded, in which case the
;  queue instruction returns a locked status to the user (r0 = -1).
;-

    .macro	retry_lock inst, rn, n
      retry_lock_'inst':
      subq	'rn', #1, 'rn'
      bne	'rn', lock_'inst'
      br	r31, queue_busy'n'	; too many retries => return -1
      .long	0
    .endm

    align_to_cache_block
    retry_lock insqhil,  r14, 2
    retry_lock insqhiq,  r14, 2
    retry_lock insqtil,  r14, 2
    retry_lock insqtiq,  r14, 2
    
    retry_lock remqhil,  r1,  1
    retry_lock remqhiq,  r1,  1
    retry_lock remqtil,  r14, 2
    retry_lock remqtiq,  r14, 2

    retry_lock insqhilr, r14, 2
    retry_lock insqhiqr, r14, 2
    retry_lock insqtilr, r14, 2
    retry_lock insqtiqr, r14, 2
    
    retry_lock remqhilr, r1,  1
    retry_lock remqhiqr, r1,  1
    retry_lock remqtilr, r14, 2
    retry_lock remqtiqr, r14, 2



;+
; Return to the user with a status code of -1 (secondary interlock locked)
;-
	align_to_cache_block
queue_busy2:
	mf	r14, pt14
queue_busy1:
	 stl_c	r0, (r16)		; release primary interlock
	mt	r12, exc_addr		; set the rei address
	 subq	r31, #1, r0		; set failed to get lock code
	mf	r12, pt12
	 mf	r13, pt13
	hw_rei


;+
; Return to the user with a status code of 0 (queue already empty)
;-
	align_to_cache_block
queue_empty2:
	mf	r14, pt14
queue_empty1:
;;;	stl_c	r0, (r16)	; release primary interlock (no required)
	mt	r12, exc_addr	; set the rei address
;;;	or	r31, r31, r0	; R0, already is ZERO
	mf	r12, pt12
	or	r16, r31, r1	; set addr of rem'd entry
	mf	r13, pt13
	hw_rei


;+
; Alignment is bogus, go post a invalid operand trap.  If this happened
; on the initial check we don't have to release the secondary lock, otherwise
; we do.
;-
	.align	quad
queue_addr_error2l:			; case where pt14 is used
	stl	r0, (r16)		; release secondary lock
queue_addr_error2:
	lda	r13, scb$v_illpal(r31)	; scb vector
	mf	r14, pt14		; restore r14
	br	r31, pal$post_km_trap_nr45

	.align	quad
queue_addr_error1l:			; case where pt14 is not used
	stl	r0, (r16)		; release secondary lock
queue_addr_error1:
	lda	r13, scb$v_illpal(r31)	; scb vector
	br	r31, pal$post_km_trap_nr45

	.align	quad
queue_addr_error3:
	lda	r13, scb$v_illpal(r31)	; scb vector
	mf	r14, pt14		; restore r14
	mf	r15, pt15		; restore r14
	mf	r18, pt18		; restore r14
	br	r31, pal$post_km_trap_nr45


	END_PAL_ROUTINE		REMQTIQR

.endc


.if eq	disable_probe
.sbttl PROBER	- PALcode for PROBER instruction

;+
; PROBE
;
; Entry:
;	Vectored into via hardware PALcode instruction dispatch
;	PALcode enviornment set up.
;
;	r16 -> base address
;	r17 -> offset
;	r18 -> mode
;
; Function:
;	Probe the base address and the base address + offset
;	
; Returns:	
;-


	START_PAL_ROUTINE	PROBER,longflow=1;
	mf	r0, pt9			; get ps 
	 mt	r12, pt12
	sll	r18, #ps$v_cm, r12	; shift requested mode to ps<cm>
	 mt	r13, pt13
	and	r0, #ps$m_cm, r0	; clean ps to current mode
	 and	r12, #ps$m_cm, r13	; clean req ps to current mode
	subq 	r0, r13, r12		; do max of modes
	 cmovgt	r12, r0, r13		; cm gt req mode so use cm
	mt	r13, pt15_alt_mode	; set mode for access
	 addq	r16, r17, r0		; set up other address
	mf	r12, exc_addr		; get address of PAL call
	 stall	1

pal$prober_ldl1::
	ldl/a	r13, (r16)		; try and read (r16)
	pvc$jsr	prbokr, dest=1
pal$prober_ldl2::
	 ldl/a	r0, (r0)		; try and read (r16+r17)
	 pvc$jsr prbokr, dest=1
	mt	r12, exc_addr		; set return address
	 CONT_PAL_ROUTINE	PROBER
	mf	r12, pt12		; restore r12
	 mt	r31, alt_mode		; clear alt_mode hw
	or	r31, #1, r0		; return success
	 mf	r13, pt13		; restore r13
	hw_rei				; back to user
	END_PAL_ROUTINE		PROBER




.sbttl PROBEW	- PALcode for PROBEW instruction


	START_PAL_ROUTINE	PROBEW,longflow=1;
	mf	r0, pt9			; get ps 
	 mt	r12, pt12
	sll	r18, #ps$v_cm, r12	; shift requested mode to ps<cm>
	 mt	r13, pt13
	and	r0, #ps$m_cm, r0	; clean ps to current mode
	 and	r12, #ps$m_cm, r13	; clean req ps to current mode
	subq 	r0, r13, r12		; do max of modes
	 cmovgt	r12, r0, r13		; cm gt req mode so use cm
	mt	r13, pt15_alt_mode	; set mode for access
	 addq	r16, r17, r0		; set up other address
	mf	r12, exc_addr		; get address of PAL call
	 stall	1

pal$probew_ldl1::
	ldl/aw	r13, (r16)		; try and read (r16)
	pvc$jsr	prbokr, dest=1
pal$probew_ldl2::
	 ldl/aw	r0, (r0)		; try and read (r16+r17)
	 pvc$jsr prbokr, dest=1
	mt	r12, exc_addr		; set return address
	 CONT_PAL_ROUTINE	PROBEW
	mf	r12, pt12		; restore r12
	 mt	r31, alt_mode		; clear alt_mode hw
	or	r31, #1, r0		; return success
	 mf	r13, pt13		; restore r13
	hw_rei				; back to user
	END_PAL_ROUTINE		PROBEW

.endc

.sbttl RD_PS	- PALcode for RD_PS instruction

;+
; RD_PS
;
; Entry:
;	Vectored into via hardware PALcode instruction dispatch
;	PALcode enviornment set up.
;
; Function:
;	
; Returns:	
;-

	START_PAL_ROUTINE	RD_PS	; 2 cycles
	mf	r0, pt9			; get PS
	 hw_rei				; back to user
	END_PAL_ROUTINE		RD_PS


.sbttl REI	- PALcode for REI instruction

;+
; REI
;
; Entry:
;	Vectored into via hardware PALcode instruction dispatch routine.
;	PALcode enviornment set up.
;
;	SP-> top of current stack
;
; Function:
;	
; Returns:	
;-



	START_PAL_ROUTINE	REI, longflow=1
pal$rei::
	mf	r3, pt9			; get ps
	 and	sp, #^X3F, r2		; check stack alignment
	mf	r7, exc_addr		; get the address of the REI
	 bne	r2, 100$		; error, sp align fault
pal$rei_ldq::
	ldq	r2, 56(sp)		; get new ps
	 and	r3, ps$m_cm, r4		; get ps<mode>
	ldq	r6, (sp)		; start the fetch of the rst of frame
	 addq	r3, #1, r5		; get ps+1 to save for halt/pasive release flow
	mt	r5, pt3			; set indicator for halt flow
	 rc	r31			; clear intr_flag

	.if ne	low_core_ipl
	 stq/pc	r5, Pal$BitBucket(r31)	; clear Lock flag
	.iff
	 mf	r5, pal_base
	 sget_addr r5, <Pal$BitBucketHi-pal$start>,r5; get addr of bit bucket
	 stq/pc	r5, (r5)		; clear lock flag
	.endc


	 bne	r4, pal$reiFromNonKern	; goto from non kern flow
 	mt	r7, exc_addr		; put exc_addr back in case we dtb missed
;	 .br	r31, pal$reiFromKern	; stay in line for from Kern flow


;+
; Pal$reiFromKern
;
; entry:
;	r2 = new ps
;	r3 = current ps
;	r7 = pc of rei+4
;	r2, r4..r6 free for use
;-
	CONT_PAL_ROUTINE	REI, DOUBLE=1
pal$reiFromKern:
	 and	r2, #ps$m_cm, r5	; extract new cm
	beq	r5, pal$reiKernToKern 	; staying in kern, go do kern_to_kern
	 stall	1, mxpr=0
;        .br	r31, pal$reiKernToNonKern; not, go do Kern to non-kern flow



;+
; Pal$reiKernToNonKern
;
; entry:
;	r2 = new ps
;	r3 = current ps
;	r5 = new mode * 8
;	r7 = pc of rei+4
;	r4, r6 free for use
;-
Pal$reiKernToNonKern:			; 32 cycles top to bottom
	trace_pc	<rei_kern_to_nonkern>

	mf	r7, pt31		; get the pcbb
	 subq	r31, #1, r4		; get a -1
	mt	r4, sier		; enable ALL software int's

	;;;;; Start of keep together zone.
	;;;;;   Warning, this lable, and the next two lines of code must
	;;;;;   not be seperated. This label is used to patch the data
	;;;;;   portion of the following two instructions.
pal$rei_nhier:				; patch point for perfmon
	.if ne	cfw_system
	mf	r3, pt8			; Get base of IPL table
	ldq/p	r3, (r3)		; Get the HW and SW enable bits
	.iff
	 lda	r3, nhier(r31)		; get ipl=0, hier mask
	ldah	r3, 0(r3)		; handle sign extend on patch above
	.endc
	;;;;;
	;;;;; End of keep together zone.

	 mt	r3, hier		; enable hardware int's
	extbl	r2, #<ps$v_sp/8>, r4	; get ps<sp_align> bits

	.if ne lca4
	get_high_addr r3, mem$csr_base
	stq/p	r31, mem$q_esr(r3)	; ICE = 0 with nhier
	.endc

	 and	r2, <ps$m_cm!ps$m_sw>, r2 ; clean new ps

	lda	r6, 64(sp)		; inc stack pointer
	 or	r4, r6, r6		; and finish the stack pop
	mf	r3, hirr		; get hardware interrupt mask's

	 addq	r7, r5, r4		; point to new sp
	mt	r6, pt26		; save old ksp

	 ldq/p	r5, (r4)		; fetch new sp
	and	r3, #<hirrr$m_hwr!hirrr$m_swr!hirrr$m_atr>, r3; any pending?
	 mt	r2, PT9_PS		; set new ps
	bne	r3, pal$interrupt	; yes go handle, bag the rei

	 mt	r5, pt12		; save off the new sp
	.if ne lca4
	ldq/a	r2, 48(sp)		; get new pc
	 lda	r7, mem$csr_base(r31)	; get_high_addr part 1...
	ldq/a	r3, 16(sp)		; restore r4 without useing LDQ/a r4
	 sll	r7, #28, r7		; ...get_high_addr part 2
	ldq/a	r6, 32(sp)		; restore r6
	 stq/p	r31, mem$q_esr(r7)	; ICE = 0 with nhier
	ldq/a	r7, 40(sp)		; restore r7
	.if ne	medulla_system
	; We mask ints for the new ipl
	mt	r12, pt16			; save, pt12 in use
	mt	r13, pt13			; save
	mt	r14, pt14			; save
	mt	r15, pt15			; save
	stall	3
	mf	r15, pt9			; get new ps
	srl	r15, #ps$v_ipl, r15		; get ipl to bit 0
	and	r15, #<ps$m_ipl@<-ps$v_ipl>>, r15 ; clean to just ipl
	pvc$jsr		medmskint5, bsr=1
	bsr	r13, medu$mask_ints_all		; mask ints at SIO & VIP
	mf	r12, pt16			; restore
	mf	r13, pt13			; restore
	mf	r14, pt14			; restore
	mf	r15, pt15			; restore
	.endc
	.iff
	ldq/a	r2, 48(sp)		; get new pc
	 ldq/a	r3, 16(sp)		; restore r4 without useing LDQ/a r4
	ldq/a	r6, 32(sp)		; restore r6
	 ldq/a	r7, 40(sp)		; restore r7
	.endc
	bic	r2, #3, r2		; clean pc

	 ldq/a	r5, 24(sp)		; restore r5
	or	r3, r31, r4		; complete the restore of r4
	 ldq/a	r3,  8(sp)		; restore r3
	mt	r2, exc_addr		; set the new address
	 ldq/a	r2,   (sp)		; restore r2
.if ne enable_sstep
	mf	sp, pt25		; get the misc bits
	 srl	sp, #pt25$v_ss, sp	; get single step bit
	blbs	sp, 110$		; br if we are single steping
.endc
	mf	sp, pt12		; set the new sp
	 hw_rei				; and back we go

;+
; Pal$reiKernToKern
;
; entry:
;	r2 = new ps
;	r3 = current ps
;	r5 = new mode * 8
;	r7 = pc of rei+4
;	r2, r4, r6 free for use
;-
	align_to_double_cache_block	; align for branch target
pal$reiKernToKern:
	trace_pc	<rei_kern_to_kern>
	extbl	r2, <ps$v_ipl/8>, r5	; get new IPL
	 extbl	r2, #<ps$v_sp/8>, r4	; get ps<sp_align> bits

	.if ne	cfw_system
	mf	r3, pt8			; Get base of IPL table
	s8addq	r5, r3, r5		; Multiply by 8 for quadword index
	ldq/p	r3, (r5)		; Get the HW and SW enable bits
	.iff
	.if ne	low_core_ipl
	s8addq	r5, r31, r5		; * 8
	 ldq/p	r3, Pal$IplTbl(r5)	; get the hw&sw enable bits
	.iff
	mf	r3, pal_base		; get pal base
	 s8addq	r5, r3, r5		; * 8
	sget_addr r5, <pal$IplTblHi-pal$start>,r5; get addr of enable bits
	 ldq/p	r3, (r5)		; get the hw&sw enable bits
	.endc
	.endc

	lda	r6, 64(sp)		; inc stack pointer
	 or	r4, r6, r6		; and finish the stack pop


	mt	r3, hier		; turn on hardware ints
	 zap	r2, ^x80, r2		; clean off SP_ALIGN bits from new ps
	mt	r3, sier		; turn on sw ints

	.if ne lca4
	mf	r4, pt25		; get MCES
	and	r3, hierw$m_cre, r3	; isolate CRE bit
	srl	r4, <pt25$v_dpc - hierw$v_cre>, r4 ; move DPC to hierw<cre> pos
	bic	r3, r4, r3		; hierw<cre> & !mces<dpc>
	get_high_addr r4, mem$csr_base	; 2 instructions
	xor	r3, hierw$m_cre, r3	; toggle it
	sll	r3, <esr$v_ice-hierw$v_cre>, r3  ; move it into position
	stq/p	r3, mem$q_esr(r4)	; write ICE
	.endc

	 mt	r2, PT9			; set new sw ps
	mt	r6, pt12		; save off the new sp

	 mf	r3, hirr		; get hardware interrupt mask's

	ldq	r2, 48(sp)		; get new pc
	 ldq	r4, 16(sp)		; restore r4
	ldq	r5, 24(sp)		; restore r5
	 and	r3, #<hirrr$m_hwr!hirrr$m_swr!hirrr$m_atr>, r3; any pending?
	ldq	r6, 32(sp)		; restore r6
	 bne	r3, pal$interrupt	; yes go handle
	.if ne	<medulla_system & lca4>
	; We mask ints for the new ipl
	mt	r12, pt16			; save, pt12 in use
	mt	r13, pt13			; save
	mt	r14, pt14			; save
	mt	r15, pt15			; save
	stall	3
	mf	r15, pt9			; get new ps
	srl	r15, #ps$v_ipl, r15		; get ipl to bit 0
	and	r15, #<ps$m_ipl@<-ps$v_ipl>>, r15 ; clean to just ipl
	pvc$jsr		medmskint5, bsr=1
	bsr	r13, medu$mask_ints_all		; mask ints at SIO & VIP
	mf	r12, pt16			; restore
	mf	r13, pt13			; restore
	mf	r14, pt14			; restore
	mf	r15, pt15			; restore
	.endc
	ldq	r7, 40(sp)		; restore r7
	 bic	r2, #3, r2		; clean pc
	ldq	r3,  8(sp)		; restore r3
	 mt	r2, exc_addr		; set the new address
	ldq	r2,   (sp)		; restore r2
.if ne enable_sstep
	 mf	sp, pt25		; get the misc bits
	srl	sp, #pt25$v_ss, sp	; get single step bit
	 blbs	sp, 110$		; br if we are single steping
.endc
	 mf	sp, pt12		; set the new sp
	hw_rei				; and back we go

;+
; Pal$reiFromNonKern
;
; entry:
;	r2 = new ps
;	r3 = current ps
;	r4 = current mode
;	r7 = pc of rei+7
;	r2, r4, r6 free for use
;-
	align_to_double_cache_block	; align for branch target
pal$reiFromNonKern:
	trace_pc	<rei_nonkern>
	lda	r6, ^x3f(r31)		; build cleaning mask
	 sll	r6, #ps$v_sp, r6	; shift to correct spot
	lda	r6, <ps$m_cm!ps$m_sw>(r6) ; add the rest of mask
	 bic	r2, r6, r5		; clear out sw,cm,sp fields
	bne	r5, 100$		; rest should be zero - post error
	 and	r2, #ps$m_cm, r5	; extract new mode
	cmplt	r5, r4, r6		; check for mode going "right way"
	 bne	r6, 100$		; wrong way  - post error


	; made it this far all access checks done
	srl	r2, #ps$v_sp, r7	; get ps<sp_align> bits
	 mt	r0, pt0			; get scratch reg
	mf	r0, pt31		; get the pcbb
	 lda	r6, 64(sp)		; inc stack pointer
	zap	r2, ^x80, r2		; clean off SP_ALIGN bits from new ps
	 or	r7, r6, r6		; and finish the stack pop
	mt	r2, pt13		; save off the new ps
	 addq	r0, r4, r3		; point to current sp
	stq/p	r6, (r3)		; save updated old sp
	 addq	r0, r5, r0		; point to new sp
	ldq/p	r0, (r0)		; fetch new sp

	 ldq	r2, 48(sp)		; get new pc
	ldq	r7, 40(sp)		; restore r7
	 ldq	r5, 24(sp)		; restore r5
	mt	r0, pt12		; save off the new sp
	 mf	r0, pt13		; get new ps
	ldq	r4, 16(sp)		; restore r4
	 bic	r2, #3, r2		; clean pc
	ldq	r3,  8(sp)		; restore r3
	 mt	r2, exc_addr		; set the new address
	ldq	r2,   (sp)		; restore r2
	 ldq	r6, 32(sp)		; restore r6
	mt	r0, pt9_PS		; set new ps
	 mf	sp, pt12		; set the new sp
	stall	3
	 mf	r0, pt0

	.if ne	<medulla_system & lca4>
	; We mask ints for the new ipl
	mt	r12, pt16			; save, pt12 in use
	mt	r13, pt13			; save
	mt	r14, pt14			; save
	mt	r15, pt15			; save
	stall	3
	mf	r15, pt9			; get new ps
	srl	r15, #ps$v_ipl, r15		; get ipl to bit 0
	and	r15, #<ps$m_ipl@<-ps$v_ipl>>, r15 ; clean to just ipl
	pvc$jsr		medmskint5, bsr=1
	bsr	r13, medu$mask_ints_all		; mask ints at SIO & VIP
	mf	r12, pt16			; restore
	mf	r13, pt13			; restore
	mf	r14, pt14			; restore
	mf	r15, pt15			; restore
	.endc

.if ne enable_sstep
	mf	sp, pt25		; get the misc bits
	srl	sp, #pt25$v_ss, sp	; get single step bit
	blbs	sp, 110$		; br if we are single steping
	mf	sp, pt12		; set the new sp
.endc
	hw_rei				; and back we go


.if ne enable_sstep
	; single step request
	.align	quad
110$:	mf	sp, exc_addr		; get new pc
	 addq	sp, #4, sp		; make it pc+4 for halt flow
	mt	sp, exc_addr		; put back in chip
	 mf	sp, pt12		; put the sp back
	br	r31, PAL$ENTRY_HALT	; take the halt
.endc


	
; +
;
; stack frame or ps for rei was bad, report a pal reserved operand fault
;
;-
	.align	quad
100$:					; prepare to post the trap
;	trace_pc	<rei_bad_ps_or_sp>
	mt	r12, pt12		; 
	 or	r7,  r31, r12		; move pc to r12
	mt	r13, pt13		; 
	 lda	r13, scb$v_illpal(r31)	; set scb vector to use
	br	r31, pal$post_km_trap_nr45; go build trap


; +
;
; mm error while accessing SP
; we have to clean up from the mm fault, and setup to report the new
; fault on the kernel stack, with the PC of the REI.
;
; We do not check for the case of cm=K, and leave that problem to the stack
; frame builder.
;
; input:
;
; output:
;
;-
	align_to_double_cache_block	; align for branch target
pal$rei_ldq_error::
	mf	r21, pt21
	 or	r23, r31, r1
	mf	r23, pt23
	 mt	r12, pt12
	subq	r7,  #4,  r12		; get errant pc (not +4) to r12
	 mf	r0,  pt0
	mt	r13, pt13
	 or	r1, r31, r13		; scb offset
	mf	r1,  pt1
	 mt	r20, pt16		; va
	mf	r20, pt20
	 mt	r22, pt17		; mmf
	mf	r22, pt22
	 br	r31, pal$post_km_trap	; go build trap
	
	END_PAL_ROUTINE	REI




.sbttl SWASTEN	- PALcode for SWASTEN instruction

;+
; SWASTEN
;
; Entry:
;	Vectored into via hardware PALcode instruction dispatch
;	PALcode enviornment set up.
;
;
; Function:
;	
; Returns:	
;-
	START_PAL_ROUTINE	SWASTEN, longflow=1	; 20 cycles
	mt	r12, pt12
	 mf	r12, pt9		; get PS
	mt	r13, pt13
	 or	r31, #1, r13		; get a one
	mf	r0, aster		; get aster
	 and	r12, #ps$m_cm, r12	; get PS<cm>
	mt	r14, pt14		; save r14
	 srl	r12, #ps$v_cm, r12	; get cm
	addq	r12, #hirrr$v_astrr, r12; shift amount in read format
	 sll	r13, r12, r13		; 1 bit in correct spot (read format)
	bic	r0, r13, r14		; zonk old bit
	 cmovlbc r16, r31, r13		; clear bit if user requested no set
	srl	r0, r12, r0		; get old bit to <0>
	 or	r14, r13, r12		; new aster
	sll	r12, #<hirrw$v_astrr-hirrr$v_astrr>, r12 ; new aster in write pos
	 CONT_PAL_ROUTINE	SWASTEN
	and	r0, #1, r0		; isolate it
	 mt	r12, aster		; write it
	mf	r12, pt12		; restore r12
	 mf	r13, pt13		; restore r13
	mf	r14, pt14		; restore r14
	 hw_rei				; back to user
	END_PAL_ROUTINE		SWASTEN


.sbttl WR_PS_SW - PALcode for WR_PS_SW instruction

;+
; WR_PS_SW
;
; Entry:
;	Vectored into via hardware PALcode instruction dispatch
;	PALcode enviornment set up.
;
;	r16<2:0> -> new ps sw bits
;
; Function:
;	
; Returns:	
;-
	START_PAL_ROUTINE	WR_PS_SW; 10 cycles
	mt	r12, pt12		; save r12
	 mf	r12, pt9		; get PS
	mt	r13, pt13		; save r13
	 and	r16, #<3@ps$v_sw>, r13	; get new sw field
	bic	r12, #<3@ps$v_sw>, r12	; clear ps<sw>
	 or	r12, r13, r12		; build new ps
	mf	r13, pt13		; restore r13
	 mt	r12, pt9
	mf	r12, pt12		; restore r12
	 hw_rei				; back to user
	END_PAL_ROUTINE		WR_PS_SW


.sbttl CFLUSH	- PALcode for CFLUSH instruction

;+
; CFLUSH
;
; Entry:
;	Vectored into via hardware PALcode instruction dispatch
;	PALcode enviornment set up.
;
;	r16 -> pfn to scrub from D caches
;
; Function:
;	
; Returns:	
;-
	START_PAL_ROUTINE	CFLUSH, longflow=1	; lots of cycles
	.if ne	adu_system ! cfw_system
	mt	r12, pt12		; get working regs
	mt	r13, pt13
	mt	r14, pt14
	mt	r15, pt15
	mt	r16, pt16
	mt	r17, pt17

	.if ne	adu_system
	; convert pfn to addr, and clean off <63:20>
	sll	r16, #<<page_offset_size_bits>+<63-20>>, r12
	ldah	r13,<<1@18>+32768>@-16(r31); + xxx<31:16>
	srl	r12, #<63-20>, r12	; shift back to normal position
	xor	r12, r13, r12		; xor addr<18>
	virtualize r12, r13
	
	or	r31, #8192/<32*8>, r13	; get count of loads
	.endc
	.if ne	cfw_system
	;
	; We flush the cache by touching aliases of the specified PFN.
	; Below we use a default Bcache size of 4MB.  We strip the high
	; bits of the PFN so that an address between 0 and twice the
	; size of the Bcache results.  We then XOR this with 4MB, and
	; thus assure that an alias is created.
	;
	; If 4MB is not sufficient for your platform, you may override
	; it by defining BCACHE_SIZE in your platform-specific prefix
	; file.
	;
	.iif ndf bcache_size, bcache_size		== 22

	sll	r16, #<<page_offset_size_bits>+<64-<bcache_size+1>>>, r12
	ldah	r13, <<1@bcache_size>+32768>@-16(r31)
	srl	r12, #<64-<bcache_size+1>>, r12
	xor	r12, r13, r12
	virtualize r12, r13
	
	or	r31, #page_size_bytes/<32*8>, r13
	.endc
	CONT_PAL_ROUTINE	CFLUSH

	align_branch_target		; align for branch target
10$:	subq	r13, #1, r13		; decr counter
	 ldq/p	r14, 32*0(r12)		; do a load
	ldq/p	r15, 32*1(r12)		; do next load
	 ldq/p	r16, 32*2(r12)		; do next load
	ldq/p	r17, 32*3(r12)		; do next load
	 ldq/p	r14, 32*4(r12)		; do next load
	ldq/p	r15, 32*5(r12)		; do next load
	 ldq/p	r16, 32*6(r12)		; do next load
	ldq/p	r17, 32*7(r12)		; do next load
	 mf	r14, hirr		; get hardware interrupt mask's
	and	r14, #<hirrr$m_atr !hirrr$m_swr !hirrr$m_hwr>, r14 ; check int's
	 lda	r12, <32*8>(r12)	; skip to next cache block addr
	bne	r14, 30$		; if any int's pending, re-queue CFLUSH
	 bne	r13, 10$		; loop till done


20$:	mf	r12, pt12		; restore working regs
	mf	r13, pt13
	mf	r14, pt14
	mf	r15, pt15
	mf	r16, pt16
	mf	r17, pt17
	hw_rei				; back to user

30$:	mf	r12, exc_addr		; fetch pc
	subq	r12, #4, r12		; backup pc to point to cflush
	mt	r12, exc_addr		; reset pc
	br	r31, 20$		; join common exit path

	.iff
	stall	1
	 hw_rei				; back to user
	.endc
	END_PAL_ROUTINE		CFLUSH


.sbttl DRAINA	- PALcode for DRAINA instruction

;+
; DRAINA
;
; Entry:
;	Vectored into via hardware PALcode instruction dispatch
;	PALcode enviornment set up.
;
;
; Function:
;	
; Returns:	
;-
	START_PAL_ROUTINE	DRAINA	; 2 cycles
	stall	1
	 hw_rei				; back to user
	END_PAL_ROUTINE		DRAINA



.sbttl HALT	- PALcode for HALT instruction

;+
; HALT
;
; Entry:
;	Vectored into via hardware PALcode instruction dispatch
;	PALcode enviornment set up.
;
;
; Function:
;	
; Returns:	
;-
	START_PAL_ROUTINE	HALT	; 7 cycles, to start, then hang on..
	mt	r0, pt0
	 mf	r0, exc_addr		; get pc
	subq	r0, #4, r0		; make pc=pc
	 mt	r0, exc_addr
	pvc$jsr updpcb, bsr=1
	bsr	r0, pal$update_pcb	; update the pcb
	.if ne	cfw_system
	CONT_PAL_ROUTINE	HALT

pal$halt_osf::
	.if ne	sable_system_debug
	mt	r12, pt12
	mt	r13, pt13
	mt	r14, pt14
	mt	r15, pt15
	mt	r16, pt16
	mt	r17, pt17
	mt	r18, pt18
	mt	r19, pt19
	combo_setup
	combo_lock
	combott_putc	<^x0d>
	combott_putc	<^x0a>
	combott_putc	<^x37>
	combott_putc	<^x3c>
	mf	r16, exc_addr
	combott_puth
	combott_putc	<^x3e>
	combo_unlock
	mf	r12, pt12
	mf	r13, pt13
	mf	r14, pt14
	mf	r15, pt15
	mf	r16, pt16
	mf	r17, pt17
	mf	r18, pt18
	mf	r19, pt19
	.endc

	.if ne	medulla_system_debug
	cmpeq	r0, #hlt$c_callback, r16	; Is this a callback?
	beq	r16, medu$noprint		; then don't dump the info
	mt	r12, pt12
	mt	r13, pt13
	mt	r14, pt14
	mt	r15, pt15
	mt	r16, pt16
	mt	r17, pt17
	mt	r18, pt18
	mt	r19, pt19
	medu$putc	<^x0d>
	medu$putc	<^x0a>
	medu$putc	<^a/H/>
	medu$putc	<^a/a/>
	medu$putc	<^a/l/>
	medu$putc	<^a/t/>
	medu$putc	<^a/ />
	medu$putc	<^x3c>	; '<'
	mf	r16, exc_addr
	medu$puth
	medu$putc	<^x3e>	; '>'
	mf	r12, pt12
	mf	r13, pt13
	mf	r14, pt14
	mf	r15, pt15
	mf	r16, pt16
	mf	r17, pt17
	mf	r18, pt18
	mf	r19, pt19
     medu$noprint:
	.endc
	.endc
	 lda	r0, hlt$c_sw_halt(r31)	; set halt code to sw halt
	br	r31, pal$enter_console	; enter the console
	END_PAL_ROUTINE	HALT




.if ne	enable_nphalt

;+
;
; Non-privleged version of HALT, for use in debuging console's etc only
; This code MUST not be included in any released PALCODE.
;
;-

	START_PAL_ROUTINE	NPHALT	; 11 cycles, to start, then hang on..
	mt	r0, pt0
	 mf	r0, exc_addr		; get pc
	subq	r0, #4, r0		; make pc=pc
	 mt	r0, exc_addr
	pvc$jsr updpcb, bsr=1
	bsr	r0, pal$update_pcb	; update the pcb
	 lda	r0, hlt$c_sw_halt(r31)	; set halt code to sw halt
	br	r31, pal$enter_console	; enter the console
	END_PAL_ROUTINE	NPHALT

.endc




.sbttl CONSOLE	- PALcode for ENTERING console

;+
; PAL$ENTER_CONSOLE
;
; Entry:
;	Entered when PAL wants to enter the console.
;	usually as the result of a HALT instruction or button,
;	or catastrophic error.
;
; Regs' on entry...
;
;	R0 	= halt code
;	pt0	<- r0
;
; Function:
;
;	Save all readable machine state, and "call" the console
;	
; Returns:
;
;	Eventually, the console may return to use, with state altered
;	in any way.
;
; Notes:
;
;	In these routines, once the save state routine has been executed,
;	the remainder of the registers become scratchable, as the only
;	"valid" copy of them is the "saved" copy.
;
;	Any registers or PT's that are modified before calling the save 
;	routine will have their data lost. The code below, will save all
;	state, but will loose pt's 0,1,3, 4.
;	
;-


	goto_new_code			; need someplace to start...
PAL$ENTER_CONSOLE::
	stall	1

	.if ne	adu_system
	; this code is for modeling only, and should not be included in 
	; product versions of pal.
	.print	0			; Model specific console code included, should not be in released code
	mt	r1, pt1
	debug_boot	r1
	mf	r1, pt25		; get adu flag
	srl	r1, #pt25$v_adu, r1	; get adu flag to <0>
	blbc	r1, 30$			; br unless using HACK BOOT

	cmpeq	r0, #hlt$c_reset, r1	; are we here because of RESET?
	beq	r1, 10$			; no, so halt, else "boot"

	get_addr r0, <^x20000000>, r31	; get pc
	mt	r0, exc_addr		; set boot pc
	get_addr sp, <^x207fe000>, r31	; get sp
	mt	sp, pt26		; set ksp
	get_addr r0, <^x04000>, r31	; ptbr
	mt	r0, pt28		; set ptbr
	or	r31, #2, r0		; get a 2
	sll	r0, #8*4, r0		; get 200000000
	mt	r0, pt29		; set l3vert
	get_addr r0, <^x1>, r31		; scbb
	mt	r0, pt30		; set scbb
	get_addr r0, <^x2980>, r31	; ptbr
	mt	r0, pt31		; set pcb
	
	mf	r1, pt1
;;;	ldah	r0, 4(r31)		; get VA of initial program 40000#16
;;;	mt	r0, exc_addr		; set it into exc_addr for REI
;;;	stall	1
	hw_rei

10$:	mf	r1, pt1
	pvc$violate	1003		; disable rule checker on the HALT
20$:	halt				; halt,
	br	r31, 20$		;  and stay halted.

30$:	mf	r1, pt1

	.endc



;
; Console entry
;

;
; Preserve a reg, and call the save routine
;

	mt	r3, pt3			; save a work register
	pvc$jsr	savsta, bsr=1
	bsr	r3, pal$save_state	; go save all state



	; if doing pc traceing or event traceing, disable the trace
	; while in the console
	.if ne <enable_debug_pctrace ! enable_debug_pcevent>
	  mf	r3, pt11		; get current trace ptr
	  bis	r3, #1, r3		; set, disable trace flag
	  mt	r3, pt11		; cleared by normal restore_state
	.endc	

	.if ne	cfw_system
pal$reenter_console:
	.if ne	sable_system_debug
	ldq/p	r12, pal$callback(r31)
	bne	r12, 98$
	combo_setup
	combo_lock
	combott_putc	<^x32>
	mf	r16, pt27
	addq	r16, #48, r16
	combott_putc	r16
	combott_putc	<^x3c>
	ldq/p	r16, cns$hlt(r1)
	combott_puth
	combott_putc	<^x2f>
	mf	r16, exc_addr
	combott_puth
	combott_putc	<^x3e>
	combo_unlock
98$:
	.endc
	.if ne	medulla_system_debug
	cmpeq	r0, #hlt$c_callback, r16	; Is this a callback?
	beq	r16, medu$noprintfhalt		; then don't dump the info
	medu$putc	<^x3c>
	ldq/p	r16, cns$hlt(r1)
	medu$puth
	medu$putc	<^x2f>
	mf	r16, exc_addr
	medu$puth
	medu$putc	<^x3e>
	medu$putc	<^x0d>
	medu$putc	<^x0a>
     medu$noprintfhalt:
	.endc
	.endc

	; if requested, enable physical mode prior to console entry
	.if ne enable_physical_console
	  stall	2			; required stall
	  mf	r3, pt28
	  mf	r4, pt29
	  bis	r3, #1, r3
	  bis	r4, #1, r4
	  mt	r3, pt28
	  mt	r4, pt29
	.endc

	.if ne	cfw_system
	ldq/p	r0, cns$hlt(r1)		; Get saved halt code
	br	r1, 10$			; Get current PC
10$:	get_addr r1, pal$start-10$, r1	;  and compute PAL base
	mt	r1, pal_base		; Set PAL base
	get_addr r1, bt$pcb-pal$start, r1 ; Get dummy PCB address
	mt	r1, pt31		; Set PCBB
	.if ne	low_core_ipl
	get_addr r12, pal$ipltbl, r31	; Get base of IPL table
	.iff
	get_addr r12, pal$ipltblhi-pal$start, r1 ; Get base of IPL table
	.endc
	.if ne	sable_system
	mf	r0, pt27		; Get WHAMI
	ldq/p	r3, pal$primary(r31)	; Adjust IPL table for MP
	cmpeq	r0, r3, r0		;  (add ^X200 for secondaries)
	xor	r0, #1, r0		;
	sll	r0, #9, r0		;
	addq	r12, r0, r12		;
	.endc
	mt	r12, pt8		;
	lda	r0, ^x1f00(r31)		;
	mt	r0, pt9_ps		; Set new PS
	ldq/p	r3, <31*8>(r12)		; Get the HW and SW enable bits
	mt	r3, hier		; Turn on hardware bits
	mt	r3, sier		; Turn on software bits

	.if ne	lca4
	mf	r0, pt25		; get MCES
	and	r3, hierw$m_cre, r3	; isolate CRE bit
	srl	r0, <pt25$v_dpc - hierw$v_cre>, r0 ; move DPC to hierw<cre> pos
	bic	r3, r0, r3		; hierw<cre> & !mces<dpc>
	get_high_addr	r0, mem$csr_base
	xor	r3, hierw$m_cre, r3	; Toggle it.
	sll	r3, <esr$v_ice-hierw$m_cre>, r3  ; Move it into position.
	stq/p	r3, mem$q_esr(r0)	; Write ICE
	.endc

	mt	r31, sirr		; Turn off software interrupt requests
	mt	r31, astrr		; Turn off AST requests
	get_addr r5, pal$console_base, r31 ; Get address of console
	.iff
	; get address of "console" code
	br	r4, cns$addr_cont	; get our address
cns$addr:
	.long <pal$console-cns$addr> 	; address of console code
					; note, if console addr specifies
					; addr<0> as a 1, then the console
					; will be entered in pal mode. Else
					; in ? mode. (Hmmm KM, ipl=31, etc
					; would probably be better...)

cns$addr_cont:
	ldl/p	r5, (r4)		; fetch console offset
	addq	r4, r5, r5		; now is addr of console code
	.endc
	mt	r5, exc_addr		; set the console as new pc
					; addr<0> controls if enter as pal or not
	.if ne	sable_system_debug
	ldq/p	r12, pal$callback(r31)
	bne	r12, 97$
	combo_setup
	combo_lock
	combott_putc	<^x33>
	mf	r16, pt27
	addq	r16, #48, r16
	combott_putc	r16
	combott_putc	<^x0d>
	combott_putc	<^x0a>
	combo_unlock
97$:
	.endc

	stall	3			; required stall
	pvc$jsr	entcns
	hw_rei				; dispatch to console
					; we do NOT return here.





.sbttl RECONSOLE - PALcode for RETURNING from console

;+
; pal$exit_console
;
; Entry:
;	Entered when console wants to reenter PAL.
;	usually as the result of a CONTINUE.
;
;
; Regs' on entry...
;
;
; Function:
;
;	Restore all readable machine state, and return to user code.
;	
;
;	
;-

	align_to_cache_block
PAL$EXIT_CONSOLE::

	.if ne	sable_system_debug
	ldq/p	r12, pal$callback(r31)
	bne	r12, 99$
	combo_setup
	combo_lock
	combott_putc	<^x38>
	mf	r16, pt27
	addq	r16, #48, r16
	combott_putc	r16
	combott_putc	<^x3c>
	ldq/p	r16, cns$exc_addr(r1)
	combott_puth
	combott_putc	<^x3e>
	combott_putc	<^x0d>
	combott_putc	<^x0a>
	combott_putc	<^x00>
	combo_unlock
99$:
	.endc

	; if requested, disable physical mode prior to console return
	.if ne enable_physical_console
	  mf	r3, pt28
	  mf	r4, pt29
	  bic	r3, #1, r3
	  bic	r4, #1, r4
	  mt	r3, pt28
	  mt	r4, pt29
	.endc

	.if ne	cfw_system
	ldq/p	r3, pal$callback(r31)	; Get the callback flag
	mb				;  (for sure!)
	stq/p	r31, pal$callback(r31)	;  and clear it
	bic	r3, #1, r3		; Does it show a pending ^P/break/halt?
	beq	r3, 10$			; Nope
	lda	r0, hlt$c_hw_halt(r31)	; Set halt code to hardware halt
	stq/p	r0, cns$hlt(r1)		;
	br	r31, pal$reenter_console ; Enter the console
10$:
	.endc

	; clear lock and intr_flags prior to leaveing console
	rc	r3			; clear intr_flag
	; lock flag cleared by restore_state
	pvc$jsr	rststa, bsr=1
	bsr	r3, pal$restore_state	; go restore all state
					; note, R1 and R3 are NOT restored
					; by restore_state.

	.if ne	cfw_system
	mt	r4, pt4			; Save register
	ldq/p	r3, cns$pal_type(r1)	; Get PAL type
	cmpeq	r3, #vms_pal, r4	; Is it VMS PALcode?
	beq	r4, 20$			; No, don't touch HIER/SIER
	mf	r4, pt9			; Get current PS
	extbl	r4, #1, r4		; Get current IPL
	mf	r3, pt8			;  and interrupt table
	s8addq	r4, r3, r3		; Multiply by 8 for quadword index
	ldq/p	r3, (r3)		; Get the HW and SW enable bits
	mt	r3, hier		; Turn on hardware bits
	mt	r3, sier		; Turn on software bits

	.if ne	lca4
	mf	r4, pt25		; get MCES
	and	r3, hierw$m_cre, r3	; isolate CRE bit
	srl	r4, <pt25$v_dpc - hierw$v_cre>, r4 ; move DPC to hierw<cre> pos
	bic	r3, r4, r3		; hierw<cre> & !mces<dpc>
	get_high_addr	r4, mem$csr_base
	xor	r3, hierw$m_cre, r3	; Toggle it.
	sll	r3, <esr$v_ice-hierw$m_cre>, r3  ; Move it into position.
	stq/p	r3, mem$q_esr(r4)	; Write ICE.
	.endc

	br	r31, 30$		; Join common code
20$:	cmpeq	r3, #osf_pal, r4	; Is it OSF PALcode?
	beq	r4, 30$			; No, don't touch HIER/SIER
	mf	r4, pt9			; Get current PS
	mf	r3, pt22		; Get OSF interrupt masks
	and	r4, #7, r4		; Clean to IPL only
	extbl	r3, r4, r3		; Get mask for this IPL
	insbl	r3, #1, r3		; Position it properly for HIER/SIER
	mt	r3, hier		; Turn on hardware bits
	mt	r3, sier		; Turn on software bits

	.if ne	lca4
	mf	r4, pt25		; get MCES
	and	r3, hierw$m_cre, r3	; isolate CRE bit
	srl	r4, <pt25$v_dpc - hierw$v_cre>, r4 ; move DPC to hierw<cre> pos
	bic	r3, r4, r3		; hierw<cre> & !mces<dpc>
	get_high_addr	r4, mem$csr_base
	xor	r3, hierw$m_cre, r3	; Toggle it.
	sll	r3, <esr$v_ice-hierw$m_cre>, r3  ; Move it into position.
	stq/p	r3, mem$q_esr(r4)	; Write ICE.
	.endc

30$:	mf	r3, pt10		; Is SCC zero?
	bne	r3, 40$			; Nope
	.if ne	generic_system
	.endc
	.if ne	sable_system
	mf	r3, pt27		; Get WHAMI
	lda	r3, ^x380(r3)		; Write 38x000180
	sll	r3, #24, r3		;
	lda	r4, 1(r31)		; Get bit to clear
	sll	r4, #2, r4		;
	stq/p	r4, ^x180(r3)		; Clear the Cbus error interrupt
	mb				; Make sure it goes out
	ldq/p	r4, ^x0e0(r3)		; Get CBE (Cbus error)
	stq/p	r4, ^x0e0(r3)		; Clear locked error bits
	mb				; Make sure it goes out
	.endc
40$:	mf	r4, pt4			; Restore register
	.endc


	.if ne	adu_system
	; on the adu, we have to notify the console, that we are continueing
	; on the adu, pt0, also has the saved addr of the IOM
	mf	r3, pt0			; get addr of doorbell
	stq/p	r31, (r3)		; poke the console
	mb
	.endc

	ldq/p	r3, cns$r3(r1)		; restore r3
	ldq/p	r1, cns$r1(r1)		; restore r1
	hw_rei				; back to user

;+
;
; Pal$save_state
;
;	Function
;		All chip state saved, all PT's, SR's FR's, IPR's
;
;
; Regs' on entry...
;
;	R0 	= halt code
;	pt0	<- r0
;	R3	= return addr
;	pt3	= r3
;
;	register usage:
;		r0 = halt_code
;		r1 = addr of impure area
;		r3 = return_address
;		r4 = scratch
;
;-


	align_to_cache_block		; align for branch target
pal$save_state::
	mt	r1, pt1
	mf	r1, pt7			; get addr of impure area



;
;
; start of implimentation independent save routine
;
;

	stq/p	r31, cns$flag(r1)	; clear dump area valid flag
	stq/p	r0, cns$hlt(r1)		; save halt code

	mf	r0, pt0			; get r0 back
	stq/p	r0, cns$r0(r1)		; save it


	mf	r0, pt1			; get r1 back
	stq/p	r0, cns$r1(r1)		; save it

	stq/p	r2, cns$r2(r1)		; save r2

	mf	r0, pt3			; get r3 back
	stq/p	r0, cns$r3(r1)		; save it


	; reason code has been saved
	; r0 has been saved
	; r1 has been saved
	; r2 has been saved
	; r3 has been saved
	; pt0, pt1, pt3 have been lost


	; save all pal regs
	t = 2
	.repeat 30
	  store_reg \t	, pal=1
	  t = t + 1
	.endr


	; save all integer regs
	t = 4
	.repeat 28
	  store_reg \t
	  t = t + 1
	.endr

	.if ne	cfw_system
	mf	r4, pal_base		; Get PAL base
	br	r5, 10$			; Point to the PALcode base table
	.long	pal$start+^x8000
	.global	osfpal$start
	.weak	osfpal$start
	.long	osfpal$start+^x8000
10$:	cmoveq	r31, #0, r0		; Assume unknown PALcode
	ldl/p	r6, 0(r5)		; Get VMS PALcode base
	cmpeq	r6, r4, r6		; Is VMS PALcode current?
	cmovne	r6, #vms_pal, r0	; If so, say so
	ldl/p	r6, 4(r5)		; Get OSF PALcode base
	cmpeq	r6, r4, r6		; Is OSF PALcode current?
	cmovne	r6, #osf_pal, r0	; If so, say so
	stq/p	r0, cns$pal_type(r1)	; Set PAL type
	.endc


	; save the ipr's
	store_reg exc_addr,	ipr=1	; save ipr
	store_reg pal_base,	ipr=1	; save ipr
	store_reg hirr	,	ipr=1	; save ipr
	store_reg hier	,	ipr=1	; save ipr
	store_reg mm_csr,	ipr=1	; save ipr
	store_reg va,		ipr=1	; save ipr
	store_reg biu_stat,	ipr=1	; save ipr
	store_reg biu_addr,	ipr=1	; save ipr
	store_reg dc_stat,	ipr=1	; save ipr
	store_reg dc_addr,	ipr=1	; save ipr
	store_reg fill_syndrome,ipr=1	; save ipr
	store_reg bc_tag,	ipr=1,nodata=1	; save ipr
	store_reg fill_addr,	ipr=1	; save ipr
;	store_reg abox_ctl,	ipr=1	; save ipr
;	store_reg biu_ctl,	ipr=1	; save ipr


	; save all floating regs
	mf	r0, pt2			; get iccsr
	or	r31, #1, r2		; get a one
	sll	r2, #iccsrw$v_fpe, r2	; shift for fpu spot
	or	r2, r0, r0		; set FEN on
	mt	r0, pt2_iccsr		; write to iccsr, enableing FEN


	; map the save area virtually
	mt	r31, xtbzap		; clear the tb's
	srl	r1, #<page_offset_size_bits>, r0 ; Clean off low bits of VA
	sll	r0, #32, r0		; shift to PFN field
	t = <pte$m_kwe!pte$m_kre!pte$m_ewe!pte$m_ere>
	t = <t ! pte$m_swe!pte$m_sre!pte$m_uwe!pte$m_ure>
	get_addr r0, t, r0		; add ctl fields
	mt	r31, dtb_ctl		; Set dtb ctl
	stall	3
	mt	r1, tb_tag		; write ITB tag
	mt	r0, dtb_pte		; Load PTE and set TB valid bit
	stall	4

	; now save the regs
	t = 0
	.repeat 32
	  store_reg \t , fpu=1
	  t = t + 1
	.endr
	mf_fpcr  f0
	stt	f0, cns$fpcsr(r1)	; get fpcsr


	lda	r0, cns$mchksize(r31)	; get size of mchk area
	stq/p	r0, cns$mchkflag(r1)	; set mcheck flags
	mb

	or	r31, #1, r0		; get a one
	stq/p	r0, cns$flag(r1)	; set dump area valid flag
	mb

	pvc$jsr	savsta, bsr=1, dest=1
	ret	r31, (r3)		; and back we go


;+
;
;	Pal$restore_state
;
;
;	register usage:
;		r1 = addr of impure area
;		r3 = return_address
;		all other regs are scratchable, as they are about to
;		be reloaded from ram.
;
;	Function:
;		All chip state restored, all SR's, FR's, PT's, IPR's
;					*** except R1, r3, PT0, PT1 ***
;
;-

	align_to_cache_block		; align for branch target
pal$restore_state::

	; update the ast, sixr, hixr regs
	stall	1
	ldq/p	r0, cns$hirr(r1)		; get hirr in read format
	or	r0, r31, r12
	stq/pc	r12, cns$hirr(r1)		; clear lock flag
	sll	r0, #<hirrw$v_sirr-hirrr$v_sirr>, r12; get sirr for write
	mt	r12, sirr
	sll	r0, #<hirrw$v_astrr-hirrr$v_astrr>, r2; get astrr for write
	mt	r2, astrr

	ldq/p	r0, cns$hier(r1)		; get hier in read format
	sll	r0, #<hierw$v_sier-hierr$v_sier>, r2; get sier for write
	mt	r2, sier
	sll	r0, #<hierw$v_aster-hierr$v_aster>, r2; get aster for write
	mt	r2, aster

	lda	r4, 7@hierr$v_hier53(r31)	; get mask of high hier bits
	and	r0, r4, r2			; isolate hier high bits
	lda	r4, 7@hierr$v_hier20(r31)	; get mask of low hier bits
	and	r0, r4, r4			; isolate hier low bits
	sll	r2, #<hierw$v_hier+3>-hierr$v_hier53, r2 ; shift to write spot
	srl	r4, #hierr$v_hier20-hierw$v_hier, r4 ; shift to write spot
	or	r2, r4, r2			; merge high and low


	lda	r4, 1@hierr$v_cre(r31)		; get mask of hier bit
	and	r0, r4, r4			; isolate hier bit
	srl	r4, #<hierr$v_cre-hierw$v_cre>, r4; move to write spot
	or	r4, r2, r2			; merge in
	lda	r4, 1@hierr$v_pc0(r31)		; get mask of hier bit
	and	r0, r4, r4			; isolate hier bit
	srl	r4, #<hierr$v_pc0-hierw$v_pc0>, r4; move to write spot
	or	r4, r2, r2			; merge in
	lda	r4, 1@hierr$v_pc1(r31)		; get mask of hier bit
	and	r0, r4, r4			; isolate hier bit
	sll	r4, #<hierw$v_pc1-hierr$v_pc1>, r4; move to write spot
	or	r4, r2, r2			; merge in
	lda	r4, 1@hierr$v_sle(r31)		; get mask of hier bit
	and	r0, r4, r4			; isolate hier bit
	sll	r4, #<hierw$v_sle-hierr$v_sle>, r4; move to write spot
	or	r4, r2, r2			; merge in
	mt	r2, hier

	.if ne lca4
	mf	r4, pt25		; get MCES
	and	r2, hierw$m_cre, r2	; isolate CRE bit
	srl	r4, <pt25$v_dpc - hierw$v_cre>, r4 ; move DPC to hierw<cre> pos
	bic	r2, r4, r2		; hierw<cre> & !mces<dpc>
	get_high_addr r4, mem$csr_base
	xor	r2, hierw$m_cre, r2	; toggle it
	sll	r2, <esr$v_ice-hierw$v_cre>, r2  ; move it into position
	stq/p	r2, mem$q_esr(r4)	; write ICE
	.endc

	; update the abox_ctl, biu_ctl
	restore_reg abox_ctl,	ipr=1

	.if ne	generic_system ! -
		medulla_system ! -
		avanti_system ! -
		mikasa_system ! -
		noritake_system ! -
		mtu_system ! - 
		k2_system ! -
		lean_system ! -
		cortex_system
	.iff
	.if eq lca4
	restore_reg biu_ctl,	ipr=1
	.endc
	.endc

	; map the console io area virtually
	mt	r31, xtbzap		; clear the tb's
	srl	r1, #<page_offset_size_bits>, r0 ; Clean off low bits of VA
	sll	r0, #32, r0		; shift to PFN field
	t = <pte$m_kwe!pte$m_kre!pte$m_ewe!pte$m_ere>
	t = <t ! pte$m_swe!pte$m_sre!pte$m_uwe!pte$m_ure>
	get_addr r0, t, r0		; add ctl fields
	mt	r31, dtb_ctl		; Set dtb ctl
	stall	3
	mt	r1, tb_tag		; write ITB tag
	mt	r0, dtb_pte		; Load PTE and set TB valid bit
	stall	4

	; restore all floating regs
	ldt	f0, cns$fpcsr(r1)	; get fpcsr
	mt_fpcr  f0
	t = 0
	.repeat 32
	  restore_reg \t , fpu=1
	  t = t + 1
	.endr



	; restore all pal regs
	t = 2
	.repeat 30
	  restore_reg \t	, pal=1
	  t = t + 1
	.endr


	; fix pt25, high sw bits
	extwl	r12, #4, r12		; get current sw int requests

	lda	r14, 0(r31)		; assume sw int in low bits

	cmpule	r12, #^xff, r16		; see if any swints 's > 7 are reqstd
	xor	r16, #1, r16		; flip <0>

	extbl	r12, r16, r12		; get byte of interest to <0>
	cmovne	r16, #8, r14		; update base bit, if workin on high 8


	; reduce to 4 bits
	lda	r17, (r31)		; start at bit 0
	and	r12, #^xF0, r16		; check the bits that set <2>
	cmovne	r16, r16, r12		; keep the correct half
	cmovne	r16, #4, r17		; set <2>	
	and	r12, #^xCC, r16		; check the bits that set <1>
	or	r14, r17, r14		; merge into result
	cmovne	r16, r16, r12		; keep the correct half
	cmovne	r16, #2, r17		; set <1>	
	and	r12, #^xAA, r16		; check the bits that set <0>
	or	r14, r17, r14		; merge into result
	cmovne	r16, #1, r17		; set <0>	
	cmovne	r16, r16, r12		; keep the correct half
	or	r14, r17, r14		; merge into result
	mf	r12, pt25		; fetch current misc reg

	bic	r12, #^xff, r12		; clear out old high sirr
	or	r12, r14, r14		; merge the data
	mt	r14, pt25		; and store it away


	; update chip IPR's from shadow copies
	mf	r0, pt2
	mt	r0, pt2_iccsr		; write to iccsr

	mf	r0, pt9
	mt	r0, PT9_PS		; set new ps

	mt	r31, alt_mode		; set alt_mode

	restore_reg exc_addr,	ipr=1	; restore ipr
	restore_reg pal_base,	ipr=1	; restore ipr

	.if ne	cfw_system
	mf	r4, pal_base		; Get PAL base
	br	r5, 10$			; Point to the PALcode base table
	.long	pal$start+^x8000
	.global	osfpal$start
	.weak	osfpal$start
	.long	osfpal$start+^x8000
10$:	cmoveq	r31, #0, r0		; Assume unknown PALcode
	ldl/p	r6, 0(r5)		; Get VMS PALcode base
	cmpeq	r6, r4, r6		; Is VMS PALcode current?
	cmovne	r6, #vms_pal, r0	; If so, say so
	ldl/p	r6, 4(r5)		; Get OSF PALcode base
	cmpeq	r6, r4, r6		; Is OSF PALcode current?
	cmovne	r6, #osf_pal, r0	; If so, say so
	stq/p	r0, cns$pal_type(r1)	; Set PAL type
	.endc

	; restore all integer regs
	t = 4
	.repeat 28
	  restore_reg \t
	  t = t + 1
	.endr



	mt	r31, flush_ic		; flush the icache
	mt	r31, xtbzap		; clear the tb's
	stall	5


	stq/p	r31, cns$flag(r1)	; clear dump area valid flag
	mb


	; and back we go
;	restore_reg 3
	restore_reg 2
	restore_reg 0
;	restore_reg 1

	pvc$jsr	rststa, bsr=1, dest=1
	ret	r31, (r3)		; back we go


;+
;
; pal$console
;
;-

	align_to_cache_block		; align for branch target
	.if ne	adu_system
pal$console == . + 1			; ADU console, runs in PAL mode.
	pvc$jsr	entcns, dest=1

; Jumping to the ADU console, really consists of the following steps.
; 	1. Save machine state (this has been done previously)
;	2. Notify ADU console, that we are halting.
;	3. Spin waiting for the ADU console to ack that we are halting
;	4. Spin waiting to be told by the ADU console to continue


	; calculate address of ADU's IOM
	; save the addr in pt0, and poke the console.

	mf	r5, pt27		; get WHAMI/IOM/CLUMP addr
	srl	r5, #8, r2		; isolate IOM slot number
	and	r2, #^xf, r2		; clean to IOM slot only
	subq	r31, #1, r4		; get io space indicator
	sll	r4, #tv$v_space, r4	; shift io space indicator
	sll	r2, #tv$v_node, r2	; shift to make tv node number
	or	r2, r4, r2		; now have base addr of board
	get_addr r2, <tv$v_iom_attn_doorbell>, r2; merge in IOM attn doorbell addr

	srl	r5, #12, r4		; isolate clump
	and	r4, #^x3, r4
	cmplt	r31, r4, r6		; is this NOT clump 0
	sll	r6, #17+5, r7		; is not clump 0, set ibank1
	sll	r6, #5+5, r8		; is not clump 0, set rbank1
	or	r7, r8, r6		; merge ibank and rbank
	or	r6, r2, r2		; into addr
	cmpeq	r4, #2, r6		; is this clump 2
	sll	r6, #5, r6		; * 32
	bic	r2, r6, r2		; yes, so change dev from 5 to 4
	mt	r2, pt0			; save addr of doorbell in pt0


	stq/p	r31, (r2)		; poke the console
	mb


	; Enter spin loops, waiting for the ACK, and CONtinue
10$:	mf	r0, hirr		; get the HALT request bit irq<0>
	srl	r0, #hirrr$v_hirr20, r0	; to <0>
	blbc	r0, 10$			; wait for halt to be set


20$:	mf	r0, hirr		; get the HALT request bit irq<0>
	srl	r0, #hirrr$v_hirr20, r0	; to <0>
	blbs	r0, 20$			; wait for halt to be cleared


	br	r31, pal$exit_console	; now exit the console
	.endc


	end_new_code


.sbttl LDQP	- PALcode for LDQP instruction

;+
; LDPQ
;
; Entry:
;	Vectored into via hardware PALcode instruction dispatch
;	PALcode enviornment set up.
;
;	r16 -> address
;
; Function:
;	Read quadword from physical address (r16)
;	
; Returns:	
;	R0 <- memory(r16)
;-
	START_PAL_ROUTINE	LDQP	; 2 cycles
	.if ne virtualize_memory
	  virtualize r16, r0, swap=1
	  cmovlt	r16, r16, r0	; don't virtualize io space
	  ldq/p	r0, (r0)		; get the data
	.iff
	  ldq/p	r0, (r16)		; get the data
	.endc
	hw_rei				; back to user
	END_PAL_ROUTINE		LDQP

.sbttl STQP	- PALcode for STQP instruction

;+
; STQP
;
; Entry:
;	Vectored into via hardware PALcode instruction dispatch
;	PALcode enviornment set up.
;
;	r16 -> address
;	r17 -> data to store
; Function:
;	Write quadword to physical address (r16)
;	
; Returns:	
;	memory(r16) <- r17
;-
	START_PAL_ROUTINE	STQP	; 2 cycles
	.if ne virtualize_memory
	  mt	     r0,  pt0
	  virtualize r16, r0, swap=1
	  cmovlt     r16, r16, r0	; don't virtualize io space
	  stq/p	r17, (r0)		; store the data
	  mf	     r0,  pt0
	.iff
	  stq/p	r17, (r16)		; store the data
	.endc
	hw_rei				; back to user
	END_PAL_ROUTINE		STQP

.sbttl SWPCTX	- PALcode for SWPCTX instruction

;+
; SWPCTX
;
; Entry:
;	Vectored into via hardware PALcode instruction dispatch
;	PALcode enviornment set up.
;
;
; Function:
;	
; Returns:	
;-

	START_PAL_ROUTINE	SWPCTX, longflow=1
	; virtualize the pcbb if required
	.if ne virtualize_memory
	mt	r0, pt0
	 mf	r0, pt8
	mt	r16, pt16			; if cache block bndry here
	 addq	r16, r0, r16
	.if defined MACRO64$
	.iif eq <<<%integer(.) & 31>/4> - 2>, stall 2	; stall here
	.iff
	.iif eq <<<. & 31>/4> - 2>, stall 2	; stall here
	.endc
	.endc

	mt	r12, pt12
	 mf	r12, pt31		; get addr of old pcb
	mt	r15, pt15
	 ldq/p	r15, pcb$q_ast(r16)	; get new astxx
	mt	r13, pt13
	 stq/p	sp, pcb$q_ksp(r12)	; save old sp, in old pcb	
	mf	r13, astrr		; Get old astrr
	 and	r16, #^x7f, sp		; check new pcbb for alignment
	mt	r14, pt14
	 mf	r14, aster		; Get old aster
	srl	r13, #hirrr$v_astrr-4, r13; shift old astrr to spot
	 .iif ne virtualize_memory, CONT_PAL_ROUTINE	SWPCTX, DOUBLE=1
	 srl	r14, #hirrr$v_astrr, r14; shift old astrr to zero
	bne	sp, 100$		; oops, pcb is not aligned report error
	 bic	r13, #^xf, r13		; clean astrr
	rpcc	sp			; get old cycle counter
	 .iif eq virtualize_memory, CONT_PAL_ROUTINE	SWPCTX, DOUBLE=1

	;  sp = cc
	; r12 = old pcb
	; r13 = old astrr
	; r14 = old aster
	; r15 = new astxx
	; r16 = new pcb

	or	r14, r13, r13		; merge old asten, astrr
	 stq/p	r13, pcb$q_ast(r12)	; store old asten/astrr in old pcb
	sll	r15, #<hirrw$v_astrr-4>, r14 ;get new astrr to correct spot
	 ldl/p	r13, pcb$q_cc(r16)	; get new cc from pcb
	sll	r15, #<hirrw$v_astrr>, r15; shift new aster to correct spot

	 mt	r14, astrr		; update new astrr
	srl	sp, #32, r14		; get old cc<63:32>
	 mt	r15, aster		; update new aster it

	mf	r15, pt2		; get current iccsr
	 addl	sp, r14, r14		; old cc<31:0> + cc<63:32>
	stl/p	r14, pcb$q_cc(r12)	; store old cc in old pcb
	 lda	r14, ^x7f9(r31)		; get zap mask for fpe/asn/datafx/pme
	subl	r13, sp, r13		; now have new rpcc<63:32> in <31:0>
	 ldq/p	sp, pcb$q_fen(r16)	; get new fen/datafx
	sll	r13, #32, r13		; now have new rpcc<63:32> in <63:32>
	 sll	r14, #iccsrw$v_fpe, r14	; shift iccsr zap mask for fpe/asn
	mt	r13, cc			; store new cc in cc
	 bic	r15, r14, r15		; clear out old fpe/asn fields of iccsr
	ldq/p	r13, pcb$q_asn(r16)	; get new asn
	 srl	sp, #<63-4>, r14	;  = 1@4 if datafx, else 0
	or	sp, r14, sp		; merge fen/datafx
	 and	sp, #^b11001, sp	; clean new fen/datafx/pme
	ldq/p	r14, pcb$q_ptbr(r16)	; get new ptbr
	 sll	sp, #iccsrw$v_fpe, sp	; shift new fen to spot
	mt	r16, pt31		; update the new PCBB
	 and	r13, ^x3f, r13		; clean new asn
	sll	r13, #iccsrw$v_asn, r13	; shift new asn to spot
	 mf	r12, pt28		; get old ptbr
	or	r15, sp, r15		; merge iccsr + new fen
	 ldq/p	sp, pcb$q_ksp(r16)	; get new ksp

	or	r15, r13, r13		; merge iccsr + new asn
	.iif eq <enable_debug_pctrace ! enable_debug_pcevent>, ldq/p r15, pcb$q_unq(r16); get UNQ
	sll	r14, #page_offset_size_bits, r14 ; convert ptbr from PFN to PA
	 mt	r13, pt2_iccsr		; write iccsr
	.iif ne virtualize_memory, stall 2
	.iif ne virtualize_memory, addq	r14, r0, r14; virtualize new ptbr
	.iif ne virtualize_memory, mf r0, pt0
	mt	sp, pt26		; save new ksp in pt
	 mt	r14, pt28		; save new PTBR
	cmpeq	r14, r12, r12		; is old PTBR same as new?
	 bne	r12, 10$		; new/old PTBR's same, skip store/flush
	mt	r31, xtbasm		; clear tb's with asm=0
10$:	 stall	1
	.iif eq <enable_debug_pctrace ! enable_debug_special ! enable_debug_pcevent>, mt r15, pt11; set new UNQ
	 .iif eq <enable_debug_pctrace ! enable_debug_special ! enable_debug_pcevent>, stall 3
	mf	r12, pt12
	 mf	r13, pt13
	mf	r14, pt14
	 mf	r15, pt15
	.iif ne virtualize_memory, mf r16, pt16
	 hw_rei				; back to user


	; illegal operand, setup and take fault
	.align	quad
100$:	ldq/p	sp, pcb$q_ksp(r12)	; restore old sp, from old pcb	
	.iif ne virtualize_memory, mf r0, pt0
	.iif ne virtualize_memory, mf r16, pt16
	  mf	r12, exc_addr		; get address of PAL call
	lda	r13, scb$v_illpal(r31)	; set scb vector to use
	 mf	r14, pt14
	mf	r15, pt15
	 br	r31, pal$post_km_trap_nr45; go build trap
	END_PAL_ROUTINE		SWPCTX


.sbttl MFPR ASN - PALcode for MFPR ASN

;+
; MFPR ASN
;
; Entry:
;	Vectored into via hardware PALcode instruction dispatch
;	PALcode enviornment set up.
;
; Function:
;	return ASN for current process
;	
; Returns:
;	ASN in R0
;-

	START_PAL_ROUTINE	MFPR_ASN; 4cycles
	mf	r0, pt2			; get iccsr
	 stall	1, mxpr=0		; stall for scheduling
	srl	r0, #iccsrw$v_asn, r0	; shift asn to <0>
	 hw_rei				; back to user
	END_PAL_ROUTINE		MFPR_ASN



.sbttl QUILTPOINT -- PALcode for quiltpoints
;+
; Entry:
;	Vectored into via PALcode instruction dispatch routine.
;	PALcode enviornment set up.
;
; Function:
;	This pal call is used by quilt to instrument console images.  Quilt
;	copies the console image into a cloned area, and for subroutines that
;	are instrumented, replaces each instruction with a pal call to this
;	routine.  When this routine gets control, it replaces the instruction
;	from the cloned area.  The instruction to replace with is obtained by
;	adding the pc to an offset (located in pal common area at 4040).
;	
; Returns:
;	nothing
;
; 
;-
	START_PAL_ROUTINE	QUILTPOINT

	CONT_PAL_ROUTINE	QUILTPOINT

	;
	; If we are in console mode, let this opcode work.  Otherwise,
	; fail the opcode (so that Egore will work unmodified).
	;
	mt	r0, pt0
	mf	r0, pt28
	blbs	r0, 10$
	mf	r0, pt0
	br	r31, pal$calpal_opcdec

10$:	mf	r0, pt0

	;+
	; save state
	;-
	mt	r12,pt12
	mt	r13,pt13
	mt	r14,pt14

	;+
	; update pc
	;-
	mf	r12, exc_addr
	subq	r12,#4,r12
	mt	r12, exc_addr

	lda	r13,pal$impure_base+impure$quilt_offset(r31) ; the location of the quilt offset
	ldq/p	r13,(r13)		;
	addq	r12,r13,r13		; r13 - address of cloned instruction
	ldl/p	r14,(r13)		; r14 - cloned instruction

	cmpeq	r14, PAL_FUNC_QUILTPOINT, r13		; use halt code if we're installing
	cmovne	r13, r31, r14		; a quiltpoint

	stl/p	r14,(r12)		; restore instruction


	;+
	; since we've written to the instruction stream, we
	; have to synchronize
	; (this was cloned from IMB)
	;-
	mt	r31, flush_ic		; flush the icache
	 mb				; start forcing d stream out
	stall	<7-2>			; Give icache time to drain
					; and ensure that we take a miss on
					; the rei... thus clearing the stream
					; buffer.
	 mb				; Wait till the previous MB completes

	;+
	; restore state
	;-
	mf	r12,pt12
	mf	r13,pt13
	mf	r14,pt14
	hw_rei

	END_PAL_ROUTINE QUILTPOINT



.sbttl MxPR ASTEN - PALcode for MxPR ASTEN

;+
; MxPR ASTEN
;
; Entry:
;	Vectored into via PALcode instruction dispatch routine.
;	PALcode enviornment set up.
;
;	r16 -> asten and/or vaules
;
; Function:
;	return ASTEN for current process
;	
; Returns:
;	ASTEN in R0
;-

	START_PAL_ROUTINE	MTPR_ASTEN, longflow=1; 15 cycles
	mf	r0, aster		; get ast state
	 srl	r16, #4, r17		; shift for next or
	srl	r0, #hirrr$v_astrr, r0	; shift to correct spot
	 and	r0, r16, r1		; and with r16
	or	r1, r17, r1		; now has new dirty asten
	 and	r1, #^xF, r1		; now is clean
	sll	r1, #hirrw$v_astrr, r1	; now is positioned
	 mt	r1, aster		; write it
	and	r0, #^xF, r0		; clean to just asten
	 stall	3			; required stall
	 hw_rei				; back to user
	END_PAL_ROUTINE		MTPR_ASTEN




	START_PAL_ROUTINE	MFPR_ASTEN; 6 cycles
	mf	r0, aster		; get ast state
	 srl	r0, #hirrr$v_astrr, r0	; shift to correct spot
	and	r0, #^xF, r0		; clean to just asten
	 hw_rei				; back to user
	END_PAL_ROUTINE		MFPR_ASTEN



.sbttl MxPR ASTSR - PALcode for MxPR ASTSR

;+
; MxPR ASTSR
;
; Entry:
;	Vectored into via hardware PALcode instruction dispatch
;	PALcode enviornment set up.
;
;	r16 -> astsr and/or vaules
;
; Function:
;	Requerst or clear an AST.
;-
	START_PAL_ROUTINE	MTPR_ASTSR, longflow=1; 15 cycles
	mf	r0, astrr		; get ast state
	 srl	r16, #4, r17		; shift for next or
	srl	r0, #hirrr$v_astrr, r0	; shift to correct spot
	 and	r0, r16, r1		; and with r16
	or	r1, r17, r1		; now has new dirty asten
	 and	r1, #^xF, r1		; now is clean
	sll	r1, #hirrw$v_astrr, r1	; now is positioned
	 mt	r1, astrr		; done
	and	r0, #^xF, r0		; clean to just asten
	stall	3			; required stall
	 hw_rei				; back to user
	END_PAL_ROUTINE		MTPR_ASTSR


	START_PAL_ROUTINE	MFPR_ASTSR; 6 cycles
	mf	r0, astrr		; get ast state
	 srl	r0, #hirrr$v_astrr, r0	; shift to correct spot
	and	r0, #^xF, r0		; clean to just asten
	 hw_rei				; back to user
	END_PAL_ROUTINE		MFPR_ASTSR



.sbttl MxPR FEN - PALcode for MxPR FEN

;+
; MxPR FEN
;
; Entry:
;	Vectored into via hardware PALcode instruction dispatch
;	PALcode enviornment set up.
;
;	r16 -> new FEN for MTPR
;
; Function:
;	MFPR - return FEN 
;	MTPR - set new FEN
;	
; Returns:
;	FEN in R0
;-
	START_PAL_ROUTINE	MFPR_FEN; 6 cycles
	mf	r0, pt2			; get iccsr
	 srl	r0, #iccsrw$v_fpe, r0	; get fen
	and	r0, #1, r0		; clean fen
	 hw_rei				; back to user
	END_PAL_ROUTINE		MFPR_FEN



	START_PAL_ROUTINE	MTPR_FEN, longflow=1; 13 cycles
	mf	r17, pt31		; Get current PCBB 
	 and	r16, #1, r16		; clean it
	mf	r0, pt2			; get iccsr/datafx
	 or	r31, #1, r1		; get a one
	stl/p	r16, pcb$q_fen(r17)	; set fen
	 sll	r1, #iccsrw$v_fpe, r1	; shift to pos
	sll	r16, #iccsrw$v_fpe, r16 ; position the data
	 bic	r0, r1, r0		; clear out current fen bit
	bis	r0, r16, r0		; set new fen bit
	 mt	r0, pt2_iccsr		; store back into chip
	mf	r1, pt2			; 4 cycle stall
	pvc$violate	139		; pvc does not under stand this stall.
	 mf	r1, pt2			; 4 cycle stall
	and	r1, r1, r1		; ... part 2
	pvc$violate	77		; pvc does not under stand this stall.
	 hw_rei				; back to user
	END_PAL_ROUTINE		MTPR_FEN



.sbttl MTPR IPIR - PALcode for MTPR IPIR

;+
; MTPR IPIR
;
; Entry:
;	Vectored into via hardware PALcode instruction dispatch
;	PALcode enviornment set up.
;
;	r16 -> proc number to interrupt
;
; Function:
;	interrupt proc number r16
;	
;-

	START_PAL_ROUTINE	MTPR_IPIR, longflow=1
	.if ne	adu_system
	and	r16, #15, r0		; get proc to interrupt's whami
	 sll	r0, #tv$v_node, r1	; shift to make tv node number
	subq	r31, #1, r17		; get io space indicator
	 sll	r17, #tv$v_space, r17	; shift io space indicator
	or	r17, r1, r17		; now have base addr of board
	get_addr r17, <tv$v_cpu_irr>, r17; merge in cpu IRR addr

	or	r31, #1, r1		; get a one
	sll	r1, #tv$v_cpu_isr_proc, r1; move to interproc
	stq/p	r1, (r17)		; set the interrupt request
	mb
	.endc
	.if ne	generic_system
	.endc
	.if ne	sable_system
	and	r16, #3, r17		; Get processor number to request
	lda	r17, ^x380(r17)		; Write 38x000160
	sll	r17, #24, r17		;
	lda	r1, 1(r31)		; Get bit to set
	stq/p	r1, ^x160(r17)		; Set the IP interrupt request
	mb				; Make sure it goes out
	.endc
	stall	1
	 hw_rei				; back to user
	END_PAL_ROUTINE	MTPR_IPIR


.sbttl MxPR IPL - PALcode for MFPR IPL

;+
; MxPR IPL
;
; Entry:
;	Vectored into via hardware PALcode instruction dispatch
;	PALcode enviornment set up.
;
;	r16 -> for MTPR new IPL
;
; Function:
;	MTPR set new ipl
;	MFPR get current ipl
;-


	START_PAL_ROUTINE	MFPR_IPL; 6 cycles
	mf	r0, pt9			; get current ps
	 srl	r0, #ps$v_ipl, r0	; get ipl to bit 0
	and	r0, #<ps$m_ipl@<-ps$v_ipl>>, r0 ; clean to just ipl
	 hw_rei				; back to user
	END_PAL_ROUTINE		MFPR_IPL




	START_PAL_ROUTINE	MTPR_IPL, longflow=1; 13 cycles
	mf	r0, pt9			; get old ipl
	.if ne	cfw_system
	mf	r17, pt8		; Get base of IPL table
	s8addq	r16, r17, r17		; Multiply by 8 for quadword index
	sll	r16, #ps$v_ipl, r1	; Move IPL to IPL field
	ldq/p	r17, (r17)		; Get the HW and SW enable bits
	.iff
	.if ne	low_core_ipl
	 s8addq	r16, r31, r17		; x8 for quadword index
	sll	r16, ps$v_ipl, r1	; move ipl to its field
	 ldq/p	r17, Pal$IplTbl(r17)	; get new hw&sw masks
	.iff
	 mf	r17, pal_base		; get pal base
	sll	r16, ps$v_ipl, r1	; move ipl to its field
	 s8addq	r16, r17, r17		; x8 for quadword index
	sget_addr r17, <pal$IplTblHi-pal$start>,r17; get addr of enable bits
	 ldq/p	r17, (r17)		; get new hw&sw masks
	.endc
	.endc

	zap	r0, ^x2, r16		; clear out <15:8> ipl 
	 extbl	r0, #1, r0		; get ipl to <0>
	or	r1, r16, r16		; make new ps
	 mt	r16, pt9		; load saved PS, real ps did not change
	mt	r17, hier		; turn on hw ints
	 mt	r17, sier		; and the software ones
	.if ne lca4
	mf	r16, pt25		; get MCES
	and	r17, hierw$m_cre, r17	; isolate CRE bit
	srl	r16, <pt25$v_dpc - hierw$v_cre>, r16 ; move DPC to hierw<cre> pos
	CONT_PAL_ROUTINE	MTPR_IPL
	bic	r17, r16, r16		; hierw<cre> & !mces<dpc>
	get_high_addr r17, mem$csr_base
	xor	r16, hierw$m_cre, r16	; toggle it
	sll	r16, <esr$v_ice-hierw$v_cre>, r16  ; move it into position
	stq/p	r16, mem$q_esr(r17)	; write ICE
	.if ne	medulla_system
	; we enforce the IPL value via the SIO/VIP int masks
	mt	r12, pt12		; save
	mt	r13, pt13		; save
	mt	r14, pt14		; save
	mt	r15, pt15		; save
	stall	3
	mf	r15, pt9		; get current ps
	srl	r15, #ps$v_ipl, r15	; get ipl to bit 0
	and	r15, #<ps$m_ipl@<-ps$v_ipl>>, r15 ; clean to just ipl
	pvc$jsr		medmskint5, bsr=1
	bsr	r13, medu$mask_ints_all	; mask ints at SIO & VIP
	mf	r15, pt15		; restore
	mf	r14, pt14		; restore
	mf	r13, pt13		; restore
	mf	r12, pt12		; restore
	.endc
	.iff
	stall	3			; required stall
	.endc
	 hw_rei				; and back to user

	assume ps$v_ipl eq 8		; ps<ipl> starts at 8
	END_PAL_ROUTINE		MTPR_IPL



.sbttl MxPR MCES - PALcode for MxPR MCES

;+
; MxPR MCES
;
; Entry:
;	Vectored into via hardware PALcode instruction dispatch
;	PALcode enviornment set up.
;
;
; Function:
;	MFPR - return MCES
;	MTPR - clear MCES if r16<0> = 1
;	
; Returns:
;
;-
	START_PAL_ROUTINE	MFPR_MCES; 6 cycles
	mf	r0, pt25		; get MCES
	 srl	r0, #pt25$v_mck, r0	; get mces to <0>
	and	r0, #^x1f, r0		; clean to just mces bits
	 hw_rei				; back to user
	END_PAL_ROUTINE		MFPR_MCES



	START_PAL_ROUTINE	MTPR_MCES, longflow=1; 11 cycles
	mf	r1, pt25		; get mces and timerintp
	 and	r16, #7, r0		; isolate
	bis	r0, #3@3,r0		; add clear pcl/scl bits
	 sll	r0, #pt25$v_mck, r0	; move to position
	bic	r1, r0, r1		; clear mces
	 and	r16, #3@3, r0		; isolate pcl/scl
	sll	r0, #pt25$v_mck, r0	; move to position
	 bis	r1, r0, r1		; set mces pcl/scl
	mt	r1, pt25		; set MCES

	; set CRD interrupt state based on MCES<DPC>
	.if ne lca4
	srl	r1, <pt25$v_dpc - hierr$v_cre>, r0 ; move DPC to hierr<cre> pos
	mf	r16, hier		; get hier
	bic	r16, r0, r0		; hierr<cre> & !mces<dpc>
	get_high_addr r16, mem$csr_base
	and	r0, <1@hierr$v_cre>, r0	; isolate CRE bit
	CONT_PAL_ROUTINE	MTPR_MCES
	xor	r0, <1@hierr$v_cre>, r0	; toggle it
	sll	r0, <esr$v_ice-hierr$v_cre>, r0  ; move it into position
	stq/p	r0, mem$q_esr(r16)	; write ICE
	.iff
	 srl	r1, #<pt25$v_dpc-abox$v_crd>, r0; get DPC bit to right spot
	mf	r16, pt7		; get addr of impure area
	 and	r0, #<1@abox$v_crd>, r0	; isolate it
	ldq/p	r1, cns$abox_ctl(r16)	; get abox_ctl
	 xor	r0, #<1@abox$v_crd>, r0	; flip it
	bic	r1, #<1@abox$v_crd>, r1	; clear out old CRD
	 CONT_PAL_ROUTINE	MTPR_MCES
	bis	r1, r0, r1		; merge in new CRD
	 mt	r1, abox_ctl		; set new abox_ctl
	stq/p	r1, cns$abox_ctl(r16)	; update saved abox_ctl
	.endc
	 hw_rei				; back to user
	END_PAL_ROUTINE		MTPR_MCES






.sbttl MFPR PCBB - PALcode for MFPR PCBB

;+
; MFPR PCBB
;
; Entry:
;	Vectored into via hardware PALcode instruction dispatch.
;	PALcode enviornment set up.
;
; Function:
;	MFPR get current pcbb
;-
	START_PAL_ROUTINE	MFPR_PCBB; 2 cycles
	mf	r0, pt31		; get pcbb address
	unvirtualize r0, r1
	 hw_rei				; back to user
	END_PAL_ROUTINE		MFPR_PCBB


.sbttl	MxPR PRBR - PALcode for MxPR PRBR

;+
; MxPR PRBR
;
; Entry:
;	Vectored into via hardware PALcode instruction dispatch.
;	PALcode enviornment set up.
;
;	r16 -> new prbr for mtpr
;
; Function:
;	MFPR get current prbr
;	MTPR set new prbr
;-

	START_PAL_ROUTINE	MFPR_PRBR; 2 cycles
	mf	r0, pt24		; get prbr
	 hw_rei				; back to user
	END_PAL_ROUTINE		MFPR_PRBR



	START_PAL_ROUTINE	MTPR_PRBR; 2 cycles
	mt	r16, pt24		; set prbr
	 hw_rei				; back to user
	END_PAL_ROUTINE		MTPR_PRBR




.sbttl MFPR PTBR - PALcode for MFPR PTBR

;+
; MFPR PTBR
;
; Entry:
;	Vectored into via hardware PALcode instruction dispatch
;	PALcode enviornment set up.
;
; Function:
;	MFPR get current ptbr
;-

	START_PAL_ROUTINE	MFPR_PTBR; 4 cycles
	mf	r0, pt28		; get ptbr address
	unvirtualize r0, r1
	 stall	1,mxpr=0		; stall for alignment
	srl	r0, #page_offset_size_bits, r0 ; convert from PA to pfn
	 hw_rei				; back to user
	END_PAL_ROUTINE		MFPR_PTBR

.sbttl	MxPR SCBB - PALcode for MxPR SCBB

;+
; MxPR SCBB
;
; Entry:
;	Vectored into via hardware PALcode instruction dispatch
;
;	r16 -> new SCBB for mtpr
;
; Function:
;	MFPR get current scbb to R0
;	MTPR set new scbb
;-
	START_PAL_ROUTINE	MFPR_SCBB; 4 cycles
	mf	r0, pt30		; get the SCBB
	 stall	1,mxpr=0		; stall for alignment
	unvirtualize r0, r1
	srl	r0, #page_offset_size_bits, r0 ; convert from PA to pfn
	 hw_rei				; back to user
	END_PAL_ROUTINE		MFPR_SCBB


	START_PAL_ROUTINE	MTPR_SCBB; 6 cycles
	zapnot	r16, #^xf, r16		; clear off high long
	 sll	r16, #page_offset_size_bits, r0 ; convert from pfn to PA
	virtualize r0, r1
	mt	r0, pt30		; set the new SCBB
	hw_rei				; back to user
	END_PAL_ROUTINE		MTPR_SCBB

.sbttl MTPR SIRR - PALcode for MTPR SIRR

;+
; MTPR SIRR
;
; Entry:
;	Vectored into via hardware PALcode instruction dispatch
;
;	r16<3:0> = level to request int for
;
; Function:
;	Requerst an int for the level in r16<3:0>
;-

	START_PAL_ROUTINE	MTPR_SIRR, longflow=1; 17 cycles
	mf	r0, sirr		; get int bits
	 and	r16, #^xF, r16		; Get sirr number
	addq	r16, #<hirrw$v_sirr-1>, r17; add sirr base
	 or 	r31, #1, r1		; get a one
	sll	r1, r17, r1		; get bit to set
	 mf	r17, pt25		; fetch misc flags
	sll	r0, #<hirrw$v_sirr-hirrr$v_sirr>, r0; get to correct spot for write
	 or	r1, r0, r0		; merge
	mt	r0, sirr		; set int bits
	 cmpbge	r16, r17, r1		; is new gtr than old
	and	r1, #1, r1		; isolate bit 0
	 zap	r17, r1, r0		; remove old request
	cmovlbc r1, r17, r16		; new is lower, use the old
	 or	r0, r16, r17		; build new flags
	mt	r17, pt25		; and store it away
	 hw_rei				; back to user
	END_PAL_ROUTINE		MTPR_SIRR




.sbttl MFPR SISR - PALcode for MFPR SISR

;+
; MFPR SISR
;
; Entry:
;	Vectored into via hardware PALcode instruction dispatch
;
; Function:
;	return SISR in R0
;-
	START_PAL_ROUTINE	MFPR_SISR; 5 cycles
	mf	r0, sirr		; get interrupt request data
	 get_addr r1, <hirrr$m_sirr>, r31	; cleaning mask
	 and	r0, r1, r0		; clean off junk
	srl	r0, #<hirrr$v_sirr-1>, r0; shift to correct spot
	 hw_rei				; back to user
	END_PAL_ROUTINE		MFPR_SISR


.sbttl MFPR TBCHK - PALcode for MFPR TBCHK

;+
; MTPR TBCHK
;
; Entry:
;	Vectored into via hardware PALcode instruction dispatch
;
;	r16 = va to check
;
; Function:
;	return TBCHK in R0 (constant)
;-
	START_PAL_ROUTINE	MFPR_TBCHK; 2 cycles
	or	r31, #1, R0		; get a one
	 stall	1			; stall for alignment
	sll	r0, #63, r0		; and set not imp 
	 hw_rei				; back to user
	END_PAL_ROUTINE		MFPR_TBCHK


.sbttl MTPR TBIx - PALcode for MFPR TBIx

;+
; MTPR TBIx
;
; Entry:
;	Vectored into via hardware PALcode instruction dispatch
;
;	r16 -> VA for TBIS
;
; Function:
;	Flush translation buffers all/single/asm
;-

	START_PAL_ROUTINE	MTPR_TBIA, longflow=1; 9 cycles
	mt	r31, flush_ic		; flush the icache
	 mt	r31, xtbzap		; clear the tb's
	stall	<9-1>			; required stall
	hw_rei				; back to user
	END_PAL_ROUTINE		MTPR_TBIA

	START_PAL_ROUTINE	MTPR_TBIAP, longflow=1; 9 cycles
	mt	r31, flush_ic_asm	; flush the icache_asm
	 mt	r31, xtbasm		; clear the tb's 
	stall	<9-1>			; required stall
	hw_rei				; back to user
	END_PAL_ROUTINE		MTPR_TBIAP

	START_PAL_ROUTINE	MTPR_TBIS, longflow=1; 9 cycles
	mt	r31, flush_ic		; flush the icache
	 mt	r16, dtbis		; clear the tb's
	mt	r16, itbis		; clear the tb's
	 stall	<9-2>			; required stall
	hw_rei				; back to user
	END_PAL_ROUTINE		MTPR_TBIS


	START_PAL_ROUTINE	MTPR_TBISD; 3 cycles
	mt	r16, dtbis		; clear the tb's
	 stall	1			; required stall
	hw_rei				; back to user
	END_PAL_ROUTINE		MTPR_TBISD


	START_PAL_ROUTINE	MTPR_TBISI, longflow=1; 9 cycles
	mt	r31, flush_ic		; flush the icache
	 mt	r16, itbis		; clear the tb's
	stall	<9-1>			; required stall
	hw_rei				; back to user
	END_PAL_ROUTINE		MTPR_TBISI





.sbttl MxPR xSP - PALcode for MxPR xSP

;+
; MxPR xSP
;
; Entry:
;	Vectored into via hardware PALcode dispatch
;	PT31 -> PCBB
;	r16 -> new SP for MTPR xSP
;
; Function:
;	Read/Write outer mode stacks
;-
	START_PAL_ROUTINE	MFPR_ESP; 5 cycles
	mf	r0, pt31		; Get PCBB 
	 ldq/p	r0, pcb$q_esp(r0)	; get the ESP
	hw_rei				; back to user
	END_PAL_ROUTINE		MFPR_ESP

	START_PAL_ROUTINE	MTPR_ESP; 5 cycles
	mf	r0, pt31		; Get PCBB 
	stq/p	r16, pcb$q_esp(r0)	; set the new ESP
	 hw_rei				; back to user
	END_PAL_ROUTINE		MTPR_ESP



	START_PAL_ROUTINE	MFPR_SSP; 5 cycles
	mf	r0, pt31		; Get PCBB 
	 ldq/p	r0, pcb$q_ssp(r0)	; get the SSP
	hw_rei				; back to user
	END_PAL_ROUTINE		MFPR_SSP

	START_PAL_ROUTINE	MTPR_SSP; 5 cycles
	mf	r0, pt31		; Get PCBB 
	 stq/p	r16, pcb$q_ssp(r0)	; set the new SSP
	hw_rei				; back to user
	END_PAL_ROUTINE		MTPR_SSP



	START_PAL_ROUTINE	MFPR_USP; 5 cycles
	mf	r0, pt31		; Get PCBB 
	 ldq/p	r0, pcb$q_usp(r0)	; get the USP
	hw_rei				; back to user
	END_PAL_ROUTINE		MFPR_USP

	START_PAL_ROUTINE	MTPR_USP; 5 cycles
	mf	r0, pt31		; Get PCBB 
	 stq/p	r16, pcb$q_usp(r0)	; set the new USP
	hw_rei				; back to user
	END_PAL_ROUTINE		MTPR_USP


.sbttl MFPR WHAMI - PALcode for MFPR WHAMI

;+
; MTPR WHAMI
;
; Entry:
;	Vectored into via hardware dispatch
;
; Function:
;	return WHAMI in R0
;-

	START_PAL_ROUTINE	MFPR_WHAMI; 4 cycles
	.if ne	adu_system
	mf	r0, pt27		; Get WHAMI
	 stall	1,mxpr=0		; stall for alignment
	and	r0, #^xff, r0		; isolate whami
	 hw_rei				; back to user
	.endc
	.if ne	cfw_system
	mf	r0, pt27		; Get WHAMI
	hw_rei				; Return back to user
	.endc
	END_PAL_ROUTINE		MFPR_WHAMI


.sbttl MxPR VPTBASE - PALcode for MxPR VPTBASE

;+
; MxPR VPTBASE
;
; Entry:
;	Vectored into via hardware dispatch
;
; Function:
;
;-

	START_PAL_ROUTINE	MFPR_VPTBASE; 2 cycles
	mf	r0, pt29	; Get VPTEBASE
	 stall	1, mxpr=0	; stall for scheduling
	bic	r0, #1, r0	; clean vptbase
	 hw_rei			; back to user
	END_PAL_ROUTINE		MFPR_VPTBASE

	START_PAL_ROUTINE	MTPR_VPTBASE; 3 cycles
	bic	r16, #1, r16	; clean vptbase
	 mt	r16, pt29	; Set VPTEBASE
	hw_rei			; back to user
	END_PAL_ROUTINE		MTPR_VPTBASE



	.if ne	cfw_system
	.iff
.sbttl CSERVE - PALcode for CSERVE

;+
; CSERVE
;
; Entry:
;	Vectored into via hardware dispatch
;
; Function:
;	Various functions for private use of console software
;
;	option selector in r0
;	arguments in r16....
;
;
;	r0 = 0	unknown
;
;	r0 = 1	ldqp
;	r0 = 2	stqp
;		args, are as for normal STQP/LDQP in VMS PAL
;
;	r0 = 3	dump_tb's
;	r16 = detination PA to dump tb's to.
;
;	r0<0> = 1, success
;	r0<0> = 0, failure, or option not supported
;	r0<63:1> = (generally 0, but may be function dependent)
;
;
;
;
;-

	START_PAL_ROUTINE	CSERVE, longflow=1;
	.if ne	adu_system
	mt	r12, pt12
	cmpeq	r0, #1, r12		; check for ldqp
	bne	r12, 10$		; br if
	cmpeq	r0, #2, r12		; check for stqp
	bne	r12, 20$		; br if
	cmpeq	r0, #3, r12		; check for dump_tb's
	bne	r12, 30$		; br if
	or	r31, r31, r0		; set failure
	mf	r12, pt12
	hw_rei				; and back we go
	

	CONT_PAL_ROUTINE	CSERVE, ibr=0

; ldqp
	.align	quad
10$:
	.if ne virtualize_memory
	  stall	1
	  virtualize r16, r0, swap=1
	  cmovlt	r16, r16, r0	; don't virtualize io space
	  ldq/p	r0, (r0)		; get the data
	.iff
	  ldq/p	r0, (r16)		; get the data
	.endc
	mf	r12, pt12
	hw_rei				; and back we go

; stqp
	.align	quad
20$:
	.if ne virtualize_memory
	  virtualize r16, r12, swap=1
	  cmovlt     r16, r16, r12	; don't virtualize io space
	  stq/p	r17, (r12)		; store the data
	.iff
	  stq/p	r17, (r16)		; store the data
	.endc
	or	r31, #1, r0		; set success
	mf	r12, pt12
	hw_rei				; and back we go



; dump tb's
	.align	quad
30$:
	; DTB PTEs - 32 with full granularity hints
	mt	r31, dtb_ctl		; select small pages
	addq	r31, #32, r0		; initialize loop counter
31$:	mf	r12 ,dtb_pte		; read out next sp pte
	stall	2
	mf	r12, dpte_temp		; read out next sp pte
	stq/p	r12, (r16)		; store out PTE
	addq	r16, #8 ,r16		; increment pointer
	subq	r0, #1, r0		; decrement loop counter
	bne	r0, 31$


	; small page ITB PTEs - 8 entries
	mt	r31, dtb_ctl		; select small pages
	stall	1			; setup lp/sp decode
	addq	r31, #8, r0		; initialize loop counter
32$:	mf	r12, itb_pte		; read out next sp pte
	stall	3
	mf	r12, ipte_temp		; read out next sp pte
	stq/p	r12, (r16)		; store out PTE
	addq	r16, #8, r16		; increment pointer
	subq	r0, #1, r0		; decrement loop counter
	bne	r0, 32$


	; large page ITB PTEs - 4 entries
	subq	r31, #1, r0		;
	mt	r0, dtb_ctl		; select large pages
	stall	1			; setup lp/sp decode
	addq    r31, #4, r0		; initialize loop counter
33$:	mf	r12, itb_pte		; read out next lp pte
	stall	3
	mf	r12, ipte_temp		; read out next lp pte
	stq/p	r12, (r16)		; store out PTE
	addq	r16, #8, r16		; increment pointer
	subq	r0, #1, r0		; decrement loop counter
	bne	r0, 33$
	or	r31, #1, r0		; set success
	mf	r12, pt12
	hw_rei				; and back we go
	.iff
	stall	1
	hw_rei
	.endc

	END_PAL_ROUTINE		CSERVE
	.endc


.sbttl MTPR PERFMON - PALcode for MTPR PERFMON

;+
; MTPR PERFMON
;
; Entry:
;	Vectored into via hardware dispatch
;
; Function:
;	Various control functions for the onchip performance counters
;
;	option selector in r16
;	option argument in r17
;	returned status in r0
;
;
;	r16 = 0	Disable performance monitoring for one or more cpu's
;	  r17 = na (or cpu specific data)
;
;	r16 = 1	Enable performance monitoring for one or more cpu's
;	  r17 = na (or cpu specific data)
;
;	r16 = 2	Mux select for one or more cpu's
;	  r17 = mux ctl (cpu specific)
;
;	r16 = 3	Options
;	  r17 = (cpu specific)
;		<0> = log all processese
;		<1> = log only selected processese
;
;	r16 = 4	Start/Stop debug counters
;	  r17 = (cpu specific)
;		<0> = 0, continue debug counters
;		<0> = 1, pause debug counters
;		<63:1> MBZ
;
;	r16 = 5	Reload debug area base/limit
;	  r17 = 
;		<63:32> limit bit mask
;		<63:32> area pa
;
;	r0<0> = 1, success
;	r0<0> = 0, failure, or option not supported
;	r0<63:1> = (generally 0, but may be function dependent)
;			if r16=4, then = phy addr of log area
;
;
;
;
;
;
;-

	START_PAL_ROUTINE	MTPR_PERFMON, longflow=1; ? cycles
	mt	r12, pt12
	 beq	r16, 10$		; br if requested to disable?
	cmpeq	r16, #1, r0		; check for enable
	 bne	r0, 20$			; br if requested to enable?
	cmpeq	r16, #3, r0		; check for options
	 bne	r0, 30$			; br if request to set options?
	.if ne <enable_debug_pctrace ! enable_debug_pcevent>
	cmpeq	r16, #4, r0		; check for debug count pause/cont
	 bne	r0, 40$			; br if request to pause/cont?
	cmpeq	r16, #5, r0		; check for reload debug counters base
	 bne	r0, 50$			; br if request to reload
	.endc
	cmpeq	r16, #2, r0		; check for mux ctl
	 beq	r0, 19$			; br if unknown request

; mux ctl
	mf	r12, pt2		; get current iccsr
	lda	r16, <<^XF@ICCSRW$V_MUX0>!<1@ICCSRW$V_PC0>!<1@ICCSRW$V_PC1>>(R31)
	lda	r0, <^X7@<ICCSRW$V_MUX1-32>>(r31) ; get the rest
	sll	r0, #32, r0		; move to correct spot
	or	r0, r16, r16		; build cleaning mask
	and	r17, r16, r17		; clean request mask
	bic	r12, r16, r12		; remove old data from iccsr
	CONT_PAL_ROUTINE	mtpr_perfmon
	or	r12, r17, r12		; insert new stuff into iccsr
	mt	r12, pt2_iccsr		; update iccsr
	or	r31, #1, r0		; set success
	mf	r12, pt12
	pvc$violate	77		; disable rule checker on the hw_rei
	 hw_rei				; back to user



; requested to disable perf monitoring
	.align	quad
10$:
	.if	ne low_core_ipl
	  mf	r12, pal_base		; get pal base
	  lda	r17, Pal$IplTbl(r31)	; get addr of ipl table
	.iff
	 mf	r12, pal_base		; get pal base
	 sget_addr r17, <pal$IplTblHi-pal$start>,r12; get addr of ipl table
	.endc

	get_addr r16, <<1@HIERW$V_PC0>!<1@HIERW$V_PC1>>, r31; get pc bits
	.if ne	cfw_system
	.iff
	get_addr r12, <pal$rei_nhier-pal$start>, r12; get addr of hier jammer in rei

	ldl/p	r0, (r12)		; get the lda
	ldl/p	r1, 4(r12)		; get the ldah
	bic	r0, r16, r0		; disable the perfmon int's
	bic	r1, #1, r1		; kill the sign extend fixup
	stl/p	r0, (r12)		; set the lda
	stl/p	r1, 4(r12)		; set the ldah
	mb
	mb				; make sure the data gets to memory
	mt	r31, flush_ic		; flush the icache
	.endc


	or	r31, #29, r0		; get loop count
15$:	ldq/p	r12, (r17)		; fetch current entry
	bic	r12, r16, r12		; set the enable bits on
	stq/p	r12, (r17)		; store the new bits
	.if ne	sable_system
	ldq/p	r12, ^x200(r17)		; fetch current entry
	bic	r12, r16, r12		; set the enable bits on
	stq/p	r12, ^x200(r17)		; store the new bits
	.endc
	addq	r17, #8, r17		; bump ptr to next entry
	subq	r0, #1, r0		; dec counter
	bne	r0, 15$			; keep looping
	mb
	mb				; make sure the data gets to memory
	or	r31, #1, r0		; set success
19$:	mf	r12, pt12
	 hw_rei				; back to user





; requested to enable perf monitoring
	.align	quad
20$:
	.if	ne low_core_ipl
	  lda	r17, Pal$IplTbl(r31)	; get addr of ipl table
	  mf	r12, pal_base		; get pal base
	.iff
	 mf	r12, pal_base		; get pal base
	 sget_addr r17, <pal$IplTblHi-pal$start>,r12; get addr of ipl table
	.endc

	get_addr r16, <<1@HIERW$V_PC0>!<1@HIERW$V_PC1>>, r31; get pc bits
	.if ne	cfw_system
	.iff
	get_addr r12, <pal$rei_nhier-pal$start>, r12; get addr of hier jammer in rei

	ldl/p	r0, (r12)		; get the lda
	ldl/p	r1, 4(r12)		; get the ldah
	bis	r0, r16, r0		; enable the perfmon int's
	bis	r1, #1, r1		; set the sign extend fixup
	stl/p	r0, (r12)		; set the lda
	stl/p	r1, 4(r12)		; set the ldah
	mb
	mb				; make sure the data gets to memory
	mt	r31, flush_ic		; flush the icache
	.endc

	or	r31, #29, r0		; get loop count
25$:	ldq/p	r12, (r17)		; fetch current entry
	bis	r12, r16, r12		; set the enable bits on
	stq/p	r12, (r17)		; store the new bits
	.if ne	sable_system
	ldq/p	r12, ^x200(r17)		; fetch current entry
	bis	r12, r16, r12		; set the enable bits on
	stq/p	r12, ^x200(r17)		; store the new bits
	.endc
	addq	r17, #8, r17		; bump ptr to next entry
	subq	r0, #1, r0		; dec counter
	bne	r0, 25$			; keep looping
	mb
	mb				; make sure the data gets to memory
	or	r31, #1, r0		; set success
	mf	r12, pt12
	hw_rei				; back to user


; options...
	.align	quad
30$:	mf	r0, pt2			; get options from iccsr
	and	r17, #3, r17		; isolate perfmon enable bits
	lda	r1, 3(r31)		; get bits
	sll	r1, #iccsrw$v_pme0, r1	; shift to position
	bic	r0, r1, r0		; clear out old pme bits
	sll	r17, #iccsrw$v_pme0, r17; shift options to position
	or	r0, r17, r0		; merge in new pme bits
	mt	r0, pt2_iccsr		; set the new options
	or	r31, #1, r0		; set return status
	mf	r12, pt12
	pvc$violate	77		; disable rule checker on the hw_rei
	hw_rei				; back to user

	.if ne <enable_debug_pctrace ! enable_debug_pcevent>
; debug counters pause/continue...
	.align	quad
40$:	mf	r0, pt11		; get current pos
	and	r17, #1, r17		; get pause bit
	bic	r0, #1, r0		; clear out current pauser
	bis	r0, r17, r0		; set current pauser
	mt	r0, pt11		; set the new options
	or	r0, #1, r0		; set return status
	unvirtualize r0, r17
	mf	r12, pt12
	 hw_rei			; back to user


; reset debug counters base/limit
	.align	quad
50$:	mf	r12, pt11		; get current location
	or	r17, r31, r0		; get a copy of addr
	virtualize r0, r1		; virtualize the PA
	mt	r0, pt11		; get current pos
	
	.if ne <enable_debug_pcevent>
	addl	r0, #0, r0		; get new ptr
	bic	r0, #7, r0		; align it

	lda	r17, <$$debug_boot$$last*16>(r31); get size of perf data area
	stq/p	r17, (r0)		; set lenght of data structure

	mf	r12, pal_base		; initialize PAL_BASE
	get_addr r17, <patch$jam_addrs-pal$start>, r12 ; get addr of text data
	ldl/p	 r17, <3*4>(r17)	; get offset to text
	addq	r12, r17, r17		; now is read addr
	stq/p	r17, 8(r0)		; set PA of text it in new structure
	.endc
	or	r31, #1, r0		; set return status
	mf	r12, pt12
	 hw_rei				; back to user

	.endc


.iif ndf perfmon_support1, .print 0 ; Required PERFMON interrupt support not included.
.iif ndf perfmon_support2, .print 0 ; Required PERFMON interrupt support not included.
	END_PAL_ROUTINE		MTPR_PERFMON


.sbttl AMOVRR - PALcode for AMOVRR

;+
; AMOVRR
;
; Entry:
;	Vectored into via hardware dispatch
;
; Function:
;
;-

	START_PAL_ROUTINE	AMOVRR, longflow=1; ? cycles
	mt	r12, pt12
	 mf	r12, exc_addr		; get address of PAL call
	mt	r13, pt13
	 rc	r13			; check intr_flag
	mt	r14, pt14
	 bic	r12, #3, r12		; make sure <1:0> are clear for flag
	mt	r15, pt15
	 cmoveq	r13, r31, r18		; if intr_flag = 0, set r18=0

	mt	r18, pt18
	 sget_addr r14, <pal$queue_fault_setup3nl-pal$start>, r31; get address
	 
	
	and	r21, #^x3, r21		; ensure that r21, stays in range
	 beq	r13, 90$		;    and exit
	mt	r14, pt3		; set recovery address



	; probe the first write
	 or	r31, #1, r14		; get a one
	ldl/w	r15, (r17)		; probe first data

	; probe the second write
	 CONT_PAL_ROUTINE	amovrr, DOUBLE=1
	ldl/w	r15, (r20)		; probe second datum, part 1

	; see if data is aligned
	; if not, go do the second half of the probes and
	; load the data the sloooow way.
	and	r21, #3,  r21		; clear unused bits of r21 (used as flag)
	and	r18, #3,  r18		; clear unused bits of r18
	sll	r14, r18, r14		; get size of data
	subq	r14, #1, r14		;  minus one.
	and	r17, r14, r15		; or the low bits of the addr
	bne	r15, 30$		; br if this access would be unaligned

	or	r31, #1, r14		; get a one
	sll	r14, r21, r14		; get size of data
	subq	r14, #1, r14		;  minus one.
	and	r20, r14, r15		; or the low bits of the addr
	bne	r15, 40$		; br if this access would be unaligned



	; probes have completed, we have now crossed the point of no return
	; the only tolerable mm error allowed now is TNV, and on that
	; we will "fix up" the tb entry and continue.

	debug_mp_queue 			; if mp queue debug, zap dtb's
	sget_addr r13, <pal$queue_fault3-pal$start>, r31; get address
	mt	r13, pt3		; set recovery address

	; branch to correct rtn
	align_branch_target
10$:	lda	r15, ldxl_stxc_retry_count(r31)
	 mt	r15, pt16		; save retry count
	beq	r18, lock_amovrrb	; br if byte access
	 subq	r18, #2, r15		; is access long?
	beq	r15, lock_amovrrl	; br if long access
	 subq	r18, #1, r15		; is access word?
	beq	r15, lock_amovrrw	; br if word access
;;;	 subq	r18, #3, r15		; is access quad?
;;;	beq	r15, lock_amovrrq	; br if quad access

	
	; access is quadword
lock_amovrrq:
	or	r16, r31, r18		; get data to r18
	stq	r18, (r17)		; store the data, no lock needed
	br	r31, 20$		; on to next access


	; access is byte
	.align	quad
lock_amovrrb:
	or	r16, r31, r18		; get data to r18
	and	r17, #3, r13		; get low bits of address
	or	r31, #1, r15		; get a one
	sll	r15, r13, r15		; now is a 1 in position for zap
	insbl	r18, r13, r18		; reposition data
	bic	r17, #3, r14		; get aligned long addr
	ldl_l	r13, (r14)		; fetch data, and lock it
	zap	r13, r15, r13		; remove old data
	or	r13, r18, r13		; merge new and old data
	debug_mp_store r13, r17		; if mp debug, sometimes fail the _c
	stl_c	r13, (r14)		; store the data, undo the lock
	blbc	r13, retry_lock_amovrrb ; failed to lock => retry
	br	r31, 20$		; on to next access


	; access is word
	.align	quad
lock_amovrrw:
	or	r16, r31, r18		; get data to r18
	and	r17, #3, r13		; get low bits of address
	or	r31, #3, r15		; get a 3
	sll	r15, r13, r15		; now is a 3 in position for zap
	inswl	r18, r13, r18		; reposition data
	bic	r17, #3, r14		; get aligned long addr
	ldl_l	r13, (r14)		; fetch data, and lock it
	zap	r13, r15, r13		; remove old data
	or	r13, r18, r13		; merge new and old data
	debug_mp_store r13, r17		; if mp debug, sometimes fail the _c
	stl_c	r13, (r14)		; store the data, undo the lock
	blbc	r13, retry_lock_amovrrw ; failed to lock => retry
	br	r31, 20$		; on to next access


	; access is longword
	.align	quad
lock_amovrrl:
	or	r16, r31, r18		; get data to r18
	stl	r18, (r17)		; store the data, no lock needed
;	br	r31, 20$		; on to next access


	; first store has completed, now on to the second set
	align_branch_target
20$:	blt	r21, 100$		; br if all done
	or	r19, r31, r16		; make second write, look like first
	or	r20, r31, r17
	or	r21, r31, r18
	subq	r31, #1,  r21		; set "in part 2" flag
	br	r31, 10$		; and go do part 2, just like part 1


; unaligned amovrr
	.align	quad
30$:	; probe the first write, part 2
	addq	r14, r17, r15		; get addr of part 2
	ldl/w	r15, (r15)		; probe first data

40$:
	; probe the second write, part 2
	or	r31, #1, r14		; get a one
	sll	r14, r21, r14		; get size of data
	addq	r14, r20, r15		; get addr of part 2
	ldl/w	r15, -1(r15)		; probe second datum, part 1



	; probes have completed, we have now crossed the point of no return
	; the only tolerable mm error allowed now is TNV, and on that
	; we will "fix up" the tb entry and continue.

	debug_mp_queue 			; if mp queue debug, zap dtb's
	sget_addr r13, <pal$queue_fault3-pal$start>, r31; get address
	mt	r13, pt3		; set recovery address

	; branch to correct rtn
	align_branch_target
45$:	lda	r15, ldxl_stxc_retry_count(r31)
	 mt	r15, pt16		; save retry count
	beq	r18, lock_amovrrbu	; br if byte access
	 subq	r18, #2, r15		; is access long?
	beq	r15, lock_amovrrlu	; br if long access
	 subq	r18, #1, r15		; is access word?
	beq	r15, lock_amovrrwu	; br if word access
;	 subq	r18, #3, r15		; is access quad?
;	beq	r15, lock_amovrrqu	; br if quad access

	

	; access is unaligned quadword
lock_amovrrqu:
	store_unaligned_quad	r16, r17, r13, r18, r15, lock=1, -
		err=retry_lock_amovrrqu, err1=retry_lock_amovrrqu1
	br	r31, 50$		; on to the next access
	

	; access is byte
	.align	quad
lock_amovrrbu:
	and	r17, #3, r13		; get low bits of address
	or	r31, #1, r18		; get a one
	sll	r18, r13, r18		; now is a 1 in position for zap
	insbl	r16, r13, r15		; reposition data
	bic	r17, #3, r14		; get aligned long addr
	ldl_l	r13, (r14)		; fetch data, and lock it
	zap	r13, r18, r13		; remove old data
	or	r13, r15, r13		; merge new and old data
	debug_mp_store r13, r17		; if mp debug, sometimes fail the _c
	stl_c	r13, (r14)		; store the data, undo the lock
	blbc	r13, retry_lock_amovrrbu; store failed, backout with failure
	br	r31, 50$		; on to the next access



	; access is unaligned word
	.align	quad
lock_amovrrwu:
	store_unaligned_word	r16, r17, r13, r18, r15, lock=1, -
		err=retry_lock_amovrrwu,err1=retry_lock_amovrrwu1
	br	r31, 50$		; on to the next access


	; access is unaligned longword
	.align	quad
lock_amovrrlu:
	store_unaligned_long	r16, r17, r13, r18, r15, lock=1, -
		err=retry_lock_amovrrlu,err1=retry_lock_amovrrlu1
	br	r31, 50$		; on to the next access



	; first store has completed, now on to the second set
	.align	quad
50$:	blt	r21, 100$		; br if all done
	or	r19, r31, r16		; make second write, look like first
	or	r20, r31, r17
	or	r21, r31, r18
	subq	r31, #1,  r21		; set "in part 2" flag
	br	r31, 45$		; and go do part 2, just like part 1


; failure, or success
	align_to_cache_block
90$:	or	r31, r31, r21		; set failure
100$:	cmplt	r21, r31, r18		; set success or failure
	 mt	r12, exc_addr		; set the rei address
	mf	r12, pt12
	 mf	r13, pt13
	mf	r14, pt14
	 mf	r15, pt15
;	mf	r18, pt18		; note, don't unwind r18
	hw_rei				; and back to the user
	



    .macro	retry_lock inst, rn, pstfx
      retry_lock_'inst''pstfx':
      mf	'rn', pt16		; fetch retry counter
      subq	'rn', #1, 'rn'
      mt	'rn', pt16		; update retry counter
      bge	'rn', lock_'inst'
;;;   br	r31, 90$		; too many retries => fall through
;;;   stall	1, mxpr=0
    .endm


    align_to_cache_block
    retry_lock amovrrw,  r13
    bge	r21, 90$			; br if lock fail in first half
    ldl r13, (r14)			; fetch data, and lock it
    zap	r13, r15, r13			; remove old data
    or	r13, r18, r13			; merge new and old data
    stl r13, (r14)			; store the data, undo the lock
    br	r31, 20$			; on to next access


    retry_lock amovrrb,  r13
    bge	r21, 90$			; br if lock fail in first half
    ldl r13, (r14)			; fetch data, and lock it
    zap	r13, r15, r13			; remove old data
    or	r13, r18, r13			; merge new and old data
    stl r13, (r14)			; store the data, undo the lock
    br	r31, 20$			; on to next access


    retry_lock amovrrqu,  r14
      bge r21, 90$
    retry_lock amovrrqu,  r14, pstfx=1
     store_unaligned_quad	r16, (r17), r13, r18, r15
     br	r31, 50$		; on to the next access

    retry_lock amovrrlu,  r14
      bge r21, 90$
    retry_lock amovrrlu,  r14, pstfx=1
     store_unaligned_long	r16, (r17), r13, r18, r15
     br	r31, 50$		; on to the next access

    retry_lock amovrrwu,  r14
      bge r21, 90$
    retry_lock amovrrwu,  r14, pstfx=1
     store_unaligned_word	r16, (r17), r13, r18, r15
     br	r31, 50$		; on to the next access


    retry_lock amovrrbu,  r13
      bge r21, 90$
    ldl r13, (r14)			; fetch data, and lock it
    zap	r13, r15, r13			; remove old data
    or	r13, r18, r13			; merge new and old data
    stl r13, (r14)			; store the data, undo the lock
    br	r31, 50$			; on to the next access




	END_PAL_ROUTINE		AMOVRR

.sbttl AMOVRM - PALcode for AMOVRM

;+
; AMOVRM
;
; Entry:
;	Vectored into via hardware dispatch
;
; Function:
;
;-

	START_PAL_ROUTINE	AMOVRM, longflow=1; ? cycles
	mt	r12, pt12
	 mf	r12, exc_addr		; get address of PAL call
	mt	r13, pt13
	 rc	r13			; check intr_flag
	mt	r14, pt14
	 bic	r12, #3, r12		; make sure <1:0> are clear for flag
	mt	r15, pt15
	 cmoveq	r13, r31, r18		; if intr_flag = 0, set r18=0

	mt	r18, pt18
	 sget_addr r14, <pal$queue_fault_setup3nl-pal$start>, r31; get address
	 
	
	and	r21, #^x3f, r21		; ensure that r21, stays in range
	 beq	r13, 90$		;    and exit
	mt	r14, pt3		; set recovery address



	; probe the first write
	 ldl/w	r15, (r17)		; probe first data

	beq	r21, 5$			; skip probe on data mover if dl=0
	 CONT_PAL_ROUTINE	amovrm, DOUBLE=1

	; perform alignment check on data mover addresses
	or	r19, r20, r15		; merge the two addresses
	and	r15, #3, r15		; get itty bitty low bits
	bne	r15, queue_addr_error3	; alignment error, report illpalop


	; probe the second write
	ldl/w	r15, (r20)		; probe second datum dest
	s4addq	r21, r20, r15		; probe second datam second dest
	ldl/w	r15, -4(r15)		; probe second datum dest


	; probe the second's read
	ldl	r15, (r19)		; probe second datum source
	s4addq	r21, r19, r15		; probe second datam second source
	ldl	r15, -4(r15)		; probe second datum source


	; see if data is aligned
	; if not, go do the second half of the probe and
	; load the data the sloooow way.
5$:	and	r18, #^x3, r18		; ensure that r18, stays in range
	or	r31, #1, r14		; get a one
	sll	r14, r18, r14		; get size of data
	subq	r14, #1, r14		;  minus one.
	and	r17, r14, r15		; or the low bits of the addr
	bne	r15, 30$		; br if this access would be unaligned



	; probes have completed, we have now crossed the point of no return
	; the only tolerable mm error allowed now is TNV, and on that
	; we will "fix up" the tb entry and continue.

	debug_mp_queue 			; if mp queue debug, zap dtb's
	sget_addr r13, <pal$queue_fault3-pal$start>, r31; get address
	mt	r13, pt3		; set recovery address

	; branch to correct rtn
	align_branch_target
10$:	lda	r15, ldxl_stxc_retry_count(r31)
	 mt	r15, pt16		; save retry count
	beq	r18, lock_amovrmb	; br if byte access
	 subq	r18, #2, r15		; is access long?
	beq	r15, lock_amovrml	; br if long access
	 subq	r18, #1, r15		; is access word?
	beq	r15, lock_amovrmw	; br if word access
;	 subq	r18, #3, r15		; is access quad?
;	beq	r15, lock_amovrmq	; br if quad access

	
	; access is quadword
lock_amovrmq:
	or	r16, r31, r18		; get data to r18
	stq	r18, (r17)		; store the data, no lock needed
	br	r31, 20$		; on to next access


	; access is byte
	.align	quad
lock_amovrmb:
	or	r16, r31, r18		; get data to r18
	and	r17, #3, r13		; get low bits of address
	or	r31, #1, r15		; get a one
	sll	r15, r13, r15		; now is a 1 in position for zap
	insbl	r18, r13, r18		; reposition data
	bic	r17, #3, r14		; get aligned long addr
	ldl_l	r13, (r14)		; fetch data, and lock it
	zap	r13, r15, r13		; remove old data
	or	r13, r18, r13		; merge new and old data
	debug_mp_store r13, r17		; if mp debug, sometimes fail the _c
	stl_c	r13, (r14)		; store the data, undo the lock
	blbc	r13, retry_lock_amovrmb ; failed to lock => retry
	br	r31, 20$                ; on to next access


	; access is word
	.align	quad
lock_amovrmw:
	or	r16, r31, r18		; get data to r18
	and	r17, #3, r13		; get low bits of address
	or	r31, #3, r15		; get a 3
	sll	r15, r13, r15		; now is a 3 in position for zap
	inswl	r18, r13, r18		; reposition data
	bic	r17, #3, r14		; get aligned long addr
	ldl_l	r13, (r14)		; fetch data, and lock it
	zap	r13, r15, r13		; remove old data
	or	r13, r18, r13		; merge new and old data
	debug_mp_store r13, r17		; if mp debug, sometimes fail the _c
	stl_c	r13, (r14)		; store the data, undo the lock
	blbc	r13, retry_lock_amovrmw ; failed to lock => retry
	br	r31, 20$                ; on to next access


	; access is longword
	.align	quad
lock_amovrml:
	or	r16, r31, r18		; get data to r18
	stl	r18, (r17)		; store the data, no lock needed
;	br	r31, 20$		; on to next access


	; the register data move has been completed.
	; now we start the bulk memory transfer
	; (at least the things aligned...)

20$:	beq	r21, 100$		; all done if DL=0
	s4addq	r21, r31, r21		; convert long count to byte count
	or	r19, r20, r15		; merge both addresses
	or	r15, r21, r15		; and the dl
	and	r15, #7, r15		; see if both addrs, and count are
					;   properly quad aligned.
	bne	r15, 27$		; br if not
	; data and count is multiple of quad
	; move data as quads
25$:	ldq	r18, (r19)		; get source
	subq	r21, #8, r21		; dec count
	lda	r19, 8(r19)		; bump address
	stq	r18, (r20)		; store the data and unlock
	lda	r20, 8(r20)		; bump address
	bgt	r21, 25$		; br if more to do
	br	r31, 100$		; else we are done, success
	
	; data or count is not multiple of quad
	; move data as longs
	align_to_double_cache_block
27$:	ldl	r18, (r19)		; get source
	subq	r21, #4, r21		; dec count
	lda	r19, 4(r19)		; bump address
	stl	r18, (r20)		; store the data and unlock
	lda	r20, 4(r20)		; bump address
	bgt	r21, 27$		; br if more to do
	br	r31, 100$		; else we are done, success




; unaligned amovrm
	align_to_cache_block
30$:	; probe the first write, part 2
	addq	r14, r17, r15		; get addr of part 2
	ldl/w	r15, (r15)		; probe first data



	; probes have completed, we have now crossed the point of no return
	; the only tolerable mm error allowed now is TNV, and on that
	; we will "fix up" the tb entry and continue.

	debug_mp_queue 			; if mp queue debug, zap dtb's
	sget_addr r13, <pal$queue_fault3-pal$start>, r31; get address
	mt	r13, pt3		; set recovery address

	; branch to correct rtn
	align_branch_target
	lda	r15, ldxl_stxc_retry_count(r31)
	 mt	r15, pt16		; save retry count
	beq	r18, lock_amovrmbu	; br if byte access
	 subq	r18, #2, r15		; is access long?
	beq	r15, lock_amovrmlu	; br if long access
	 subq	r18, #1, r15		; is access word?
	beq	r15, lock_amovrmwu	; br if word access
;	 subq	r18, #3, r15		; is access quad?
;	beq	r15, lock_amovrmqu	; br if quad access

	

	; access is unaligned quadword
lock_amovrmqu:
	store_unaligned_quad	r16, r17, r13, r18, r15, lock=1, -
		err=retry_lock_amovrmqu,err1=retry_lock_amovrmqu1
	br	r31, 20$		; on to the next access
	

	; access is byte
	.align	quad
lock_amovrmbu:
	and	r17, #3, r13		; get low bits of address
	or	r31, #1, r18		; get a one
	sll	r18, r13, r18		; now is a 1 in position for zap
	insbl	r16, r13, r15		; reposition data
	bic	r17, #3, r14		; get aligned long addr
	ldl_l	r13, (r14)		; fetch data, and lock it
	zap	r13, r18, r13		; remove old data
	or	r13, r15, r13		; merge new and old data
	debug_mp_store r13, r17		; if mp debug, sometimes fail the _c
	stl_c	r13, (r14)		; store the data, undo the lock
	blbc	r13, retry_lock_amovrmbu; store failed, backout with failure
	br	r31, 20$		; on to the next access



	; access is unaligned word
	.align	quad
lock_amovrmwu:
	store_unaligned_word	r16, r17, r13, r18, r15, lock=1, -
		err=retry_lock_amovrmwu, err1=retry_lock_amovrmwu1
	br	r31, 20$		; on to the next access


	; access is unaligned longword
	.align	quad
lock_amovrmlu:
	store_unaligned_long	r16, r17, r13, r18, r15, lock=1, -
		err=retry_lock_amovrmlu, err1=retry_lock_amovrmlu1
	br	r31, 20$		; on to the next access


; failure, or success
	align_to_cache_block
90$:	subq	r31, #1, r21		; set failure
100$:	 mt	r12, exc_addr		; set the rei address
	cmpeq	r21, r31, r18		; set success or failure
	 mf	r12, pt12
	mf	r13, pt13
	 mf	r14, pt14
	mf	r15, pt15
; 	mf	r18, pt18		; note, don't unwind r18
	 hw_rei				; and back to the user
	


    retry_lock amovrmw,  r14
      br r31, 90$
    retry_lock amovrmb,  r14
      br r31, 90$


    retry_lock amovrmqu,  r14
      br r31, 90$
    retry_lock amovrmqu,  r14, pstfx=1
     store_unaligned_quad	r16, (r17), r13, r18, r15
     br	r31, 20$		; on to the next access

    retry_lock amovrmlu,  r14
      br r31, 90$
    retry_lock amovrmlu,  r14, pstfx=1
     store_unaligned_long	r16, (r17), r13, r18, r15
     br	r31, 20$		; on to the next access

    retry_lock amovrmwu,  r14
      br r31, 90$
    retry_lock amovrmwu,  r14, pstfx=1
     store_unaligned_word	r16, (r17), r13, r18, r15
     br	r31, 20$		; on to the next access


    retry_lock amovrmbu,  r14
      br r31, 90$


	END_PAL_ROUTINE	 AMOVRM



.sbttl MxPR_DATAFX - PALcode for MxPR_DATAFX

;+
; MxPR_DATAFX
;
; Entry:
;	Vectored into via hardware dispatch
;
; Function:
;
;-

	START_PAL_ROUTINE	MTPR_DATAFX, longflow=1
	mf	r0, pt2			; get iccsr/datafx
	 and	r16, #1, r16		; clean it
	mf	r17, pt31		; Get current PCBB 
	 addq	r16, r16, r16		; get datafx @1
	srl	r0, #<iccsrw$v_pme1>, r1; isolate pme/old datafx
	 and	r1, #1, r1		; isolate old pme
	or	r1, r16, r1		; merge old pme/new datafx
	 sll	r1, #<62-32>, r16	; move to pcb pos
	stl/p	r16, pcb$q_fen+4(r17)	; update the pcb
	 sll	r1, #<iccsrw$v_datafx-1>, r17; move to pos
	or	r31, #1, r16		; get zonker
	 sll	r16, #<iccsrw$v_datafx>, r16 ; position the zonk
	bic	r0, r16, r0		; zonk, old datafx
	 bis	r0, r17, r0		; insert new datafx
	mt	r0, pt2			; save in chip
	 hw_rei				; back to user
	END_PAL_ROUTINE		MTPR_DATAFX


.sbttl SWPPAL	- PALcode for switch to pals instruction

;+
; SWPPAL
;
; Entry:
;	Vectored into via hardware PALcode instruction dispatch
;	PALcode enviornment set up.
;
; Function:
;	
;-

;
;	"I'ld rather switch than fight"
;


	START_PAL_ROUTINE	SWPPAL, longflow=1
	cmpule	r16, #255, r0		; see if a kibble was passed
	cmoveq	r16, r16, r0		; if r16=0 then a valid address (ECO #59)
	or	r16, r31, r3		; set r3 incase this is a address
	blbc	r0, 20$			; nope, try it as an address
	cmpeq	r16, #2, r0		; is it our friend OSF?
	blbc	r0, 30$			; nope, don't know this fellow
	br	r2, 10$			; tis out buddy OSF
	.external osfpal$hw_entry_reset
	.weak	osfpal$hw_entry_reset
	.long	<osfpal$hw_entry_reset-pal$start>
10$: 	ldl/p	r3, (r2)		; fetch target addr
	ble	r3, 30$			; if OSF not linked in say not loaded.
	mf	r2, pal_base		; fetch pal base
	addq	r2, r3, r3		; add pal base
20$:	lda	r2, ^x3FFF(r31)		; get pal base checker mask
	and	r3, r2, r2		; any funky bits set?
	cmpeq	r2, #0, r0		; r0=0, if bad, 0+2, = not loaded
	CONT_PAL_ROUTINE	SWPPAL

	blbc	r0, 30$			; return unknown if bad bit set.
	mf	r2, pt25		; get misc bits
	lda	r0,1(r31)	
	sll	r0, #pt25$v_switch, r0	; create the "I've switched" bit
	or	r2, r0, r2		; set the bit
	mt	r2, pt25		; update the chip
	or	r31, r31, r0		; set status to success
	or	r3, r31, r4		; hang on to address
	mf	r3, pt7			; pass pointer to impure in r3
	ldq/p	r1,cns$abox_ctl(r3)	; pass abox ctl in r1
	ldq/p	r2,cns$biu_ctl(r3)	; pass biu ctl in r2
	pvc$violate	1007
	jmp	r31, (r4)		; and call our friend, it's his problem now


30$:	addq	r0, #1, r0		; set unknown pal or not loaded
	hw_rei				; and return


	END_PAL_ROUTINE		SWPPAL


	.if ne enable_physical_console
.sbttl PHYSICAL_TB	- Physical mode tb miss routines


;+
;
; on entry pt3, 4,5 <- r3, 4,5
;		r3 = pc
;
;-

	goto_new_code
	align_to_cache_block
pal$physical_itb::			; 13 cycles
	.if ne	0*cfw_system
	srl	r3, #page_offset_size_bits, r4 ; Clean off low bits of VA
	beq	r4, 6$			; RO access to VA 0
	cmplt	r4, #pal$pal_base@-page_offset_size_bits, r5 ; Check for VA < PAL$PAL_BASE
	bne	r5, 5$			; Branch if it is
	cmplt	r4, #pal$console_base@-page_offset_size_bits, r5 ; Check for VA < PAL$CONSOLE_BASE
	beq	r5, 5$			; Branch if it is not
6$:	lda	r5, pte$m_kre!pte$m_v(r31) ; Load control fields for RO
	br	r31, 1$			; Go set up PTE
5$:	lda	r5, pte$m_kwe!pte$m_kre!pte$m_v(r31) ; Load control fields for RW
1$:	sll	r4, #32, r4		; Shift to PFN field
	addq	r4, r5, r4		; Add control fields to form PTE
	.iff
	srl	r3, #<page_offset_size_bits>, r4 ; Clean off low bits of VA
	 sll	r4, #32, r4		; shift to PFN field
	lda	r4,<pte$m_kwe!pte$m_kre!pte$m_v>(r4) ; add ctl fields
	.endc
	 mt	r4, dtb_ctl		; Set dtb ctl
	stall	1			; stall for instr issue
	 mt	r3, tb_tag		; write ITB tag
	.if ne virtualize_phy_tb
	  mf r5, pt8
	  sll r5, #32-page_offset_size_bits, r5; turn virt mem offset into pfn addr
	  addq	r4, r5, r4		; bump the pfn
	.endc
	mt	r4, itb_pte		; Load PTE and set TB valid bit

	 mf	r3, pt3
	mf	r4, pt4
	 mf	r5, pt5
	hw_rei				; go back and try access

	    
	    
.sbttl PHYSICAL_DTB	- Physical mode dtb miss routines

;+
;
;	for Ndtb miss...
;
; on entry pt3, 4,5 <- r3, 4,5
;		r3 = va>>10
;
;
;
;	for Pdtb miss...
;
; on entry pt20,21,22 <- r20,21,22
;		r20 = va
;
;-


	align_to_cache_block
pal$physical_ndtb::			; 15 cycles
	sll	r3, #10, r3		; undo preshift in caller
	.if ne	0*cfw_system
	srl	r3, #page_offset_size_bits, r4 ; Clean off low bits of VA
	beq	r4, 6$			; RO access to VA 0
	cmplt	r4, #pal$pal_base@-page_offset_size_bits, r5 ; Check for VA < PAL$PAL_BASE
	bne	r5, 5$			; Branch if it is
	cmplt	r4, #pal$console_base@-page_offset_size_bits, r5 ; Check for VA < PAL$CONSOLE_BASE
	beq	r5, 5$			; Branch if it is not
6$:	lda	r5, pte$m_kre!pte$m_v(r31) ; Load control fields for RO
	br	r31, 1$			; Go set up PTE
5$:	lda	r5, pte$m_kwe!pte$m_kre!pte$m_v(r31) ; Load control fields for RW
1$:	sll	r4, #32, r4		; Shift to PFN field
	addq	r4, r5, r4		; Add control fields to form PTE
	.iff
	srl	r3, #<page_offset_size_bits>, r4 ; Clean off low bits of VA
	 sll	r4, #32, r4		; shift to PFN field
	lda	r4,<pte$m_kwe!pte$m_kre!pte$m_v>(r4) ; add ctl fields
	.endc
	 mt	r4, dtb_ctl		; Set dtb ctl
	stall	1			; stall for instr issue
	 mt	r3, tb_tag		; write TB tag
	.if ne virtualize_phy_tb
	  mf r3, pt8
	  srl	r4, #<20+32>, r5	; get IO space indicator from PFN
	  cmovne r5, R31, r3		; if IO space, don't virtualize
	  sll r3, #32-page_offset_size_bits, r3; turn virt mem offset into pfn addr
	  addq	r3, r4, r4		; bump the pfn
	.endc
	mt	r4, dtb_pte		; Load PTE and set TB valid bit

	mf	r3, pt3
	mf	r4, pt4
	mf	r5, pt5
	hw_rei				; go back and try access

	    



	align_to_cache_block
pal$physical_pdtb::			; 13 cycles
	.if ne	0*cfw_system
	srl	r20, #page_offset_size_bits, r21 ; Clean off low bits of VA
	beq	r21, 6$			; RO access to VA 0
	cmplt	r21, #pal$pal_base@-page_offset_size_bits, r22 ; Check for VA < PAL$PAL_BASE
	bne	r22, 5$			; Branch if it is
	cmplt	r21, #pal$console_base@-page_offset_size_bits, r22 ; Check for VA < PAL$CONSOLE_BASE
	beq	r22, 5$			; Branch if it is not
6$:	lda	r22, pte$m_kre!pte$m_v(r31) ; Load control fields for RO
	br	r31, 1$			; Go set up PTE
5$:	lda	r22, pte$m_kwe!pte$m_kre!pte$m_v(r31) ; Load control fields for RW
1$:	sll	r21, #32, r21		; Shift to PFN field
	addq	r21, r22, r21		; Add control fields to form PTE
	.iff
	srl	r20, #<page_offset_size_bits>, r21 ; Clean off low bits of VA
	 sll	r21, #32, r21		; shift to PFN field
	lda	r21,<pte$m_kwe!pte$m_kre!pte$m_v>(r21) ; add ctl fields
	.endc
	 mt	r21, dtb_ctl		; Set dtb ctl
	stall	1			; stall for instr issue
	 mt	r20, tb_tag		; write TB tag
	.if ne virtualize_phy_tb
	  mf r20, pt8
	  srl	r21, #<20+32>, r22	; get IO space indicator from PFN
	  cmovne r22, R31, r20		; if IO space, don't virtualize
	  sll r20, #32-page_offset_size_bits, r20; turn virt mem offset into pfn addr
	  addq	r20, r21, r21		; bump the pfn
	.endc
	mt	r21, dtb_pte		; Load PTE and set TB valid bit

	mf	r20, pt20
	mf	r21, pt21
	mf	r22, pt22
	hw_rei				; go back and try access

	end_new_code
	    
.endc	    




pal$mid::
	.iif eq ev4_pass1, assume <pal$mid - pal$start> lt <^x10000>	; assumes pal addrs can use lda


.sbttl BOOT_PCB - PCB for Boot use only


	; align to 128b boundary
	.align 7

bt$pcb::
	.quad	0
	.quad	0
	.quad	0
	.quad	0
	.quad	0

	.rept	4+7
	.quad	0
	.endr
	end_new_code





	.if ne	cfw_system

	START_PAL_ROUTINE	MTPR_EXC_ADDR

	CONT_PAL_ROUTINE	MTPR_EXC_ADDR

	;
	; If we are in console mode, let this opcode work.  Otherwise,
	; only allow this opcode to work if all of the following are
	; true:  pt9 shows that we are at IPL 31 in kernel mode; the new
	; PC (r16) is less than 16MB; the new PC is long-aligned, yet
	; indicates PALmode (r16<1:0> = 1); the instruction that the new
	; PC points to is exactly "mt r31, flush_ic".  If any of these
	; conditions are not met, then fail the opcode (so that Egore
	; will work unmodified).
	;
	mt	r0, pt0
	mf	r0, pt28
	blbs	r0, 20$
	mf	r0, pt9
	lda	r0, -^x1f00(r0)
	bne	r0, 10$
	ldah	r0, -^x0100(r16)
	bgt	r0, 10$
	and	r16, #3, r0
	cmpeq	r0, #1, r0
	beq	r0, 10$
	ldl/p	r0, -1(r16)
	lda	r0, -^x0055(r0)
	ldah	r0, -^x77ff(r0)
	beq	r0, 20$
10$:	mf	r0, pt0
	br	r31, pal$calpal_opcdec

20$:	mf	r0, pt0
	mt	r16, exc_addr
	stall	2
	hw_rei

	END_PAL_ROUTINE		MTPR_EXC_ADDR

;
;	PALcode entry point for CSERVE
;

	START_PAL_ROUTINE	CSERVE

	CONT_PAL_ROUTINE	CSERVE

	.dsabl	lsb

;
; R16 = 0:	init
;     = 1:	getc_ready
;	in:	R17 = unit
;	out:	R0 = 0, not ready
;		   = 1, ready
;     = 2:	getc
;	in:	R17 = unit
;	out:	R0 = character
;     = 3:	putc_ready
;	in:	R17 = unit
;	out:	R0 = 0, not ready
;		   = 1, ready
;     = 4:	putc
;	in:	R17 = unit
;		R18 = character
;     = 5:	rx_int
;	in:	R17 = unit
;		R18 = 0, disabled
;		    = 1, enabled
;	out:	R0 = 0, previously disabled
;		   = 1, previously enabled
;     = 6:	tx_int
;	in:	R17 = unit
;		R18 = 0, disabled
;		    = 1, enabled
;	out:	R0 = 0, previously disabled
;		   = 1, previously enabled
;     = 7:	control
;	in:	R17 = unit
;     = 8:	Enable hwe in iccsr	
;     = 9:	Disable hwe in iccsr
;     = 10:	write bad check bits to memory
;	in:     r17 = cmm csr6 address 
;       	r18 = cmm csr6 value to write
;       	r19 = qw memory init value
;       	r20 = memory addr to write access
;

	cmpeq	r16, #cserve$set_hwe, r0
	bne	r0, ena_hwe
	cmpeq	r16, #cserve$clear_hwe, r0
	bne	r0, dis_hwe
	cmpeq	r16, #cserve$write_bad_check_bits, r0
	bne	r0, wr_cbits
	cmpeq	r16, #cserve$configure_memory, r0
	bne	r0, config_mem
	cmpeq	r16, #cserve$size_simms, r0
	bne	r0, size_simm
	cmpeq	r16, #cserve$configure_simms, r0
	bne	r0, config_simm

	cmpeq	r16, #16, r0
	bne	r0, cfw_ldlp
	cmpeq	r16, #17, r0
	bne	r0, cfw_stlp

	cmpeq	r16, #cserve$halt, r0
	bne	r0, cfw_halt
	cmpeq	r16, #cserve$whami, r0
	bne	r0, cfw_whami
	cmpeq	r16, #cserve$start, r0
	bne	r0, cfw_start
	cmpeq	r16, #cserve$callback, r0
	bne	r0, cfw_callback
	cmpeq	r16, #cserve$mtpr_exc_addr, r0
	bne	r0, cfw_mtpr_exc_addr
	cmpeq	r16, #cserve$jump_to_arc, r0
	bne	r0, cfw_jump_to_arc

	cmpeq	r16, #cserve$mp_work_request, r0
	bne	r0, cfw_mp_work_request

	.if ne	<medulla_system & lca4>
	cmpeq	r16, #cserve$medu_int_enable, r0
	bne	r0, medu_int_enable
	cmpeq	r16, #cserve$medu_int_disable, r0
	bne	r0, medu_int_disable
	cmpeq	r16, #cserve$write_bad_ecc, r0
	bne	r0, wr_bad_ecc
	cmpeq	r16, #cserve$write_bad_tag, r0
	bne	r0, wr_bad_tag
	cmpeq	r16, #cserve$medu_wdog_int_rd, r0
	bne	r0, medu_wdog_ints
	.endc

	.if ne	cortex_system
	cmpeq	r16, #cserve$medu_int_enable, r0
	bne	r0, cortex_int_enable
	cmpeq	r16, #cserve$medu_int_disable, r0
	bne	r0, cortex_int_disable
	cmpeq	r16, #cserve$medu_wdog_int_rd, r0
	bne	r0, cortex_wdog_ints
	.endc

	hw_rei				; Return to the user

;
;	The following functions are used to enable and disable
;       the hwe bit in the iccsr.
;-
	align_branch_target

ena_hwe:
	.if ne	sable_sromtt_debug
	hw_rei
	.endc
	lda	r0,1(r31)	; Get a 1
	sll	r0,iccsrw$v_hwe,r0 ;Shift it
	mf	r16,pt2		; Get iccsr
	bis	r16,r0,r16	; Enable hwe
	mt	r16, pt2_iccsr	; store back into chip
	stall	4
	pvc$violate	77
	hw_rei

	align_branch_target

dis_hwe:
	.if ne	sable_sromtt_debug
	hw_rei
	.endc
	lda	r0,1(r31)	; Get a 1
	sll	r0,iccsrw$v_hwe,r0 ;Shift it
	mf	r16,pt2		; Get iccsr
	bic	r16,r0,r16	; Disable hwe
	mt	r16, pt2_iccsr	; store back into chip
	stall	4
	pvc$violate	77
	hw_rei

;
;	The following function are used to write memory with
;       substitute check bits in memory csr6
;-

	align_branch_target

;       r17	- cmm csr6 address 
;       r18	- cmm csr6 value to write
;       r19	- qw memory init value
;       r20	- memory addr to write access
;       r21	- bcache alias to flush data to memory
wr_cbits:         
;
; Initialize the cache block with known data
;
        stq/p	r19,8*0(r20)    
        stq/p	r19,8*1(r20)    
        stq/p	r19,8*2(r20)    
        stq/p	r19,8*3(r20)	
        mb                      
;
; use the sub write check bits
;            
        ldq/p	r22,(r17)	; save csr6
	mb
        stq/p	r18,(r17)       ; set up the sub check bits
	mb
;
; write to memory with sub check bits
;
        stq/p	r19,(r20)       
        mb
	ldq/p	r0,(r21)
	mb

        stq/p	r22,(r17)       ; restore csr6
	mb
	hw_rei			; Return

;
;	The following function is used to configure memory
;	and gather the console
;	---- marks the cache block boundries every cache block must be
;	touched the first time through the loop so all the code will
;	be in the icache.  If code is added be sure that a brach touches
;	every cache block.
;-
	align_to_cache_block

;       r17	- base address of where the console will be located after
;		  the configuration registers have been changed
;       r18	- the board size
;       r19	- increment of the console after the configuration registers
;		  have been changed.
;       r20	- array of values to write to the memory CSRs
	align_to_cache_block
config_mem:         

	lda	r1, 1(r31)

	br 	r31, 10$

1$:     bis	r31, r31, r1

; get the csr values from memory
	ldq/p	r21, 8*0(r20)	; get memory 0 csr3 value
	ldq/p	r22, 8*1(r20)	; get memory 1 csr3 value
	ldq/p	r23, 8*2(r20)	; get memory 2 csr3 value
	ldq/p	r24, 8*3(r20)	; get memory 3 csr3 value

; force the console out of the bcache. After this is done no access can
; be made to memory until the CSRs have been updated.
; The bcache cannot have a valid address in the first 4MB.

	lda	r16, (r31)	; read address 0
;----
	pvc$violate	1008
10$:	bne	r1, 20$

	lda	r20, 4(r31)	; read 8MB = 256k cache blocks
	sll	r20, #16, r20

3$:	subq	r20, #1, r20	; decr counter
	ldq/p 	r0, (r16)	; read location

	addq	r16, #32, r16	; next cache block

	bne	r20, 3$		; loop till done

;build the base csr value
	lda	r20, ^x388(r31)	;
;----
	pvc$violate	1008
20$:	bne	r1, 30$

	sll	r20, #^x18, r20	; ^x388000000
	lda	r0, ^x60(r31)	; configuration offset ^x60
	bis	r20, r0, r20	; ^x388000060
	lda	r16, 1(r31)
	sll	r16, #^x18, r16	; board offset

; write the csrs for the installed modules

	beq 	r21, 11$	; if it's zero then don't write the register
        stq/p	r21, (r20)	; write the register
;----
	pvc$violate	1008
30$:	bne	r1, 40$

        mb

11$:	addq	r20, r16, r20	; mem1 csr 3 address
	beq 	r22, 21$	; if it's zero then don't write the register
        stq/p	r22, (r20)	; write the register
        mb

21$:	addq	r20, r16, r20	; mem2 csr 3 address
	beq 	r23, 31$	; if it's zero then don't write the register
;----
	pvc$violate	1008
40$:	bne	r1, 50$

        stq/p	r23, (r20)	; write the register
        mb

31$:	addq	r20, r16, r20	; mem3 csr 3 address
	beq 	r24, 41$	; if it's zero then don't write the register
        stq/p	r24, (r20)	; write the register
        mb

; gather the console
41$:	lda	r16, (r31)	; start at 0
;----
	pvc$violate	1008
50$:	bne	r1, 60$

	lda	r20, 4(r31)	; copy 4MB
	sll	r20, #20 ,r20
;
; The console may be scattered after the the configuration change.
; For 1-way interleave 
;	address 0x0  -> new_base_address + 0x0
;	address 0x20 -> new_base_address + 0x20
;	address 0x40 -> new_base_address + 0x40
;	address 0x60 -> new_base_address + 0x60
; For 2-way interleave 
;	address 0x0  -> new_base_address + 0x0
;	address 0x20 -> new_base_address + board_size + 0x0 
;	address 0x40 -> new_base_address + 0x40
;	address 0x60 -> new_base_address + board_size + 0x40 
; For 4-way interleave 
;	address 0x0  -> new_base_address + 0x0
;	address 0x20 -> new_base_address + board_size + 0x0 
;	address 0x40 -> new_base_address + board_size*2 + 0x0
;	address 0x60 -> new_base_address + board_size*3 + 0x0
;	address 0x80 -> new_base_address + 0x80
;	address 0xa0 -> new_base_address + board_size   + 0x80
;	address 0xc0 -> new_base_address + board_size*2 + 0x80
;	address 0xe0 -> new_base_address + board_size*3 + 0x80

	addq	r17, r18, r25	; new console base plus board size
	addq	r25, r18, r28	; new console base plus 2*board size
	addq	r28, r18, r18	; new console base plus 3*board size

51$:	ldq/p	r21, 8*0(r17)	; read the scattered console qw 0
	ldq/p	r22, 8*1(r17)	; read the scattered console qw 1
;----
	pvc$violate	1008
60$:	bne	r1, 70$

	ldq/p	r23, 8*2(r17)	; read the scattered console qw 2
	ldq/p	r24, 8*3(r17)	; read the scattered console qw 3

	stq/p	r21, 8*0(r16)	; write the gathered console qw 0
	stq/p	r22, 8*1(r16)	; write the gathered console qw 1
	stq/p	r23, 8*2(r16)	; write the gathered console qw 2
	stq/p	r24, 8*3(r16)	; write the gathered console qw 3
	mb
;----
	pvc$violate	1008
70$:	bne	r1, 80$

	addq	r17, r19, r17

	cmpeq	r19, #32, r0	; check interleave 32 = 1-way
	bne	r0, 81$

	addq	r16, #32, r16	; point to the next cache block

	ldq/p	r21, 8*0(r25)	; read the scattered console qw 0

	ldq/p	r22, 8*1(r25)	; read the scattered console qw 1
	ldq/p	r23, 8*2(r25)	; read the scattered console qw 2
;----
	pvc$violate	1008
80$:	bne	r1, 90$

	ldq/p	r24, 8*3(r25)	; read the scattered console qw 3
	stq/p	r21, 8*0(r16)	; write the gathered console qw 0
	stq/p	r22, 8*1(r16)	; write the gathered console qw 1
	stq/p	r23, 8*2(r16)	; write the gathered console qw 2
	stq/p	r24, 8*3(r16)	; write the gathered console qw 3
	mb

	addq	r25, r19, r25
;----
	pvc$violate	1008
90$:	bne	r1, 100$

	cmpeq	r19, #64, r0	; check interleave 64 = 2-way
	bne	r0, 81$		; not 64? then must be 4-way

	addq	r16, #32, r16	; point to the next cache block

	ldq/p	r21, 8*0(r28)	; read the scattered console qw 0
	ldq/p	r22, 8*1(r28)	; read the scattered console qw 1
	ldq/p	r23, 8*2(r28)	; read the scattered console qw 2
	ldq/p	r24, 8*3(r28)	; read the scattered console qw 3
;----
	pvc$violate	1008
100$:	bne	r1, 110$

	stq/p	r21, 8*0(r16)	; write the gathered console qw 0
	stq/p	r22, 8*1(r16)	; write the gathered console qw 1
	stq/p	r23, 8*2(r16)	; write the gathered console qw 2
	stq/p	r24, 8*3(r16)	; write the gathered console qw 3
	mb

	addq	r28, r19, r28
	addq	r16, #32, r16	; point to the next cache block
;----
	pvc$violate	1008
110$:	bne	r1, 120$

	ldq/p	r21, 8*0(r18)	; read the scattered console qw 0
	ldq/p	r22, 8*1(r18)	; read the scattered console qw 1
	ldq/p	r23, 8*2(r18)	; read the scattered console qw 2
	ldq/p	r24, 8*3(r18)	; read the scattered console qw 3

	stq/p	r21, 8*0(r16)	; write the gathered console qw 0
	stq/p	r22, 8*1(r16)	; write the gathered console qw 1
	stq/p	r23, 8*2(r16)	; write the gathered console qw 2
;----
	pvc$violate	1008
120$:	bne	r1, 130$

	stq/p	r24, 8*3(r16)	; write the gathered console qw 3
	mb

	addq	r18, r19, r18

81$:	addq	r16, #32, r16	; point to the next cache block
	cmplt	r16, r20, r0

	bne	r0, 51$

	bis	r31, r31, r31	; keep aligned on cache block
;----
	pvc$violate	1008
130$:	bne	r1, 1$
	hw_rei			;  and return
;----

;
;	The following function is used to determine the size of the
;	DRAMs installed on a given memory module.  This will check
;	for 4MBit and 16MBit DRAMs.
;	---- marks the cache block boundries every cache block must be
;	touched the first time through the loop so all the code will
;	be in the icache.  If code is added be sure that a brach touches
;	every cache block.
;-

;	r0	- return simm size
;	r1	- icache loop flag
;	r16	- saved value of csr3
;       r17	- address of memory csr3(configuration register)
;       r18	- value to write to csr3
;	r19	- address to write test patterns
;	r20	- address alias to flush write test patterns
;	r21	- scratch
;	r23	- scratch
;	r24	- scratch
	align_to_cache_block
size_simm:

	lda	r1, 1(r31)

	br 	r31, 10$

1$:     bis	r31, r31, r1


; force the console out of the bcache. After this is done no access can
; be made to memory until the CSRs have been updated.
; The bcache cannot have a valid address in the first 4MB.

	lda	r23, (r31)	; start at address 0x400000
	lda	r24, 4(r31)	; read 8MB = 256k cache blocks
	sll	r24, #16, r24

3$:	subq	r24, #1, r24	; decr counter
	ldq/p 	r0, (r23)	; read location
;----
	pvc$violate	1008
10$:	bne	r1, 15$

	addq	r23, #32, r23	; next cache block

	bne	r24, 3$		; loop till done

	ldq/p	r16, (r17)	; save the current value of csr3
	mb			; Make sure it goes out
	mb			; Make sure it goes out
	stq/p	r18, (r17)	; setup csr3
	mb			; Make sure it goes out

;----
	pvc$violate	1008
15$:	bne	r1, 20$
;
; In order to find out what size SIMMs are on the module two locations
; are written with different patterns.  The locations must be 0x20000 apart.
; Physical address Bit 17 maps to C8 on 4MBit DRAMs and to R10 on 16MBit DRAMs.
; Physical address Bit 25 is C8 on 16MBit DRAMs. When 4MBit DRAMs are configured
; as 16MBit parts data written on 0x20000 boundries will wrap around and
; overwrite previous data. So, if the second write wraps and over writes the 
; first location then 4MBit SIMMs are installed.  If the locations remain
; unique than 16MBit SIMMs are installed.
;
	ldah	r21, ^x3342(r31) ; test pattern
	lda	r21, ^x4348(r21) ; test pattern

	stq/p	r21, (r19)	; write to the test address
	mb			; Make sure it goes out
	ldq/p	r0, (r20)	; read alias to be sure it goes out
	mb			; Make sure it goes out


	lda	r23, 2(r31)	; build the 0x20000 offset
;----
	pvc$violate	1008
20$:	bne	r1, 30$

	sll	r23, #16, r23	; build the 0x20000 offset

	addq	r20, r23, r24	; get the new alias address
	addq	r23, r19, r23	; get the new address
;
; write the second location. If this is a 4MBit DRAM it will wrap around
; and overwrite the first write
;
	lda	r22, (r31)	; test pattern
	stq/p	r22, (r23)	; write to the test address
	mb			; Make sure it goes out

	ldq/p	r0, (r24)	; read alias to be sure it goes out
;----
	pvc$violate	1008
30$:	bne	r1, 40$

	mb			; Make sure it goes out

	ldq/p	r22, (r19)	; read the first location
	mb			; Make sure it goes out

	cmpeq	r22, r21, r22
	lda	r0, 1(r31)	; assume 4MBit DRAMs
	
	beq	r22, 31$	; if the first location was not overwritten
	lda	r0, 2(r31)	; then 16MBit DRAMs are installed

;----
	pvc$violate	1008
40$:	bne	r1, 50$

31$:	stq/p	r16, (r17)	; restore the value of csr3
	mb			; Make sure it goes out
;
; clean up the test addresses and the test aliases so they don't have
; bad EDC
;
	stq/p	r31, (r19)	; read the first test location
	mb			; Make sure it goes out
	ldq/p	r22, (r20)	; read alias to be sure it goes out
	stq/p	r22, (r20)	; write alias to make it dirty
	mb			; Make sure it goes out
;----
	pvc$violate	1008
50$:	bne	r1, 1$

	stq/p	r31, (r23)	; read the second test location
	mb			; Make sure it goes out
	ldq/p	r22, (r24)	; read alias to be sure it goes out
	stq/p	r22, (r24)	; write the alias to make it dirty
	mb			; Make sure it goes out

	hw_rei			; and return

;----

;
;	The following function is used to determine the size of the
;	DRAMs installed on a given memory module.  This will check
;	for 4MBit and 16MBit DRAMs.
;	---- marks the cache block boundries every cache block must be
;	touched the first time through the loop so all the code will
;	be in the icache.  If code is added be sure that a brach touches
;	every cache block.
;-
;	r0	- scratch
;	r1	- icache loop flag
;       r17	- address of memory csr3(configuration register)
;       r18	- value to write to csr3
;	r19	- list of shift values to use
;	r20	- list of mask values to use
;	r21	- scratch
;	r22	- scratch
;	r23	- scratch
;	r24	- scratch

	align_to_cache_block
config_simm:
	lda	r1, 1(r31)

	br 	r31, 10$

1$:     bis	r31, r31, r1

; force the console out of the bcache. After this is done no access can
; be made to memory until the CSRs have been updated.
; The bcache cannot have a valid address in the first 4MB.

	lda	r23, (r31)	; start at address 0x400000
	lda	r24, 4(r31)	; read 8MB = 256k cache blocks
	sll	r24, #16, r24

3$:	subq	r24, #1, r24	; decr counter
	ldq/p 	r0, (r23)	; read location
;----
	pvc$violate	1008
10$:	bne	r1, 15$

	addq	r23, #32, r23	; next cache block

	bne	r24, 3$		; loop till done

;;;;1000$:	br	r31, 1000$

	stq/p	r18, (r17)	; write csr3 with new configuration
	mb			; Make sure it completes
	mb			; Make sure it completes



; flood uninitialized memory

	ldah	r18, ^x80(r31)	; flood 8MB
	lda	r16, (r31)	; start at address 0
;----
	pvc$violate	1008
15$:	bne	r1, 20$

11$:	and 	r16, r20, r0	; only write uninitialized memory
	beq	r0, 12$

	stq/p	r31, (r16)

12$:	addq	r16, #32, r16	; next cache block
	cmplt	r16, r18, r0
	bne	r0, 11$

	lda	r16, (r31)	; copy to address 0
;----
	pvc$violate	1008
20$:	bne	r1, 30$		

	lda	r17, (r31)	; start at address 0
	ldah	r18, ^x40(r31)	; copy 4MB

21$:
	and 	r17, r20, r25
	sll 	r25, r19, r25

	bis	r31, r31, r31

;	bic 	r17, r20, r17

	addq	r17, r25, r17

	ldq/p	r21, 8*0(r17)	; read the scattered console qw 0
;----
	pvc$violate	1008
30$:	bne	r1, 40$

	ldq/p	r22, 8*1(r17)	; read the scattered console qw 1
	ldq/p	r23, 8*2(r17)	; read the scattered console qw 2
	ldq/p	r24, 8*3(r17)	; read the scattered console qw 3

	stq/p	r21, 8*0(r16)	; write the gathered console qw 0
	stq/p	r22, 8*1(r16)	; write the gathered console qw 1
	stq/p	r23, 8*2(r16)	; write the gathered console qw 2
	stq/p	r24, 8*3(r16)	; write the gathered console qw 3
;----
	pvc$violate	1008
40$:	bne	r1, 1$

	mb

	addq	r16, #32, r16	; point to the next cache block
	bis	r31, r16, r17	; point to the next cache block

	cmplt	r16, r18, r0

	bne	r0, 21$

	hw_rei			; and return
;----

cfw_ldlp:
	ldl/p	r0, (r17)		; Load the data
	hw_rei				;  and return

cfw_stlp:
	stl/p	r18, (r17)		; Store the data
	hw_rei				;  and return
	
cfw_halt:
	mt	r0, pt0			; Save R0
	pvc$jsr 	updpcb, bsr=1
	bsr	r0, pal$update_pcb	; Update the PCB
	lda	r0, hlt$c_hw_halt(r31)	; Set halt code to hardware halt
	br	r31, pal$enter_console	; Enter the console

cfw_whami:
	mf	r0, pt27		; Get WHAMI
	hw_rei				;  and return

cfw_start:
	mf	r1, pt7			; Get base address of impure area
	br	r31, pal$exit_console	; Just exit the console

cfw_callback:
	bis	r1, r31, r16		; Restore R16
	.if ne	sable_system
	mf	r1, pt27		; Get WHAMI
	lda	r1, ^x380(r1)		; Write 38x000180
	sll	r1, #24, r1		;
	lda	r0, 1(r31)		; Get bit to clear
	sll	r0, #2, r0		;
	stq/p	r0, ^x180(r1)		; Clear the Cbus error interrupt
	mb				; Make sure it goes out
	ldq/p	r0, ^x0e0(r1)		; Get CBE (Cbus error)
	stq/p	r0, ^x0e0(r1)		; Clear locked error bits
	mb				; Make sure it goes out
	.endc
	lda	r0, 1(r31)		; Set callback flag
	stq/p	r0, pal$callback(r31)	;
	pvc$jsr 	updpcb, bsr=1
	bsr	r0, pal$update_pcb	; Update the PCB
	lda	r0, hlt$c_callback(r31)	; Set halt code to callback
	br	r31, pal$enter_console	; Enter the console

cfw_mtpr_exc_addr:
	mt	r17, exc_addr		; Set new exception address
	stall	2			; Wait for it to settle
	hw_rei				;  and return

cfw_jump_to_arc:
	.if ne	avanti_system ! mikasa_system ! noritake_system ! k2_system
	bis	r17, r31, r22		; save load address
	.endc
	mt	r17, exc_addr		; Set new exception address
	ldq/p	r16, 0*8(r18)		; Load arguments (six of them)
	ldq/p	r17, 1*8(r18)		;
	ldq/p	r19, 3*8(r18)		;
	ldq/p	r20, 4*8(r18)		;
	ldq/p	r21, 5*8(r18)		;
	ldq/p	r18, 2*8(r18)		;
	.if ne	avanti_system ! mikasa_system ! noritake_system ! k2_system
	ldah	r23, ^x10(r31)		; destination of the code - 1MB
	ldah	r0, 1(r31)		; 64k quad words

1000$:	ldq/p	r24, (r22)
	addq	r22, #8, r22
	stq/p	r24, (r23)
	addq	r23, #8, r23
	subq	r0, #1, r0
	bgt	r0, 1000$

	mt	r31, hier		; make sure the interrupts are off
	ldah	r22, ^x10(r31)		; reset to 1meg
	bis	r22, #1, r22		; force pal mode on exit
	mt	r22, exc_addr		; Set new exception address
	.endc

	mf	r3, pt7			; Get pointer to impure area
	ldq/p	r1, cns$abox_ctl(r3)	; Pass ABOX_CTL in R1
	ldq/p	r2, cns$biu_ctl(r3)	; Pass BIU_CTL in R2
	stall	2			; Wait for it to settle
	hw_rei				;  and return

cfw_mp_work_request:
	mt	r12, pt12		; Save registers
	mt	r13, pt13		;
	stall	2			;
	cmpeq	r18, #mp$restart, r12	; Is this a restart request?
	beq	r12, 10$		; Nope
	ldq/p	r12, pal$primary(r31)	; Get primary CPU
	mf	r13, pt27		; Get WHAMI
	cmpeq	r13, r12, r13		; Are we the primary?
	beq	r13, 10$		; Branch if not
	cmpeq	r17, r12, r13		; Are we restarting the primary?
	bne	r13, 20$		; Branch if so, don't do it!
10$:	sget_addr r12, pal$impure_base, r31 ; Base of scratch area
	mulq	r17, #pal$impure_specific_size/8, r13 ; WHAMI * per node size/8
	addq	r13, #pal$impure_common_size/8, r13 ; Add common size
	sll	r13, #3, r13		; Multiply by 8
	addq	r12, r13, r12		; Get specific address of impure area
	stq/p	r18, cns$work_request(r12) ;  and save the work request
	mb				; Make sure it goes out
	.if ne	sable_system
	s8addq	r17, #0, r12		; See if CPU exists
	subq	r31, r12, r12		;
	ldq/p	r12, pal$cpu0(r12)	;
	beq	r12, 20$		; Branch if it doesn't
	lda	r12, ^x380(r17)		; Write 38x000160
	sll	r12, #24, r12		;
	lda	r13, 1(r31)		; Get bit to set
	sll	r13, #35, r13		;
	stq/p	r13, ^x160(r12)		; Set the node halt request
	mb				; Make sure it goes out
	.endc
20$:	mf	r12, pt12		; Restore registers
	mf	r13, pt13		;
	hw_rei				; Return


	.if ne	<medulla_system & lca4>
;+
; MEDU_INT_ENABLE - Cserve Function Enable Interrupts (Medulla)
;
; Entry:
;	Hardware dispatch via callPal cserve instruction
;	Cserve vector 52 in a0
;	New bits to add to the interrupt mask set in a1
;
; Exit:
;	r0 has current enabled interrupts mask
;	SIO/VIP interrupt masks updated
;	registers preserved
;-

medu_int_enable:
	mt	r12, pt12		; save
	mt	r13, pt13		; save
	mt	r14, pt14		; save
	mt	r15, pt15		; save

	sget_addr r13, pal$impure_base, r31	; Base of scratch area
	ldq/p	r12, medu$q_enabled_ints_mask(r13) ; get current mask
	bis	r12, r17, r12		; turn on new bits
	stq/p	r12, medu$q_enabled_ints_mask(r13) ; set as new mask

	stall	1			;??? need 3 cycles from last mt
	mf	r15, pt9			; get ps
	srl	r15, #ps$v_ipl, r15		; get ipl to bit 0
	and	r15, #<ps$m_ipl@<-ps$v_ipl>>, r15 ; clean to just ipl to pass

	pvc$jsr		medmskint5, bsr=1
	bsr	r13, medu$mask_ints_all_noopt	; mask ints at SIO & VIP

	pvc$jsr         medvicint, bsr=1
	bsr     r13, medu$setup_ints_vic	; enable ints at the VIC

	; reenable wdog halt if turned on
	sget_addr r12, pal$impure_base, r31		; Base of scratch area
	ldq/p	r14, medu$q_enabled_ints_mask(r12)	; mask of enabled ints
	srl	r14, #IMASK$V_IRQ0_HALT, r12	; halt interrupt
	blbc	r12, 10$			; br if not to set
	medu$write_sio	<^x00>, SIO$B_NMI_CSR	; enable SERR/IOCHK ints
10$:
	; A PCI reset may have disabled master NMI
	medu$write_sio	<^x00>, SIO$B_NMI_ENB	; master NMI enable

	sget_addr r12, pal$impure_base, r31     ; Base of scratch area
	ldq/p	r0, medu$q_enabled_ints_mask(r12) ; return current mask

	mf	r15, pt15		; restore
	mf	r14, pt14		; restore
	mf	r13, pt13		; restore
	mf	r12, pt12		; restore
	 hw_rei			; back


;+
; MEDU_INT_DISABLE - Cserve Function Disable Interrupts (Medulla)
;
; Entry:
;	Hardware dispatch via callPal cserve instruction
;	Cserve vector 53 in a0
;	Bits to clear from the interrupt mask set in a1
;
; Exit:
;	r0 has current enabled interrupts mask
;	SIO/VIP interrupt masks updated
;	registers preserved
;-

medu_int_disable:
	mt	r12, pt12		; save
	mt	r13, pt13		; save
	mt	r14, pt14		; save
	mt	r15, pt15		; save

	sget_addr r13, pal$impure_base, r31	; Base of scratch area
	ldq/p	r12, medu$q_enabled_ints_mask(r13) ; get current mask
	bic	r12, r17, r12		; turn off selected bits
	stq/p	r12, medu$q_enabled_ints_mask(r13) ; set as new mask

	stall	1			;??? need 3 cycles from last mt
	mf	r15, pt9			; get ps
	srl	r15, #ps$v_ipl, r15		; get ipl to bit 0
	and	r15, #<ps$m_ipl@<-ps$v_ipl>>, r15 ; clean to just ipl to pass

	pvc$jsr		medmskint5, bsr=1
	bsr	r13, medu$mask_ints_all_noopt	; mask ints at SIO & VIP

	pvc$jsr         medvicint, bsr=1
	bsr     r13, medu$setup_ints_vic	; enable ints at the VIC

	sget_addr r12, pal$impure_base, r31     ; Base of scratch area
	ldq/p	r0, medu$q_enabled_ints_mask(r12) ; return current mask

	mf	r15, pt15		; restore
	mf	r14, pt14		; restore
	mf	r13, pt13		; restore
	mf	r12, pt12		; restore
	 hw_rei			; back

;
; wr_bad_ecc
;       This routine sets a write_bad_ecc bit in the ESR and writes data
;       to the address value passed in R16 and then clears the ESR.  This
;       code sequence is critical to the functioning of this test. The code
;	must be loaded into bcache by running thru the code w/out setting the
;	error bits.  The 2nd time thru the error bits are written and the 
;	address in Bcache|Memory is written with bad ECC.                
;
;	This test can be used to test ECC logic in either Bcache or Memory.
;
; Inputs:
;	r17, r18, r19, r20: address, data, wec value to write, and 2nd address
;	                    to get around a hit in Icache from occurring on 2nd
;			    read.  
;			
;	r12 - r15 : Scratch registers
; Output: 
;	r0   	: Return Error Status Register(ESR) value to caller
;-
wr_bad_ecc::

memctlr_base = ^x1200
esr$offset = ^x0068
esr$err_mask = ^x1686

	mt	r12, pt12		; save
	mt	r13, pt13		; save
	mt	r14, pt14		; save
	mt	r15, pt15		; save

	zap r12, #^xff, r12               ; zero the register
	zap r13, #^xff, r13               ; zero the register
	zap r14, #^xff, r14               ; zero the register
	zap r15, #^xff, r15               ; zero the register

	bis 	r15, r17, r15		; set address to test for 1st pass.

        ; Set the write bad ecc bit in ESR
        ldah     r12, memctlr_base(r31)  ; 0.1200.0000       
	sll	 r12, #4, r12             ; 1.2000.0000
	bis	 r12, esr$offset, r12     ; 1.2000.0068
10$:
	; load write bad ecc <WEC> bit(s)
	sll	 r14, #32, r14            ; X.0000.0000
	stq_p	 r14, (r12)       	; write to the ESR
        mb
	;stall 	 3			; let it settle

	; Now force bad ecc to occur
	stq_p	r18, (r15)       	; write to memory|bcache
	mb

	; Clear the <WEC> bit(s) but not the error!  MCHCK will handle.
	stq_p	 r31, (r12)       	; write to the ESR
        mb
	;stall 	 3			; give time for ESR to clear

	ldq_p	r22, (r15)       	; read to memory|bcache to 
					; cause the calculation of ecc
	stall 	 3			; give time for error to be flagged

        ; Store the ESR to return
	ldq_p	 r0, (r12)       	; read the ESR and store 

	; Write good ecc to restore memory
        stq_p   r18, (r15)              ; write to memory|bcache
        mb

      	bne	r13, 30$                ; This loop ensures that we execute     
	bis	r13, #1, r13            ; out of bcache for bcache tests.
	bis	r14, r19, r14           ; load write bad ecc bit 2nd time thru
	bis 	r31, r20, r15		; set address to test for 2nd pass.
	br 	r31, 10$
30$:

	; DEBUG - This was used to clear errors before mchecks were enabled
	;lda	 r15, esr$err_mask(r31)  ; load error bits
	;stq_p	 r15, (r12)       	; write to the ESR

	mf	r15, pt15		; restore
	mf	r14, pt14		; restore
	mf	r13, pt13		; restore
	mf	r12, pt12		; restore
	hw_rei				;  and return
; end of wr_bad_ecc

;
; wr_bad_tag
;	This routine sets the write_bad_tag bit in the CAR and writes data 
;       to the address value passed in R16 and then clears the CAR.  This
;       code sequence is critical to the functioning of this test. The code
;	must be loaded into bcache by running thru the code w/out setting the
;	error bits.  The 2nd time thru the error bits are written and the 
;	address in Bcache is written with bad parity.              
;
; Inputs:
;	r17, r18    : Address and data to be tested.
;	r12 -r15      : Scratch registers
;
; Output: 
;	r0   	: Return Error Status Register(ESR) value to caller
;-
wr_bad_tag::


memctlr_base = ^x1200
car$offset = ^x0078
esr$offset = ^x0068
esr$err_mask = ^x1686

	mt	r12, pt12		; save
	mt	r13, pt13		; save
	mt	r14, pt14		; save
	mt	r15, pt15		; save

	zap r12, #^xff, r12               ; zero the register
	zap r13, #^xff, r13               ; zero the register
	zap r14, #^xff, r14               ; zero the register
	zap r15, #^xff, r15               ; zero the register

	; Force a hit in bcache to occur
	ldq_p	r31, (r17)       	; read memory
	mb
	; ensure good ecc is established
	ldq_p	r31, (r17)       	; read memory
	mb

        ; Set the write bad tag bit <WWP> in CAR
        ldah     r13, memctlr_base(r31) ; 0.1200.0000       
	sll	 r13, #4, r13           ; 1.2000.0000
	bis	 r13, car$offset, r13   ; 1.2000.0078
	ldq_p	 r14, (r13)       	; read the CAR
10$:
	bis	 r14, r15, r15          ; load write bad tag bit
	stq_p	 r15, (r13)       	; write to CAR
	mb
	stall	 3			; let it settle 

	; Now force the calculation of bad tag to occur
	stq_p	r18, (r17)       	; write Bcache
	mb

	; Clear the setting of bad tag bit <WWP> in CAR
	stq_p	 r14, (r13)       	; restore CAR
	mb
	stall	 3			; let it settle 

	; One more write will Flag an error and restore good tag
	stq_p	r18, (r17)       	; write Bcache
	mb
	
      	bne	r12, 30$
	bis	r12, #1, r12
	bis	r31, #^x8, r15          ; load write bad tag bit
	br 	r31, 10$
30$:
        ; Store ESR and return
        ldah     r13, memctlr_base(r31) ; 0.1200.0000       
	sll	 r13, #4, r13           ; 1.2000.0000
	bis	 r13, esr$offset, r13   ; 1.2000.0068
	ldq_p	 r0, (r13)       	; read the ESR and store

	; This was used to clear errors before mchecks were enabled
	;lda	 r15, esr$err_mask(r31)  ; load error bits
	;stq_p	 r15, (r13)       	; write to ESR
        ;mb

	mf	r15, pt15		; restore
	mf	r14, pt14		; restore
	mf	r13, pt13		; restore
	mf	r12, pt12		; restore
	hw_rei				;  and return
; end of wr_bad_tag


;+
; MEDU_WDOG_INTS - Cserve Function Read & Clear Watchdog Interrupts (Medulla)
;
; Entry:
;	Hardware dispatch via callPal cserve instruction
;	Cserve vector 51 in a0
;
; Exit:
;	r0 has current count of watchdog interrupts received.
;	Count is cleared in palcode memory.
;	a0 changed.
;-

medu_wdog_ints:
	sget_addr r16, pal$impure_base, r31	; Base of scratch area
	ldq/p	r0, medu$q_wdog_ints_count(r16)	; get current count for return
	stq/p	r31, medu$q_wdog_ints_count(r16) ; clear count in memory
	 hw_rei			; back

	.endc

	.if ne	cortex_system
;+
; CORTEX_INT_ENABLE - Cserve Function Enable Interrupts (Cortex)
;
;	Note: unlike the MEDU_INT_ENABLE cserve, from which this cserve is
; 	largely copied, this cserve does not control interrupts handled by
;	the SIO PICs.  Those interrupts must be enabled and disabled by the
;	O/S directly.
;	
;	Note: The format of the interrupt mask as stored in the impure area is
;	optimized for interrupt service, and includes bits in the Xilinx 
;	IRR's that are always '1'.  The mask passed back and forth through this
;	CSERVE does not contain these bits, hence there is are two translation
;	routines to insert and strip these bits.
;
; Entry:
;	Hardware dispatch via callPal cserve instruction
;	Cserve vector 52 in a0 (r17)
;	New bits to add to the interrupt mask set in a1
;
; Exit:
;	r0 has current enabled interrupts mask
;	SIO/VIP interrupt masks updated
;	registers preserved
;-

cortex_int_enable:
	mt	r12, pt12		; save
	mt	r13, pt13		; save
	mt	r14, pt14		; save
	mt	r15, pt15		; save

	pvc$jsr		ctxintxlate1, bsr=1
	bsr	r13, cortex$xlate_ctoi	; xlate cserve msk to impure msk(r17)

	; turn on "must be one" bits in mask before "oring" old and new masks.

	get_addr r13, IMASK$M_MBO, r31	
	bis	r13, r17, r17		; Turn on "must be one" bits.	

	sget_addr r13, pal$impure_base, r31	; Base of scratch area
	ldq/p	r15, cortex$q_enabled_ints_mask(r13) ; get current mask
	bis	r15, r17, r15		; turn on new bits
	stq/p	r15, cortex$q_enabled_ints_mask(r13) ; set as new mask

; Push the mask bits that apply to the xilinx out to the respective mask
; registers at ^x802-^x805.  Note that ipl23 and ipl22 are contained in 
; a single register, and also that ipl20 ints are spread across ^x804 
; and ^x805.

	eqv	r15, r31, r15		; Compliment the mask bits.

	bis	r15, r15, r14		; r14 = current masks.
	out_word <^x804>, r14 		; Write all ipl20 int enables.
	srl	r15, #CORTEX$V_IRQ1_SHIFT, r14
	out	<^x803>, r14		; Write ipl21 int enables.
	srl	r15, #CORTEX$V_IRQ3_SHIFT, r14
	out	<^x802>, r14		; Write ipl23+ipl22 int enables.
		
	pvc$jsr         medvicint, bsr=1
	bsr	r13, medu$setup_ints_vic	; enable ints at the VIC

	; reenable wdog halt if turned on
	sget_addr r12, pal$impure_base, r31		; Base of scratch area
	ldq/p	r14, cortex$q_enabled_ints_mask(r12)	; mask of enabled ints
	srl	r14, #IMASK$V_IRQ0_HALT, r12	; halt interrupt
	blbc	r12, 10$			; br if not to set
	medu$write_sio	<^x00>, SIO$B_NMI_CSR	; enable SERR/IOCHK ints
10$:
	; A PCI reset may have disabled master NMI
	medu$write_sio	<^x00>, SIO$B_NMI_ENB	; master NMI enable

	sget_addr r12, pal$impure_base, r31     ; Base of scratch area
	ldq/p	r17, cortex$q_enabled_ints_mask(r12) ; fetch current mask

	pvc$jsr		ctxintxlate2, bsr=1
	bsr	r13, cortex$xlate_itoc	; xlate impure msk(r17)
        bis	r17, r17, r0		; Return current mask in CSERVE format.

	mf	r15, pt15		; restore
	mf	r14, pt14		; restore
	mf	r13, pt13		; restore
	mf	r12, pt12		; restore
	hw_rei			; back

;+
; CORTEX_INT_DISABLE - Cserve Function Disable Interrupts (Cortex)
;
;	Note: unlike the MEDU_INT_DISABLE cserve, from which this cserve is
; 	largely copied, this cserve does not control interrupts handled by
;	the SIO PICs.  Those interrupts must be enabled and disabled by the
;	O/S directly.
;	
;	Note: The format of the interrupt mask as stored in the impure area is
;	optimized for interrupt service, and includes bits in the Xilinx 
;	IRR's that are always '1'.  The mask passed back and forth through this
;	CSERVE does not contain these bits, hence there is are two translation
;	routines to insert and strip these bits.
;
; Entry:
;	Hardware dispatch via callPal cserve instruction
;	Cserve vector 52 in a0 (r17)
;	New bits to add to the interrupt mask set in a1
;
; Exit:
;	r0 has current enabled interrupts mask
;	SIO/VIP interrupt masks updated
;	registers preserved
;-

cortex_int_disable:
	mt	r12, pt12		; save
	mt	r13, pt13		; save
	mt	r14, pt14		; save
	mt	r15, pt15		; save

	pvc$jsr		ctxintxlate1, bsr=1
	bsr	r13, cortex$xlate_ctoi	; xlate cserve msk to impure msk(r17)

	; clear MBO bits in mask before bic'ing old and new masks.

	get_addr r13, IMASK$M_MBO, r31	
	bic	r17, r13, r17		; remove mbo bits from disable mask.

	sget_addr r13, pal$impure_base, r31	; Base of scratch area
	ldq/p	r15, cortex$q_enabled_ints_mask(r13) ; get current mask
	bic	r15, r17, r15		; turn off new bits
	stq/p	r15, cortex$q_enabled_ints_mask(r13) ; set as new mask

; Push the mask bits that apply to the xilinx out to the respective mask
; registers at ^x802-^x805.  Note that ipl23 and ipl22 are contained in 
; a single register, and also that ipl20 ints are spread across ^x804 
; and ^x805.

	eqv	r15, r31, r15		; Compliment the mask bits.
	bis	r15, r15, r14		; r14 = current masks.
	out_word <^x804>, r14 		; Write all ipl20 int enables.
	srl	r15, #CORTEX$V_IRQ1_SHIFT, r14
	out	<^x803>, r14		; Write ipl21 int enables.
	srl	r15, #CORTEX$V_IRQ3_SHIFT, r14
	out	<^x802>, r14		; Write ipl23+ipl22 int enables.
		
	pvc$jsr         medvicint, bsr=1
	bsr	r13, medu$setup_ints_vic	; enable ints at the VIC

	; reenable wdog halt if turned on
	sget_addr r12, pal$impure_base, r31		; Base of scratch area
	ldq/p	r14, cortex$q_enabled_ints_mask(r12)	; mask of enabled ints
	srl	r14, #IMASK$V_IRQ0_HALT, r12	; halt interrupt
	blbc	r12, 10$			; br if not to set
	medu$write_sio	<^x00>, SIO$B_NMI_CSR	; enable SERR/IOCHK ints
10$:
	; A PCI reset may have disabled master NMI
	medu$write_sio	<^x00>, SIO$B_NMI_ENB	; master NMI enable

	sget_addr r12, pal$impure_base, r31     ; Base of scratch area
	ldq/p	r17, cortex$q_enabled_ints_mask(r12) ; fetch current mask

	pvc$jsr		ctxintxlate3, bsr=1
	bsr	r13, cortex$xlate_itoc	; xlate impure msk(r17)
        bis	r17, r17, r0		; Return current mask in CSERVE format.


	mf	r15, pt15		; restore
	mf	r14, pt14		; restore
	mf	r13, pt13		; restore
	mf	r12, pt12		; restore
	hw_rei			; back


;; Routine to translate Cortex interrupt bit masks for Cortex from the 
;; CSERVE format to the format used in the impure area.  Two formats are 
;; needed because there are several bits in the Xilinx interrupt control 
;; registers that are MBO; these represent enables for SIO and VME interrupts,
;; which are enabled/disabled in the SIO and VIC, respectively.
;;
;; Entry:
;; 	Quadword int mask from CSERVE caller in R17.
;;      Return address in r13
;;
;; Registers Used:
;;	R17: input quadword, and mask accumulator
;;	r12: scratch
;;	r14: scratch
;; 
;; Exit:
;;	r17: Quadword int mask in "impure" format (as stored in impure area 
;;	for masking with Xilinx int status registers during int dispatch).
;;
cortex$xlate_ctoi:
 	bis	r17, r17, r12	; r12 = CSERVE mask.

	; Bits <63:23>, <9:0> of mask are the same between the two formats, 
	; so there is nothing to do for those bits.

	; clear bits needing xlation in accumulated impure mask before bis'ing
	; in the source bits.

	get_addr r14, CORTEX$M_XLATE_CTOI_ZAP, r31	; Load up mask of bits to xlate.
	bic	r17, r14, r17		; Zap the bits that require xlation.	

	sll	r12, #1, r12		; Step 1.
	get_addr r14, CORTEX$M_XLATE1, r31 
	and	r12, r14, r14		; Mask source bits not being xlated.
	bis	r14, r17, r17		; Accumulate xlated bits from step 1.	

	sll	r12, #1, r12		; Step 2.
	get_addr r14, CORTEX$M_XLATE2, r31 
	and	r12, r14, r14		; Mask source bits not being xlated.
	bis	r14, r17, r17		; Accumulate xlated bits from step 1.	

	sll	r12, #1, r12		; Step 3.
	get_addr r14, CORTEX$M_XLATE3, r31 
	and	r12, r14, r14		; Mask source bits not being xlated.
	bis	r14, r17, r17		; Accumulate xlated bits from step 1.	

	ret	r31, (r13)


;; Routine to translate Cortex interrupt bit masks for Cortex from the 
;; impure area format to the format used by the int_enable and int_disable
;; CSERVEs.  
;;
;; Entry:
;; 	Quadword int mask from CSERVE caller in R17.
;;      Return address in r13
;;
;; Registers Used:
;;	R17: input quadword, and mask accumulator
;;	r12: scratch
;;	r14: scratch
;;	r15: scratch
;; 
;; Exit:
;;	r17: Quadword int mask in "CSERVE" format (as stored in impure area for
;;	rapid masking with Xilinx int status registers during int dispatch).
;;
cortex$xlate_itoc:
 	bis	r17, r17, r12	; r12 = impure mask.

	; Bits <63:23>, <9:0> of mask are the same between the two formats, 
	; so there is nothing to do for those bits.

	; clear bits needing xlation in accumulated CSERVE mask before bis'ing 
	; in the source bits.

	get_addr r14, CORTEX$M_XLATE_ITOC_ZAP, r31 ; Load up mask of bits to xlate.
	bic	r17, r14, r17		; Zap the bits that require xlation.	

	get_addr r14, CORTEX$M_XLATE1, r31 
	and	r12, r14, r15		; Mask source bits not being xlated.
	srl	r15, #1, r15		; Step 1.
	bis	r15, r17, r17		; Accumulate xlated bits from step 1.	

	get_addr r14, CORTEX$M_XLATE2, r31 
	and	r12, r14, r15		; Mask source bits not being xlated.
	srl	r15, #2, r15		; Step 2.
	bis	r15, r17, r17		; Accumulate xlated bits from step 2.	

	get_addr r14, CORTEX$M_XLATE3, r31 
	and	r12, r14, r15		; Mask source bits not being xlated.
	srl	r15, #3, r15		; Step 3.
	bis	r15, r17, r17		; Accumulate xlated bits from step 3.	

	ret	r31, (r13)



;+
; CORTEX_WDOG_INTS - Cserve Function Read & Clear Watchdog Interrupts (Cortex)
;
; Entry:
;	Hardware dispatch via callPal cserve instruction
;	Cserve vector 51 in a0
;
; Exit:
;	r0 has current count of watchdog interrupts received.
;	Count is cleared in palcode memory.
;	a0 changed.
;-

cortex_wdog_ints:
	sget_addr r16, pal$impure_base, r31	; Base of scratch area
	ldq/p	r0, medu$q_wdog_ints_count(r16)	; get current count for return
	stq/p	r31, medu$q_wdog_ints_count(r16) ; clear count in memory
	 hw_rei			; back

	.endc


	.enabl	lsb

	END_PAL_ROUTINE		CSERVE

show_pal_banner:
	mf	r1, pt27
	ldq/p	r2, pal$primary(r31)
	subq	r2, r1, r2
	bne	r2, 50$
	cfw_setup
	cfw_lock
	.if ne	sable_system
	.if eq	sable_sromtt_debug
	bis	r15, r31, r19
	eisa_write	<rtco>, <^x0e>
	eisa_read	<rtcd>
	bis	r19, r31, r15
	cmpeq	r12, #^x01, r12
	bne	r12, 20$
	.endc
	.endc
	br	r18, 10$
	.long	pal_banner+^x8000
	.global	osfpal_banner
	.long	osfpal_banner+^x8000
10$:	ldl/p	r2, 0(r18)
	pvc$jsr		cs, bsr=1
	bsr	r19, cfw_string
	ldl/p	r2, 4(r18)
	pvc$jsr		cs, bsr=1
	bsr	r19, cfw_string
20$:	mf	r1, pt27
	lda	r2, pal$impure_base+impure$cpu_type_offset(r31)
	s8addq	r1, r2, r1
	ldl/p	r2, (r1)
	ldl/p	r3, 4(r1)
	.if ne	ev4_pass1
	cmpeq	r3, #2, r3
	beq	r3, cfw_warn_die
	cmpeq	r2, #1, r3
	beq	r3, cfw_warn_die
	.endc
	.if ne	ev4_pass2
	cmpeq	r3, #2, r3
	beq	r3, 30$
	cmpeq	r2, #1, r3
	bne	r3, cfw_warn_die
	cmpeq	r2, #2, r3
	bne	r3, 40$
30$:	pvc$jsr		cw, bsr=1
	bsr	r19, cfw_warn
	.endc
	.if ne	ev4_pass3
	cmpeq	r3, #2, r3
	beq	r3, 40$
	cmpeq	r2, #1, r3
	bne	r3, cfw_warn_die
	cmpeq	r2, #3, r3
	bne	r3, 40$
	pvc$jsr		cw, bsr=1
	bsr	r19, cfw_warn
	.endc
40$:	cfw_unlock
	pvc$jsr		spb, bsr=1, dest=1
50$:	ret	r31, (r26)

cfw_string:
10$:	bic	r2, #7, r3
	ldq/p	r3, (r3)
	extbl	r3, r2, r3
	beq	r3, 20$
	cfw_putc	r3
	addq	r2, #1, r2
	br	r31, 10$
20$:	lda	r2, 4(r31)
30$:	cfw_putc	r31
	subq	r2, #1, r2
	bne	r2, 30$
	pvc$jsr		cs, bsr=1, dest=1
	ret	r31, (r19)

	.align	quad

pal_banner::
	.ascii	<13><10><10>"VMS PALcode "
	.if ne	vltr
	.ascii	"V"
	.iff
	.ascii	"X"
	.endc
	.if ne	vmaj/10
	.byte	^a"0"+<vmaj/10>
	.endc
	.byte	^a"0"+<vmaj-<vmaj/10*10>>
	.ascii	"."
	.byte	^a"0"+<vmin/10>
	.byte	^a"0"+<vmin-<vmin/10*10>>
	.ascii	"-"
	.if ne	vvar/100
	.byte	^a"0"+<vvar/100>
	.endc
	.if ne	vvar/10
	.byte	^a"0"+<<vvar-<vvar/100*100>>/10>
	.endc
	.byte	^a"0"+<vvar-<vvar/10*10>>
	.if ne	vmod
	.byte	^a"A"+<vmod-1>
	.endc
	.byte	0
	.align	quad

cfw_warn_die:
	pvc$jsr		cw, bsr=1
	bsr	r19, cfw_warn
	pvc$violate	1006
10$:	br	r31, 10$

cfw_warn:
	mf	r2, pal_base
	get_addr r2, 40$-pal$start, r2
10$:	bic	r2, #7, r3
	ldq/p	r3, (r3)
	extbl	r3, r2, r3
	beq	r3, 20$
	cfw_putc	r3
	addq	r2, #1, r2
	br	r31, 10$
20$:	lda	r2, 4(r31)
30$:	cfw_putc	r31
	subq	r2, #1, r2
	bne	r2, 30$
	pvc$jsr		cw, bsr=1, dest=1
	ret	r31, (r19)

	.align	quad
40$:	.ascii	"warning -- PALcode is not built for this CPU chip version"
	.asciz	<13><10><10>
	.align	quad

	.endc

	.if ne	generic_system

reset_generic_hardware:
	pvc$jsr		rgh, bsr=1, dest=1
	ret	r31, (r26)

	.endc

	.if ne	sable_system

reset_sable_hardware:
	;
	; Get 38x000000 into R14, and 38e000000 into R15.
	;
	mf	r14, pt27
	lda	r14, ^x380(r14)
	sll	r14, #24, r14
	lda	r15, ^x38e(r31)
	sll	r15, #24, r15
	;
	; Make sure Bcache allocation is on.
	;
	lda	r12, ^x0001(r31)
	sll	r12, #32, r12
	lda	r12, ^x0001(r12)
	ldq/p	r13, ^x000(r14)
	bis	r13, r12, r13
	stq/p	r13, ^x000(r14)
	;
	; Skip this if we're not the primary.
	;
	mf	r12, pt27
	ldq/p	r13, pal$primary(r31)
	subq	r13, r12, r13
	.if ne	sable_sromtt_debug
	beq	r31, reset_sable_secondary
	.iff
	bne	r13, reset_sable_secondary
	.endc
notify_sable_secondaries:
	;
	; Ask the secondaries to restart.
	;
	lda	r13, mp$restart(r31)
	sget_addr r12, pal$impure_base_cpu0, r31
	stq/p	r13, cns$work_request(r12)
	sget_addr r12, pal$impure_base_cpu1, r31
	stq/p	r13, cns$work_request(r12)
	sget_addr r12, pal$impure_base_cpu2, r31
	stq/p	r13, cns$work_request(r12)
	sget_addr r12, pal$impure_base_cpu3, r31
	stq/p	r13, cns$work_request(r12)
	;
	; Disable machine checks so that we can probe.
	;
	mf	r12, pt7
	ldq/p	r13, cns$abox_ctl(r12)
	bic	r13, #1@abox$v_mchk, r12
	mt	r12, abox_ctl
	stall	5
	;
	; See which CPU modules exist.
	;
	mf	r12, biu_addr
	lda	r15, ^x380(r31)
	sll	r15, #24, r15
	ldq/p	r12, (r15)
	mb
	mf	r12, biu_stat
	and	r12, #1, r12
	cmovne	r12, r31, r15
	stq/p	r15, pal$cpu0(r31)
	mf	r12, biu_addr
	lda	r15, ^x381(r31)
	sll	r15, #24, r15
	ldq/p	r12, (r15)
	mb
	mf	r12, biu_stat
	and	r12, #1, r12
	cmovne	r12, r31, r15
	mf	r12, biu_addr
	stq/p	r15, pal$cpu1(r31)
	lda	r15, ^x382(r31)
	sll	r15, #24, r15
	ldq/p	r12, (r15)
	mb
	mf	r12, biu_stat
	and	r12, #1, r12
	cmovne	r12, r31, r15
	stq/p	r15, pal$cpu2(r31)
	mf	r12, biu_addr
	lda	r15, ^x383(r31)
	sll	r15, #24, r15
	ldq/p	r12, (r15)
	mb
	mf	r12, biu_stat
	and	r12, #1, r12
	cmovne	r12, r31, r15
	stq/p	r15, pal$cpu3(r31)
	mf	r12, biu_addr
	lda	r16, ^x38f(r31)
	sll	r16, #24, r16
	ldq/p	r12, (r16)
	mb
	mf	r12, biu_stat
	and	r12, #1, r12
	cmovne	r12, r31, r16
	;
	; Enable machine checks again.
	;
	mf	r12, biu_addr
	mt	r13, abox_ctl
	stall	5
	lda	r15, ^x38e(r31)
	sll	r15, #24, r15
	;
	; Try notifying each secondary.
	;
	lda	r12, 1(r31)
	sll	r12, #35, r12
	ldq/p	r13, pal$cpu0(r31)
	beq	r13, 10$
	stq/p	r12, ^x160(r13)
	mb
10$:	ldq/p	r13, pal$cpu1(r31)
	beq	r13, 20$
	stq/p	r12, ^x160(r13)
	mb
20$:	ldq/p	r13, pal$cpu2(r31)
	beq	r13, 30$
	stq/p	r12, ^x160(r13)
	mb
30$:	ldq/p	r13, pal$cpu3(r31)
	beq	r13, 40$
	stq/p	r12, ^x160(r13)
	mb
40$:
enable_sio:
	.if ne	lynx_system
	;
	; Enable the standard I/O module as a bus master.
	;   (Write de030000 23000380 to 38e000000 for pass 1 T3/T4.)
	;   (Write de030e00 23000b80 to 38e000000 for pass 2 T3/T4.)
	;   (Write de240e00 23000b80 to 38e000000 for pass 3 T3/T4.)
	;   (Write 00000000 00080000 to 38e000080.)
	;
	ldq/p	r12, ^x000(r15)
	srl	r12, #33, r12
	and	r12, #7, r12
	cmpeq	r12, #4, r13
	beq	r13, 10$
	lda	r12, ^x0000(r31)
	ldah	r12, ^xde03(r12)
	sll	r12, #32, r12
	lda	r12, ^x0380(r12)
	ldah	r12, ^x2300(r12)
	br	r31, 30$
10$:	cmpeq	r12, #5, r13
	beq	r13, 20$
	lda	r12, ^x0e00(r31)
	ldah	r12, ^xde03(r12)
	sll	r12, #32, r12
	lda	r12, ^x0b80(r12)
	ldah	r12, ^x2300(r12)
	br	r31, 30$
20$:	lda	r12, ^x0e00(r31)
	ldah	r12, ^xde24(r12)
	sll	r12, #32, r12
	lda	r12, ^x0b80(r12)
	ldah	r12, ^x2300(r12)
30$:	stq/p	r12, ^x000(r15)
	mb
	ldah	r12, ^x0008(r31)
	stq/p	r12, ^x080(r15)
	mb
	;
	; Enable the ICIC.
	;   (Write 00000000 01000542 to 38e0004c0.)
	; Set the ICIC mode register.
	;   (Write 00000000 00000070 to 38e000460.)
	;   (Write 00000000 00000000 to 38e0004a0.)
	; Set the ICIC mask register.
	;   (Write 00000000 00000040 to 38e000460.)
	;   (Write ffffffff ffffffff to 38e0004a0.)
	; Set the ICIC edge/level control register.
	;   (Write 00000000 00000050 to 38e000460.)
	;   (Write ffffffff ff000000 to 38e0004a0.)
	;
	lda	r15, +^x400(r15)
	lda	r12, ^x0542(r31)
	ldah	r12, ^x0100(r12)
	stq/p	r12, ^x0c0(r15)
	mb
	lda	r12, ^x70(r31)
	stq/p	r12, ^x060(r15)
	mb
	lda	r12, ^x0000(r31)
	stq/p	r12, ^x0a0(r15)
	mb
	ldq/p	r12, ^x0a0(r15)
	bis	r12, r12, r12
	lda	r12, ^x40(r31)
	stq/p	r12, ^x060(r15)
	mb
	lda	r12, ^xffff(r31)
	stq/p	r12, ^x0a0(r15)
	mb
	ldq/p	r12, ^x0a0(r15)
	bis	r12, r12, r12
	lda	r12, ^x50(r31)
	stq/p	r12, ^x060(r15)
	mb
	ldah	r12, ^xff00(r31)
	stq/p	r12, ^x0a0(r15)
	mb
	ldq/p	r12, ^x0a0(r15)
	bis	r12, r12, r12
	lda	r15, -^x400(r15)
	.iff
	;
	; Enable the standard I/O module as a bus master.
	;   (Write de000040 23000184 to 38e000000 for pass 1 T2.)
	;   (Write de000000 23000180 to 38e000000 for pass 2 T2.)
	;   (Write de000000 23000180 to 38e000000 for pass 3 T2.)
	;
	ldq/p	r12, ^x000(r15)
	srl	r12, #33, r12
	and	r12, #7, r12
	bne	r12, 10$
	lda	r12, ^x0040(r31)
	ldah	r12, ^xde00(r12)
	sll	r12, #32, r12
	lda	r12, ^x0184(r12)
	ldah	r12, ^x2300(r12)
	br	r31, 30$
10$:	cmpeq	r12, #1, r13
	beq	r13, 20$
	lda	r12, ^x0000(r31)
	ldah	r12, ^xde00(r12)
	sll	r12, #32, r12
	lda	r12, ^x0180(r12)
	ldah	r12, ^x2300(r12)
	br	r31, 30$
20$:	lda	r12, ^x0000(r31)
	ldah	r12, ^xde00(r12)
	sll	r12, #32, r12
	lda	r12, ^x0180(r12)
	ldah	r12, ^x2300(r12)
30$:	stq/p	r12, ^x000(r15)
	mb
	.endc
enable_xio:
	;
	; Enable the external I/O module as a bus master.
	;   (Write de030000 23000380 to 38f000000 for pass 1 T3/T4.)
	;   (Write de030e00 23000b80 to 38f000000 for pass 2 T3/T4.)
	;   (Write de240e00 23000b80 to 38f000000 for pass 3 T3/T4.)
	;   (Write 00000000 00080000 to 38f000080.)
	;
	beq	r16, reset_pci_bus
	ldq/p	r12, ^x000(r16)
	srl	r12, #33, r12
	and	r12, #7, r12
	cmpeq	r12, #4, r13
	beq	r13, 10$
	lda	r12, ^x0000(r31)
	ldah	r12, ^xde03(r12)
	sll	r12, #32, r12
	lda	r12, ^x0380(r12)
	ldah	r12, ^x2300(r12)
	br	r31, 30$
10$:	cmpeq	r12, #5, r13
	beq	r13, 20$
	lda	r12, ^x0e00(r31)
	ldah	r12, ^xde03(r12)
	sll	r12, #32, r12
	lda	r12, ^x0b80(r12)
	ldah	r12, ^x2300(r12)
	br	r31, 30$
20$:	lda	r12, ^x0e00(r31)
	ldah	r12, ^xde24(r12)
	sll	r12, #32, r12
	lda	r12, ^x0b80(r12)
	ldah	r12, ^x2300(r12)
30$:	stq/p	r12, ^x000(r16)
	mb
	ldah	r12, ^x0008(r31)
	stq/p	r12, ^x080(r16)
	mb
	.if ne	xio_icic
	;
	; Enable the ICIC.
	;   (Write 00000000 01000542 to 38f0004c0.)
	; Set the ICIC mode register.
	;   (Write 00000000 00000070 to 38f000460.)
	;   (Write 00000000 00000000 to 38f0004a0.)
	; Set the ICIC mask register.
	;   (Write 00000000 00000040 to 38f000460.)
	;   (Write ffffffff ffffffff to 38f0004a0.)
	; Set the ICIC edge/level control register.
	;   (Write 00000000 00000050 to 38f000460.)
	;   (Write ffffffff ffffffff to 38f0004a0.)
	;
	lda	r16, +^x400(r16)
	lda	r12, ^x0542(r31)
	ldah	r12, ^x0100(r12)
	stq/p	r12, ^x0c0(r16)
	mb
	lda	r12, ^x70(r31)
	stq/p	r12, ^x060(r16)
	mb
	lda	r12, ^x0000(r31)
	stq/p	r12, ^x0a0(r16)
	mb
	ldq/p	r12, ^x0a0(r16)
	bis	r12, r12, r12
	lda	r12, ^x40(r31)
	stq/p	r12, ^x060(r16)
	mb
	lda	r12, ^xffff(r31)
	stq/p	r12, ^x0a0(r16)
	mb
	ldq/p	r12, ^x0a0(r16)
	bis	r12, r12, r12
	lda	r12, ^x50(r31)
	stq/p	r12, ^x060(r16)
	mb
	lda	r12, ^xffff(r31)
	stq/p	r12, ^x0a0(r16)
	mb
	ldq/p	r12, ^x0a0(r16)
	bis	r12, r12, r12
	lda	r16, -^x400(r16)
	.endc
reset_pci_bus:
	;
	; Get the value of the EISA clock divisor register, before we reset
	; the PCI (and EISA) bus.
	;
	lda	r8, (r14)
	lda	r9, (r15)
	eisa_write	<esc+addr>, <^x02>
	eisa_write	<esc+data>, <^x0f>
	eisa_write	<esc+addr>, <^x4d>
	eisa_read	<esc+data>
	lda	r20, (r12)
	lda	r14, (r8)
	lda	r15, (r9)
	;
	; Pause for 50 milliseconds, reset the PCI bus, and pause again
	; for 50 milliseconds.
	;
	delay	50
	ldq/p	r13, ^x000(r15)
	mb
	ldah	r12, ^x0040(r31)
	bis	r12, r13, r12
	stq/p	r12, ^x000(r15)
	mb
	delay	50
	stq/p	r13, ^x000(r15)
	mb
	beq	r16, clear_sable_errors
	delay	50
	ldq/p	r13, ^x000(r16)
	mb
	ldah	r12, ^x0040(r31)
	bis	r12, r13, r12
	stq/p	r12, ^x000(r16)
	mb
	delay	50
	stq/p	r13, ^x000(r16)
	mb
clear_sable_errors:
	delay	1000
	;
	; Clear pending Cbus and PCI errors and interrupts.
	;   (Write ffffffff ffffffff to 38e000020.)
	;   (Write ffffffff fff8ffff to 38e000080.)
	;
	lda	r12, ^xffff(r31)
	stq/p	r12, ^x020(r15)
	ldah	r12, ^xfff9(r12)
	stq/p	r12, ^x080(r15)
	;
	; Clear pending Bcache errors.
	;   (Write ffffffff ffffffff to 380000020.)
	;   (Write ffffffff ffffffff to 380000060.)
	;   (Write ffffffff ffffffff to 3800000a0.)
	;   (Write ffffffff ffffffff to 3800000e0.)
	;
	lda	r12, ^xffff(r31)
	stq/p	r12, ^x020(r14)
	stq/p	r12, ^x060(r14)
	stq/p	r12, ^x0a0(r14)
	stq/p	r12, ^x0e0(r14)
	;
	; Clear pending Cbus error interrupt.
	;   (Write 00000000 00000004 to 380000180.)
	;
	lda	r12, ^x0004(r31)
	stq/p	r12, ^x180(r14)
	mb
setup_sable_io:
	;
	; Set up T2 registers as needed.
	;   (Write 00000000 00002000 to 38e000120.)
	;   (Write 00000000 000807ff to 38e000140.)
	;   (Write 00000000 7ff00000 to 38e000160.)
	;   (Write 00000000 00000000 to 38e000180.)
	;
	lda	r12, ^x2000(r31)
	stq/p	r12, ^x120(r15)
	lda	r12, ^x07ff(r31)
	ldah	r12, ^x0008(r12)
	stq/p	r12, ^x140(r15)
	ldah	r12, ^x7ff0(r31)
	stq/p	r12, ^x160(r15)
	stq/p	r31, ^x180(r15)
	;
	; Get on with life.
	;
	eisa_write	<esc+addr>, <^x02>
	eisa_write	<esc+data>, <^x0f>
	eisa_write	<esc+addr>, <^x4d>
	eisa_write	<esc+data>, r20
	eisa_write	<esc+addr>, <^x40>
	eisa_write	<esc+data>, <^x6b>
	;
	; Select bus mode (80x86) for the I²C chip.
	;
	eisa_write	<esc+addr>, <^x64>
	eisa_write	<esc+data>, <^x30>
	eisa_write	<esc+addr>, <^x65>
	eisa_write	<esc+data>, <^x05>
	eisa_write	<esc+addr>, <^x66>
	eisa_write	<esc+data>, <^x0f>
	eisa_write	<esc+addr>, <^x6f>
	eisa_write	<esc+data>, <^x01>
	eisa_write	<iic+s1>, <s1$m_pin>
	;
	; Get the baud rate of COM1.
	;
	lda	r20, baud_9600(r31)
	eisa_write	<rtco>, <^x11>
	eisa_read	<rtcd>
	cmpeq	r12, #69, r13
	beq	r13, 20$
	eisa_write	<rtco>, <^x12>
	eisa_read	<rtcd>
	cmplt	r12, #18, r13
	beq	r13, 20$
	br	r13, 10$
	.long	2			; 57600
	.long	3			; 38400
	.long	6			; 19200
	.long	12			; 9600
	.long	16			; 7200
	.long	24			; 4800
	.long	32			; 3600
	.long	48			; 2400
	.long	58			; 2000
	.long	64			; 1800
	.long	96			; 1200
	.long	192			; 600
	.long	384			; 300
	.long	768			; 150
	.long	857			; 134.5
	.long	1047			; 110
	.long	1536			; 75
	.long	2304			; 50
10$:	s4addq	r12, r13, r12
	ldl/p	r20, 0(r12)
20$:	;
	; Initialize COM1.
	;
	eisa_write	<com1+lcr>, <lcr$m_dla>
	extbl	r20, #0, r16
	eisa_write	<com1+dll>, r16
	extbl	r20, #1, r16
	eisa_write	<com1+dlm>, r16
	eisa_write	<com1+lcr>, <char_8bit!lcr$m_sbs>
	eisa_write	<com1+mcr>, <mcr$m_dtr!mcr$m_rts!mcr$m_out1!mcr$m_out2>
	eisa_write	<com1+fcr>, <fcr$m_fe!fcr$m_rfr!fcr$m_tfr>
	eisa_write	<com1+ier>, <0>
	;
	; Initialize COM2.
	;
	eisa_write	<com2+lcr>, <lcr$m_dla>
	eisa_write	<com2+dll>, <baud_9600@-0>
	eisa_write	<com2+dlm>, <baud_9600@-8>
	eisa_write	<com2+lcr>, <char_8bit!lcr$m_sbs>
	eisa_write	<com2+mcr>, <mcr$m_dtr!mcr$m_rts!mcr$m_out1!mcr$m_out2>
	eisa_write	<com2+fcr>, <fcr$m_fe!fcr$m_rfr!fcr$m_tfr>
	eisa_write	<com2+ier>, <0>
	pvc$jsr		rsh, bsr=1, dest=1
	ret	r31, (r26)

reset_sable_secondary:
	;
	; Clear pending Bcache errors.
	;   (Write ffffffff ffffffff to 38x000020.)
	;   (Write ffffffff ffffffff to 38x000060.)
	;   (Write ffffffff ffffffff to 38x0000a0.)
	;   (Write ffffffff ffffffff to 38x0000e0.)
	;
	lda	r12, ^xffff(r31)
	stq/p	r12, ^x020(r14)
	stq/p	r12, ^x060(r14)
	stq/p	r12, ^x0a0(r14)
	stq/p	r12, ^x0e0(r14)
	;
	; Clear pending Cbus error interrupt.
	;   (Write 00000000 00000004 to 38x000180.)
	;
	lda	r12, ^x0004(r31)
	stq/p	r12, ^x180(r14)
	mb
	;
	; Get on with life.
	;
	pvc$jsr		rsh, bsr=1, dest=1
	ret	r31, (r26)

	align_branch_target

hw_sio:
	.if ne	lynx_system
	lda	r13, ^x38e(r31)		; Read 38e000480
	sll	r13, #24, r13		;
	ldq/p	r12, ^x480(r13)		;
	.if ne	0*sable_system_debug
	cmpeq	r12, #^x08, r14
	bne	r14, 10$
	cmpeq	r12, #^x0c, r14
	bne	r14, 10$
	cmpeq	r12, #^x0f, r14
	bne	r14, 10$
	cmpeq	r12, #^x13, r14
	bne	r14, 10$
	cmpeq	r12, #^x17, r14
	bne	r14, 10$
	mt	r16, pt16
	mt	r17, pt17
	mt	r18, pt18
	mt	r19, pt19
	mt	r12, pt20
	combo_setup
	combo_lock
	combott_putc	<^x0d>
	combott_putc	<^x0a>
	combott_putc	<^x37>
	combott_putc	<^x3c>
	mf	r16, exc_addr
	combott_puth
	combott_putc	<^x2f>
	mf	r16, pt20
	combott_puth	2
	combott_putc	<^x3e>
	combott_putc	<^x0d>
	combott_putc	<^x0a>
	combo_unlock
	mf	r16, pt16
	mf	r17, pt17
	mf	r18, pt18
	mf	r19, pt19
	mf	r12, pt20
10$:
	.endc
	and	r12, #^x80, r14		; Check for passive release
	bne	r14, dismiss_interrupt	;  and exit if so
	and	r12, #^x3f, r12		; Keep only the low six bits
	lda	r15, ^x14(r31)		; Set IPL
	sll	r12, #4, r13		; Set vector offset
	lda	r13, ^x800(r13)		;
	br	r31, complete_interrupt	; Go build trap
	.iff
	eisa_read	<iack>		; Read the interrupt vector
	cmpeq	r12, #^xf8, r14		; Check for a vector of F8
	bne	r14, check_esc		; If so, go check for an ESC interrupt
	.if ne	0*sable_system_debug
	cmpeq	r12, #^x88, r14
	bne	r14, 10$
	cmpeq	r12, #^x8c, r14
	bne	r14, 10$
	cmpeq	r12, #^x8f, r14
	bne	r14, 10$
	cmpeq	r12, #^x93, r14
	bne	r14, 10$
	cmpeq	r12, #^x97, r14
	bne	r14, 10$
	mt	r16, pt16
	mt	r17, pt17
	mt	r18, pt18
	mt	r19, pt19
	mt	r12, pt20
	combo_setup
	combo_lock
	combott_putc	<^x0d>
	combott_putc	<^x0a>
	combott_putc	<^x37>
	combott_putc	<^x3c>
	mf	r16, exc_addr
	combott_puth
	combott_putc	<^x2f>
	mf	r16, pt20
	combott_puth	2
	combott_putc	<^x3e>
	combott_putc	<^x0d>
	combott_putc	<^x0a>
	combo_unlock
	mf	r16, pt16
	mf	r17, pt17
	mf	r18, pt18
	mf	r19, pt19
	mf	r12, pt20
10$:
	.endc
	beq	r12, dismiss_interrupt	; Get out if no vector
	cmpeq	r12, #^xff, r14		; Check for a vector of FF
	bne	r14, dismiss_interrupt	; If so, passive release!
	lda	r15, ^x14(r31)		; Set IPL
	sll	r12, #4, r13		; Set vector offset
	br	r31, complete_interrupt	; Go build trap

check_esc:
	eisa_write	<pic1>, <^x0c>	; Poll the ESC master
	eisa_read	<pic1>,			setup=0
	eisa_write	<pic1>, <^x08>,		setup=0
	and	r12, #^x80, r14		; Did we get valid data?
	beq	r14, 20$		; Nope, get out
	and	r12, #7, r12		; Preserve just the IRQ number
	cmpeq	r12, #2, r14		; Is it the ESC slave?
	beq	r14, 10$		; Branch if not, go finish trap

	eisa_write	<pic2>, <^x0c>	; Poll the ESC slave
	eisa_read	<pic2>,			setup=0
	eisa_write	<pic2>, <^x08>,		setup=0
	and	r12, #^x80, r14		; Did we get valid data?
	beq	r14, 20$		; Nope, get out
	and	r12, #7, r12		; Preserve just the IRQ number
	addq	r12, #8, r12		; Slave is higher than master
10$:	addq	r12, #^xa8, r12		; Add in vector base
	lda	r15, ^x14(r31)		; Set IPL
	sll	r12, #4, r13		; Set vector offset
	br	r31, complete_interrupt	; Go build trap

20$:	eisa_write	<pic0>, <^x60>	; Issue EOI to the SIO master
	br	r31, dismiss_interrupt	;  and bag the interrupt
	.endc

	align_branch_target

hw_xio:
	.if ne	xio_icic
	lda	r13, ^x38f(r31)		; Read 38f000480
	sll	r13, #24, r13		;
	ldq/p	r12, ^x480(r13)		;
	and	r12, #^x80, r14		; Check for passive release
	bne	r14, dismiss_interrupt	;  and exit if so
	and	r12, #^x3f, r12		; Keep only the low six bits
	lda	r15, ^x14(r31)		; Set IPL
	sll	r12, #4, r13		; Set vector offset
	lda	r13, ^xc00(r13)		;
	br	r31, complete_interrupt	; Go build trap
	.iff
	eisa_read	<iack>, hose=1	; Read the interrupt vector
	.if ne	0*sable_system_debug
	mt	r16, pt16
	mt	r17, pt17
	mt	r18, pt18
	mt	r19, pt19
	mt	r12, pt20
	mt	r15, pt21
	combo_setup
	combo_lock
	combott_putc	<^x0d>
	combott_putc	<^x0a>
	combott_putc	<^x37>
	combott_putc	<^x3c>
	mf	r16, exc_addr
	combott_puth
	combott_putc	<^x2f>
	mf	r16, pt20
	combott_puth	2
	combott_putc	<^x3e>
	combott_putc	<^x0d>
	combott_putc	<^x0a>
	combo_unlock
	mf	r16, pt16
	mf	r17, pt17
	mf	r18, pt18
	mf	r19, pt19
	mf	r12, pt20
	mf	r15, pt21
	.endc
	beq	r12, dismiss_interrupt	; Get out if no vector
	cmpeq	r12, #^xff, r14		; Check for a vector of FF
	bne	r14, dismiss_interrupt	; If so, passive release!
	lda	r15, ^x14(r31)		; Set IPL
	sll	r12, #4, r13		; Set vector offset
	br	r31, complete_interrupt	; Go build trap
	.endc

	align_branch_target

hw_timer:
	mf	r13, pt27		; Get WHAMI
	lda	r13, ^x380(r13)		; Write 38x000180
	sll	r13, #24, r13		;
	lda	r14, 1(r31)		; Get bit to clear
	sll	r14, #32, r14		;
	stq/p	r14, ^x180(r13)		; Clear the timer interrupt
	mb				; Make sure it goes out
	rpcc	r13			; Get process cycle counter
	or	r31, #1, r14		; Get a 1
	mf	r12, pt10		; Get system cycle counter
	sll	r14, #32, r14		; Now we have 100000000
	zap	r13, ^xf0, r13		; Get low long of PCC
	zap	r12, ^xf0, r15		; Get low long of SCC
	zap	r12, ^x0f, r12		; Get high long of SCC
	subq	r13, r15, r15		; If PCC<31:0> is less than SCC<31:0>,
	cmovge	r15, r31, r14		;  zero the wrap value
	addq	r12, r14, r12		; Add wrap value to the SCC
	or	r12, r13, r12		; Merge
	mt	r12, pt10		;  and update the SCC
   	lda	r15, ^x16(r31)		; Set IPL
    	lda	r13, ^x600(r31)		; Get vector offset
	stall	1			; Stall
   	br	r31, complete_interrupt	; Go build trap

	align_branch_target

hw_work_request:
	mf	r12, pt7		; Get impure pointer
	ldq/p	r13, cns$work_request(r12) ; Check it for work
	bne	r13, 10$		; Branch if there's work for us to do
	br	r31, dismiss_interrupt	; Otherwise, just exit

10$:	stq/p	r31, cns$work_request(r12) ; Clear pending work request
	srl	r13, #8, r14		; Get parameter
	zapnot	r13, #1, r13		;  and then clear it
	cmpeq	r13, #mp$restart, r12	; Is it a restart request?
	beq	r12, 40$		; Nope
	mf	r15, pt27		; Get WHAMI
	ldq/p	r12, pal$primary(r31)	;
	subq	r12, r15, r12		;
	pvc$violate	1006
	beq	r12, pal$hw_entry_reset	; If primary, go restart now
	lda	r15, ^x380(r15)		; Read 38x00xxxx
	sll	r15, #24, r15		;
	ldq/p	r12, ^x000(r15)		; Read BCC
	lda	r13, 1(r31)		; Clear bits 0 and 32
	sll	r13, #32, r13		;  (turn off Bcache allocation)
	lda	r13, 1(r13)		;
	bic	r12, r13, r12		;
	stq/p	r12, ^x000(r15)		; Write BCC
	mb				;
	stq/p	r31, ^x140(r15)		; Make sure processor mailbox is clear
	mb				;
	mf	r12, pt7		; Get impure pointer
	ldq/p	r12, cns$abox_ctl(r12)	; Set ABOX_CTL the way we want it
	lda	r13, 1@abox$v_dc(r31)	;  (with the Dcache off)
	bic	r12, r13, r12		;
	mt	r12, abox_ctl		;
	stall	5			;
	mt	r31, flush_ic		; Zap out our I-stream cache
	mb				;
	stall	5			;
	mb				;
	br	r31, 20$		;

	align_to_cache_block

20$:	ldah	r12, 1(r31)		; Delay a short while
30$:	subq	r12, #1, r12		;
	bne	r12, 30$		;
	ldq/p	r12, ^x140(r15)		; Read to get new PC
	beq	r12, 20$		; Loop back if no new PC yet
	stq/p	r31, ^x140(r15)		; Clear it again
	mb				;
	pvc$violate	1007
	jmp	r31, (r12)		; Go where we're supposed to go

40$:	cmpeq	r13, #mp$halt, r12	; Is it a halt request?
	beq	r12, dismiss_interrupt	; Nope
	mf	r12, pt12		; Restore R12
	mf	r13, pt13		; Restore R13
	mf	r14, pt14		; Restore R14
	mf	r15, pt15		; Restore R15
	mt	r0, pt0			; Save R0
	pvc$jsr 	updpcb, bsr=1
	bsr	r0, pal$update_pcb	; Update the PCB
	lda	r0, hlt$c_hw_halt(r31)	; Set halt code to hardware halt
	br	r31, pal$enter_console	; Enter the console

	align_branch_target

hw_ip_request:
	mf	r13, pt27		; Get WHAMI
	lda	r13, ^x380(r13)		; Write 38x000160
	sll	r13, #24, r13		;
	stq/p	r31, ^x160(r13)		; Clear the IP interrupt request
	mb				; Make sure it goes out
   	lda	r15, ^x16(r31)		; Set IPL
    	lda	r13, ^x610(r31)		; Get vector offset
   	br	r31, complete_interrupt	; Go build trap

	align_branch_target

hw_cbus_error:
	.if ne	sable_system_debug
	mt	r16, pt16
	mt	r17, pt17
	mt	r18, pt18
	mt	r19, pt19
	combo_setup
	combo_lock
	combott_putc	<^x0d>
	combott_putc	<^x0a>
	combott_putc	<^x0d>
	combott_putc	<^x0a>
	combott_putc	<^x38>
	mf	r16, pt27
	addq	r16, #48, r16
	combott_putc	r16
	combott_putc	<^x3c>
	mf	r16, exc_addr
	combott_puth
	combott_putc	<^x2f>
	mf	r12, pt27
	lda	r12, ^x380(r12)
	sll	r12, #24, r12
	ldq/p	r16, ^x0e0(r12)
	combott_puth
	combott_putc	<^x2f>
	mf	r12, pt27
	lda	r12, ^x380(r12)
	sll	r12, #24, r12
	ldq/p	r16, ^x000(r12)
	and	r16, #1, r16
	combott_puth	1
	combott_putc	<^x3e>
	combott_putc	<^x0d>
	combott_putc	<^x0a>
	combo_unlock
	mf	r16, pt16
	mf	r17, pt17
	mf	r18, pt18
	mf	r19, pt19
	.endc
	mf	r13, pt27		; Get WHAMI
	lda	r13, ^x380(r13)		; Write 38x000180
	sll	r13, #24, r13		;
	lda	r14, 1(r31)		; Get bit to clear
	sll	r14, #2, r14		;
	ldq/p	r12, ^x180(r13)		; Read SIC (CSR12)
	and	r12, r14, r12		; Is the Cbus error interrupt bit set?
	beq	r12, dismiss_interrupt	; Nope, somebody cleared it
	stq/p	r14, ^x180(r13)		; Clear the Cbus error interrupt
	mb				; Make sure it goes out
	;
	; Set up initial values for some things.
	;
	lda	r12, mchk$c_unknown(r31) ; Set error code to "unknown"
	mt	r12, pt0		;
	mf	r12, biu_stat		; Save BUI_STAT
	mt	r12, pt20		;
	mf	r12, biu_addr		; Save BUI_ADDR
	mt	r12, pt21		;
	;
	; Check for Bcache tag or tag control parity errors.  If we find
	; one, we start to panic...
	;
	mf	r15, pt27		; Get WHAMI
	lda	r15, ^x380(r15)		; Read 38x00xxxx
	sll	r15, #24, r15		;
	ldq/p	r12, ^x060(r15)		; Read BCUE
	ldq/p	r13, ^x080(r15)		; Read BCUEA, assume low is valid
	srl	r12, #1, r12		; Check for parity error
	blbs	r12, 80$		; Yep, got one
	srl	r13, #32, r13		; From BCUEA, assume high is valid
	srl	r12, #32, r12		; Check for parity error
	blbc	r12, 90$		; Nope, didn't get one
80$:	mt	r13, pt1		; Save address for later
	;
	; Okay, we have found a Bcache tag or tag control parity error.  We
	; will try to clean up the mess.  We turn off parity checking, and
	; turn allocation back on.  We also turn off the EV's probing of the
	; Bcache.  We then use "allocate invalid" space to flush the cache
	; entry which is bad (this will cause us to lose the data).  After all
	; that, we can put things back like they were:  probing on, parity
	; checking on, allocation off.
	;
	; Due to a bug in the C³, whenever the Bcache is disabled, the Dcache
	; must be disabled as well.  Bcache tag or tag control parity errors
	; cause the Bcache to be automatically disabled, so we must now disable
	; the Dcache as well.
	;
	mf	r12, pt7		; Get impure pointer
	ldq/p	r13, cns$abox_ctl(r12)	; Get ABOX_CTL
	lda	r14, 1@abox$v_dc(r31)	;
	bic	r13, r14, r13		;
	stq/p	r13, cns$abox_ctl(r12)	;
	mt	r13, abox_ctl		; Turn off the Dcache
	stall	3			;
	lda	r12, mchk$c_c3_tag_par(r31) ; Say it's a tag parity error
	mt	r12, pt0		;
	ldq/p	r14, ^x000(r15)		; Read BCC
	lda	r13, 4(r31)		; Clear bits 2 and 34
	sll	r13, #32, r13		;  (turn off parity checking)
	lda	r13, 4(r13)		;
	bic	r14, r13, r12		;
	lda	r13, 1(r31)		; Set bits 0 and 32
	sll	r13, #32, r13		;  (turn on Bcache allocation)
	lda	r13, 1(r13)		;
	bis	r12, r13, r12		;
	stq/p	r12, ^x000(r15)		; Write BCC
	mb				;
	mf	r12, pt7		; Get impure pointer
	ldq/p	r12, cns$biu_ctl(r12)	; Get BIU_CTL, so we can clear
	bic	r12, #1@bc$v_en, r12	;  Bcache enable
	mt	r12, biu_ctl		;
	stall	3			;
	mf	r12, pt1		; Get bad address
	lda	r13, ^xffff(r31)	; Mask off some bits (caution, 4MB
	ldah	r13, ^x0002(r13)	;  maximum cache size assumed here!)
	and	r12, r13, r12		;
	sll	r12, #5, r12		;
	lda	r13, ^x1(r13)		; Read 100000000 for either CPU
	sll	r13, #32, r13		;
	addq	r12, r13, r12		; Get an "allocate invalid" address
	ldq/p	r12, (r12)		; Read it
	mb				; Make sure it happens
	mf	r12, pt7		; Get impure pointer
	ldq/p	r12, cns$biu_ctl(r12)	; Restore BIU_CTL
	mt	r12, biu_ctl		;
	stall	3			;
	stq/p	r14, ^x000(r15)		; Restore BCC
	mb				;
90$:	;
	; Go build the error frame for the O/S.
	;
	lda	r13, scb$v_sysmchk(r31)	; Get vector offset
	br	r31, sable_build_error_frame ; Go log the error

	align_branch_target

hw_system_event:
	mf	r13, pt27		; Get WHAMI
	lda	r13, ^x380(r13)		; Read/write 38x00xxxx
	sll	r13, #24, r13		;
	ldq/p	r12, ^x160(r13)		; Read IPIR
	srl	r12, #35, r12		; Get node halt bit
	blbs	r12, 10$		; Branch if it's not set
	;
	; It's not a node halt, so it must be a normal system event.
	;
	lda	r14, 1(r31)		; Get bit to clear
	sll	r14, #33, r14		;
	stq/p	r14, ^x180(r13)		; Clear the system event interrupt
	mb				; Make sure it goes out
	;
	; Enter console mode on a received halt.
	;
	.if ne	sable_system_debug
	mt	r16, pt16
	mt	r17, pt17
	mt	r18, pt18
	mt	r19, pt19
	combo_setup
	combo_lock
	combott_putc	<^x0d>
	combott_putc	<^x0a>
	combott_putc	<^x0d>
	combott_putc	<^x0a>
	combott_putc	<^x36>
	mf	r16, pt27
	addq	r16, #48, r16
	combott_putc	r16
	combott_putc	<^x3c>
	mf	r16, exc_addr
	combott_puth
	combott_putc	<^x2f>
	lda	r16, 0(r26)
	combott_puth
	combott_putc	<^x2f>
	lda	r16, 0(r27)
	combott_puth
	combott_putc	<^x2f>
	lda	r16, 0(r30)
	combott_puth
	combott_putc	<^x3e>
	combott_putc	<^x0d>
	combott_putc	<^x0a>
	combo_unlock
	mf	r16, pt16
	mf	r17, pt17
	mf	r18, pt18
	mf	r19, pt19
	.endc
	mf	r12, pt28		; Fetch PTBR
	blbc	r12, 20$		; Branch if not in console mode
	ldq/p	r12, pal$callback(r31)	; Are we in a callback?
	beq	r12, dismiss_interrupt	; Nope, ignore this halt request
	lda	r12, 8(r31)		; Pend this halt request
	stq/p	r12, pal$callback(r31)	; Save flag for later
	br	r31, dismiss_interrupt	;  and don't bother now

10$:	;
	; It's a node halt.
	;
	lda	r14, 1(r31)		; Get bit to clear
	sll	r14, #35, r14		;
	stq/p	r14, ^x180(r13)		; Clear the node halt interrupt
	mb				; Make sure it goes out
	br	r31, hw_work_request	; Perform any work requests

20$:	mf	r12, pt27		; Only halt the primary!
	ldq/p	r15, pal$primary(r31)	;
	subq	r15, r12, r15		;
	bne	r15, dismiss_interrupt	;
	mf	r12, pt12		; Restore R12
	mf	r13, pt13		; Restore R13
	mf	r14, pt14		; Restore R14
	mf	r15, pt15		; Restore R15
	mt	r0, pt0			; Save R0
	pvc$jsr 	updpcb, bsr=1
	bsr	r0, pal$update_pcb	; Update the PCB
	lda	r0, hlt$c_hw_halt(r31)	; Set halt code to hardware halt
	br	r31, pal$enter_console	; Enter the console

.macro	mchk$store	n, pal=0, ipr=0
assume	pal+ipr		lt	2	; Either PAL or IPR may be selected
	.if ne	pal
	mf	r14, pt'n'
	stq/p	r14, mchk$pt'n'(r15)
	.endc
	.if ne	ipr
	mf	r14, 'n'
	stq/p	r14, mchk$'n'(r15)
	.endc
.endm

	align_branch_target

sable_build_error_frame:
	;
	; Get the address to use to build the frame.
	;
	lda	r15, pal$logout_base(r31) ; Get logout base address
	lda	r14, pal$logout_specific_size(r31) ; Load CPU-specific size
	mf	r12, pt27		; Get WHAMI
	mulq	r12, r14, r12		;
	addq	r15, r12, r15		; Point to CPU-specific area

	;
	; If a double error is encountered, pass it off to the console;
	; otherwise, build the trap.
	;
	mf	r14, pt25		; Get MCES
	srl	r14, #pt25$v_mck, r12	;  to low bit of R12
	blbc    r12, 10$		; Branch if not double error
	mf	r12, va			; Unlock VA (just in case)
	mf	r13, exc_addr		; Unlock EXC_ADDR (just in case)
	mf	r12, pt12		; Restore R12
	mf	r13, pt13		; Restore R13
	mf	r14, pt14		; Restore R14
	mf	r15, pt15		; Restore R15
	mt	r0, pt0			; Save R0
	pvc$jsr 	updpcb, bsr=1
	bsr	r0, pal$update_pcb	; Update the PCB
	lda	r0, hlt$c_dbl_mchk(r31)	; Set halt code to double error
	br	r31, pal$enter_console	; Enter the console 

10$:	or	r31, #1, r12		; Set MCES flag
	sll	r12, #pt25$v_mck, r12	;  in correct position
	or	r14, r12, r14		;
	mt	r14, pt25		; Store flags

	;
	; Start building the frame.
	;
    	stq/p	r31, mchk$byte_count(r15) ; Zero count just in case
	stq/p	r13, mchk$offsets(r15)	; Store SCB vector 

	;
	; Store error code and revision.
	;
	mf	r14, pt0		; Get error code
	lda	r12, 1(r31)		; Get revision
	sll	r12, #32, r12		;
	or	r14, r12, r14		;
	stq/p	r14, mchk$mchk_code(r15) ; Save it

	;
	; Store PALtemps.
	;
t = 1
.repeat	31
	mchk$store  \t, pal=1		; PALtemps
t = t + 1
.endr

	;
	; Store EV4 IPRs.
	;
	mf	r13, pt7		; Get impure area pointer
	mchk$store  exc_addr, ipr=1	;
;;;	mchk$store  iccsr, ipr=1	;
	mf	r14, pt2		;
	stq/p	r14, mchk$iccsr(r15)	;
	mchk$store  pal_base, ipr=1	;
	mchk$store  hirr, ipr=1		;
	mchk$store  hier, ipr=1		;
	mchk$store  mm_csr, ipr=1	;
;;;	mchk$store  biu_stat, ipr=1	;
	mf	r14, pt20		; BIU_STAT is in PT20
	stq/p	r14, mchk$biu_stat(r15)	;
;;;	mchk$store  biu_addr, ipr=1	; Unlocks BIU_STAT
	mf	r14, pt21		; BIU_ADDR is in PT21
	stq/p	r14, mchk$biu_addr(r15)	;
	mchk$store  va, ipr=1		; Unlocks VA
	mchk$store  dc_stat, ipr=1	;
	mchk$store  dc_addr, ipr=1	; Unlocks DC_STAT
	mchk$store  fill_syndrome, ipr=1 ;
	mchk$store  fill_addr, ipr=1	; Unlocks FILL_SYNDROME
;;;	mchk$store  abox_ctl, ipr=1	;
	ldq/p	r14, cns$abox_ctl(r13)	;
	stq/p	r14, mchk$abox_ctl(r15)	;
;;;	mchk$store  biu_ctl, ipr=1	;
	ldq/p	r14, cns$biu_ctl(r13)	;
	stq/p	r14, mchk$biu_ctl(r15)	;

	;
	; Clear any pending CRDs.
	;
	ornot	r31, #1@sl_clr$v_crd, r13 ; Get acknowledge bit for CRDs
	mt	r13, sl_clr		; Clear it

	;
	; Pull BC_TAG the hard way.
	;
	or	r31, r31, r14		; Clear BC_TAG-to-be
	or	r31, r31, r12		; Start with bit 0
20$:	mf	r13, bc_tag		; Read next bit of BC_TAG
	and	r13, #1, r13		; Make sure to keep just the lowest bit
	sll	r13, r12, r13		; Position that bit correctly
	bis	r14, r13, r14		; Add in the new bit
	addq	r12, #1, r12		; Count up one bit
	cmpeq	r12, #64, r13		; See if we've done all 64 bits
	beq	r13, 20$		; Branch back if not all done yet
	stq/p	r14, mchk$bc_tag(r15)	; Store nice new BC_TAG value
	mt	r31, bc_tag		; Unlocks BC_TAG

	;
	; Pull EXC_MSK the hard way.
	;
	or	r31, r31, r14		; Clear EXC_MSK-to-be
	or	r31, r31, r12		; Start with bit 0
30$:	mf	r13, exc_sum		; Read next bit of EXC_MSK
	srl	r13, #33, r13		; Shift interesting bit down
	and	r13, #1, r13		; Make sure to keep just the lowest bit
	sll	r13, r12, r13		; Position that bit correctly
	bis	r14, r13, r14		; Add in the new bit
	addq	r12, #1, r12		; Count up one bit
	cmpeq	r12, #64, r13		; See if we've done all 64 bits
	beq	r13, 30$		; Branch back if not all done yet
	stq/p	r14, mchk$exc_msk(r15)	; Store nice new EXC_MSK value
	mchk$store  exc_sum, ipr=1	;  and EXC_SUM value
	mt	r31, exc_sum		; Unlocks EXC_SUM

	;
	; Store Sable CSRs.
	;
	mf	r13, pt27		; Get WHAMI
	lda	r13, ^x380(r13)		; Load 38x00000
	sll	r13, #24, r13		;
	ldq/p	r12, ^x000(r13)		; BCC_CSR0
	stq/p	r12, mchk$bcc_csr0(r15)	;
	ldq/p	r12, ^x020(r13)		; BCCE_CSR1
	stq/p	r12, mchk$bcce_csr1(r15) ;
	ldq/p	r12, ^x040(r13)		; BCCEA_CSR2
	stq/p	r12, mchk$bccea_csr2(r15) ;
	ldq/p	r12, ^x060(r13)		; BCUE_CSR3
	stq/p	r12, mchk$bcue_csr3(r15) ;
	ldq/p	r12, ^x080(r13)		; BCUEA_CSR4
	stq/p	r12, mchk$bcuea_csr4(r15) ;
	ldq/p	r12, ^x0a0(r13)		; DTER_CSR5
	stq/p	r12, mchk$dter_csr5(r15) ;
	ldq/p	r12, ^x0c0(r13)		; CBCTL_CSR6
	stq/p	r12, mchk$cbctl_csr6(r15) ;
	ldq/p	r12, ^x0e0(r13)		; CBE_CSR7
	stq/p	r12, mchk$cbe_csr7(r15)	;
	ldq/p	r12, ^x100(r13)		; CBEAL_CSR8
	stq/p	r12, mchk$cbeal_csr8(r15) ;
	ldq/p	r12, ^x120(r13)		; CBEAH_CSR9
	stq/p	r12, mchk$cbeah_csr9(r15) ;
	ldq/p	r12, ^x140(r13)		; PMBX_CSR10
	stq/p	r12, mchk$pmbx_csr10(r15) ;
	ldq/p	r12, ^x160(r13)		; IPIR_CSR11
	stq/p	r12, mchk$ipir_csr11(r15) ;
	ldq/p	r12, ^x180(r13)		; SIC_CSR12
	stq/p	r12, mchk$sic_csr12(r15) ;
	ldq/p	r12, ^x1a0(r13)		; ADLK_CSR13
	stq/p	r12, mchk$adlk_csr13(r15) ;
	ldq/p	r12, ^x1c0(r13)		; MADRL_CSR14
	stq/p	r12, mchk$madrl_csr14(r15) ;
	ldq/p	r12, ^x1e0(r13)		; CRR_CSR15
	stq/p	r12, mchk$crr_csr15(r15) ;

	;
	; Retrieve SCB vector and set up byte count and offsets.
	;
	ldq/p	r13, mchk$offsets(r15)	; Retrieve SCB vector
	lda	r14, mchk$cpu_offset(r31) ; Build the offsets
	stl/p	r14, mchk$offsets+0(r15) ;
	lda 	r14, mchk$sys_offset(r31) ;
	stl/p	r14, mchk$offsets+4(r15) ;
	lda 	r14, mchk$mchk_size(r31) ; Get machine check size
	srl	r13, #4, r12		; Get SCB number
	subq	r12, #scb$v_procmchk@-4, r12 ; Is it a processor machine check?
	beq	r12, 50$		; Yep
	lda	r12, 1(r31)		; Set retry flag
	sll	r12, #63, r12		;
	or	r14, r12, r14		;
50$:   	stq/p	r14, mchk$byte_count(r15) ; Store byte count
	lda	r14, mchk$byte_count(r31) ; Set offset for R4
	lda	r15, ^x1f(r31)		; Set IPL
   	br	r31, complete_interrupt	; Go build trap

	.endc


	.if ne	cortex_system

.sbttl	Cortex Hardware Specific Reset
;----------------------------------------------------------------------
;
; Perform the cortex hardware specific reset. Copied from reset_eb6x_hardware.
;
reset_cortex_hardware:
;
; Enable configuration RAM decode in the Utility Bus Chip Select (UBCSB) Register
;

; Initialize COM1
;
	out	<com1+lcr>, <lcr$m_dlab> ; Access the clock divisor latch.
	out	<com1+dll>, <dla$k_brg>	 ; Set the baud rate.
	out	<com1+dlh>, <0>
	out	<com1+lcr>, <lcr$k_init> ; Set the line control register.
	out	<com1+mcr>, <mcr$k_init> ; Set the modem control register.
	out	<com1+ier>, <^xF>	 ; Turn on interrupts.
;
; Flush COM1's receive buffer
;
flush_com1:
	in	<com1+lsr>, r12		; Read the line status.
	blbc	r12, com1_done		; Are we done yet? (data ready = 0).
	in	<com1+rbr>, r12		; Read receive buffer register.
	br	r31, flush_com1		; Loop until done.

com1_done:
	mb

.macro	combo_setup
	lda	r15, ^x1c(r31)
	sll	r15, #28-5, r15
	lda	r15, com1(r15)
	sll	r15, #5, r15
.endm

.macro	combott_putc 	c, ?l1
l1:	ldl/p	r12, lsr@5(r15)
	srl	r12, #lsr$v_thre+8, r12
	pvc$violate	1008
	blbc	r12, l1
.if idn <%extract(0,1,c)> <r>
	and	c, #^xff, r12
.iff
	lda	r12, <c>&^xff(r31)
.endc
	stl/p	r12, thr@5(r15)
	mb
.endm

.macro	combott_puth	w=16, ?l1, ?l2
	lda	r17, w*4(r31)
l1:	subq	r17, #4, r17
	srl	r16, r17, r19
	and	r19, #15, r19
	lda	r18, ^x30(r19)
	cmpult	r19, #10, r19
	pvc$violate	1008
	bne	r19, l2
	addq	r18, #^x27, r18
l2:	combott_putc	r18
	pvc$violate	1008
	bne	r17, l1
.endm

	read_toy <cd_suppress>,r12, r13	; Fetch countdown suppression byte to r13.
	blbs	r13, 10$        ; Skip output if suppression turned on.
	read_toy <console_ev>, r12, r13 ; Fetch console ev (serial/graphics)
	blbs	r13, 10$	; Skip output of graphics console
	combo_setup
	combott_putc 	<^x30>
	combott_putc	<^xd>
	combott_putc	<^xa>

10$: 	bis	r31, 1, r1	; Flag to suppress further output.	
	write_toy r1, <cd_suppress> ; Suppress countdowns until hard reset.
	out	<^x800>, <^x30>	; Progress...
;
; Initialize COM2
;
	out	<com2+lcr>, <lcr$m_dlab> ; Access the clock divisor latch.
	out	<com2+dll>, <dla$k_brg>	 ; Set the baud rate.
	out	<com2+dlh>, <0>
	out	<com2+lcr>, <lcr$k_init> ; Set the line control register.
	out	<com2+mcr>, <mcr$k_init> ; Set the modem control register.
	out	<com2+ier>, <^xF>	 ; Turn on interrupts.
;
; Flush COM2's receive buffer
;
flush_com2:
	in	<com2+lsr>, r12		; Read the line status.
	blbc	r12, com2_done		; Are we done yet? (data ready = 0)
	in	<com2+rbr>, r12		; Read receive buffer register.
	br	r31, flush_com2		; Loop until done.

com2_done:
	mb


;	out	<^x800>, <^x32>		; Progress...

; now fix up the lpt port to show up at ^x3BC like the O/S wants it.
fix_lpt:	
	out 	<csr>, <^x55>	; Enter config mode.
	out 	<csr>, <^x55>	; Enter config mode.
	out	<csr>, <^x1>	; Select CR1.
	out	<cdr>, <^x1D> 	; no lock, com34_default, irq_polarity_default,
				; par_port_mode, par_port_power, par_port_addr.
				; sets par port to ^x3bc.
	out 	<csr>, <^xAA>	; Exit config mode.
	mb

;	out	<^x800>, <^x33>		; Progress...


;
; Initialize the 82C59A priority interrupt controller (PIC)
;
; init PIC2, the slave pic.
        out     <pic2+icw1>, <^x11>	; edge trig, cascade mode, icw4 needed.
        out     <pic2+icw2>, <^x08> 	; t7-t3 of vector = 00001b
        out     <pic2+icw3>, <^x02>	; ID of this slave = 2.
        out     <pic2+icw4>, <^x01>     ; not spfm, no buf, normal EOI, 8086.
        out     <pic2+ocw1>, <^xFF>     ; Interrupt mask (all disabled).

        out     <pic1+icw1>, <^x11>     ; edge trig, cascade mode, icw4 needed.
        out     <pic1+icw2>, <^x00>     ; t7-t3 of vector = 00000b
        out     <pic1+icw3>, <^x04>     ; slave on irq 2.
        out     <pic1+icw4>, <^x01>     ; not sfnm, no buf, normal EOI, 8086.
        out     <pic1+ocw1>, <^xFB>     ; Allow slave pic on irq2 only.

        iack                            ; Reset edge detection logic.

        out     <pic2+ocw2>, <^x20>     ; EOI to slave pic
        out     <pic1+ocw2>, <^x20>     ; EOI to master pic

	br	r12, 10$
	.long	IMASK$M_MBO		; All ints disabled, except those that
					; are defined as MBO (enabled) by the
					; xilinx hardware.  This is just the 
					; SIO int and the four vme ints. 
10$:	ldl/p	r14, (r12)		; fetch the mask
 
	sget_addr r12, pal$impure_base, r31
	stq/p	r14, cortex$q_enabled_ints_mask(r12)
	mb

;	out	<^x800>, <^x34>		; Progress...


; Note that PALcode does not push the interrupt masks out to the VIC or the
; xilinx interrupt controllers at this point.  The VIP has not yet been 
; configured on the PCI so we can't call medu$setup_ints_vic.  Therefore
; we must trust the console firmware's powerup procedure to call the 
; CSERVE to disable ints after the vip has been configured on the pci and 
; before the ipl is dropped.  This is done in 
; platform_init1().

;; Here starts the code stolen from Medulla's reset flow.  

; Perform the Medulla-style specific reset code.  This consists of 
; 
;    . Set up the Heartbeat timer. This is a 1k clock from the TOY fed 
;	through to IRQ1 of the SIO. 
;    . Disable the heartbeat timer. 
;    . Disable interrupts via the Module control register. The console will 
;	enable them later when they are ready to take interrupts. 
;    . Enable IRQ1 interrupt of the LCA
;    . Enable IRQ1/6 interrupt of the SIO
;    . set up the UAR/T. 


;	.if ne medulla_system_debug
;	medu$write_led	Character=<^a/r/>
;	.endc


	; Enable PCI SERR & HALT (switch/watchdog)
	medu$write_sio	<^x0c>, SIO$B_NMI_CSR	; clear pending SERR/IOCHK ints
	medu$write_sio	<^x00>, SIO$B_NMI_CSR	; enable SERR/IOCHK ints
	; the pci reset disabled master NMI
	medu$write_sio	<^x00>, SIO$B_NMI_ENB	; master NMI enable

; NOTE  The following code related to the heartbeat timer was lifted from 
; 	medulla, but the macro calls to read and write the toy perform a 
;	bad address calculation and instead are touching the DMA1 controller
;	in the SIO.  I have left the code in for now but it is commented out.
;	;
;	; Disable the heartbeat timer. 
;	;
;	; 	Set the transfer enable bit in register B. 
;	;
;	medu$write_toy	Data=<^x90>, ToyOffset=<^x0b>
;	;
;	; 	Disable the SQW bit in register 9.
;	;
;	;	The address will be formed in R12 and the data will be
;	;	placed in R13 by the toy_read macro. Be sure not to clobber 
;	;	the values before the write back out to TOY Register 9.
;	;
;	medu$read_toy	ToyOffset=<^x09>, AddrSetup=1
;	or	r13, #^x40, r13		; Set the TE bit
;	medu$write_toy	Data=r13, ToyOffset=<^x09>, AddrSetup=0
;	;
;	; 	Turn off transfer enable bit in register B -- the Register
;	;	B address should still be in R13.
;	;
;	medu$write_toy	Data=<^x7f>, ToyOffset=<^x0b>


;	out	<^x800>, <^x35>		; Progress...

        ;
        ;   Flush any outstanding heartbeat timer interrupts by writing the 
	; "Clear Heartbeat Register". 
        ;
	medu$write_module_reg	Data=<^x0>, ModRegOffset=MEDU$HBEAT_CLR_REG

;	out	<^x800>, <^x36>		; Progress...


        pvc$jsr         rxh, bsr=1, dest=1
        ret     r31, (r26)
.endc


        .if ne  lean_system

.sbttl	Lean Hardware Specific Reset
;----------------------------------------------------------------------
;
; Perform the Lean hardware specific reset.
;
reset_lean_hardware:
;
; PCI Configuration Space Partitioning
;
;	  Address	Device
;	-----------	--------------------
;	1 E001 00xx	NCR 53C810 SCSI Controller
;	1 E002 00xx	PCI Expansion Slot 0
;	1 E004 00xx	PCI Expansion Slot 1
;	1 E008 00xx	Intel 82378IB System I/O Controller
;	1 E010 00xx	DECchip 21040 Ethernet LAN Controller
;

.if ne 0
	get_high_addr r2, ioc$csr_base	; get io cntlr CSR base
	lda	r3, ^x40(r31)		; reset
;
; Reset the PCI bus
;
	mb
	stq/p	r3, ioc$q_pci_rst(r2)	; start reset of the pci bus
	mb
	
;	ldah	r13, ^x164(r31)		; 100ms at 233mhz
	get_addr r13, <100*1000*100>, r31
100$:	subq	r13, #1, r13
	bne	r13, 100$

	mb
	stq/p	r31, ioc$q_pci_rst(r2)	; reset the pci bus
	mb

;	ldah	r13, ^x164(r31)		; 100ms at 233mhz
	get_addr r13, <100*1000*100>, r31
110$:	subq	r13, #1, r13
	bne	r13, 110$
.endc
;
; Initialize the LCA memory controller's Error Status Register.
; The system may have been powered up with some of the error
; status flag bits set.
;
; The following error status flag bits are written with a '1' 
; to clear:
;
;	ESR<CEE>	Correctable Error
;	ESR<UEE>	Uncorrectable Error
;	ESR<CTE>	B-Cache Tag Parity Error
;	ESR<NXM>	Non-Existant Memory Error
;
; In addition, the following bit is set to '1' to disable logging
; of correctable errors to comply with ECO 55:
;
;	ESR<ICE>	Ignore Correctable Errors
;
	get_high_addr	r2, mem$csr_base; r2 <- 1.2000.000
	lda	r3, esr$m_init(r31)	; Load the error status mask.
	stq/p	r3, mem$q_esr(r2)	; Clear the error status bits and
	mb				; ignore correctable errors for now.

	get_high_addr r2, ioc$csr_base	; get io cntlr CSR base
	lda	r3, stat0$m_init(r31)	; load IOCSTAT0 init mask
	stq/p	r3, ioc$q_stat0(r2)	; initialize IOCSTAT0
	mb

	get_high_addr	r12, cfig_base	; r12 <- 1.E000.0000
	ldah	r12, ^x80(r12)		; r12 <- 1.E080.0000 

.if ne 0
;
; Reset the isa bus and set clock to 25mhz
;
	lda	r13, ^x49(r31)		; isa bus reset
	sll	r13, 8, r13		; Shift data into proper byte lane.
	lda	r12, sio$b_icd(r12)	; Form the port address
	stl/p	r13, 0(r12)		; Write it out.
	zap	r12, ^x3, r12		; get rid of address offset
	mb				; Make sure it gets there.

;	lda	r13, ^x400(r31)		; wait some period of time ~ 2microseconds at 233 mhz
	get_addr r13, <2*1000*100>, r31
200$:	subq	r13, #1, r13
	bne	r13, 200$

	lda	r13, ^x41(r31)		; release isa bus reset
	sll	r13, 8, r13		; Shift data into proper byte lane.
	lda	r12, sio$b_icd(r12)	; Form the port address
	stl/p	r13, 0(r12)		; Write it out.
	zap	r12, ^x3, r12		; get rid of address offset
	mb				; Make sure it gets there.

;	lda	r13, ^x400(r31)		; wait some period of time ~ 2microseconds at 233 mhz
	get_addr r13, <2*1000*100>, r31
210$:	subq	r13, #1, r13
	bne	r13, 210$
.endc
;
; Setup SIO configuration space base address
;
	lda	r13, pac$k_init(r31)	; Load data to write.
	sll	r13, 8, r13		; Shift it into the proper byte lane.
	lda	r12, sio$b_pac(r12)
	stl/p	r13, 0(r12)		; Write it out.
	zap	r12, ^x3, r12		; get rid of address offset
	mb				; Make sure it gets there.
;
; Initialize the ISA Address Decoder Control (IADCON) register
;
	lda	r13, iad$k_init(r31)	; Load data to write.
	lda	r12, sio$b_iadcon(r12)
	stl/p	r13, 0(r12)		; Write it out.
	zap	r12, ^x3, r12		; get rid of address offset
	mb				; Make sure it gets there.
;
; Initialize the ISA Address Decoder ROM Block Enable (IADRBE) register
;
	lda	r13, rbe$k_init(r31)	; Load data to write.
	sll	r13, 8, r13		; Shift it into the proper byte lane.
	lda	r12, sio$b_iadrbe(r12)
	stl/p	r13, 0(r12)		; Write it out.
	zap	r12, ^x3, r12		; get rid of address offset
	mb				; Make sure it gets there.
;
; Initialize the Utility Bus Chip Select A (UBCSA) register
;
	lda	r13, uba$k_init(r31)	; Load data to write.
	sll	r13, 16, r13		; shift to proper byte lane
	lda	r12, sio$b_ubcsa(r12)
	stl/p	r13, 0(r12)		; Write it out.
	zap	r12, ^x3, r12		; get rid of address offset
	mb				; Make sure it gets there.
;
; Initialize the Utility Bus Chip Select B (UBCSB) register
;
	lda	r13, ubb$k_init(r31)	; Load data to write.
	sll	r13, 24, r13		; Shift it into the proper byte lane.
	lda	r12, sio$b_ubcsb(r12)
	stl/p	r13, 0(r12)		; Write it out.
	zap	r12, ^x3, r12		; get rid of address offset
	mb				; Make sure it gets there.

;
; Put the DMA controllers into cascade mode
;
        out     <sio$b_dcm>, <dcm$k_init>        
; Initialize the 87312 UART serial ports
;
;	Baud rate:	9600 baud 
;	Word length:	8 bit characters
;	Stop bits:	1 stop bit
;	Parity:		No parity
;	Modem control:	DTR, RTS active, OUT1 low, UART interrupts enabled
;
;
; Initialize COM1
;
	out	<com1+fdc$b_lcr>, <lcr$m_dlab>  ; Access clock divisor latch.
	out	<com1+fdc$b_dll>, <dla$k_brg>	; Set the baud rate.
	out	<com1+fdc$b_dlh>, <0>
	out	<com1+fdc$b_lcr>, <lcr$k_init>	; Set line control register.
	out	<com1+fdc$b_mcr>, <mcr$k_init>  ; Set modem control register.
	out	<com1+fdc$b_ier>, <^xF>		; Turn on interrupts.
;
; Flush COM1's receive buffer
;
flush_com1:
	in	<com1+fdc$b_lsr>, r12	; Read the line status.
	blbc	r12, com1_done		; Are we done yet? (data ready = 0).
	in	<com1+fdc$b_rbr>, r12	; Read receive buffer register.
	br	r31, flush_com1		; Loop until done.

com1_done:
	mb
;
; Initialize the 82C59 interrupt controller (INT)
;
        out     <int2+int$b_icw1>, <^x11>
        out     <int2+int$b_icw2>, <^x08>
        out     <int2+int$b_icw3>, <^x02>
        out     <int2+int$b_icw4>, <^x01>
        out     <int2+int$b_ocw1>, <^xFF>	;disable IRQ 8-15        

        out     <int1+int$b_icw1>, <^x11>
        out     <int1+int$b_icw2>, <^x00>
        out     <int1+int$b_icw3>, <^x04>
        out     <int1+int$b_icw4>, <^x01>
        out     <int1+int$b_ocw1>, <^xFB>	; disable IRQ 0,1,3,4,5,6,7

        iack

        out     <int2+int$b_ocw2>, <^x20>
        out     <int1+int$b_ocw2>, <^x20>
;
; Initialize the DS1287A Real Time Clock (RTC)
;
        out     rtcadd, <^x0A>
        out     rtcdat, <^x26>
        out     rtcadd, <^x0B>
        in      rtcdat, r14
	lda	r13, ^x40(r31)		; Enable periodic interrupts.
        bis	r14, r13, r14
        out     rtcadd, <^x0B>
        out     rtcdat, r14
;
; Enable the NMI interrupt
;
	out	<sio$b_nmi>, <^x00>

        pvc$jsr         rph, bsr=1, dest=1
        ret     r31, (r26)
        .endc


        .if ne  mtu_system
	
.sbttl	Mustang Hardware Specific Reset
;----------------------------------------------------------------------
;
; Perform the Mustang hardware specific reset.
;
reset_mustang_hardware:
;
; This code is almost a cut and past of the eb64p code with the exception that
; the sio is sized rather than hard coded.
;

;
; Initialize the LCA memory controller's Error Status Register.
; The system may have been powered up with some of the error
; status flag bits set.
;
; The following error status flag bits are written with a '1' 
; to clear:
;
;	ESR<CEE>	Correctable Error
;	ESR<UEE>	Uncorrectable Error
;	ESR<CTE>	B-Cache Tag Parity Error
;	ESR<NXM>	Non-Existant Memory Error
;
; In addition, the following bit is set to '1' to disable logging
; of correctable errors to comply with ECO 55:
;
;	ESR<ICE>	Ignore Correctable Errors
;
	get_high_addr	r2, mem$csr_base; r2 <- 1.2000.000
	lda	r3, esr$m_init(r31)	; Load the error status mask.
	stq/p	r3, mem$q_esr(r2)	; Clear the error status bits and
	mb				; ignore correctable errors for now.

;
; Locate the sio by reading the first address in config sapce for all of the
; possible slots comparing it for the id.  Once found the code is the same.
; If the sio is not found then the code stays in the sizing loop forever.
;

;
; Setup SIO configuration space base address
;

;	lda	r12, ^x1e(r31)		
;	sll	r12, 28, r12		; make it 1.e000.0000
;	ldah	r12, 4(r12)
;	br	r31, 30$

10$:	lda	r13, <^x100@5>(r31)	; start with bit 8.
	lda	r14, ^x8086(r31)	; low word.
	zapnot	r14, #3, r14		; get rid of low stuff.
	ldah	r14, ^x0484(r14)	; make it 04848086

; use r3 for the comparison always.
20$:
	lda	r12, ^x1e(r31)		
	sll	r12, 28, r12		; make it 1.e000.0000

	bis	r12, r13, r12		; base address
	ldl/p	r3, ^x18(r12)		; get the id
	cmpeq	r3, r14, r3		; check for sio
	bne	r3, 30$			; branch if we found the sio
	addl	r13, r31, r13		; sign extend for comparson
	bgt	r13, 25$		; do the shift
	br	r31, 10$		; start over

25$:	sll	r13, 1, r13
	zapnot	r13, ^x0f, r13
	br	r31, 20$		; try again
	
;
; Initialize the PCI Arbiter Control (PAC) register
;
30$:
	lda	r13, pac$k_init(r31)	; Load data to write.
	sll	r13, 8, r13		; Shift it into the proper byte lane.
	lda	r12, sio$b_pac(r12)
	stl/p	r13, 0(r12)		; Write it out.
	zap	r12, ^x3, r12		; get rid of address offset
	mb				; Make sure it gets there.
;
; Initialize the ISA Address Decoder Control (IADCON) register
;
	lda	r13, iad$k_init(r31)	; Load data to write.
	lda	r12, sio$b_iadcon(r12)
	stl/p	r13, 0(r12)		; Write it out.
	zap	r12, ^x3, r12		; get rid of address offset
	mb				; Make sure it gets there.
;
; Initialize the ISA Address Decoder ROM Block Enable (IADRBE) register
;
	lda	r13, rbe$k_init(r31)	; Load data to write.
	sll	r13, 8, r13		; Shift it into the proper byte lane.
	lda	r12, sio$b_iadrbe(r12)
	stl/p	r13, 0(r12)		; Write it out.
	zap	r12, ^x3, r12		; get rid of address offset
	mb				; Make sure it gets there.
;
; Initialize the Utility Bus Chip Select A (UBCSA) register
;
	lda	r13, uba$k_init(r31)	; Load data to write.
	sll	r13, 16, r13		; shift to proper byte lane
	lda	r12, sio$b_ubcsa(r12)
	stl/p	r13, 0(r12)		; Write it out.
	zap	r12, ^x3, r12		; get rid of address offset
	mb				; Make sure it gets there.
;
; Initialize the Utility Bus Chip Select B (UBCSB) register
;
	lda	r13, ubb$k_init(r31)	; Load data to write.
	sll	r13, 24, r13		; Shift it into the proper byte lane.
	lda	r12, sio$b_ubcsb(r12)
	stl/p	r13, 0(r12)		; Write it out.
	zap	r12, ^x3, r12		; get rid of address offset
	mb				; Make sure it gets there.
;
; Put the DMA controllers into cascade mode
;
        out     <sio$b_dcm>, <dcm$k_init>        
;
; Initialize the 87312 UART serial ports
;
;	Baud rate:	9600 baud 
;	Word length:	8 bit characters
;	Stop bits:	1 stop bit
;	Parity:		No parity
;	Modem control:	DTR, RTS active, OUT1 low, UART interrupts enabled
;
;
; Initialize COM1
;
	out	<com1+fdc$b_lcr>, <lcr$m_dlab>  ; Access clock divisor latch.
	out	<com1+fdc$b_dll>, <dla$k_brg>	; Set the baud rate.
	out	<com1+fdc$b_dlh>, <0>
	out	<com1+fdc$b_lcr>, <lcr$k_init>	; Set line control register.
	out	<com1+fdc$b_mcr>, <mcr$k_init>  ; Set modem control register.
	out	<com1+fdc$b_ier>, <^xF>		; Turn on interrupts.
;
; Flush COM1's receive buffer
;
flush_com1:
	in	<com1+fdc$b_lsr>, r12	; Read the line status.
	blbc	r12, com1_done		; Are we done yet? (data ready = 0).
	in	<com1+fdc$b_rbr>, r12	; Read receive buffer register.
	br	r31, flush_com1		; Loop until done.

com1_done:
	mb
;
; Initialize COM2
;
	out	<com2+fdc$b_lcr>, <lcr$m_dlab>  ; Access clock divisor latch.
	out	<com2+fdc$b_dll>, <dla$k_brg>	; Set the baud rate.
	out	<com2+fdc$b_dlh>, <0>
	out	<com2+fdc$b_lcr>, <lcr$k_init>	; Set line control register.
	out	<com2+fdc$b_mcr>, <mcr$k_init>	; Set modem control register.
	out	<com2+fdc$b_ier>, <^xF>		; Turn on interrupts.
;
; Flush COM2's receive buffer
;
flush_com2:
	in	<com2+fdc$b_lsr>, r12	; Read the line status.
	blbc	r12, com2_done		; Are we done yet? (data ready = 0)
	in	<com2+fdc$b_rbr>, r12	; Read receive buffer register.
	br	r31, flush_com2		; Loop until done.

com2_done:
	mb
;
; Initialize the 82C59 interrupt controller (INT)
;
        out     <int2+int$b_icw1>, <^x11>
        out     <int2+int$b_icw2>, <^x08>
        out     <int2+int$b_icw3>, <^x02>
        out     <int2+int$b_icw4>, <^x01>
        out     <int2+int$b_ocw1>, <^xFF>	;disable IRQ 8-15        

        out     <int1+int$b_icw1>, <^x11>
        out     <int1+int$b_icw2>, <^x00>
        out     <int1+int$b_icw3>, <^x04>
        out     <int1+int$b_icw4>, <^x01>
        out     <int1+int$b_ocw1>, <^xFB>	; disable IRQ 0,1,3,4,5,6,7

        iack

        out     <int2+int$b_ocw2>, <^x20>
        out     <int1+int$b_ocw2>, <^x20>
;
; Initialize the DS1287A Real Time Clock (RTC)
;
        out     rtcadd, <^x0A>
        out     rtcdat, <^x26>
        out     rtcadd, <^x0B>
        in      rtcdat, r14
	lda	r13, ^x40(r31)		; Enable periodic interrupts.
        bis	r14, r13, r14
        out     rtcadd, <^x0B>
        out     rtcdat, r14
;
; Enable the NMI interrupt
;
;	out	<sio$b_nmi>, <^x00>

        pvc$jsr         rph, bsr=1, dest=1
        ret     r31, (r26)
        .endc


        .if ne  avanti_system ! k2_system

.sbttl	Avanti Hardware Specific Reset
;----------------------------------------------------------------------
;
; Perform the Avanti hardware specific reset.
;
reset_avanti_hardware:
;
; Apecs pass 2 config cycles different
; SIO at 1.E007.0000  instead of 1.E080.0000
; 
        in_epic <epic_dcsr> , r13,r12	; Read the epic status in r13
	srl	r13,31,r13		; Pass 2 if bit 31 is set
	bis	r31,r31,r12
	lda     r12, cfig_base(r31)     ; Load Config Space address.
        sll     r12, 28, r12    	; Shift Left 28 1.E000.0000
	blbs	r13,10$			
	ldah	r12, ^x80(r12)		; r12 <- 1.E080.0000  (SIO config cycle Pass 1)
	br	r31,20$
10$:	ldah	r12, ^x7(r12)		; r12 <- 1.E007.0000  (SIO config cycle Pass 2)
20$:
;
; Initialize the PCI Arbiter Control (PAC) register address 41 (byte 1)
;
	lda	r13, pac$k_init(r31)	; Load data to write.
	sll	r13, 8, r13		; Shift it into the proper byte lane. 
	lda	r12, sio$b_pac(r12)
	stl/p	r13, 0(r12)		; Write it out.
	zap	r12, ^x3, r12		; get rid of address offset
	mb				; Make sure it gets there.
;
; Initialize the ISA Address Decoder Control (IADCON) register (48 byte 0)
;
	lda	r13, iad$k_init(r31)	; Load data to write.
	sll	r13, 0, r13		; Shift it into the proper byte lane.
	lda	r12, sio$b_iadcon(r12)
	stl/p	r13, 0(r12)		; Write it out.
	zap	r12, ^x3, r12		; get rid of address offset
	mb				; Make sure it gets there.
;
; Initialize the ISA Address Decoder ROM Block Enable (IADRBE) register (49 byte 1)
;
	lda	r13, rbe$k_init(r31)	; Load data to write.
	sll	r13, 8, r13		; Shift it into the proper byte lane. 
	lda	r12, sio$b_iadrbe(r12)
	stl/p	r13, 0(r12)		; Write it out.
	zap	r12, ^x3, r12		; get rid of address offset
	mb				; Make sure it gets there.
;
; Initialize the Utility Bus Chip Select A (UBCSA) register (4E byte 2)
;
	lda	r13, uba$k_init(r31)	; Load data to write.
	sll	r13, 16, r13		; shift to proper byte lane
	lda	r12, sio$b_ubcsa(r12)
	stl/p	r13, 0(r12)		; Write it out.
	zap	r12, ^x3, r12		; get rid of address offset
	mb				; Make sure it gets there.
;
; Initialize the Utility Bus Chip Select B (UBCSB) register (4F byte 3)
;
	lda	r13, ubb$k_init(r31)	; Load data to write.
	sll	r13, 24, r13		; Shift it into the proper byte lane.
	lda	r12, sio$b_ubcsb(r12)
	stl/p	r13, 0(r12)		; Write it out.
	zap	r12, ^x3, r12		; get rid of address offset
	mb				; Make sure it gets there.

;
; Initialize the 87312 Configuration Registers
;
.if eq k2_system
	out	<bindex>, <ind_fer>  	 	; Function Enable Register 
	out	<bdata> , <^x5F>		;
	out	<bdata> , <^x5F>		; 

	out	<bindex>, <ind_far>   		; Function Enable Register 
	out	<bdata> , <^x11>		; LPT1=3BC,COM1=3F8,COM2=2F8,COM3=3E8,COM4=2E8 
	out	<bdata> , <^x11>		; LPT1=3BC,COM1=3F8,COM2=2F8,COM3=3E8,COM4=2E8 

	out	<bindex>, <ind_ptr>   		; Power Down Register 
	out	<bdata> , <^x80>		; no test mode
	out	<bdata> , <^x80>		; no test mode
.iff
;
; K2 uses 87303 which has 14 config regs.
;
	out	<bindex>, <ind_fer>  	 	; Function Enable Register 
	out	<bdata> , <^x4F>		; two floppy support
	out	<bdata> , <^x4F>		; 

	out	<bindex>, <ind_far>   		; Function Enable Register 
	out	<bdata> , <^x11>		; LPT1=3BC,COM1=3F8,COM2=2F8,COM3=3E8,COM4=2E8 
	out	<bdata> , <^x11>		; LPT1=3BC,COM1=3F8,COM2=2F8,COM3=3E8,COM4=2E8 

	out	<bindex>, <ind_ptr>   		; Power Down Register 
	out	<bdata> , <^x04>		; no test mode
	out	<bdata> , <^x04>		; no test mode

	out	<bindex>, <ind_fcr>  	 	; Read Function Control Reg
	in	<bdata> , r14			;
	and	r14, ^xc0, r14			; Preserve FCR<7:6>
	or	r14, ^x21, r14			;
	out	<bindex>, <ind_fcr>  	 	; Function Control Register 
	out	<bdata> , r14			;
	out	<bdata> , r14			; 

	out	<bindex>, <ind_pcr>   		; Printer config Register 
	out	<bdata> , <^x00>		;
	out	<bdata> , <^x00>		;

	out	<bindex>, <ind_krr>   		; KBD and RTC control Reg
	out	<bdata> , <^x4D>		; Keyboard enabled
	out	<bdata> , <^x4D>		; Real Time Clock enabled

	out	<bindex>, <ind_pmc>  	 	; Power Management Control
	out	<bdata> , <^x00>		; Register 
	out	<bdata> , <^x00>		; 

	out	<bindex>, <ind_tup>   		; EPP Timeout REgister
	out	<bdata> , <^x00>		;
	out	<bdata> , <^x00>		;

	out	<bindex>, <ind_asc>   		; Advanced SIO Config Register
	out	<bdata> , <^xc0>		;
	out	<bdata> , <^xc0>		;

	out	<bindex>, <ind_cs0cf0>  	; CS0 config 0 Register
	out	<bdata> , <^x00>		;
	out	<bdata> , <^x00>		; 

	out	<bindex>, <ind_cs0cf1>  	; CS0 config 1 Register
	out	<bdata> , <^x80>		;
	out	<bdata> , <^x80>		; 

	out	<bindex>, <ind_cs1cf0>  	; CS1 config 0 Register
	out	<bdata> , <^x00>		;
	out	<bdata> , <^x00>		; 

	out	<bindex>, <ind_cs1cf1>  	; CS0 config 1 Register
	out	<bdata> , <^x80>		;
	out	<bdata> , <^x80>		; 
.endc

;
; Initialize the 87312 UART serial ports
;
;	Baud rate:	9600 baud 
;	Word length:	8 bit characters
;	Stop bits:	1 stop bit
;	Parity:		No parity
;	Modem control:	DTR, RTS active, OUT1 low, UART interrupts enabled
;
;
; Initialize COM1
;
	out	<com1+fdc$b_lcr>, <lcr$m_dlab>  ; Access clock divisor latch.
	out	<com1+fdc$b_dll>, <dla$k_brg>	; Set the baud rate.
	out	<com1+fdc$b_dlh>, <0>
	out	<com1+fdc$b_lcr>, <lcr$k_init>	; Set line control register.
	out	<com1+fdc$b_mcr>, <mcr$k_init>  ; Set modem control register.
	out	<com1+fdc$b_ier>, <^xF>		; Turn on interrupts.
.if ne k2_system
;
; Enable the COM1 FIFO for K2. The FIFO control reg is at the same
; address as the Interupt ID reg.
;
	out	<com1+fdc$b_iir>, <^x1>
.endc
;
; Flush COM1's receive buffer
;
flush_com1:
	in	<com1+fdc$b_lsr>, r12	; Read the line status.
	blbc	r12, com1_done		; Are we done yet? (data ready = 0).
	in	<com1+fdc$b_rbr>, r12	; Read receive buffer register.
	br	r31, flush_com1		; Loop until done.

com1_done:
	mb
;
; Initialize COM2
;
	out	<com2+fdc$b_lcr>, <lcr$m_dlab>  ; Access clock divisor latch.
	out	<com2+fdc$b_dll>, <dla$k_brg>	; Set the baud rate.
	out	<com2+fdc$b_dlh>, <0>
	out	<com2+fdc$b_lcr>, <lcr$k_init>	; Set line control register.
	out	<com2+fdc$b_mcr>, <mcr$k_init>	; Set modem control register.
	out	<com2+fdc$b_ier>, <^xF>		; Turn on interrupts.
.if ne k2_system
;
; Enable the COM2 FIFO for K2. The FIFO control reg is at the same
; address as the Interupt ID reg.
;
	out	<com2+fdc$b_iir>, <^x1>
.endc
;
; Flush COM2's receive buffer
;
flush_com2:
	in	<com2+fdc$b_lsr>, r12	; Read the line status.
	blbc	r12, com2_done		; Are we done yet? (data ready = 0)
	in	<com2+fdc$b_rbr>, r12	; Read receive buffer register.
	br	r31, flush_com2		; Loop until done.

com2_done:
	mb
;
; Initialize the 82C59 interrupt controller (INT)
;
        out     <int2+int$b_icw1>, <^x11>
        out     <int2+int$b_icw2>, <^x08>
        out     <int2+int$b_icw3>, <^x02>
        out     <int2+int$b_icw4>, <^x01>
        out     <int2+int$b_ocw1>, <^xFF>

        out     <int1+int$b_icw1>, <^x11>
        out     <int1+int$b_icw2>, <^x00>
        out     <int1+int$b_icw3>, <^x04>
        out     <int1+int$b_icw4>, <^x01>
        out     <int1+int$b_ocw1>, <^xFB>

        iack

        out     <int2+int$b_ocw2>, <^x20>
        out     <int1+int$b_ocw2>, <^x20>
;
; Initialize the DS1287A Real Time Clock (RTC)
;
        out     rtcadd, <^x0A>
        out     rtcdat, <^x26>
        out     rtcadd, <^x0B>
        in      rtcdat, r14
	lda	r13, ^x40(r31)		; Enable periodic interrupts.
        bis	r14, r13, r14
        out     rtcadd, <^x0B>
        out     rtcdat, r14
.if ne k2_system
;
; The 87303 RTC 32kHz clock won't come to life until REG D is read.
;
        out     rtcadd, <^x0D>
        in      rtcdat, r14
.endc
;
; Enable the NMI interrupt
;
	out	<sio$b_nmi>, <^x00>

.if ne k2_system
;
; Initialise the K2 PCI interrupt accelerator hardware.
; First write the interrupt reg start address. Then mask
; all interrupts and put the controller into accelerator
; mode, msken ON.
;
	lda	r14, int_reg_base(r31);
	out_word <k2$l_int_conf + 2>, r14;
	lda	r14, mask_conf_reg(r31);
	out_word <k2$l_int_conf>, r14;
	lda	r14, accel_enable(r31);
	zap	r14, ^xfc, r14
	out_word <k2$l_int_conf>, r14;
	lda	r14, mask_int_reg(r31);
	zap	r14, ^xfc, r14
	out_word <k2$l_int_reg1+2>, r14;
	out_word <k2$l_int_reg2+2>, r14;
	out_word <k2$l_int_reg3+2>, r14;
	out_word <k2$l_int_reg4+2>, r14;
;
; Init the server management and watchdog timer hardware.
;
; Watchdog disabled, 2 timer mode, 1 second timeouts
;
	lda	r14, watchdog_init(r31);
	out_word <k2$w_watchdog>, r14;
;
; All ints and NMIs masked, POFF disabled.
; Require to do this manually, as the out_word macro can't take
; data bigger than eight bits.
;
	ldah	r12, ^x1c00(r31);
	lda	r12, ^x0a0c(r12);
	sll	r12, 4, r12		; R12 contains port 506 address
	bis	r12, ^x8, r12		; Set for qord access
	lda	r14, management_init(r31)
	sll	r14, #16, r14		; Shift data to high word
	stl/p	r14, (r12)
.endc;

        pvc$jsr         rph, bsr=1, dest=1
        ret     r31, (r26)

.endc


        .if ne  mikasa_system ! noritake_system
.sbttl	mikasa Hardware Specific Reset
;----------------------------------------------------------------------
;
; Perform the mikasa hardware specific reset.
;
reset_mikasa_hardware:
;

	;
	; Reset the EISA bus.
	;
	out	<nmiecsr>, <bus_reset>
	;
	; Pause for 50 milliseconds.
	;
	get_addr r12, <50*1000*100>, r31
10$:	subq	r12, #1, r12
	bne	r12, 10$
	out	<nmiecsr>, <0>

	bis	r31,r31,r12		; Formulate the harx2 Address 
	bis	r31,r31,r13		; Null Value
	lda     r12, ^x1a(r31)   	; Load Epic Space address.
        sll     r12, 28, r12    	; Shift Left 28 1.A000.0000
	lda	r12,^x1c0(r12)		; 1.A000.01C0
	stl/p	r13, 0(r12)		; Harx2 value 
	
	bis	r31,r31,r12		; Formulate the PCEB Address 
	lda     r12, cfig_base(r31)     ; Load Config Space address.
        sll     r12, 28, r12    	; Shift Left 28 1.E000.0000
	ldah	r12, ^x7(r12)		; r12 <- 1.E007.0000  (PCEB config cycle Pass 2)
;
; Set up the PCEB bridge chip first 
;
; Initialize the PCI control register address 40 (byte 0)
; This should only be done once and not at run time 
;
	lda	r13, pcr$k_init(r31)	; Load data to write.
	lda	r12, sio$b_pcr(r12)
	stl/p	r13, 0(r12)		; Write it out.
	zap	r12, ^x3, r12		; get rid of address offset
	mb				; Make sure it gets there.

;
; Initialize the PCI Arbiter Control (PAC) register address 41 (byte 1)
;
	lda	r13, pac$k_init(r31)	; Load data to write.
	sll	r13, 8, r13		; Shift it into the proper byte lane. 
	lda	r12, sio$b_pac(r12)
	stl/p	r13, 0(r12)		; Write it out.
	zap	r12, ^x3, r12		; get rid of address offset
	mb				; Make sure it gets there.

;
; Initialize the EISA Address Decoder Control (EADCON) register (48 byte 0 )
;
	lda	r13, iad$k_init(r31)	; Load data to write.
	sll	r13, 0, r13		; Shift it into the proper byte lane.
	lda	r12, sio$b_iadcon(r12)
	stl/p	r13, 0(r12)		; Write it out.
	zap	r12, ^x3, r12		; get rid of address offset
	mb				; Make sure it gets there.

;
; Initialize the ISA Address Decoder ROM Block Enable (IADRBE) register (49 byte 1)
;
	lda	r13, rbe$k_init(r31)	; Load data to write.
	sll	r13, 8, r13		; Shift it into the proper byte lane. 
	lda	r12, sio$b_iadrbe(r12)
	stl/p	r13, 0(r12)		; Write it out.
	zap	r12, ^x3, r12		; get rid of address offset
	mb				; Make sure it gets there.
;
; Set up the ESC chip 
; ESC configuration registers are accessed in I/O space
; Using and index/data combination
;
 	out	<esc_addr>, <^x02>  	; ESC ID register 
 	out	<esc_data>, <^x0f>  	; Must Set to ^xf

 	out	<esc_addr>, <^x40>  	; ESC Mode Register
.if ne mikasa_system
 	out	<esc_data>, <^x6b>  	; enable gpcs bits , 8 bus masters Encoded Address
.endc
.if ne noritake_system
 	out	<esc_data>, <^x2c>  	; enable gpcs bits , 2 bus masters Encoded Address
					; enable serr 
.endc 

 	out	<esc_addr>, <^x42>  	; ESC Bios Select Register
 	out	<esc_data>, <^x00>  	; we do not need access to bios code

 	out	<esc_addr>, <^x43>  	; ESC Bios Select Register
 	out	<esc_data>, <^x00>  	; we do not need access to bios code

 	out	<esc_addr>, <^x4e>  	; ESC Utility Bus Select A
 	out	<esc_data>, <^x07>	; rtc and keyboard and fdc enable

 	out	<esc_addr>, <^x4f>  	; ESC Utility Bus Select A
 	out	<esc_data>, <^x8f>  	; Enable Everything 

	out	<esc_addr>, <^x60>	; Shut off PCI routing (IRR vector 900)
 	out	<esc_data>, <^x00>  	; Off
 	out	<esc_addr>, <^x61>	; Shut off PCI routing (IRR vector 900)
	out	<esc_data>, <^x00>  	; Off
	out	<esc_addr>, <^x62>	; Shut off PCI routing (IRR vector 900)
	out	<esc_data>, <^x00>  	; Off
	out	<esc_addr>, <^x63>	; Shut off PCI routing (IRR vector 900)
	out	<esc_data>, <^x00>  	; Off

					; 10 A3 50 XX. XX is our rev. no (ED WU)
 	out	<esc_addr>, <^x50>  	; ESC ID Register [0]
 	out	<esc_data>, <^x10>  	
 	out	<esc_addr>, <^x51>  	; ESC ID Register [1]
 	out	<esc_data>, <^xA3>  	
 	out	<esc_addr>, <^x52>  	; ESC ID Register [2]
 	out	<esc_data>, <^x50>  	
 	out	<esc_addr>, <^x53>  	; ESC ID Register [3]
 	out	<esc_data>, <^x00>  	
					; GPCS0 is ocp interface [530]
					; GPCS1 is the utility register [532]
					; No Masking is required(default)
 	out	<esc_addr>, <^x64>  	; ESC GPCS0 LOW 
 	out	<esc_data>, <^x30>  	; GPCS0 at  530
 	out	<esc_addr>, <^x65>  	; ESC GPCS0 HIGH
 	out	<esc_data>, <^x05>  	
 	out	<esc_addr>, <^x66>  	; ESC GPCS0 MASK
 	out	<esc_data>, <^x01> 	; 530:531 is ocp 	

 	out	<esc_addr>, <^x68>  	; ESC GPCS1 LOW 
 	out	<esc_data>, <^x32>  	
 	out	<esc_addr>, <^x69>  	; ESC GPCS1 HIGH
 	out	<esc_data>, <^x05> 	; 532 is utility register 	
 	out	<esc_addr>, <^x6A>  	; ESC GPCS1 MASK
.if ne mikasa_system
 	out	<esc_data>, <^x01>  	; 1 byte 

 	out	<esc_addr>, <^x6C>  	; ESC GPCS2 not used
 	out	<esc_data>, <^x00>  	
 	out	<esc_addr>, <^x6D>  	; ESC GPCS2 not used 
 	out	<esc_data>, <^x00> 	; 	
 	out	<esc_addr>, <^x6E>  	; ESC GPCS2 not used 
.endc 
.if ne noritake_system
 	out	<esc_data>, <^x00>  	; 1 byte 

 	out	<esc_addr>, <^x6C>  	; ESC GPCS2 not used
 	out	<esc_data>, <^x40>  	
 	out	<esc_addr>, <^x6D>  	; ESC GPCS2 not used 
 	out	<esc_data>, <^x05> 	; 	
 	out	<esc_addr>, <^x6E>  	; ESC GPCS2 not used 
.endc
 	out	<esc_data>, <^x00>  	; 

 	out	<esc_addr>, <^x6f>  	; Enable Xbus access to ocp
 	out	<esc_data>, <^x01>	; Enable GPCS0 only

	;
	; Select bus mode (80x86) for the I²C chip.
	; Address ^x531 = ^x80
	; Note-since this is off the xbus, we do this last
	; After setting up the xbus
	;

	out 	<iic+s1>, <s1$m_pin>


; Now that Xbus is Enabled...you can do any Xbus initialization
; At this point I only wanted to initialize enough hardware
; So that the serial port driver can come up and that the
; Rest of the console initialization would perform the 
; Rest of the esc configuration space initialization.
; Remaining esc initialization done in PcebEscInitialize Routines
;
; Initialize the 87312 Configuration Registers
;	
						; Mikasa at 398
; Mikasa: rev b set fer bit to zero.
; rev b indicated by bit 0 of utility reg

	in_word	<utility>, r12			; Read Utility Bits
	blbc	r12,revb 			; If clear...then revb

reva:	out	<bindex1>, <ind_fer>  	 	; Function Enable Register 
	out	<bdata1> , <^x1F>		; rev a mikasa
	out	<bdata1> , <^x1F>		; 
	br	r31, indfar

revb:	out	<bindex1>, <ind_fer>  	 	; Function Enable Register 
	out	<bdata1> , <^x0F>		;
	out	<bdata1> , <^x0F>		; 

indfar:	out	<bindex1>, <ind_far>   		; Function Enable Register 
	out	<bdata1> , <^x11>		; LPT1=3BC,COM1=3F8,COM2=2F8,COM3=3E8,COM4=2E8 
	out	<bdata1> , <^x11>		; LPT1=3BC,COM1=3F8,COM2=2F8,COM3=3E8,COM4=2E8 

	out	<bindex1>, <ind_ptr>   		; Power Down Register 
	out	<bdata1> , <^x0>		; no test mode
	out	<bdata1> , <^x0>		; no test mode
;
; Initialize the 87312 UART serial ports
;
;	Baud rate:	from ev com1_baud default 9600
;	Word length:	8 bit characters
;	Stop bits:	1 stop bit
;	Parity:		No parity
;	Modem control:	DTR, RTS active, OUT1 low, UART interrupts enabled
;
;
baud_9600 = 12
;
; Get the baud rate of COM1.
;
	lda	r20, baud_9600(r31)
	out	<rtcadd>, <^x11>
	in	<rtcdat>, r12
	cmpeq	r12, #69, r13
	beq	r13, 20$
	out	<rtcadd>, <^x12>
        in	<rtcdat>, r12
	cmplt	r12, #18, r13
	beq	r13, 20$
	br	r13, 10$
	.long	2			; 57600
	.long	3			; 38400
	.long	6			; 19200
	.long	12			; 9600
	.long	16			; 7200
	.long	24			; 4800
	.long	32			; 3600
	.long	48			; 2400
	.long	58			; 2000
	.long	64			; 1800
	.long	96			; 1200
	.long	192			; 600
	.long	384			; 300
	.long	768			; 150
	.long	857			; 134.5
	.long	1047			; 110
	.long	1536			; 75
	.long	2304			; 50
10$:	s4addq	r12, r13, r12
	ldl/p	r20, 0(r12)
20$:	;

; Initialize COM1
;
	out	<com1+fdc$b_lcr>, <lcr$m_dlab>  ; Access clock divisor latch.
	extbl	r20, #0, r16
	out	<com1+fdc$b_dll>, r16		; Set the baud rate.
	extbl	r20, #1, r16
        out	<com1+fdc$b_dlh>, r16
	out	<com1+fdc$b_lcr>, <lcr$k_init>	; Set line control register.
	out	<com1+fdc$b_mcr>, <mcr$k_init>  ; Set modem control register.
	out	<com1+fdc$b_ier>, <^xF>		; Turn on interrupts.
;
; Flush COM1's receive buffer
;
flush_com1:
	in	<com1+fdc$b_lsr>, r12	; Read the line status.
	blbc	r12, com1_done		; Are we done yet? (data ready = 0).
	in	<com1+fdc$b_rbr>, r12	; Read receive buffer register.
	br	r31, flush_com1		; Loop until done.

com1_done:
	mb
;
; Initialize COM2
;
	out	<com2+fdc$b_lcr>, <lcr$m_dlab>  ; Access clock divisor latch.
	out	<com2+fdc$b_dll>, <dla$k_brg>	; Set the baud rate.
	out	<com2+fdc$b_dlh>, <0>
	out	<com2+fdc$b_lcr>, <lcr$k_init>	; Set line control register.
	out	<com2+fdc$b_mcr>, <mcr$k_init>	; Set modem control register.
	out	<com2+fdc$b_ier>, <^xF>		; Turn on interrupts.
;
; Flush COM2's receive buffer
;
flush_com2:
	in	<com2+fdc$b_lsr>, r12	; Read the line status.
	blbc	r12, com2_done		; Are we done yet? (data ready = 0)
	in	<com2+fdc$b_rbr>, r12	; Read receive buffer register.
	br	r31, flush_com2		; Loop until done.

com2_done:
	mb
;
; Initialize the 82C59 interrupt controller (INT)
;
        out     <int2+int$b_icw1>, <^x11>
        out     <int2+int$b_icw2>, <^x08>
        out     <int2+int$b_icw3>, <^x02>
        out     <int2+int$b_icw4>, <^x01>
        out     <int2+int$b_ocw1>, <^xFF>

        out     <int1+int$b_icw1>, <^x11>
        out     <int1+int$b_icw2>, <^x00>
        out     <int1+int$b_icw3>, <^x04>
        out     <int1+int$b_icw4>, <^x01>
        out     <int1+int$b_ocw1>, <^xFB>

        iack

        out     <int2+int$b_ocw2>, <^x20>
        out     <int1+int$b_ocw2>, <^x20>
;
; Initialize the DS1287A Real Time Clock (RTC)
;
        out     rtcadd, <^x0A>
        out     rtcdat, <^x26>
        out     rtcadd, <^x0B>
        in      rtcdat, r14
	lda	r13, ^x40(r31)		; Enable periodic interrupts.
        bis	r14, r13, r14
        out     rtcadd, <^x0B>
        out     rtcdat, r14
;
; Enable the NMI interrupt
;
	out	<sio$b_nmi>, <^x00>

        pvc$jsr         rph, bsr=1, dest=1
        ret     r31, (r26)



        .endc

.if ne mikasa_system ! noritake_system ! avanti_system ! k2_system ! cortex_system


.sbttl	EB64+ Machine Check Frame
;----------------------------------------------------------------------
;
; EB64+ Machine Check Frame.  This code also adjust the vector based on the
; machine check value.  If the value is 80,82, or 201 through 20d then the 
; vector gets adjusted to 660.
; 

avanti_build_error_frame::
mikasa_build_error_frame::
cortex_build_error_frame::
	mt	r31, alt_mode		; make sure altmode is KERNEL mode
	mf	r0, pt25		; go get mchk flag
	srl	r0, #pt25$v_mck, r1	; get mces to <0>
	blbc	r1, 10$			; continue, if no mchk's in progress

;;;	MCHK	DBL_MCHK, halt=1	; else, halt
	lda	r0,<hlt$c_DBL_MCHK>(r31); set halt code
	mt	r3, pt5			; save old mchk code in pt5
	br	r31, pal$error_halt

10$:	ldah	r1, <1@<pt25$v_mck-16>>(r31); get new mces flag
	or	r0, r1, r0		; set mchk in progress flag
	mt	r0, pt25		; save it in the chip

;
; Get the address to use to build the frame.
;
	lda	r0, pal$logout_specific_size(r31) ; Load CPU-specific size
	mf	r1, pt27		; Get WHAMI
	mulq	r1, r0, r1		;
	lda	r1, pal$logout_base(r1) ; Get logout base address
	lda	r1, laf$base(r1)	; LAOFF

	lda	r0, laf$exc_addr(r31) 	; cpu offset
	stl/p	r0, laf$off(r1) 	; set offset
	lda	r0, laf$plt0(r31) 	; sys offset
	stl/p	r0, <laf$off+4>(r1) 	; set offset

;	lda	r0, laf$size(r31) 	; build flag
	lda	r0, mchk$mchk_size(r31)	; build flag
	stl/p	r0, laf$flag(r1) 	; set flag

	zapnot	r3, #^xf, r0		; get mchk code
	cmpeq	r0, #MCHK$C_ICPERR, r0	; was error i cache parity error?
	sll	r0, #31, r0		; retryable if ic parity error, pos it

	; set the proper state of retry. This is required for Morgan

	stl/p	r0, <laf$flag+4>(r1)	; set retry flag

	srl	r3, #32, r0		; get saved dc_stat (if any)
	stq/p	r0, <laf$dc_stat>(r1)	; save to logout area

	zap	r3, #^xf0, r3		; remove dc_stat from error code
	or	r31, #1, r0		; get a one
	sll	r0, #32, r0		; get an mchk rev level
	or	r3, r0, r3		; merge rev level and mchk code
	stq/p	r3, <laf$pt0>(r1)	; set error code into save pt0

	.macro	movr lax, reg n
	   .if nb "n"
	     mf	r0, 'reg''n'
	     stq/p r0, 'lax'$'reg''n'(r1)
	  .iff
	     mf	r0, 'reg'
	     stq/p r0, 'lax'$'reg'(r1)
	  .endc
	.endm

	.macro	movcsr lax, cntlr, name
	  ldq/p	r13, <'cntlr'$q_'name'>(r14)
	  stq/p r13, 'lax'$q_'name'(r1)
	.endm

	t = 1
	.repeat 31
	movr	laf, pt \t
	t = t + 1
	.endr
	

	; check for pending arith exceptions
	mt	r12, pt12
	mt	r13, pt13
	mt	r14, pt14
	mt	r15, pt15
	mt	r1,  pt4
	pvc$jsr	armc, bsr=1
	bsr	r12, arith_and_mchk	; go check for and deal with arith

	mf	r1,  pt4
	movr	laf, pt9		; propagate ps, from arith

	movr	laf, exc_addr
;	movr	laf, exc_sum
;	movr	laf, exc_msk
;	movr	laf, iccsr

	mf	r0, pt2		;
	stq/p	r0, mchk$iccsr(r1)		;

	movr	laf, pal_base
	movr	laf, hier
	movr	laf, hirr
	movr	laf, mm_csr
	ldq/p	r0, <laf$dc_stat>(r1)		; fetch possibly saved dc_stat
	bne	r0, 15$				; skip save, if already saved
	movr	laf, dc_stat
15$:	movr	laf, dc_addr			; Unlocks DC_STAT

	mf	r13, pt7		; address of impure

	ldq/p	r0, cns$abox_ctl(r13)		; get current abox_ctl
	stq/p	r0, laf$abox_ctl(r1)		; pass it

	ldq/p	r0, cns$biu_ctl(r13)		; get current biu_ctl
	stq/p	r0, laf$biu_ctl(r1)		; pass it

;	movr	laf, abox_ctl
	movr	laf, biu_stat
	movr	laf, biu_addr			; Unlocks BIU_STAT
;	movr	laf, biu_ctl
	movr	laf, fill_syndrome
	movr	laf, fill_addr			; Unlocks FILL_SYNDROME
	movr	laf, va				; Unlocks VA
;	movr	laf, bc_tag

	ornot	r31, #<1@sl_clr$v_crd>, r13	; get ack bit for crd
	mt	r13, sl_clr			; ack any pending crds

	; read out and save bc_tag

	or	r31, r31, r13		; init counter
	or	r31, r31, r14		; start with no bits set
20$:	mf	r12, bc_tag		; get next bit of bc_tag
	sll	r12, r13, r12		; move current mask over by one
	or	r14, r12, r14		; set this bit in mask
	addq	r13, #1, r13		; inc counter
	cmplt	r13, #64, r12		; are we done?
	blbs	r12, 20$		; loop till done

	mt	r31, bc_tag		; unlock bc_tag
	stq/p	r14, laf$bc_tag(r1)	; and salt it away
.if	eq	cfw_system
	assume	<cns$size-<las$size+mchk$mchk_size>> gt 0 ; la size too big
.endc
;
; Store DECchip 21071-CA (Commanche) CSRs.
;
	bis	r31, r31, r12			
	bis	r31, r31, r13			
	lda	r13, coma_base(r31)			
	sll	r13, #28, r13

	ldl/p	r12, coma_gcr(r13)			
	stq/p	r12, mchk$coma_gcr(r1)		
	ldl/p	r12, coma_ter(r13)			
	stq/p	r12, mchk$coma_ter(r1)	
	ldl/p	r12, coma_elar(r13)			
	stq/p	r12, mchk$coma_elar(r1)	
	ldl/p	r12, coma_ehar(r13)			
	stq/p	r12, mchk$coma_ehar(r1)	
	ldl/p	r12, coma_ldlr(r13)			
	stq/p	r12, mchk$coma_ldlr(r1)	
	ldl/p	r12, coma_ldhr(r13)			
	stq/p	r12, mchk$coma_ldhr(r1)	


	lda	r13, ^x1000 (r13)			; 1.8000.0800	

	ldl/p	r12, coma_base0(r13)			
	stq/p	r12, mchk$coma_base0(r1)	
	ldl/p	r12, coma_base1(r13)			
	stq/p	r12, mchk$coma_base1(r1)	
	ldl/p	r12, coma_base2(r13)			
	stq/p	r12, mchk$coma_base2(r1)	

	ldl/p	r12, coma_cnfg0(r13)			
	stq/p	r12, mchk$coma_cnfg0(r1)	
	ldl/p	r12, coma_cnfg1(r13)			
	stq/p	r12, mchk$coma_cnfg1(r1)	
	ldl/p	r12, coma_cnfg2(r13)			
	stq/p	r12, mchk$coma_cnfg2(r1)	

.if	ne	mikasa_system ! noritake_system
; these are valid onl for mikasa
	ldl/p	r12, coma_base3(r13)			
	stq/p	r12, mchk$coma_base3(r1)	
	ldl/p	r12, coma_cnfg3(r13)			
	stq/p	r12, mchk$coma_cnfg3(r1)	
.endc

	lda	r13, -^x1000(r13)		; reset the base address
	ldl/p	r12, coma_edsr(r13)			
	stq/p	r12, mchk$coma_edsr(r1)	
	stl/p	r12, coma_edsr(r13)		; clear the errors

;
; Store DECchip 21071-DA (Epic) CSRs
;
	bis	r31, r31, r13
	lda	r13, epic_base(r31)
	sll	r13, #28, r13

	ldl/p	r12, epic_pear(r13)			
	stq/p	r12, mchk$epic_pear(r1)	
	ldl/p	r12, epic_sear(r13)			
	stq/p	r12, mchk$epic_sear(r1)	
	ldl/p	r12, epic_tbr1(r13)			
	stq/p	r12, mchk$epic_tbr1(r1)	
	ldl/p	r12, epic_tbr2(r13)			
	stq/p	r12, mchk$epic_tbr2(r1)	
	ldl/p	r12, epic_pbr1(r13)			
	stq/p	r12, mchk$epic_pbr1(r1)	
	ldl/p	r12, epic_pbr2(r13)			
	stq/p	r12, mchk$epic_pbr2(r1)	
	ldl/p	r12, epic_pmr1(r13)			
	stq/p	r12, mchk$epic_pmr1(r1)	
	ldl/p	r12, epic_pmr2(r13)			
	stq/p	r12, mchk$epic_pmr2(r1)	
	ldl/p	r12, epic_haxr1(r13)			
	stq/p	r12, mchk$epic_harx1(r1)	
	ldl/p	r12, epic_haxr2(r13)			
	stq/p	r12, mchk$epic_harx2(r1)	
; force bus to zero
	stl/p   r31,  epic_haxr2(r13)
;
	ldl/p	r12, epic_pmlt(r13)			
	stq/p	r12, mchk$epic_pmlt(r1)	
	ldl/p	r12, epic_tag0(r13)			
	stq/p	r12, mchk$epic_tag0(r1)	
	ldl/p	r12, epic_tag1(r13)			
	stq/p	r12, mchk$epic_tag1(r1)	
	ldl/p	r12, epic_tag2(r13)			
	stq/p	r12, mchk$epic_tag2(r1)	
	ldl/p	r12, epic_tag3(r13)			
	stq/p	r12, mchk$epic_tag3(r1)	
	ldl/p	r12, epic_tag4(r13)			
	stq/p	r12, mchk$epic_tag4(r1)	
	ldl/p	r12, epic_tag5(r13)			
	stq/p	r12, mchk$epic_tag5(r1)	
	ldl/p	r12, epic_tag6(r13)			
	stq/p	r12, mchk$epic_tag6(r1)	
	ldl/p	r12, epic_tag7(r13)			
	stq/p	r12, mchk$epic_tag7(r1)	
	ldl/p	r12, epic_data0(r13)			
	stq/p	r12, mchk$epic_data0(r1)	
	ldl/p	r12, epic_data1(r13)			
	stq/p	r12, mchk$epic_data1(r1)	
	ldl/p	r12, epic_data2(r13)			
	stq/p	r12, mchk$epic_data2(r1)	
	ldl/p	r12, epic_data3(r13)			
	stq/p	r12, mchk$epic_data3(r1)	
	ldl/p	r12, epic_data4(r13)			
	stq/p	r12, mchk$epic_data4(r1)	
	ldl/p	r12, epic_data5(r13)			
	stq/p	r12, mchk$epic_data5(r1)	
	ldl/p	r12, epic_data6(r13)			
	stq/p	r12, mchk$epic_data6(r1)	
	ldl/p	r12, epic_data7(r13)			
	stq/p	r12, mchk$epic_data7(r1)	

;
; Clear the error conditions
;

	ldl/p	r12, epic_dcsr(r13)			
	stq/p	r12, mchk$epic_dcsr(r1)	
	stl/p	r12, epic_dcsr(r13)			

.if	ne	mikasa_system ! noritake_system
	;
	; Now Pull in PCEB config registers 
	;
	cfg_read <cfig_pceb> <pceb_vid> <clong> r12, r13	
	extwl	r12, #0, r13		; Vendor ID            (bytes 0-1)
	stq/p	r13, mchk$pceb_vid(r1)	
	extwl	r12, #2, r13		; Device ID            (bytes 2-3)
	stq/p	r13, mchk$pceb_did(r1)	

	cfg_read <cfig_pceb> <pceb_command> <clong> r12, r13	
	extwl	r12, #0, r13		; Command Reg          (bytes 0-1)
	stq/p	r13, mchk$pceb_command(r1)	
	extwl	r12, #2, r13		; Status Reg           (bytes 2-3)
	stq/p	r13, mchk$pceb_status(r1)	

	cfg_read <cfig_pceb> <pceb_latency> <clong> r12, r13	
	extbl	r12, #1, r13		; Master Latency       (byte 1)
	stq/p	r13, mchk$pceb_latency(r1)	

	cfg_read <cfig_pceb> <pceb_revision> <clong> r12, r13	
	extbl	r12, #0, r13		; PCEB Revision        (byte 0)
	stq/p	r13, mchk$pceb_revision(r1)	

	cfg_read <cfig_pceb> <pceb_control> <clong> r12, r13	
	extbl	r12, #0, r13		; PCI Control          (byte 0)
	stq/p	r13, mchk$pceb_control(r1)	
	extbl	r12, #1, r13		; PCI Arbiter Control  (byte 1)
	stq/p	r13, mchk$pceb_arbcon(r1)	
	extbl	r12, #2, r13		; PCI Arbiter Priority (byte 2)
	stq/p	r13, mchk$pceb_arbpri(r1)	

	;
	; ESC configuration space registers 
	; accessed using index/data pairs
	;
 	out	<esc_addr>, <^x02>  	; ESC ID register 
	in	<esc_data> , r12
	stq/p	r12, mchk$esc_id(r1)	

 	out	<esc_addr>, <^x08>  	; ESC Revision register 
	in	<esc_data> , r12
	stq/p	r12, mchk$esc_revision(r1)	

	;
	; ESC registers in I/O space
	;
	in	<esc_int0> , r12
	stq/p	r12, mchk$esc_int0(r1)	
	in	<esc_int1> , r12
	stq/p	r12, mchk$esc_int0(r1)	
	in	<esc_elcr0> , r12
	stq/p	r12, mchk$esc_elcr0(r1)	
	in	<esc_elcr1> , r12
	stq/p	r12, mchk$esc_elcr1(r1)	
	in	<esc_last_eisa> , r12
	stq/p	r12, mchk$esc_last_eisa(r1)	
	in	<esc_nmi_stat> , r12
	stq/p	r12, mchk$esc_nmi_stat(r1)	

.if	ne	mikasa_system
	;
	; Now get the mikasa registers
	;
	in	<mik_irr> , r12
	stq/p	r12, mchk$mik_irr(r1)	
	in	<mik_imr> , r12
	stq/p	r12, mchk$mik_imr(r1)	
	in	<mik_utility> , r12
	stq/p	r12, mchk$mik_utility(r1)	
.endc
.if	ne	noritake_system
;
; Add the noritake stuff
;
	in	<nor_irr1> , r12
	stq/p	r12, mchk$nor_irr1(r1)	
	in	<nor_irr2> , r12
	stq/p	r12, mchk$nor_irr2(r1)	
	in	<nor_irr3> , r12
	stq/p	r12, mchk$nor_irr3(r1)	

	in	<nor_imr1> , r12
	stq/p	r12, mchk$nor_imr1(r1)	
	in	<nor_imr2> , r12
	stq/p	r12, mchk$nor_imr2(r1)	
	in	<nor_imr3> , r12
	stq/p	r12, mchk$nor_imr3(r1)	
	in	<utility> , r12
	stq/p	r12, mchk$utility(r1)	
.endc

.endc

.if	ne	k2_system
;
; Now save the K2 interrupt, watchdog and server management registers.
;
	lda	r12, io_base(r31)	; Load I/O base address.
	sll	r12, <28-5>, r12
	lda	r12, ^x500(r12)		; Form the port address.
        sll     r12, 5, r12		; Shift it into correct position.
	lda	r12, ^x18(r12)		; make it a longword operation

        ldl/p   r13, (r12)		; Read the interrupt config reg
	stq/p	r13, mchk$inter_config(r1)
        ldl/p   r13, ^x200(r12)		; Read the interrupt1 reg
	stq/p	r13, mchk$inter_reg1(r1)
        ldl/p   r13, ^x280(r12)		; Read the interrupt2 reg
	stq/p	r13, mchk$inter_reg2(r1)
        ldl/p   r13, ^x300(r12)		; Read the interrupt3 reg
	stq/p	r13, mchk$inter_reg3(r1)
        ldl/p   r13, ^x380(r12)		; Read the interrupt4 reg
	stq/p	r13, mchk$inter_reg4(r1)

	in_word	<k2$w_watchdog>, r13	; Read the watchdog reg
	stq/p	r13, mchk$watchdog_reg(r1)
	in_word	<k2$w_management>, r13	; Read the server management reg
	stq/p	r13, mchk$srvman_reg(r1)
;
; Store SIO (82378) CSRs. First create SIO configuration space
; base address - 1E0070000 (ID = AD18).
;
	ldah	r13, ^x1E00(r31)
	sll	r13, #4, r13
	ldah	r13, ^x7(r13)
;
; First save the SIO status and revision.
;
	lda	r13, sio$w_status(r13)
	ldl/p	r14, 0(r13)
	srl	r14, 16, r14		; shift to proper byte lane
	zap	r14, #^xfc, r14		; clear unwanted data
	stq/p	r14, mchk$sio_status(r1); Write it
	zap	r13, ^x3, r13		; get rid of address offset
	mb				; Make sure it gets there.
	lda	r13, sio$b_rev(r13)
	ldl/p	r14, 0(r13)
	zap	r14, #^xfe, r14		; clear unwanted data
	stq/p	r14, mchk$sio_rev(r1)	; Write it
	zap	r13, ^x3, r13		; get rid of address offset
	mb				; Make sure it gets there.
;
; Save the Utility Bus Chip Select registers (UBCSA, UBCSB)
;
	lda	r13, sio$b_ubcsa(r13)
	ldl/p	r14, 0(r13)
	srl	r14, 16, r14		; shift to proper byte lane
	zap	r14, #^xfe, r14		; clear unwanted data
	stq/p	r14, mchk$sio_ubcsa(r1)	; Write it
	zap	r13, ^x3, r13		; get rid of address offset
	mb				; Make sure it gets there.
	lda	r13, sio$b_ubcsb(r13)
	ldl/p	r14, 0(r13)
	srl	r14, 24, r14		; shift to proper byte lane
	zap	r14, #^xfe, r14		; clear unwanted data
	stq/p	r14, mchk$sio_ubcsb(r1)	; Write it
	zap	r13, ^x3, r13		; get rid of address offset
	mb				; Make sure it gets there.
;
; Now save PCI interrupt routing reg as a LW.
;
	lda	r13, sio$l_pirq(r13)
	ldl/p	r14, 0(r13)
	zap	r14, #^xf0, r14		; clear unwanted data
	stq/p	r14, mchk$sio_pirq(r1)	; Write it
	zap	r13, ^x3, r13		; get rid of address offset
	mb				; Make sure it gets there.
;
; Now save away the Interrupt controller regs.
; First save the interrupt edge/level and masks.
;
	in	<sio$irq_mask0>, r14
	zap	r14, #^xfe, r14
	stq/p	r14, mchk$sio_irq_mask0(r1)
	in	<sio$irq_mask1>, r14
	zap	r14, #^xfe, r14
	stq/p	r14, mchk$sio_irq_mask1(r1)
	in	<sio$irq_edge0>, r14
	zap	r14, #^xfe, r14
	stq/p	r14, mchk$sio_irq_edge0(r1)
	in	<sio$irq_edge1>, r14
	zap	r14, #^xfe, r14
	stq/p	r14, mchk$sio_irq_edge1(r1)
;
; Now save the IRR and ISR regs.
;
	out	<sio$irq_ocw3c0>, <sio_irr>, r14, r13
	in	<sio$irq_ocw3c0>, r14
	zap	r14, #^xfe, r14
	stq/p	r14, mchk$sio_irq_irr0(r1)
	out	<sio$irq_ocw3c1>, <sio_irr>, r14, r13
	in	<sio$irq_ocw3c1>, r14
	zap	r14, #^xfe, r14
	stq/p	r14, mchk$sio_irq_irr1(r1)
                                                   
	out	<sio$irq_ocw3c0>, <sio_isr>, r14, r13
	in	<sio$irq_ocw3c0>, r14
	zap	r14, #^xfe, r14
	stq/p	r14, mchk$sio_irq_isr0(r1)
	out	<sio$irq_ocw3c1>, <sio_isr>, r14, r13
	in	<sio$irq_ocw3c1>, r14
	zap	r14, #^xfe, r14
	stq/p	r14, mchk$sio_irq_isr1(r1)
;
; Lastly save the NMI regs and the DMA status reg.
;
	in	<sio$b_nmisc>, r14
	zap	r14, #^xfe, r14
	stq/p	r14, mchk$sio_nmi_status(r1)
	in	<sio$b_dma_stat0>, r14
	zap	r14, #^xfe, r14
	stq/p	r14, mchk$sio_dma_status0(r1)
	in	<sio$b_dma_stat1>, r14
	zap	r14, #^xfe, r14
	stq/p	r14, mchk$sio_dma_status1(r1)

.endc
;
; Done Shoving All those registers on the frame
;





;
; done this way to avoid doing it out side this code.
;
	zapnot	r3, ^x0f, r14		; only the low long word

	lda	r13, scb$v_procmchk(r31) ; trap is mchk as starting point
	bis	r31, r31, r0		; adjustmet value

	lda	r12, -^x80(r14)		; check range of errors
	cmoveq	r12, ^x10, r0		; adjust vector

	lda	r12, -^x82(r14)		; check range of errors
	cmoveq	r12, ^x10, r0		; adjust vector

	lda	r12, -^x200(r14)	; if code >= 200 then at least 660
	cmovge	r12, ^x10, r0		; adjust vector for 660 errors
	
	lda	r12, -^x206(r14)	; check for corrected dma read error
	cmoveq	r12, ^x50, r0		; make it 620

	lda	r12, -^x225(r14)	; check range of errors
	cmovge	r12, ^x50, r0		; make it 620

		

.if	ne	<mikasa_system ! noritake_system ! avanti_system ! k2_system>

; Only on the 0x220 code temp failure do we (Noritake) expect to
;      deliver a 660 (fatal) vector all others will be delivered
;      as 620 vectors
11$:
.if ne noritake_system
        lda     r12, -^x221(r14)	; check range of errors
        cmovge  r12, ^x50, r0		; make it 620
        lda     r12, -^x220(r14)	; if code 0x220 then make 660
        cmoveq  r12, ^x10, r0		; adjust vector for 660 errors
.endc
	subq	r13, r0, r13		; adjust vector down.

.if	ne	<mikasa_system ! noritake_system>
	mf	r0, pt25		; go get mchk flag
        lda     r12, -^x620(r13)        ; check the final vector 
	bne	r12, 23$		; it's a 660 or 670
					; it's a 620 set pt25$v_sce	
	ldah	r1, 1@<pt25$v_sce-16>(r31) ; Get SCE
	bis	r0, r1, r0		; set new bit in progress flag
	ldah	r1, 1@<pt25$v_mck-16>(r31) ; get mces flag
	bic	r0, r1, r0		; clear mchk in progress flag
	mt	r0, pt25		; save it in the chip
23$:
.endc

.if_false
11$:	bis	r31, r31, r31		; just a filler
.endc
12$:

	; set up the km trap, via interrupt completion

	lda	r14, laf$base(r31)	; LAOFF

	mf	r0, pt0
	mf	r1, pt1
	mf	r3, pt3
	mt	r31, pt3		; set not from rei flag

	or	r31, #31, r15		; set new ipl to 31
	stall	1
	br	r31, complete_interrupt	; and go to post interrupt processor

	.endc

	.if ne	medulla_system
.sbttl	Medulla Hardware Specific Reset
;----------------------------------------------------------------------
;
; Perform the Medulla platform specific reset.
;
reset_medulla_hardware:
; ++
; Perform the Medulla specific reset code.  This consists of 
; 
;    . Set up the Heartbeat timer. This is a 1k clock from the TOY fed 
;	through to IRQ1 of the SIO. 
;    . Disable the heartbeat timer. 
;    . Disable interrupts via the Module control register. The console will 
;	enable them later when they are ready to take interrupts. 
;    . Enable IRQ1 interrupt of the LCA
;    . Enable IRQ1/6 interrupt of the SIO
;    . set up the UAR/T. 


	.if ne medulla_system_debug
	medu$write_led	Character=<^a/r/>
	.endc

	;
	; Save the speed pins coming into the IRQ
	; lines, prior to switching them over to
	; real IRQ-s.  Save into nvram.
	;
	mf	r14, hirr			; Get a copy of HIRR
	srl	r14, #10, r14			; position IRQ bits to 0
	and 	r14, #7, r14			; keep only hw IRQ bits
	medu$pci_addr	<^x8027>		; nvram store location to r12
	insbl	r14, #<^x8027&3>, r14		; put into correct byte lane
	stl/p	r14, (r12)             
	mb					; flush wb

        .if ne  lca4
        ; Initialize our impure area vars
	sget_addr r14, pal$impure_base, r31		; Base of scratch area
        stq/p   r31, medu$q_last_masked(r14)		; set all ints masked
        stq/p   r31, medu$q_enabled_ints_mask(r14)      ; no ints enabled
	; we cannot setup vip/vic ints now, pci isn't configured
        .endc

	;
	; Reset the PCI local bus. 
	;
;;;	Don't do, since SROM has set up the PCI bus
;;;	medu$reset_pci

        .if ne  lca4
	; Enable IRQ0: PCI SERR & HALT (switch/watchdog)
	medu$write_sio	<^x0c>, SIO$B_NMI_CSR	; clear pending SERR/IOCHK ints
	medu$write_sio	<^x00>, SIO$B_NMI_CSR	; enable SERR/IOCHK ints
	; the pci reset disabled master NMI
	medu$write_sio	<^x00>, SIO$B_NMI_ENB	; master NMI enable
        .endc

	;
	; Init the 8530 UART, both channels.
	;

	;
	; Set-up WR12 and WR13 - Baud Rate Generator Time Constant
	;       
	; The NVRAM should contain the baud rate constants
	; in two bytes for WR13 and WR12 of the 8530.  The
	; two bytes and the third byte should sum to 0xab
	; to be usable.
	;
	medu$pci_addr	<^x8024>	; WR13
	ldl/p	r14, (r12)             
	medu$pci_addr	<^x8025>     	; WR12
	ldl/p	r15, (r12)
	extbl	r15, #<^x8025&3>, r15 ; Extract correct byte lane
	medu$pci_addr	<^x8026>	; checksum
	ldl/p	r13, (r12)
	extbl	r13, #<^x8026&3>, r13 ; Extract correct byte lane
	addq	r15, r14, r12
	addq	r13, r12, r12
	and	r12, #^xff, r12
	subq	r12, #^xab, r12		; checksum constant
	bne	r12, 10$		; br if bad sum
	
	; use values from nvram

	medu$pci_addr	MEDU$K_UART_BASE, r12	; setup PCI UART addr

	lda 	r13, MEDU$WR12(r31)	; prepare for access to WR12
	stl/p	r13, MEDU$UART_CHA_RDWR(r12)
	mb				; flush wb to prevent merges

	stl/p	r15, MEDU$UART_CHA_RDWR(r12)
	mb				; flush wb to prevent merges

	lda 	r13, MEDU$WR13(r31)	; prepare for access to WR13
	stl/p	r13, MEDU$UART_CHA_RDWR(r12)
	mb				; flush wb to prevent merges

	stl/p	r14, MEDU$UART_CHA_RDWR(r12)
	mb				; flush wb to prevent merges

	br	r31, 20$

10$:
	; use default values

	medu$pci_addr	MEDU$K_UART_BASE, r12	; setup PCI UART addr

	lda 	r13, MEDU$WR12(r31)	; prepare for access to WR12
	stl/p	r13, MEDU$UART_CHA_RDWR(r12)
	mb				; flush wb to prevent merges

	lda	r13, MEDU$TIME_CONST_LOW(r31)	; write low part of baud rate
	stl/p	r13, MEDU$UART_CHA_RDWR(r12)
	mb				; flush wb to prevent merges

	lda 	r13, MEDU$WR13(r31)	; prepare for access to WR13
	stl/p	r13, MEDU$UART_CHA_RDWR(r12)
	mb				; flush wb to prevent merges

	lda	r13, MEDU$TIME_CONST_HIGH(r31)	; write high part of baud rate
	stl/p	r13, MEDU$UART_CHA_RDWR(r12)
	mb				; flush wb to prevent merges
20$:
	;
	; Set-up WR11 - Clock Mode Control
	;
	lda 	r13, MEDU$WR11(r31)	; prepare for WR11 access
	stl/p	r13, MEDU$UART_CHA_RDWR(r12)
	mb				; flush wb to prevent merges

	lda	r13, MEDU$BAUD_RATE_GEN(r31)	; write byte to register
	stl/p	r13, MEDU$UART_CHA_RDWR(r12)
	mb				; flush wb to prevent merges
	;
	; Set-up WR14 - Miscellaneous Control bits 
	;
	lda 	r13, MEDU$WR14(r31)	; prepare to access WR14
	stl/p	r13, MEDU$UART_CHA_RDWR(r12)
	mb				; flush wb to prevent merges

	lda	r13, MEDU$BAUD_AS_CLK(r31)	; write byte to register
	stl/p	r13, MEDU$UART_CHA_RDWR(r12)
	mb				; flush wb to prevent merges
	;
	; Set-up WR4 - Tx/Rx Misc. Parameters and Modes
	;
	lda 	r13, MEDU$WR4(r31)	; prepare to access to WR4
	stl/p	r13, MEDU$UART_CHA_RDWR(r12)
	mb				; flush wb to prevent merges

	lda	r13, MEDU$GENERAL_SETUP(r31)	; write byte to register
	stl/p	r13, MEDU$UART_CHA_RDWR(r12)
	mb				; flush wb to prevent merges
	;
	; Set-up WR3 - Receive Parameters and Control Modes
	;
	lda 	r13, MEDU$WR3(r31)		; Put WR3 into a register.
	stl/p	r13, MEDU$UART_CHA_RDWR(r12)
	mb				; flush wb to prevent merges

	lda	r13, MEDU$RX_CONTROL(r31)	; Put data into a register
	stl/p	r13, MEDU$UART_CHA_RDWR(r12)
	mb				; flush wb to prevent merges
	;
	; Set-up WR5 - Transmit Parameters and Control Modes
	;
	lda 	r13, MEDU$WR5(r31)	; prepare to access to WR5
	stl/p	r13, MEDU$UART_CHA_RDWR(r12)
	mb				; flush wb to prevent merges

	lda	r13, MEDU$TX_CONTROL(r31)	; write byte to register
	stl/p	r13, MEDU$UART_CHA_RDWR(r12)
	mb				; flush wb to prevent merges

	; Init Channel B.
	;
	; Set-up WR12 and WR13 - Baud Rate Generator Time Constant
	;
	; The NVRAM should contain the baud rate constants
	; in two bytes for WR13 and WR12 of the 8530.  The
	; two bytes and the third byte should sum to 0xab
	; to be usable.
	;
	medu$pci_addr	<^x8024>	; WR13
	ldl/p	r14, (r12)             
	medu$pci_addr	<^x8025>     	; WR12
	ldl/p	r15, (r12)
	extbl	r15, #<^x8025&3>, r15 ; Extract correct byte lane
	medu$pci_addr	<^x8026>	; checksum
	ldl/p	r13, (r12)
	extbl	r13, #<^x8026&3>, r13 ; Extract correct byte lane
	addq	r15, r14, r12
	addq	r13, r12, r12
	and	r12, #^xff, r12
	subq	r12, #^xab, r12		; checksum constant
	bne	r12, 30$		; br if bad sum
	
	; use values from nvram

	medu$pci_addr	MEDU$K_UART_BASE, r12	; setup PCI UART addr

	lda 	r13, MEDU$WR12(r31)	; prepare for access to WR12
	stl/p	r13, MEDU$UART_CHB_RDWR(r12)
	mb					; flush wb to prevent merges

	stl/p	r15, MEDU$UART_CHB_RDWR(r12)
	mb				; flush wb to prevent merges

	lda 	r13, MEDU$WR13(r31)	; prepare for access to WR13
	stl/p	r13, MEDU$UART_CHB_RDWR(r12)
	mb					; flush wb to prevent merges

	stl/p	r14, MEDU$UART_CHB_RDWR(r12)
	mb					; flush wb to prevent merges

	br	r31, 40$

30$:
	; use default values

	medu$pci_addr	MEDU$K_UART_BASE, r12	; setup PCI UART addr

	lda 	r13, MEDU$WR12(r31)	; prepare for access to WR12
	stl/p	r13, MEDU$UART_CHB_RDWR(r12)
	mb					; flush wb to prevent merges

	lda	r13, MEDU$TIME_CONST_LOW(r31)	; write low part of baud rate
	stl/p	r13, MEDU$UART_CHB_RDWR(r12)
	mb					; flush wb to prevent merges

	lda 	r13, MEDU$WR13(r31)	; prepare for access to WR13
	stl/p	r13, MEDU$UART_CHB_RDWR(r12)
	mb					; flush wb to prevent merges

	lda	r13, MEDU$TIME_CONST_HIGH(r31)	; write high part of baud rate
	stl/p	r13, MEDU$UART_CHB_RDWR(r12)
	mb					; flush wb to prevent merges

40$:
	;
	; Set-up WR11 - Clock Mode Control
	;
	lda 	r13, MEDU$WR11(r31)	; prepare for WR11 access
	stl/p	r13, MEDU$UART_CHB_RDWR(r12)
	mb					; flush wb to prevent merges

	lda	r13, MEDU$BAUD_RATE_GEN(r31)	; write byte to register
	stl/p	r13, MEDU$UART_CHB_RDWR(r12)
	mb					; flush wb to prevent merges
	;
	; Set-up WR14 - Miscellaneous Control bits 
	;
	lda 	r13, MEDU$WR14(r31)	; prepare to access WR14
	stl/p	r13, MEDU$UART_CHB_RDWR(r12)
	mb					; flush wb to prevent merges

	lda	r13, MEDU$BAUD_AS_CLK(r31)	; write byte to register
	stl/p	r13, MEDU$UART_CHB_RDWR(r12)
	mb					; flush wb to prevent merges
	;
	; Set-up WR4 - Tx/Rx Misc. Parameters and Modes
	;
	lda 	r13, MEDU$WR4(r31)	; prepare to access to WR4
	stl/p	r13, MEDU$UART_CHB_RDWR(r12)
	mb					; flush wb to prevent merges

	lda	r13, MEDU$GENERAL_SETUP(r31)	; write byte to register
	stl/p	r13, MEDU$UART_CHB_RDWR(r12)
	mb					; flush wb to prevent merges
	;
	; Set-up WR3 - Receive Parameters and Control Modes
	;
	lda 	r13, MEDU$WR3(r31)		; Put WR3 into a register.
	stl/p	r13, MEDU$UART_CHB_RDWR(r12)
	mb					; flush wb to prevent merges

	lda	r13, MEDU$RX_CONTROL(r31)	; Put data into a register
	stl/p	r13, MEDU$UART_CHB_RDWR(r12)
	mb					; flush wb to prevent merges
	;
	; Set-up WR5 - Transmit Parameters and Control Modes
	;
	lda 	r13, MEDU$WR5(r31)	; prepare to access to WR5
	stl/p	r13, MEDU$UART_CHB_RDWR(r12)
	mb					; flush wb to prevent merges

	lda	r13, MEDU$TX_CONTROL(r31)	; write byte to register
	stl/p	r13, MEDU$UART_CHB_RDWR(r12)
	mb					; flush wb to prevent merges

	;
	; Print the welcome message.
	;
    .if ne medulla_system_debug
	medu$write_led	Character=<^a/!/>

	medu$putc	<^x0d>, AddrSetup=1
	medu$putc	<^x0a>, AddrSetup=0
	medu$putc	<^a/M/>, AddrSetup=0
	medu$putc	<^a/e/>, AddrSetup=0
	medu$putc	<^a/d/>, AddrSetup=0
	medu$putc	<^a/u/>, AddrSetup=0
	medu$putc	<^a/l/>, AddrSetup=0
	medu$putc	<^a/l/>, AddrSetup=0
	medu$putc	<^a/a/>, AddrSetup=0
	medu$putc	<^a/ />, AddrSetup=0
      .if ne medulla_lcads
	medu$putc	<^a/B/>, AddrSetup=0
	medu$putc	<^a/L/>, AddrSetup=0
	medu$putc	<^a/1/>, AddrSetup=0
	medu$putc	<^a/-/>, AddrSetup=0
	medu$putc	<^a/0/>, AddrSetup=0
      .iff
	medu$putc	<^a/L/>, AddrSetup=0
	medu$putc	<^a/C/>, AddrSetup=0
	medu$putc	<^a/A/>, AddrSetup=0
      .endc
	medu$putc	<^x0d>, AddrSetup=0
	medu$putc	<^x0a>, AddrSetup=0
    .endc

	;
	; Disable interrupts in the module control register (for Bob, of course
	;   he asked for this on Monday morning before his first coffee). 
	; Disable clock multpliers to LCA, which brings in interrupt lines.
	;
	medu$write_module_reg	Data=<^x10>, ModRegOffset=MEDU$MOD_CNTRL_REG
	;
	; Disable the heartbeat timer. 
	;
	; 	Set the transfer enable bit in register B. 
	;
	medu$write_toy	Data=<^x90>, ToyOffset=<^x0b>
	;
	; 	Disable the SQW bit in register 9.
	;
	;	The address will be formed in R12 and the data will be
	;	placed in R13 by the toy_read macro. Be sure not to clobber 
	;	the values before the write back out to TOY Register 9.
	;
	medu$read_toy	ToyOffset=<^x09>, AddrSetup=1
	or	r13, #^x40, r13		; Set the TE bit
	medu$write_toy	Data=r13, ToyOffset=<^x09>, AddrSetup=0
	;
	; 	Turn off transfer enable bit in register B -- the Register
	;	B address should still be in R13.
	;
	medu$write_toy	Data=<^x7f>, ToyOffset=<^x0b>
        ;
        ;   Flush any outstanding heartbeat timer interrupts by writing the 
	; "Clear Heartbeat Register". 
        ;
	medu$write_module_reg	Data=<^x0>, ModRegOffset=MEDU$HBEAT_CLR_REG

      .if ne medulla_int_cntrs
	;
	; Clear the debug interrupt counters.
	;
	ldah	r12, ^x0060(r31)	; 0.0060.0000
	lda	r13, ^x0300(r31)	; Up to offset 300
      medu_clear_loop:
	stq/p   r31, (r12)		; Zero it
	addq	r12, ^x0010, r12	; Increment address by 10H
	subq	r13, #^x10, r13		; Decrement counter by 10H
	bne	r13, medu_clear_loop
      .endc

	;
	; Initialize the interrupt controllers: first do PIC 2
	;	Initialization Command Word 1 (ICW1) is a write at the PIC 1
	;	or 2 base address with data bit 4 set to 1. The next 3 writes
	;	to base address + 1 must follow ICW1, representing ICW2 - 4. 
	;
	;	Set ICW1<3> to select Level sensitive interrupt detection. 
	;	
	;	Set ICW1<4> to select ICW1, and ICW1<0> to tell the SIO that
	;	ICW4 write is going to be written. 
	;
	medu$write_sio	<^x19>, SIO$B_PIC2_ICW1
	;
	;	ICW2<7:3> provide the interrupt vector that will be released
	;	onto the data bus by the interrupt controller during an 
	;	interrupt acknowledge. For PIC2 we will set the int vector
	;	to be 1. ICW2<2:0> are the IRQL and should be 0.
	;
	medu$write_sio	<^x08>, SIO$B_PIC2_ICW2
	;
	;	ICW3<2:0> set the slave ID code and must be 010b for PIC 2.
	;
	medu$write_sio	<^x02>, SIO$B_PIC2_ICW3
	;
	;	ICW4<0> selects 80x86 mode and must be set to 1.
	;
	medu$write_sio	<^x01>, SIO$B_PIC2_ICW4
	;
	;	Disable all interrupts into PIC2. The console or OS will enable
	; 	the interrupts on the SIO as the appropriate driver is added. 
	;	A value of 1 in any bit position disables the interrupt. 
	;
	medu$write_sio	<^xff>, SIO$B_PIC2_MASK
	;
	; 
	; Now do PIC1:
	;	ICW1 for PIC1 is written the same as for PIC2.
	;
	medu$write_sio	<^x19>, SIO$B_PIC1_ICW1
	;
	;	ICW2<7:3> will set the int vector to be 0. 
	;
	medu$write_sio	<^x00>, SIO$B_PIC1_ICW2
	;
	;	ICW3 in PIC1 is different than in PIC2. Here ICW3<2> set to
	;	1 tells the SIO that PIC2 is cascaded through IRQ<2>. This 
	;	must be set to 1. 
	;
	medu$write_sio	<^x04>, SIO$B_PIC1_ICW3
	;
;;;	;	ICW4 in PIC1 is different than in PIC2.  Here ICW4<4> set to
;;;	;	1 to indicate Special Fully Nested Mode, so we can recognize
;;;	;	multiple interrupts on PIC2 coming in on IRQ2 of PIC1.
;;;	medu$write_sio	<^x11>, SIO$B_PIC1_ICW4
	;
	;	ICW4<0> selects 80x86 mode and must be set to 1.
	;
	medu$write_sio	<^x01>, SIO$B_PIC1_ICW4
	;
	;	Disable all interrupts into PIC1. The console or OS will enable
	; 	the interrupts on the SIO as the appropriate driver is added. 
	;	A value of 1 in any bit position disables the interrupt. 
	;	We leave IRQ2 enabled, since this is the cascade from
	;	PIC2.
	;
	medu$write_sio	<^xfb>, SIO$B_PIC1_MASK

	.if ne	medulla_old_sio_ints
	;
	; Flush any interrupts that are there now. 
	;
	medu$iack
	; 
	; Do a nonspecific EOI write. 
	;
	medu$write_sio	<^x20>, SIO$B_PIC2_OCW2
	medu$write_sio	<^x20>, SIO$B_PIC1_OCW2
	.endc
	;
	; Set Special Mask Mode (allows us to control interrupt
	; priorities).
	;
	medu$write_sio	<^x68>, SIO$B_PIC1_OCW3
	medu$write_sio	<^x68>, SIO$B_PIC2_OCW3

	;
	; Select the IRR for the reads of the PIC1 and PIC2 register during 
	; the interrupt handler. 
	;
	medu$write_sio	<^x0a>, SIO$B_PIC1_OCW3
	medu$write_sio	<^x0a>, SIO$B_PIC2_OCW3

      .if ne medulla_lcads
	;
	; For the LCADS version, set the 3rd LED to say that we are leaving.
	; 
	ldah	r12, ^x3000(r31)	; r12 = 0.3000.0000
        sll     r12, #4, r12		; r12 = 3.0000.0000
	lda     r12, ^x060(r12)		; r12 = 3.0000.0060 = LCADS PCI CSR
	ldl/p   r13, (r12)		; Read the current value
	or	r13, #^x80, r13		; Set LED3 <7> 
	stl/p   r13, (r12)		; Write it out
	mb				; Flush it out of the write buffer
      .endc

	;
	; Return to the caller. 
	;
	pvc$jsr		rgh, bsr=1, dest=1
	ret	r31, (r26)


;
; Medulla Machine Check Frame builder.
; Copied from Mustang.
; 

medulla_build_error_frame::
	mt	r31, alt_mode		; make sure altmode is KERNEL mode
	mf	r0, pt25		; go get mchk flag
	srl	r0, #pt25$v_mck, r1	; get mces to <0>
	blbc	r1, 10$			; continue, if no mchk's in progress

	lda	r0,<hlt$c_DBL_MCHK>(r31); set halt code
	mt	r3, pt5			; save old mchk code in pt5
	br	r31, pal$error_halt

10$:	ldah	r1, <1@<pt25$v_mck-16>>(r31); get new mces flag
	or	r0, r1, r0		; set mchk in progress flag
	mt	r0, pt25		; save it in the chip

	; fetch mchk impure area ptr
	get_addr r1, <pal$logout_base + laf$base>, r31; offset to logout area

	lda	r0, laf$exc_addr(r31) 	; cpu offset
	stl/p	r0, laf$off(r1) 	; set offset
	lda	r0, laf$plt0(r31) 	; sys offset
	stl/p	r0, <laf$off+4>(r1) 	; set offset

	lda	r0, laf$size(r31) 	; build flag
	stl/p	r0, laf$flag(r1) 	; set flag

	zapnot	r3, #^xf, r0		; get mchk code
	cmpeq	r0, #MCHK$C_ICPERR, r0	; was error i cache parity error?
	sll	r0, #31, r0		; retryable if ic parity error, pos it
	stl/p	r0, <laf$flag+4>(r1)	; set retry flag

	srl	r3, #32, r0		; get saved dc_stat (if any)
	stq/p	r0, <laf$dc_stat>(r1)	; save to logout area
	zap	r3, #^xf0, r3		; remove dc_stat from error code
	or	r31, #1, r0		; get a one
	sll	r0, #32, r0		; get an mchk rev level
	or	r3, r0, r3		; merge rev level and mchk code
	stq/p	r3, <laf$pt0>(r1)	; set error code into save pt0

	.macro	movr lax, reg n
	   .if nb "n"
	     mf	r0, 'reg''n'
	     stq/p r0, 'lax'$'reg''n'(r1)
	  .iff
	     mf	r0, 'reg'
	     stq/p r0, 'lax'$'reg'(r1)
	  .endc
	.endm

	.macro	movcsr lax, cntlr, name
	  ldq/p	r13, <'cntlr'$q_'name'>(r14)
	  stq/p r13, 'lax'$q_'name'(r1)
	.endm

	t = 1
	.repeat 31
	movr	laf, pt \t
	t = t + 1
	.endr
	

	; check for pending arith exceptions
	mt	r12, pt12
;	mt	r13, pt13
	mt	r14, pt14
	mt	r15, pt15
;;;DEB	mt	r1,  pt4
;;;DEB	pvc$jsr	armc, bsr=1
;;;DEB	bsr	r12, arith_and_mchk	; go check for and deal with arith
;;;DEB	mf	r1,  pt4
	stall	3			; MEDULLA DEBUG

	movr	laf, pt9		; propagate ps, from arith

	movr	laf, exc_addr
;	movr	laf, exc_sum
;	movr	laf, exc_msk
;	movr	laf, iccsr
	movr	laf, pal_base
	movr	laf, hier
	movr	laf, hirr
	movr	laf, mm_csr
	ldq/p	r0, <laf$dc_stat>(r1)	; fetch possibly saved dc_stat
	bne	r0, 15$			; skip save, if already saved
	movr	laf, dc_stat
15$:	movr	laf, dc_addr

	mf	r13, pt7		; address of impure

	;
	; Get the address to use to build the frame.
	;

	ldq/p	r0, cns$abox_ctl(r13)		; get current abox_ctl
	stq/p	r0, laf$abox_ctl(r1)		; pass it
	get_high_addr r14, mem$csr_base
	movcsr	laf, mem, ear
	movcsr	laf, mem, esr
	stq/p	r13, mem$q_esr(r14)
	movcsr	laf, mem, car
	get_high_addr r14, ioc$csr_base
	movcsr	laf, ioc, stat1
	movcsr	laf, ioc, stat0
	stq/p	r13, ioc$q_stat0(r14)
	mb				; flush write buffer
	assume	<cns$size-<las$size+laf$size>> gt 0 ; la size too big

	; set up the km trap, via interrupt completion

	lda	r14, laf$base(r31)	; LAOFF

	mf	r0, pt0
	mf	r1, pt1
	mf	r3, pt3
	mt	r31, pt3		; set not from rei flag

	lda	r13, scb$v_procmchk(r31); trap is mchk
	or	r31, #31, r15		; set new ipl to 31
	stall	1
	br	r31, complete_interrupt	; and go to post interrupt processor

	.endc
;
;	End of Medulla-specific reset. 
;


pal$end::
.print	pal$end

	.if ne	cfw_system
assume <.-pal$pal_size> lt 0
. = pal$pal_size
	.iff
.sbttl DATSALL - Align to 2 page boundary incase linked with other pal's


	.iif ne enable_debug_pcevent, $$debug_boot$$last  = $$debug_boot$$
	.if df MACRO64$
	  $$$current_dot = %integer(.)
	.iff
	  $$$current_dot = .
	.endc
	. = <<<$$$current_dot + <8192*2>-1> & ^xFFFFC000>-4>
	.LONG	0
	.endc

	.end		; the end of it all
