MODULE
  %if %variant gtr 0 %then
	delta(
		MAIN = xdt$start,
  %else
	xdelta(
  %fi
		IDENT = 'V01-000'
		) =
BEGIN
!
!			  Copyright (c) 1990 by
!	      Digital Equipment Corporation, Maynard, Mass.
!
! This software is furnished under a license and may be used and  copied
! only  in  accordance  with  the  terms  of  such  license and with the
! inclusion of the above copyright notice.  This software or  any  other
! copies  thereof may not be provided or otherwise made available to any
! other person.  No title to and ownership of  the  software  is  hereby
! transferred.
!
! The information in this software is subject to change  without  notice
! and  should  not  be  construed  as  a commitment by Digital Equipment
! Corporation.
!
! Digital assumes no responsibility for the use or  reliability  of  its
! software on equipment which is not supplied by Digital.
!
!++
! Facility:
!
!	Executive - Debugging Tools
!
! Abstract:
!
!	XDELTA is the VMS stand-alone debugging tool. It must be physically
! resident and executes in kernel mode at elevated IPL. It is a "no frills"
! debugger, providing the basic set of functions necessary to do system-level
! debugging.
!	DELTA is a similar style debugging tool which operates in process
! context in any access mode, but never at elevated IPL. It is typically
! used to debug IPL 0 inner mode code which cannot be debugged using the
! VMS symbolic debugger.
!	Both XDELTA and DELTA are built from the same set of sources. A
! compile-time switch is used to control the environment settings for whichever
! is being built. The resulting command syntax and error messages are
! identical between the two.
!	XDELTA was written a LONG time ago (15-Nov-1976) by Dick Hustvedt
! with only VAX/VMS in mind. It has undergone fairly significant changes over
! the years to accommodate such things as new CPU support, loadable exec,
! SMP, 34-bit PFNs, etc. However, no change presented the difficulties of
! trying to support EVAX. XDELTA was very dependent on the VAX architecture,
! and those features are no longer available on EVAX.
!	Porting XDELTA to EVAX meant a rewrite. The language of choice was
! BLISS. It meant taking a snapshot of VAX/VMS XDELTA and functionally porting
! it to EVAX. The porting effort consisted of reimplementation and redesign.
! Without even taking into account the new CPU architecture, the resulting
! implementations would be different. From the surface, this should appear
! as the same XDELTA and DELTA we all know and love. On the inside, it is
! considerably different and will likely have some visible differences on the
! outside as well. Future problems will need to be corrected in both the
! VAX and EVAX versions of XDELTA.
!	The most significant design/implementation difference between this
! EVAX version and the VAX version of XDELTA stems from the lack of a T-bit
! trap on EVAX. T-bit traps were used in the VAX version for single-step and
! proceeding from breakpoints. This version uses inline temporary breakpoints
! with the BPT PAL instruction to emulate the T-bit behavior somewhat.
!	There are other architectural differences which cause some things
! to be handled in a different manner or which require more explicit
! control on the part of XDELTA. For example, XDELTA must now worry about
! when to flush the I-cache and when to implicitly generate NUDGE and BARRIER
! instructions. Assumptions about page size can no longer be made. EVAX has
! a new instruction set to disassemble, new 64-bit GPRs and IPRs, new
! memory management, etc. This version of XDELTA also handles exceptions
! differently. The previous version had "unexpected" and "expected" exceptions,
! where expected ones were handled inline. In this version of XDELTA, all
! exceptions are unexpected and handled in the same way, by forcing the routine
! which got the exception to return immediately to its caller with the
! exception reason as the return status value (status values, where appropriate,
! propagate back up the chain). The so-called expected exceptions have gone
! away in favor of using PROBE to check access ahead of time in appropriate
! situations.
!	The user interface has also be changed somewhat to accommodate EVAX.
! Register numbers must now be specified in decimal instead of hex. With the
! increased number of registers, a two-digit register number would sometimes
! be necessary even in hex. Using decimal frees up some symbol name space for
! other useful new symbols, like PC. The symbol "PS" can be used to access
! the processor status in place of "RF+4" in the previous version.
!	Another fairly significant change to the user interface is seen when
! dealing with processor registers. EVAX doesn't have processor registers
! analogous to VAX. Instead, there are PAL calls to retrieve processor
! information, some of which resembles VAX processor register contents.
! Because there are no processor register numbers and because they were always
! difficult to remember in the first place, this version of XDELTA will use
! register names but manipulate them as before. So, for example, to "open"
! the executive stack pointer processor register, the user would type:
! "P(ESP)/", the name specified in parenthesis. XDELTA will take care of
! mapping read/write operations to the appropriate PAL calls. However, it
! should be noted that some processor registers are read-only or write-only.
! An "open" implicitly attempts a read, which may generate an error. However,
! the location will remain "open" to permit a subsequent write, if allowed.
!	The few other user interface changes will be described in more detail
! in the user documentation.
!	One pervasive, seemingly inexplicable, peculiarity in the code is its
! use of BINDs where they often seem unnecessary. BINDs allow us to refer
! to a field within a data structure using the default %BPVAL for whatever
! compiler we're using. So, let's suppose that all integers within a data
! structure are allocated as quadwords. Then we BIND symbols to these using
! the compiler default %BPVAL and do arithmetic and move data between these
! fields. Code generated by both the 32-bit and 64-bit compilers should do the
! right thing. Being able to compile this code with both the 32-bit and 64-bit
! compilers has certain advantages, although there are cases which must be
! special-cased, depending on the %BPVAL.
!	Note that XDELTA is pretty much self-contained. So using one or the
! other compiler has few serious implications. However, DELTA uses system
! services and has other external dependencies. So differences between the
! 32-bit and 64-bit calling standards cause problems which cannot be (and are
! not) solved by the simple BIND trick above. So such things as string
! descriptors are setup explicitly as two longwords to look the same
! regardless of which compiler is used. These will presumably require change
! for EVMS Phase II under the 64-bit calling standard.
!	XDELTA wants to align various things on page boundaries. However, the
! target machine page size cannot be assumed at compile time. So a literal
! for the largest possible page size is used in these cases. This constant
! can be changed in the future if necessary.
!
! Environment:
!
!	DELTA  - Normal process environment, multiple access modes
!	XDELTA - Stand-alone, resident, kernel mode, IPL=31
!
! Author: Steve DiPirro	, Creation date: 15-JAN-1990
!
!--

!
! Include files:
!
LIBRARY 'sys$library:lib';
LIBRARY 'lib$:xdelta';
REQUIRE 'src$:vms$linkages';
!
! Peculiar and unusual data structures
!
STRUCTURE
	lrefblock[o,p,s,e;bs,unit=%upval] =
		[bs*unit]
		(.lrefblock<0,32,1>+o*unit)<p,s,e>,

	lrefblockvector[i,o,p,s,e;n,bs,unit=%upval] =
		[n*bs*unit]
		(.lrefblockvector<0,32,1>+(i*bs+o)*unit)<p,s,e>;
!
! Macros
!
MACRO
!
! The /VARIANT qualifier on the BLISS command is used to produce the DELTA
! version of this module, where the "delta" macro has a true value. By default,
! %variant is zero and XDELTA is produced.
!
	delta =
	  %if %variant gtr 0 %then
	    1
	  %else
	    0
	  %fi %,
!
	xdelta =
	  %if %variant eql 0 %then
	    1
	  %else
	    0
	  %fi %,
!
! Here are some utility macros
!
	$my_probe(buf_adr,buf_size,probe_type,mode) =
	  BEGIN
	    MACRO my_pbuiltin =
	      %if %identical(probe_type,r) %then
		pal_prober
	      %else
		pal_probew
	      %fi
	      %quote %;

	    BUILTIN my_pbuiltin;
	    my_pbuiltin(buf_adr,buf_size - 1,mode)
	  END
	%,
!
	$invalidate_tb =
!	  IF mmg$tbia_simple NEQ 0 THEN
!	    mmg$tbia_simple()
!	  ELSE
	    BEGIN
	      BUILTIN pal_mtpr_tbia;
	      pal_mtpr_tbia()
	    END
	%,
!
	$cpu_id =
	  BEGIN
	    BUILTIN pal_mfpr_whami;
	    pal_mfpr_whami()
	  END
	%,

	$get_cpu_db =
	  BEGIN
	    BUILTIN pal_mfpr_prbr;
	    pal_mfpr_prbr ()
	  END
	%,
!
	$proc_status =
	  BEGIN
	    BUILTIN pal_rd_ps;
	    pal_rd_ps()
	  END
	%,
!
	$insert_queue(new_entry,queue_ptr) =
	  BEGIN
	    BUILTIN pal_insquel;
	    pal_insquel(queue_ptr,new_entry)
	  END
	%,
!
	$remove_queue(entry_to_remove) =
	  BEGIN
	    BUILTIN pal_remquel;
	    pal_remquel(entry_to_remove)
	  END
	%,
!
	$read_scb =
	  BEGIN
	    BUILTIN pal_mfpr_scbb;
	    pal_mfpr_scbb()
	  END
	%,
!
	$write_scb(scb_pfn) =
	  BEGIN
	    BUILTIN pal_mtpr_scbb;
	    pal_mtpr_scbb(scb_pfn)
	  END
	%,
!
	$memory_barrier =
	  BEGIN
	    BUILTIN barrier;
	    barrier()
	  END
	%,
!
	$instruction_memory_barrier =
	  BEGIN
	    BUILTIN pal_imb;
	    pal_imb()
	  END
	%,
!
	$init_done =
	  BEGIN
	    IF exe$gl_state EQL 0 THEN
	      0
	    ELSE
	      .exe$gl_state[boostate$v_init]
	  END
	%,
!
	$bit_position(bit_mask)[] =
	  %if bit_mask %then
	    0
	  %else
	    1 + $bit_position(bit_mask ^ -1)
	  %fi
	%,
!
! The following macros define IPR names to be used for input and output
! of processor registers. There are corresponding literals for the string
! sizes and binds for string addresses below which must be changed to
! reflect any changes to the following macros. Please try to keep the
! list alphabetical for ease of maintenance.
!
	asn_string = %STRING('ASN') %,
	asten_string = %STRING('ASTEN') %,
	astsr_string = %STRING('ASTSR') %,
	datfx_string = %STRING('DATFX') %,
	esp_string = %STRING('ESP') %,
	fen_string = %STRING('FEN') %,
	ipir_string = %STRING('IPIR') %,
	ipl_string = %STRING('IPL') %,
	mces_string = %STRING('MCES') %,
	pcbb_string = %STRING('PCBB') %,
!	perfmon_string = %STRING('PERFMON') %,
	prbr_string = %STRING('PRBR') %,
	ptbr_string = %STRING('PTBR') %,
	rscc_string = %STRING('RSCC') %,
	scbb_string = %STRING('SCBB') %,
	sirr_string = %STRING('SIRR') %,
	sisr_string = %STRING('SISR') %,
	ssp_string = %STRING('SSP') %,
	tbchk_string = %STRING('TBCHK') %,
	tbia_string = %STRING('TBIA') %,
	tbiap_string = %STRING('TBIAP') %,
	tbis_string = %STRING('TBIS') %,
	tbisd_string = %STRING('TBISD') %,
	tbisi_string = %STRING('TBISI') %,
	usp_string = %STRING('USP') %,
	vptbase_string = %STRING('VPTBASE') %,
	whami_string = %STRING('WHAMI') %,
!
! Other misc. strings used in a few routines
!
	imgsym_msg = %STRING('Symbol-Vector') %,
	imgflg_msg = %STRING('Flags') %,
	imgres_msg = %STRING('     Resident Code Sections:') %,
	imgdat_msg = %STRING('     Compressed Data Sections:') %,
	imgmoff_msg = %STRING('     Map File Offset = ') %,
	imgseq_msg = %STRING('Seq#') %,
	imgnam_msg = %STRING('Image Name') %,
	imgbas_msg = %STRING('Base') %,
	imgend_msg = %STRING('End') %,
	imgoff_msg = %STRING('Image Offset') %,
	imgadd_msg = %STRING('Address') %;
!
! BUILTINs to be used in numerous places
!
BUILTIN
	testbitssi,
	testbitcci;
!
! PSECT definitions
!
%if delta %then

PSECT	
	CODE   = z$debug_code (READ,WRITE,EXECUTE,NOSHARE,PIC,CONCATENATE,
			ALIGN(2)),	!,ADDRESSING_MODE (GENERAL)),
	PLIT   = z$debug_plit (READ,WRITE,NOEXECUTE,NOSHARE,PIC,CONCATENATE,
			ALIGN(3)),	!,ADDRESSING_MODE (GENERAL)),
	OWN    = z$debug_data (READ,WRITE,NOEXECUTE,NOSHARE,PIC,CONCATENATE,
			ALIGN(3)),	!,ADDRESSING_MODE (GENERAL)),
	GLOBAL = z$debug_global (READ,WRITE,NOEXECUTE,NOSHARE,PIC,CONCATENATE,
			ALIGN(3));	!,ADDRESSING_MODE (GENERAL));
%else

PSECT	
	CODE   = z$debug_code (READ,WRITE,EXECUTE,NOSHARE,PIC,CONCATENATE,
			ALIGN(2)),	!,ADDRESSING_MODE (GENERAL)),
	PLIT   = z$debug_plit (READ,WRITE,NOEXECUTE,NOSHARE,PIC,CONCATENATE,
			ALIGN(3)),	!,ADDRESSING_MODE (GENERAL)),
	OWN    = z$debug_data (READ,WRITE,NOEXECUTE,NOSHARE,PIC,CONCATENATE,
			ALIGN(3)),	!,ADDRESSING_MODE (GENERAL)),
	GLOBAL = z$debug_global (READ,WRITE,NOEXECUTE,NOSHARE,PIC,CONCATENATE,
			ALIGN(3)),	!,ADDRESSING_MODE (GENERAL));
	LINK = z$debug_link (READ,WRITE,NOEXECUTE,NOSHARE,PIC,CONCATENATE,
			ALIGN(4));	!,ADDRESSING_MODE (GENERAL));
%fi
!
! Module-wide literals (which needed to be defined here instead of the
! SDL file) and BIND declarations
!
LITERAL
	asn_string_size = %CHARCOUNT(asn_string),
	asten_string_size = %CHARCOUNT(asten_string),
	astsr_string_size = %CHARCOUNT(astsr_string),
	datfx_string_size = %CHARCOUNT(datfx_string),
	esp_string_size = %CHARCOUNT(esp_string),
	fen_string_size = %CHARCOUNT(fen_string),
	ipir_string_size = %CHARCOUNT(ipir_string),
	ipl_string_size = %CHARCOUNT(ipl_string),
	mces_string_size = %CHARCOUNT(mces_string),
	pcbb_string_size = %CHARCOUNT(pcbb_string),
!	perfmon_string_size = %CHARCOUNT(perfmon_string),
	prbr_string_size = %CHARCOUNT(prbr_string),
	ptbr_string_size = %CHARCOUNT(ptbr_string),
	rscc_string_size = %CHARCOUNT(rscc_string),
	scbb_string_size = %CHARCOUNT(scbb_string),
	sirr_string_size = %CHARCOUNT(sirr_string),
	sisr_string_size = %CHARCOUNT(sisr_string),
	ssp_string_size = %CHARCOUNT(ssp_string),
	tbchk_string_size = %CHARCOUNT(tbchk_string),
	tbia_string_size = %CHARCOUNT(tbia_string),
	tbiap_string_size = %CHARCOUNT(tbiap_string),
	tbis_string_size = %CHARCOUNT(tbis_string),
	tbisd_string_size = %CHARCOUNT(tbisd_string),
	tbisi_string_size = %CHARCOUNT(tbisi_string),
	usp_string_size = %CHARCOUNT(usp_string),
	vptbase_string_size = %CHARCOUNT(vptbase_string),
	whami_string_size = %CHARCOUNT(whami_string),
!
	imgsym_msg_len = %CHARCOUNT(imgsym_msg),
	imgflg_msg_len = %CHARCOUNT(imgflg_msg),
	imgres_msg_len = %CHARCOUNT(imgres_msg),
	imgdat_msg_len = %CHARCOUNT(imgdat_msg),
	imgmoff_msg_len = %CHARCOUNT(imgmoff_msg),
	imgseq_msg_len = %CHARCOUNT(imgseq_msg),
	imgnam_msg_len = %CHARCOUNT(imgnam_msg),
	imgbas_msg_len = %CHARCOUNT(imgbas_msg),
	imgend_msg_len = %CHARCOUNT(imgend_msg),
	imgoff_msg_len = %CHARCOUNT(imgoff_msg),
	imgadd_msg_len = %CHARCOUNT(imgadd_msg);
!
BIND
!
! In XDELTA only, we have predefined XDELTA command strings stashed away
! in the X14 and X15 X-registers to display the PFN database for PFNs stored
! in X0 and R0 respectively. This is done via X14;E or X15;E commands. The
! following addresses are what is stored in X14 and X15.
!
	%if xdelta %then
	  xds$gt_pfn_r0 = UPLIT(BYTE(
		cr,%c'\',cr,lf,%c'\',cr,	!Display <CR><LF>
		%string('R0[L/Q,0;X'),		!Set X0 = PFN from R0
		cr,%c'\',cr,lf,%c'\',cr,	!Display <CR><LF>
		%string('\ PFN DATA\'),cr,	!Display " PFN DATA"
		%string('[LX0='),		!Display PFN from X0
		%string('X0*20+X13+8[L/'),	!Display state/type data
		%string('X0*20+X13+18/'),	!Display refcount
		%string('X0*20+X13+4/'),	!Display BLINK/WSLX
		%string('X0*20+X13/'),		!Display FLINK/SHRCNT
		%string('X0*20+X13+C/'),	!Display PTE pointer
		%string('X0*20+X13+10[Q/'),	!Display backup address
		%string('X0*20+X13+1C[W/'),	!Display swap page
		%string('[L'),			!Reset to LONG display mode
		%c'\',cr,lf,%c'\',cr,		!Display final <CR><LF>
		0				!The Terminator
			)),
	  xds$gt_pfn_x0 = UPLIT(BYTE(
		cr,%c'\',cr,lf,%c'\',cr,	!Display <CR><LF>
		%string('\ PFN DATA\'),cr,	!Display " PFN DATA"
		%string('[LX0='),		!Display PFN from X0
		%string('X0*20+X13+8[L/'),	!Display state/type data
		%string('X0*20+X13+18/'),	!Display refcount
		%string('X0*20+X13+4/'),	!Display BLINK/WSLX
		%string('X0*20+X13/'),		!Display FLINK/SHRCNT
		%string('X0*20+X13+C/'),	!Display PTE pointer
		%string('X0*20+X13+10[Q/'),	!Display backup address
		%string('X0*20+X13+1C[W/'),	!Display swap page
		%string('[L'),			!Reset to LONG display mode
		cr,%c'\',cr,lf,%c'\',cr,	!Display final <CR><LF>
		0				!The Terminator
			)),
	%fi
!
! The following addresses are those of IPR name strings
!
	asn_string_adr = UPLIT(BYTE(asn_string)),
	asten_string_adr = UPLIT(BYTE(asten_string)),
	astsr_string_adr = UPLIT(BYTE(astsr_string)),
	datfx_string_adr = UPLIT(BYTE(datfx_string)),
	esp_string_adr = UPLIT(BYTE(esp_string)),
	fen_string_adr = UPLIT(BYTE(fen_string)),
	ipir_string_adr = UPLIT(BYTE(ipir_string)),
	ipl_string_adr = UPLIT(BYTE(ipl_string)),
	mces_string_adr = UPLIT(BYTE(mces_string)),
!	perfmon_string_adr = UPLIT(BYTE(perfmon_string)),
	pcbb_string_adr = UPLIT(BYTE(pcbb_string)),
	prbr_string_adr = UPLIT(BYTE(prbr_string)),
	ptbr_string_adr = UPLIT(BYTE(ptbr_string)),
	rscc_string_adr = UPLIT(BYTE(rscc_string)),
	scbb_string_adr = UPLIT(BYTE(scbb_string)),
	sirr_string_adr = UPLIT(BYTE(sirr_string)),
	sisr_string_adr = UPLIT(BYTE(sisr_string)),
	ssp_string_adr = UPLIT(BYTE(ssp_string)),
	tbchk_string_adr = UPLIT(BYTE(tbchk_string)),
	tbia_string_adr = UPLIT(BYTE(tbia_string)),
	tbiap_string_adr = UPLIT(BYTE(tbiap_string)),
	tbis_string_adr = UPLIT(BYTE(tbis_string)),
	tbisd_string_adr = UPLIT(BYTE(tbisd_string)),
	tbisi_string_adr = UPLIT(BYTE(tbisi_string)),
	usp_string_adr = UPLIT(BYTE(usp_string)),
	vptbase_string_adr = UPLIT(BYTE(vptbase_string)),
	whami_string_adr = UPLIT(BYTE(whami_string)),
!
! These few are DELTA only
!
	%if delta %then
	  imgsym_message = UPLIT(BYTE(imgsym_msg)),
	  imgflg_message = UPLIT(BYTE(imgflg_msg)),
	  imgres_message = UPLIT(BYTE(imgres_msg)),
	  imgdat_message = UPLIT(BYTE(imgdat_msg)),
	  imgmoff_message = UPLIT(BYTE(imgmoff_msg)),
	%fi
!
	imgseq_message = UPLIT(BYTE(imgseq_msg)),
	imgnam_message = UPLIT(BYTE(imgnam_msg)),
	imgbas_message = UPLIT(BYTE(imgbas_msg)),
	imgend_message = UPLIT(BYTE(imgend_msg)),
	imgoff_message = UPLIT(BYTE(imgoff_msg)),
	imgadd_message = UPLIT(BYTE(imgadd_msg));
!
! Table of contents:
!
FORWARD ROUTINE
	command_scanner,		!The primary command scanner
	secondary_scanner,		!For ";" this and that commands
!
! Display utility routines
!
	put_char,			!Display a character
	put_string,			!Display a string
	new_line,			!Force new line with <CR><LF>
	put_hex,			!Display hex number as a string
	put_dec,			!Display decimal number as a string
	put_ascii,			!Display ascii with some unprintables
	put_next_adr,			!Display next address
	put_address,			!Display something as an address
	put_location,			!Display and update current location
	put_quan,			!Display contents of accumulator
	put_pc,				!Display current PC and instruction
	put_instruction,		!Display current location as instruction
	put_preg,			!Display processor register name
%IF 0 %THEN
	find_imgnam,			!Find image name/size in buffer
	put_exec_images,		!Display exec loadable images
	locate_address,			!Display location of address
%FI
	bpt_message,			!Display breakpoint message
	step_over_message,		!Display step-over message
	single_step_message,		!Display single-step message
!
! Input utility routines
!
	flush_input,			!Flush the input buffer
	get_char,			!Get next input character
	fill_input_buffer,		!Get terminated input string
	peek_char,			!Look ahead in the input buffer
	get_register,			!Get register number from input stream
	get_fp_register,		!Get FP register from input stream
	get_preg,			!Get processor register from input
!
! Format conversion routines (currently unused)
!
!	cvt_hex,			!Convert hex value into string
!	cvt_dec,			!Convert decimal value into string
!
! Miscellaneous processing routines
!
	cmd_reset,			!Reset input scanner at command end
	input_reset,			!Reset input scanner to initial state
	internal_error,			!Error processing
	end_expression,			!Terminate current expression
	end_field,			!Terminate current field
	next_dot,			!Increment "current" location
	previous_dot,			!Decrement "current" location
	fetch_preg,			!Fetch contents of processor register
	fetch_current,			!Fetch contents of current location
	xdt$check_address,		!Check accessability of address
	store_preg,			!Store data in processor register
	store_current,			!Store data in current location
	open_location,			!Open and display location contents
	close_location,			!Close a location
	set_display_mode,		!Set the prevailing display mode
%IF 0 %THEN
	validate_queue,			!Process validate queue command
	analyze_queue,			!Analyze a queue structure
	execute_bugcheck: NOVALUE,	!Execute a fatal BUGCHECK
%FI
!
! DELTA-only initialization and utility routines
!
%if delta %then
!
	xdt$start,			!Init. routine for DELTA
	delta_handler,			!Condition handler for DELTA scanner
	xdt$delta_bpt,			!Delta-specific breakpoint handler
	xdt$delta_oops,			!After a last-chance exception occurs
	xdt$delta_exit,			!After exit handler's been invoked
	set_kernel_exceptions,		!Setup kernel mode exception vectors
	set_exec_exceptions,		!Setup exec and super exception vectors
	set_rundown,			!Setup process rundown handlers
	reset_kernel_exceptions,	!Reset kernel mode exception vectors
	reset_exec_exceptions,		!Reset exec and super exception vectors
	loosen_protection,		!Make pages user-writeable
	set_protection,			!Kernel routine to set page protection
	reset_protection,		!Reset page protection
	get_loadable_images,		!Make local copy of loadable image DB
	put_shareable_images,		!Display shareable image information
	locate_process_address,		!Display location of process address
	poke_other_process,		!Examine/deposit in another process
	other_process,			!Kernel mode routine to invoke exec code
%else
!
! XDELTA-only initialization and utility routines
!
	xdt$sysdbg_init,		!Exec init. routine for XDELTA
	xdt$init,			!Init. routine for XDELTA
	xdt$xdelta_bpt,			!XDELTA breakpoint handler
	xdt$owner_check,		!Check for XDELTA ownership
	xdelta_save_state,		!XDELTA save state routine
	xdelta_restore_state,		!XDELTA restore state routine
	switch_scb,			!Switch to XDELTA SCB
	xdt$cpu_wait,			!Wait for XDELTA CPU interlock
	unlock_xdelta,			!Release XDELTA lock
	virtual_console,		!Primary CPU virtual console handler
	virtual_putchar,		!Write a character to virtual console
	virtual_getchar,		!Read a character from virtual console
	xdelta_handler,			!The Dan Quayle of condition handlers
%fi
!
! Breakpoint-related routines
!
	single_step,			!Execute a single-step operation
	clear_single_step,		!Remove a single-step temporary BPT
	step_over,			!Execute a step-over operation
	clear_step_over,		!Remove a step-over temporary BPT
	add_bpt,			!Add breakpoint
	show_bpt,			!Show breakpoints
	set_bpt,			!Set breakpoint
	delete_bpt,			!Delete breakpoints
	find_bpt,			!Find breakpoint index (if any)
	proceed_from_bpt,		!Proceed from a breakpoint
	break_point,			!Breakpoint handler
!
! X-register manipulation routines
!
	add_xreg,			!Add X-register
	find_xreg,			!Best match X-register with address
	show_xreg;			!Show X-registers

!
! External data references:
!
EXTERNAL LITERAL
	bug$_debugcrash: WEAK;		!BUGCHECK error code
EXTERNAL
!
! The following external data references are common to both XDELTA and DELTA
!
	mmg$gl_va_to_vpn: 		!Bits to shift to extract VPN from VA
	  SIGNED LONG,			!
	ldr$gq_image_list:		!Loadable image list head
	  VECTOR[,LONG,SIGNED] WEAK,	!
!
! The following external data references apply to DELTA only.
!
%if delta %then
	exe$gl_ldr_seq: WEAK LONG,	!System loadable image sequence #
	exe$gl_ldr_cnt: WEAK LONG,	!System count of loadable images
	ctl$gl_imglstptr:		!IMCB list head pointer
	  LONG SIGNED WEAK
!
! The following external data references apply to XDELTA only. Note that
! some are declared as WEAK. This allows XDELTA to be built and run in
! environments where all of VMS need not be present.
!
%else
	xdt$gl_scb: LONG SIGNED,	!Private SCB page
	exe$gl_scb: LONG SIGNED,	!System control block address
	exe$gl_time_control: LONG WEAK,	!Timeout control flags
!	exe$m_nosmpsanity: WEAK,	!No SMP sanity (as if it needs it)
!	exe$m_nospinwait: WEAK,		!No spin cycle for my delicate fabrics
	exe$gl_state: BLOCK[,BYTE] WEAK,!Bootstrap state flags

	mmg$gl_sptbase:			!System page table base address
	  lrefblockvector[,quad_size,BYTE],

	smp$gl_primid: LONG WEAK,	!CPU ID of primary CPU
	smp$gl_cpuconf: LONG WEAK,	!Mask of CPUs in the active set

	sch$gl_pcbvec: LONG WEAK,	!PCB vector

	pfn$pl_database: LONG SIGNED WEAK, !PFN database pointer

	xdt$gl_owner_id:		!Current XDELTA owner on SMP system
	  LONG SIGNED VOLATILE WEAK,	!
	xdt$gl_interlock:		!XDELTA ownership interlock on SMP
	  LONG VOLATILE WEAK,		! system
	xdt$gl_benign_cpus:		!Mask of benign CPUs on SMP system
	  BITVECTOR VOLATILE WEAK,	!

	xdt$bpt_lp,			!Linkage ptr for assembly code
	xdt$iregsav,			!Integer register save area address
	xdt$fregsav,			!FP register save area address
	xdt$bpt,			!BPT ISR, written in assembly language
	xdt$ipl14_handler;		!IPL 14 ISR
%fi ;
!
! Module-wide data. Note that for the invokation of DELTA, the debug vector
! must be the first thing in the image. SYS$IMGSTA assumes it's the first
! thing in the DEBUG global section in order to transfer control to it.
! The vector consists of 3 elements: the start of the impure storage area,
! the end of impure storage, and the transfer address of DELTA.
!
OWN
	%if delta %then
	  debug_vector: VECTOR[6,LONG]		!The transfer vector
	    INITIAL(LONG(
		0,0,0,0,
		xdt$start,0)),			!Start transfer address
	%else
	  rcv_ie: LONG VOLATILE			!Receive interrupt enable
	    INITIAL(LONG(0)),
	  rcv_ready: LONG VOLATILE		!Receive ready
	    INITIAL(LONG(0)),
	  rcv_data: LONG VOLATILE		!Receive data buffer
	    INITIAL(LONG(0)),
	  tmit_ie: LONG VOLATILE		!Transmit interrupt enable
	    INITIAL(LONG(0)),
	  tmit_ready: LONG VOLATILE		!Transmit ready
	    INITIAL(LONG(0)),
	  tmit_data: LONG VOLATILE		!Transmit data buffer
	    INITIAL(LONG(0)),
	  xfer_address: INITIAL(0),		!Exec transfer code address
	%fi
!
! Miscellaneous storage items. Note that DELTA, with its external interfaces,
! has dependencies on the 32-bit calling standard
!
	init_flag: INITIAL(0),			!Once is enough for some things
	temp_data,				!For test fetches
	%if delta %then
	  ttchan: INITIAL(0),			!Channel to SYS$OUTPUT
	  ttname: WORD				!Output device name
	    INITIAL(BYTE(%STRING('TT'))),	!
	  tt_desc: VECTOR[2,LONG]		!Output device name descriptor
	    INITIAL(LONG(2,ttname)),		!
	  dbgname: VECTOR[9,BYTE]		!Output device name
	    INITIAL(BYTE(%STRING('DBG$DELTA'))),!
	  dbg_desc: VECTOR[2,LONG]		!Output device name descriptor
	    INITIAL(LONG(9,dbgname)),		!
	  devname: VECTOR[devnam_size,BYTE],	!Output device name
	  dev_desc: VECTOR[2,LONG]		!Output device name descriptor
	    INITIAL(LONG(devnam_size,devname)),	!
	  exit_status: LONG INITIAL(LONG(1)),	!Image exit status
	  exit_block: VECTOR[4,LONG]		!Exit handler block
	    INITIAL(LONG(
		0,				!Reserved
		0,				!Exit handler PD address
		1,				!Number of arguments
		exit_status)),			!The image exit status
	  kernel_primary: SIGNED INITIAL(-1),	!Kernel primary handler
	  exec_primary: SIGNED INITIAL(-1),	!Exec mode primary handler
	  super_primary: SIGNED INITIAL(-1),	!Supervisor primary handler
	  kernel_last_chance: SIGNED INITIAL(-1),!Kernel last chance handler
	  exec_last_chance: SIGNED INITIAL(-1),	!Exec last chance handler
	  super_last_chance: SIGNED INITIAL(-1),!Supervisor last chance handler
	  iosb: VECTOR[4,WORD],			!I/O status block (32-bit form)
	  term_mask: VECTOR[4,LONG]		!Read termination mask
	    INITIAL(LONG(
	      %X'8002600',			!TAB, LF, CR, ESC
	      %X'20008006',			!"!", """, "/", "="
	      %X'10088000',			!"O", "S", "\"
	      %X'88000'				!"o", "s"
		)),
	  item_list: VECTOR[item_list_size,LONG]!The READ item list
	    INITIAL(LONG(
	      (trm$_modifiers^16) + 0,		!Read modifier descriptor
	      trm$m_tm_noedit,			!No advanced editing allowed
	      0,				!That's one descriptor
	      (trm$_term^16) + term_mask_size,	!Termination mask descriptor
	      0,				!Mask address (set at runtime)
	      0					!That's two descriptors
		)),
	  ldr_image_head: VECTOR[2,LONG]	!Exec loadable image queue head
	    INITIAL(LONG(ldr_image_head,ldr_image_head)), !for local DELTA copy
	  ldr_seq: INITIAL(0),			!Sequence number for loadables
	  ldr_cnt: INITIAL(0),			!Count of loadable images
	  ldr_size: INITIAL(0),			!Allocated buffer size
	  ast_counter,				!Used for matching requests
	%fi
!
! Mode context - one for each processor mode (which means one for XDELTA
! and four for DELTA)
!
	%if delta %then
	  mode_context: BLOCKVECTOR[4,mctx$k_block_size,BYTE]
	    INITIAL(BYTE(REP (4 * mctx$k_block_size) OF (0)))
	%else
	  mode_context: BLOCK[mctx$k_block_size,BYTE]
	    INITIAL(BYTE(REP (mctx$k_block_size) OF (0)))
	%fi ,
!
! Let's not forget those X registers, initialized to zeroes for DELTA
! but with all kinds of interesting things for XDELTA
!
	xregs: VECTOR[num_x]			!X register array
	  INITIAL(				!
	    %if delta %then			!For DELTA
		REP (num_x) OF (0)		!A bunch of zeroes
	    %else				!For XDELTA
		0,0,0,0,			!X0, X1, X2, X3
		0,				!X4 = CPU database of current
		sch$gl_pcbvec,			!X5 = Base of PCB vector
		0,				!X6 = Swap page (obsolete)
		0,				!X7 = PTE back pointer (ditto)
		0,				!X8 = Backup address (obsolete)
		0,				!X9 = Reference count (obsolete)
		0,				!X10 = Forward link (obsolete)
		0,				!X11 = Backward link (obsolete)
		0,				!X12 = Page state (obsolete)
		0,				!X13 = PFN database pointer
		0,				!X14 = X14;E cmd string
		0				!X15 = X15;E cmd string
	    %fi ),
	xreg_extents: VECTOR[num_x,LONG]	!X register extent array
	  INITIAL(LONG(				!All initialized with
	  REP (num_x) OF (def_xreg_extent)	!800 hex by default
	  )),
!
! The XDELTA SCB and saved address of the "real" SCB. Note that the SCB
! has to be page-aligned. At compile time, we don't know the target machine
! page size. So we use the worst case page size. Currently, the compiler
! supports a maximum of 512-byte page alignment.
!
%if xdelta %then
	saved_scb,				!The saved SCB address
	physical_scb: SIGNED INITIAL(-1),	!Physical address of XDELTA SCB
!
! The following so-called SCB error codes are what gets stuffed into the
! SCB parameter field for each SCB entry when it is initialized. These codes
! are passed by PAL code to the interrupt service routine in R3 and will be
! the error return codes for the routines which encounter some unexpected
! exception during execution. We should never see most of these since interrupts
! are blocked during XDELTA execution. Currently, these do not propagate back
! to the user but are merely a means of tracking down unusual XDELTA problems.
!
	scb_errors: VECTOR[scb_entries]		!SCB parameter table
	  INITIAL(				!with exception reason codes
!
! 0000 - 00f0
!
	    ss$_abort,				!Unused SCB entry
	    ss$_fltdiv,				!Floating point disabled
	    REP (6) OF (ss$_abort),		!Unused (0020 - 0070)
	    ss$_accvio,				!Access violation
	    REP (4) OF (ss$_radrmod),		!TNV, FOR, FOW, and FOE
	    REP (3) OF (ss$_abort),		!Unused (00d0 - 00f0)
!
! 0100 - 01f0
!
	    REP (16) OF (ss$_abort),		!Unused (0100 - 01f0)
!
! 0200 - 02f0
!
	    ss$_artres,				!Arithmetic trap
	    REP (3) OF (ss$_abort),		!Unused (0210 - 0230)
	    REP (4) OF (ss$_astflt),		!KESU ASTs
	    REP (8) OF (ss$_abort),		!Unused (0280 - 02f0)
!
! 0300 - 03f0
!
	    REP (16) OF (ss$_bufnotalign),	!All alignment faults
!
! 0400 - 04f0
!
	    ss$_break,				!Hope I never see this one!
	    ss$_bugcheck,			!Bugcheck
	    ss$_opcdec,				!Illegal instruction
	    ss$_opcdec,				!Illegal CALL_PAL
	    REP (3) OF (ss$_abort),		!Unused (0440 - 0460)
	    ss$_abort,				!Reserved (0470)
	    ss$_cmodsupr,			!Change mode to kernel
	    ss$_cmodsupr,			!Change mode to executive
	    ss$_cmodsupr,			!Change mode to supervisor
	    ss$_cmoduser,			!Change mode to user
	    REP (4) OF (ss$_abort),		!Reserved (04c0 - 04f0)
!
! 0500 - 05f0
!
	    ss$_abort,				!Unused (0500)
	    REP (15) OF (ss$_ivssrq),		!Software int levels 1-15
!
! 0600 - 06f0
!
	    ss$_timeout,			!Interval clock interrupt
	    ss$_nosuchcpu,			!IP interrupt
	    ss$_ctrlerr,			!System cur. error interrupt
	    ss$_ctrlerr,			!Processor cur. error interrupt
	    ss$_powerfail,			!Powerfail interrupt
	    ss$_abort,				!Unused (0650)
	    ss$_mcheck,				!System machine check abort
	    ss$_mcheck,				!Processor machine check abort
	    REP (4) OF (ss$_abort),		!Reserved (0680 - 06b0)
	    REP (4) OF (ss$_abort),		!Unused (06c0 - 06f0)
!
! 0700 - 07f0
!
	    REP (16) OF (ss$_abort),		!Unused (0700 - 07f0)
!
! 0800 - 1ff0
!
	    REP (384) OF (ss$_nosuchdev)	!Device I/O interrupt slots
	  ),
%fi
!
! Breakpoint data structures. We have a number of permanent breakpoints,
! temporaries used for step-overs, and temporaries used for single-step.
! Each breakpoint type is unique and does not interfere with any of the
! others (although both temporaries share the same data structure definition).
! There are a fixed number of permanent breakpoints which span all the
! processor modes and IPLs. For step-overs, we want one for each processor
! mode in DELTA and one for each IPL in XDELTA. To avoid complication, we'll
! waste a little memory on the DELTA side and have more entries than we need.
! For single-step temporaries, we want two for each processor mode in DELTA
! and two for each IPL in XDELTA. Again, we'll waste a little memory on the
! DELTA side. The reason for having two temporaries for single-step is because
! a branch instruction (of any type) can have two possible destinations and
! we want to trap at both of them. You need one for each IPL (or mode) since
! a higher IPL (or inner mode) can interrupt activity at a lower IPL (or
! outer mode). You'll want new temporaries at the new IPL or mode so as not
! to trash the ones at the lower IPL or outer mode. When you eventually finish
! working, you'll return back to the original thread and trap at the "next"
! instruction.
!
	perm_bpts: BLOCKVECTOR[1 + num_perm_bpts,pbpt$k_block_size,BYTE],
	step_overs: BLOCKVECTOR[num_sos,tbpt$k_block_size,BYTE],
	temp_bpts: BLOCKVECTOR[num_tmp_bpts,tbpt$k_block_size,BYTE];
!
! External routines
!
EXTERNAL ROUTINE
!
! First, those specific to DELTA only
!
%if delta %then
	img$add_privileged_vector_entry: WEAK,!Add process rundown handlers
	lib$get_vm: WEAK,		!Allocate VM
	lib$free_vm: WEAK,		!Free VM
	exe$read_process: WEAK,		!Read target process memory
	exe$write_process: WEAK,	!Write target process memory
	xdt$delta_exception,		!Primary condition handler for DELTA
	xdt$delta_catchall,		!Last chance condition handler for DELTA
	xdt$exit_handler,		!Image exit handler for DELTA
%else
!
! Next, those for XDELTA only
!
	smp$intall_bit_acq:		!Acquire mutex and interrupt all CPUs
	  lnk_smp$intall_bit_acq WEAK,	!
!	mmg$tbia_simple:		!Simple TB invalidate all
!	  lnk_mmg$tbia_simple WEAK,	!
	ini$writable: 			!Make system writeable
	  lnk_ini$writable WEAK,	!
	ini$rdonly: 			!Restore system protection
	  lnk_ini$rdonly WEAK,		!
	ini$brk: WEAK,			!Initial breakpoint
	con$save_cty,			!Save console terminal state
	con$restore_cty,		!Restore console state
	con$putchar,			!Print a character on the console
	con$getchar,			!Retrieve a console input character
	xdt$exception,			!Code address of exception handler
%fi
!
! Lastly, those that apply to both XDELTA and DELTA
!
	lib$ins_decode;			!EVAX instruction disassembly
!
! DELTA needs markers for the beginning and end of the code PSECT to find
! its boundaries, providing the ability to make the code writable and
! resident for debugging when necessary.
!
%if delta %then
PSECT
	NODEFAULT = z$debug_aaaa (READ,WRITE,EXECUTE,NOSHARE,PIC,CONCATENATE,
			ALIGN(2));	!,ADDRESSING_MODE (GENERAL)),
OWN
	code_start_marker : PSECT(z$debug_aaaa);
PSECT
	NODEFAULT = z$debug_zzzz (READ,WRITE,EXECUTE,NOSHARE,PIC,CONCATENATE,
			ALIGN(2));	!,ADDRESSING_MODE (GENERAL)),
OWN
	code_end_marker : PSECT(z$debug_zzzz);
%fi


ROUTINE command_scanner(
!++
! Functional description:
!
!	This routine is the primary command scanner for XDELTA/DELTA. It
! parses user input and either invokes the appropriate command handler
! functions or issues exceptionally informative error messages. While in
! the debugger's control, most time is spent in this main loop.
!	One thing worth explaining to better understand the processing in
! the main loop is the use of certain state variables in the context block:
!
! val - Temporarily holds a number of things, including the current location,
!	pointer to the register save area for a GPR, X-register contents, etc.
!	It also acts as an accumulator while parsing numeric sequences. Val
!	most often becomes part of an expression (see below) and then one of
!	the input fields of a command.
!
! expression - An accumulator for the current expression being evaluated. Val's
!	along with operations like "+", "-", "*", "%", and "@" are evaluated
!	into the current expression. Expressions usually become input fields
!	when the current field is terminated.
!
! fld[x] - Input fields for a command, where x goes from 0 to (num_fields-1).
!
! gh_prefix - Either zero or the S0 space or P1 space address bases.
!
! dot - Always points to the "current" location
!
! quan - Always points to the "current" quantity or value of "Q", the most
!	recently displayed value.
!
! Formal parameters:
!
	ctx: REF BLOCK[0,BYTE]		!Ptr to mode context block
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

LITERAL
	max_buf_count = 80;			!Max size of temp buffer
!
! We will now bind symbols to various fields within the context block.
! All such fields are the same size but may be either 32 or 64 bits,
! depending on the defaults of the compiler used (this allows us to get
! away with using the existing SDL and either 32-bit or 64-bit compilers).
!
BIND
	val = ctx[mctx$q_val] : SIGNED,		!The current value
	expression = ctx[mctx$q_expression],	!Current expression value
	gh_prefix = ctx[mctx$q_gh_prefix],	!G/H prefix value
	dot = ctx[mctx$q_dot],			!Current location
	quan = ctx[mctx$q_quan],		!Current quantity
	iregbuf = ctx[mctx$q_iregbuf],		!GPR save area address
	fregbuf = ctx[mctx$q_fregbuf];		!FP register save area address
LOCAL
	regnum,					!Register number
	next_char: INITIAL(0),			!Next input character
	local_buf: VECTOR[max_buf_count,BYTE],	!Temporary input string buffer
	local_buf_count,			!Count of bytes in string
	status;					!Return status code
!
! Now loop until done scanning commands, retrieving one character at
! a time. Certain commands cause scanner_done to become true and kick us
! out of the loop.
!
	cmd_reset(.ctx);
	ctx[mctx$v_scanner_done] = 0;
 	WHILE NOT .ctx[mctx$v_scanner_done] DO
	  BEGIN
	    IF NOT get_char(.ctx,next_char) THEN
	      input_reset(.ctx)
	    ELSE
!
! Based on this particular character (and the current state), do the
! appropriate thing
!
	    SELECTONE .next_char OF
	      SET
!
! For numerics, add them to the VAL accumulator
!
		[%C'0' TO %C'9'] :
		  BEGIN
		    val = (.val ^ 4) + (.next_char - %C'0');
		    ctx[mctx$v_infield] = 1;
		  END;
!
! For "hex" numerics (except for "E" and "F" - See below), just add them to
! the VAL accumulator
!
		[%C'A' TO %C'D'] :
		  BEGIN
		    val = (.val ^ 4) + (.next_char - %C'A' + 10);
		    ctx[mctx$v_infield] = 1;
		  END;
!
! An "E" is treated like any other hex digit in XDELTA, but in DELTA
! we have to check for the start of the "EXIT" command. If the "E" is
! followed by an "X", that's what we assume. Otherwise, it's an ordinary
! hex digit.
!
		[%C'E'] :
		  %if delta %then
		    BEGIN
		      IF NOT peek_char(.ctx,0,next_char) THEN
		        BEGIN
			  internal_error(.ctx,0);
			  input_reset(.ctx);
		        END
		      ELSE
		        IF .next_char EQL %C'X' THEN
			  BEGIN
			    get_char(.ctx,next_char);
			    $exit(code = ss$_normal);
			  END;
		      val = (.val ^ 4) + (%C'E' - %C'A' + 10);
		      ctx[mctx$v_infield] = 1;
		    END;
		%else
		  BEGIN
		    val = (.val ^ 4) + (.next_char - %C'A' + 10);
		    ctx[mctx$v_infield] = 1;
		  END;
		%fi
!
! The "F" character might be just a plain ol' hex digit. It might also
! be the beginning of a floating point register specifier. If it's just
! a hex digit, it's handled the same as above. If it looks like an FP
! register, it has to be a valid register number and floating point has
! to be currently enabled. Otherwise, it's an error.
!
		[%C'F'] :
		  BEGIN
		    IF NOT get_fp_register(10,.ctx,regnum) THEN
		      BEGIN
			val = (.val ^ 4) + (%C'F' - %C'A' + 10);
			ctx[mctx$v_infield] = 1;
		      END
		    ELSE
		      IF NOT .ctx[mctx$v_fen] THEN
			internal_error(.ctx,ss$_opcdec)
		      ELSE
			IF .regnum GTR num_gprs THEN
			  internal_error(.ctx,ss$_badparam)
			ELSE
			  BEGIN
			    val = .fregbuf + (quad_size * .regnum);
			    ctx[mctx$v_infield] = 1;
			  END;
		  END;
!
! The "." specifies the current location. Note that we special case when
! scanning processor registers which require access via PAL calls.
!
		[%C'.'] :
		  BEGIN
		    val = .dot;
		    ctx[mctx$v_infield] = 1;
		    IF .ctx[mctx$v_preg] THEN
		      ctx[mctx$v_prmode] = 1;
		  END;
!
! A "Q" signifies the last quantity
!
		[%C'Q'] :
		  BEGIN
		    val = .quan;
		    ctx[mctx$v_infield] = 1;
		  END;
!
! An "R" signifies a register to be retrieved. Note that registers are
! saved as full quadwords and here we save a pointer to the register save
! area for this particular register.
!
		[%C'R'] :
		  BEGIN
		    IF NOT (status = get_register(10,.ctx,regnum)) THEN
		      internal_error(.ctx,.status)
		    ELSE
		      IF .regnum GEQ num_gprs THEN
		        internal_error(.ctx,ss$_badparam)
		      ELSE
		        BEGIN
			  val = .iregbuf + (quad_size * .regnum);
			  ctx[mctx$v_infield] = 1;
		        END;
		  END;
!
! An "X" signifies an X-register whose contents we must retrieve
!
		[%C'X'] :
		  BEGIN
		    IF NOT (status = get_register(10,.ctx,regnum)) THEN
		      internal_error(.ctx,.status)
		    ELSE
		      IF .regnum GEQ num_x THEN
		        internal_error(.ctx,ss$_badparam)
		      ELSE
		        BEGIN
			  val = .xregs[.regnum];
			  ctx[mctx$v_infield] = 1;
		        END;
		  END;
!
! A "G" signifies the system space address prefix. Note that we play a little
! game to get either a signed 32-bit or 64-bit address.
!
		[%C'G'] :
		  BEGIN
		    gh_prefix = NOT not_g_prefix;
		    ctx[mctx$v_prefix_flag] = 1;
		    ctx[mctx$v_infield] = 1;
		  END;
!
! An "H" signifies the P1 space address prefix
!
		[%C'H'] :
		  BEGIN
		    gh_prefix = h_prefix;
		    ctx[mctx$v_prefix_flag] = 1;
		    ctx[mctx$v_infield] = 1;
		  END;
!
! A "," signifies the end of the current field
!
		[%C','] :
		  BEGIN
		    ctx[mctx$v_infield] = 1;
		    IF NOT (status = end_field(.ctx)) THEN
		      internal_error(.ctx,.status);
		  END;
!
! A "+" or space signifies the termination of the current expression and
! an add operation
!
		[%C'+',%C' '] :
		  BEGIN
		    end_expression(.ctx);
		    ctx[mctx$l_operator] = opr$k_add;
		  END;
!
! An "@" signifies the termination of the current expression and
! a shift operation
!
		[%C'@'] :
		  BEGIN
		    end_expression(.ctx);
		    ctx[mctx$l_operator] = opr$k_shift;
		  END;
!
! A "*" signifies the termination of the current expression and
! a multiply operation
!
		[%C'*'] :
		  BEGIN
		    end_expression(.ctx);
		    ctx[mctx$l_operator] = opr$k_multiply;
		  END;
!
! A "%" signifies the termination of the current expression and
! a division operation
!
		[%C'%'] :
		  BEGIN
		    end_expression(.ctx);
		    ctx[mctx$l_operator] = opr$k_divide;
		  END;
!
! A "-" signifies the termination of the current expression (if we have
! a current value or prefix) and a negate operation
!
		[%C'-'] :
		  BEGIN
		    IF (.val NEQ 0) OR (.gh_prefix NEQ 0) THEN
		      end_expression(.ctx);
		    ctx[mctx$v_negate] = 1;
		  END;
!
! A <CR> closes the current location and begins a new line.
!
		[cr] :
		  BEGIN
		    IF NOT (status = close_location(.ctx)) THEN
		      internal_error(.ctx,.status);
		  END;
!
! A <LF> closes the current location, increments the current location, and
! displays the new address and contents
!
		[lf] :
		  BEGIN
		    IF NOT (status = close_location(.ctx)) THEN
		      internal_error(.ctx,.status)
		    ELSE
		      BEGIN
			next_dot(.ctx);
			put_next_adr(.ctx);
			IF NOT (status = put_location(.ctx)) THEN
			  internal_error(.ctx,.status);
		      END;
		  END;
!
! An <ESC> closes the current location, backs up the current location to
! the previous location, and displays the new address and contents
!
		[esc] :
		  BEGIN
		    IF NOT (status = close_location(.ctx)) THEN
		      internal_error(.ctx,.status)
		    ELSE
		      BEGIN
			previous_dot(.ctx);
			put_next_adr(.ctx);
			IF NOT (status = put_location(.ctx)) THEN
			  internal_error(.ctx,.status);
		      END;
		  END;
!
! A <TAB> closes the current location, makes the current quantity the
! current location, resets the processor register flag, and displays
! the new address and contents
!
		[tab] :
		  BEGIN
		    IF NOT (status = close_location(.ctx)) THEN
		      internal_error(.ctx,.status)
		    ELSE
		      BEGIN
			dot = .quan;
			ctx[mctx$v_preg] = .ctx[mctx$v_prmode];
			put_next_adr(.ctx);
			IF NOT (status = put_location(.ctx)) THEN
			  internal_error(.ctx,.status);
		      END;
		  END;
!
! A "/" resets both ascii and instruction display modes and opens the
! current location
!
		[%C'/'] :
		  BEGIN
		    ctx[mctx$v_ascii] = 0;
		    ctx[mctx$v_instruction] = 0;
		    IF NOT (status = open_location(.ctx)) THEN
		      internal_error(.ctx,.status);
		  END;
!
! A double-quote resets instruction display mode, sets ascii display mode,
! and opens the current location
!
		[%C'"'] :
		  BEGIN
		    ctx[mctx$v_ascii] = 1;
		    ctx[mctx$v_instruction] = 0;
		    IF NOT (status = open_location(.ctx)) THEN
		      internal_error(.ctx,.status);
		  END;
!
! A "!" resets ascii display mode, enables instruction display mode,
! and opens the current location
!
		[%C'!'] :
		  BEGIN
		    ctx[mctx$v_ascii] = 0;
		    ctx[mctx$v_instruction] = 1;
		    IF NOT (status = open_location(.ctx)) THEN
		      internal_error(.ctx,.status);
		  END;
!
! A "=" causes the current quantity to be displayed (any expressions will
! already have been evaluated)
!
		[%C'='] :
		  BEGIN
		    IF NOT (status = put_quan(.ctx)) THEN
		      internal_error(.ctx,.status);
		  END;
!
! A ";" closes the current location, terminates the current field, retrieves
! the next character in the input stream, and invokes the secondary command
! scanner to do the rest
!
		[%C';'] :
		  BEGIN
		    ctx[mctx$v_open] = 0;
		    IF NOT (status = end_field(.ctx)) THEN
		      internal_error(.ctx,.status);
		    IF NOT get_char(.ctx,next_char) THEN
		      input_reset(.ctx)
		    ELSE
		      IF NOT (status = secondary_scanner(
						.next_char,
						.ctx)) THEN
		        internal_error(.ctx,.status);
		  END;
!
! A "[" causes retrieval of the next character in the input stream and then
! setting the new display mode accordingly
!
		[%C'['] :
		  BEGIN
		    IF NOT get_char(.ctx,next_char) THEN
		      input_reset(.ctx)
		    ELSE
		      IF NOT (status = set_display_mode(.next_char,.ctx)) THEN
		        internal_error(.ctx,.status);
		  END;
!
! A ":" causes termination of the current expression and subsequent
! separation of PID from address specified. Note that PIDs remain 32 bits.
! So we'll take the low order 32 bits of the current expression and hope
! that it's valid.
!
		[%C':'] :
		  BEGIN
		    BIND
		      exp = ctx[mctx$q_expression] : VECTOR[2,LONG];
!
		    end_expression(.ctx);
		    ctx[mctx$l_pid] = .exp[0];
		    val = 0;
		    expression = 0;
		  END;
!
! An "O" signifies a step-over operation. So a step-over is attempted. If
! successful, we needn't do anything else. However, there are two possible
! other scenarios: an error was encountered while trying to decode the next
! instruction or the next instruction isn't a routine call (which indicates
! a normal single-step should be performed).
!
		[%C'O'] :
		  BEGIN
		    status = step_over(.ctx);
		    SELECTONE .status OF
		      SET
			[0] : internal_error(.ctx,.status);
			[1] :
			  BEGIN
			    ctx[mctx$v_scanner_done] = 1;
			    ctx[mctx$v_step_over] = 1;
			    ctx[mctx$v_do_step] = 0;
			    ctx[mctx$v_at_bpt] = 0;
			  END;
			[OTHERWISE] :
			  BEGIN
			    ctx[mctx$v_scanner_done] = 1;
			    ctx[mctx$v_do_step] = 1;
			    ctx[mctx$v_at_bpt] = 0;
			  END;
		      TES;
		  END;
!
! An "S" signifies a single-step operation
!
		[%C'S'] :
		  BEGIN
		    ctx[mctx$v_scanner_done] = 1;
		    ctx[mctx$v_do_step] = 1;
		    ctx[mctx$v_at_bpt] = 0;
		  END;
!
! A "P" signifies a processor register on the horizon (which includes PC and
! PS). I guess you could say that get_preg handles anything which follows
! a "P"...quite a distinction if you ask me.
!
		[%C'P'] :
		  IF NOT (status = get_preg(.ctx)) THEN
		    internal_error(.ctx,.status);
!
! A single quote signifies the start and end of ascii data to be deposited into
! the current location
!
		[quote] :
		  BEGIN
		    IF NOT get_char(.ctx,next_char) THEN
		      input_reset(.ctx)
		    ELSE
		      WHILE .next_char NEQ quote DO
		        BEGIN
			  BIND str = .dot : VECTOR[,BYTE];
			  str[0] = .next_char;
			  dot = .dot + 1;
			  IF NOT get_char(.ctx,next_char) THEN
			    input_reset(.ctx);
		        END;
		  END;
!
! A "\" signifies the start and end of raw ascii data to merely be displayed
! for output. This makes life easier for X14;E and X15;E processing as well
! as any user text displays for automatic breakpoints. The data is stored
! in a local buffer and then displayed using put_string, which displays any
! special characters "as is" for the (hopefully) intended formatting.
!
		[%C'\'] :
		  BEGIN
		    local_buf_count = 0;
		    IF NOT get_char(.ctx,next_char) THEN
		      input_reset(.ctx)
		    ELSE
		      BEGIN
		        WHILE (.next_char NEQ %C'\') AND
			      (.local_buf_count LSS max_buf_count) DO
		          BEGIN
			    local_buf[.local_buf_count] = .next_char;
			    local_buf_count = .local_buf_count + 1;
			    IF .local_buf_count LSS max_buf_count THEN
			      IF NOT get_char(.ctx,next_char) THEN
			        input_reset(.ctx);
		          END;
		        IF .local_buf_count GTR 0 THEN
		          put_string(.local_buf_count,local_buf);
		      END;
		  END;
!
! Otherwise, it's an error
!
		[OTHERWISE] : internal_error(.ctx,ss$_badparam);
	      TES;
	  END;
!
	RETURN ss$_normal;
END; 					! ROUTINE command_scanner


ROUTINE secondary_scanner(
!++
! Functional description:
!
!	This routine is the secondary command scanner, handling those
! commands prefixed by the ";" character. The character following the ";"
! is passed as a parameter and used to decide what to do next.
!
! Formal parameters:
!
	cmd,				!Secondary command specifier
	ctx: REF BLOCK[0,BYTE]		!Ptr to mode context block
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

BIND
	dot = ctx[mctx$q_dot],			!Current location
	quan = ctx[mctx$q_quan],		!Current quantity
	input_ptr = ctx[mctx$q_input_ptr],	!Input pointer
	iregbuf = ctx[mctx$q_iregbuf],		!Register save area address
	save_r27 = .iregbuf + (27 * quad_size),	!The saved R27
	save_pc = .iregbuf + (32 * quad_size),	!The saved PC
	fld = ctx[mctx$q_fields] : VECTOR;	!Input fields
LOCAL
	arg_list: VECTOR[2,LONG],		!$CMEXEC arglst for DELTA
	prev_prot,				!Previous page protection
	status;					!Return status value
!
! What we do depends on the input character which followed the ";" in the
! command
!
	SELECTONE .cmd OF
	  SET
!
! The ";B" command adds, clears, or displays breakpoints, depending on other
! input fields specified
!
	    [%C'B'] :
	      BEGIN
		IF .ctx[mctx$l_fflg] NEQ 0 THEN
		  BEGIN
		    IF NOT (status = add_bpt(.ctx)) THEN
		      RETURN .status;
		  END
		ELSE
		  show_bpt(.ctx);
		cmd_reset(.ctx);
	      END;
!
! The ";C" command forces a fatal bugcheck to occur, and I mean NOW.
! The instruction at the saved PC will be changed to a bugcheck. The
! bugcheck reason will be a debugger-induced fatal bugcheck. We will
! immediately leave the debugger to go execute the bugcheck. There is
! no need to retain the original instruction since there are no cases
! where we will attempt to continue execution after the bugcheck.
!
%IF 0 %THEN
	    [%C'C'] :
	      BEGIN
		IF bug$_debugcrash EQL 0 THEN
		  RETURN 0;
!
		%if delta %then
		  IF .ctx[mctx$l_index] GTR 0 THEN
		    RETURN 0;
		%fi
!
		save_r27 = execute_bugcheck;
		save_pc = .(.save_r27 + 8);
		ctx[mctx$v_scanner_done] = 1;
		ctx[mctx$v_do_step] = 0;
	      END;
%FI
!
! The ";X" command adds, clears, or displays X-registers, depending on other
! input fields specified
!
	    [%C'X'] :
	      BEGIN
		IF .ctx[mctx$l_fflg] NEQ 0 THEN
		  BEGIN
		    IF NOT (status = add_xreg(.ctx)) THEN
		      RETURN .status;
		  END
		ELSE
		  show_xreg(.ctx);
		cmd_reset(.ctx);
	      END;

!
! The ";L" command displays information on the exec loadable images
!
%IF 0 %THEN
	    [%C'L'] :
	      BEGIN
		%if delta %then
		  IF .ctx[mctx$l_index] GTR psl$c_exec THEN
		    BEGIN
		      arg_list[0] = 1;
		      arg_list[1] = .ctx;
		      IF NOT (status = $cmexec(
					ROUTIN = put_exec_images, 
					arglst = arg_list)) THEN
			RETURN .status;
		    END
		  ELSE
		    IF NOT (status = put_exec_images(.ctx)) THEN
		      RETURN .status;
		%else
		  IF NOT (status = put_exec_images(.ctx)) THEN
		    RETURN .status;
		%fi
		cmd_reset(.ctx);
	      END;
%FI
!
! The ";E" command causes execution of an XDELTA command string. The specified
! command field is the address of the command string to be used for further
! input until a terminator is found or until the input pointer is reset. Note
! that we do a quick check on the address specified to see if we at least have
! read access to the first quadword of data before blindly making it our source
! for input.
!
	    [%C'E'] :
	      BEGIN
		IF (.ctx[mctx$v_f0]) AND 
		   (xdt$check_address(.fld[0],quad_size,0)) THEN
		  BEGIN
		    input_ptr = .fld[0];
		    cmd_reset(.ctx);
		  END
		ELSE
		  input_reset(.ctx);
	      END;
!
! The ";G" command forces execution to resume at the specified PC (if any).
! If no resume PC is specified, the saved PC is used.
!
	    [%C'G'] :
	      BEGIN
		ctx[mctx$v_scanner_done] = 1;
		new_line();
		IF .ctx[mctx$v_f0] THEN
		  save_pc = .fld[0];
	      END;
!
! The ";H" command toggles the hardcopy/CRT display mode which starts off
! assuming we have a CRT and does rubouts, etc. accordingly.
!
	    [%C'H'] :
	      BEGIN
		ctx[mctx$v_hardcopy] = NOT .ctx[mctx$v_hardcopy];
		cmd_reset(.ctx);
	      END;
!
! Up to now (on VAX), one could always use the ";I" command
! to manipulate the PC in XDELTA and DELTA. With this version on EVAX, one
! need only "open" the PC with "PC/" to see its contents or modify the
! saved PC. So ";I" is no longer needed for this purpose. DELTA will
! make use of it for something more useful, namely displaying information
! about the shareable images currently mapped into the process address
! space with the executable image.
!
	    %if delta %then
	      [%C'I'] :
		BEGIN
		  IF NOT (status = put_shareable_images()) THEN
		    RETURN .status;
		  cmd_reset(.ctx);
		END;
	    %fi
!
! The ";M" command causes all process address spaces to be writable (or
! read-only) in DELTA only.
!
	    %if delta %then
	    [%C'M'] :
	      BEGIN
		IF .ctx[mctx$v_f0] THEN
		  IF (.fld[0] EQL 0) OR (.fld[0] EQL 1) THEN
		    ctx[mctx$l_modify_enable] = .fld[0];
		quan = .ctx[mctx$l_modify_enable];
		put_hex(.quan,.ctx[mctx$l_data_length] ^ 1);
		put_char(space);
		cmd_reset(.ctx);
	      END;
	    %fi
!
! The ";P" command causes the debugger to proceed from the current point
! and resume program execution
!
	    [%C'P'] :
	      BEGIN
		ctx[mctx$v_scanner_done] = 1;
		new_line();
	      END;
!
! The ";Q" command causes analysis of the specified queue for validity
!
%IF 0 %THEN
	    [%C'Q'] :
	      BEGIN
		IF NOT (status = validate_queue(.ctx)) THEN
		  RETURN .status;
		cmd_reset(.ctx);
	      END;
!
! The ";W" command attempts to locate a system space address within the loaded
! execlets.
!
	    [%C'W'] :
	      BEGIN
		IF NOT (status = locate_address(.ctx)) THEN
		  RETURN .status;
		cmd_reset(.ctx);
	      END;
%FI
!
! If none of the above, it's an error
!
	    [OTHERWISE] : RETURN 0;
	  TES;
!
	RETURN ss$_normal;
END; 					! ROUTINE secondary_scanner


ROUTINE put_char(
!++
! Functional description:
!
!	This routine displays a single character. How it does this depends
! on whether we're running XDELTA or DELTA. XDELTA is further complicated
! in that the display mechanism differs between the primary CPU and all
! other CPUs. Only the primary has direct access to the console. Other CPUs
! use an XDELTA-specific virtual console mechanism, where the data is handed
! off to the primary CPU for eventual display.
!	All display routines utilize this routine to display each character.
! In that way, only this routine has to worry about "how" to do it.
!
! Formal parameters:
!
	the_char: BYTE			!The character to write
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

!
! If this is DELTA, then we merely use $QIO to the previously assigned
! channel to SYS$OUTPUT. If we get particular resource errors, we'll
! retry a few times before giving up completely.
!
%if delta %then
BEGIN

LOCAL
	done: INITIAL(0),			!Boolean loop terminator
	loop_counter: INITIAL(0),		!Loop iteration counter
	status;					!Return status
!
	WHILE NOT .done DO
	  BEGIN
	    status = $QIOW(
			EFN  = out_efn,
			CHAN = .ttchan,
			FUNC = IO$_WRITEVBLK,
			P1   = the_char,
			P2   = 1);
	    IF (.status EQL ss$_insfmem) OR (.status EQL ss$_exquota) OR
	       ((.status GEQ ss$_exquotastrt) AND (.status LEQ ss$_exquotaend))
	      THEN
		BEGIN
		  loop_counter = .loop_counter + 1;
		  IF .loop_counter GEQ max_retries THEN
		    done = 1;
		END
	      ELSE
		done = 1;
	  END;
END;
!
! If this is XDELTA, then we have to check and see if we're the primary
! CPU or not. If we are, we can write directly to the console. If not,
! we use the virtual console interface.
!
!
%else
BEGIN

LOCAL
	cpu_id;				!The current CPU ID
!
! If we're the primary CPU, write the data directly to the console. Otherwise,
! use the virtual console interface. Note that if SMP symbols aren't defined,
! we only have to worry about the primary processor.
!
	IF $init_done THEN
	  BEGIN
	    cpu_id = $cpu_id;
	    IF .cpu_id EQL .smp$gl_primid THEN
	      con$putchar(.the_char)
	    ELSE
	      virtual_putchar(.the_char);
	  END
	ELSE
	  con$putchar(.the_char);
END;
%fi
!
	RETURN ss$_normal;
END; 					! ROUTINE put_char


ROUTINE put_string(
!++
! Functional description:
!
!	This routine displays a text string. The string is purposely NOT
! passed by descriptor because I don't know what they're going to look like
! in the 64-bit calling standard.
!	We optimize string output for DELTA to avoid doing single-character
! $QIOs.
!
! Formal parameters:
!
	str_size,			!String size
	str_address			!String address
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

!
! If this is DELTA, then we'll attempt to write the entire string in
! one swell foop to avoid single-character $QIOs.
!
%if delta %then

LOCAL
	done: INITIAL(0),			!Boolean loop terminator
	loop_counter: INITIAL(0),		!Loop iteration counter
	status;					!Return status
!
	WHILE NOT .done DO
	  BEGIN
	    status = $QIOW(
			EFN  = out_efn,
			CHAN = .ttchan,
			FUNC = IO$_WRITEVBLK,
			P1   = .str_address,
			P2   = .str_size);
	    IF (.status EQL ss$_insfmem) OR (.status EQL ss$_exquota) OR
	       ((.status GEQ ss$_exquotastrt) AND (.status LEQ ss$_exquotaend))
	      THEN
		BEGIN
		  loop_counter = .loop_counter + 1;
		  IF .loop_counter GEQ max_retries THEN
		    done = 1;
		END
	      ELSE
		done = 1;
	  END;
%else
!
! For XDELTA, we call PUT_CHAR for each character. PUT_CHAR knows how to
! check for primary versus secondary CPUs, and single-character writes should
! work on any console implementation.
!
BIND
	str = .str_address : VECTOR[,BYTE];	!To look at each character
!
! Just display one character at a time...
!
	INCR index FROM 0 TO (.str_size - 1) DO
	  put_char(.str[.index]);
%fi
!
	RETURN ss$_normal;
END; 					! ROUTINE put_string


ROUTINE new_line =
!++
! Functional description:
!
!	This routine causes a new line in the output stream.
!
! Formal parameters:
!
!	None
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

!
! Output a <CR><LF>
!
	put_char(cr);
	put_char(lf);
!
	RETURN ss$_normal;
END; 					! ROUTINE new_line


ROUTINE put_hex(
!++
! Functional description:
!
!	This routine displays a hex number as a string. The unsigned
! integer and field width are specified as parameters.
!
! Formal parameters:
!
	hex_value,			!The value to print as a string
	width				!The output field width
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

LITERAL
	max_hex_digits = %BPVAL / 4;		!Max. number of hex digits
LOCAL
	hex_buf: VECTOR[1 + max_hex_digits,BYTE], !Buffer for final string
	buf_count;				!Byte count
!
! The width argument cannot be bigger than (%BPVAL/4), which is the number
! of ascii bytes it takes to represent a 32-bit or 64-bit hex value. Return
! an error if something larger was specified.
!
	IF .width GTR max_hex_digits THEN
	  RETURN 0;
!
! OK, we want to display this hex value as a string from left to right.
! So we'll start with the high nibble and work down to the low nibble and
! do whatever nibbling in between that we need to do, depending on the
! width specified. Note that anything larger than a longword (8 hex digits)
! will have a space to separate the lower 8 digits from any higher digits.
!
	buf_count = 0;
	DECR index FROM (.width - 1) TO 0 DO
	  BEGIN
	    IF (.index EQL (long_size * 2 - 1)) AND
	       (.width GTR (long_size * 2)) THEN
	      BEGIN
	        hex_buf[.buf_count] = space;
		buf_count = .buf_count + 1;
	      END;
	    hex_buf[.buf_count] = (.hex_value ^ -(.index ^ 2)) AND %X'F';
	    IF .hex_buf[.buf_count] LSS %X'A' THEN
	      hex_buf[.buf_count] = .hex_buf[.buf_count] + %C'0'
	    ELSE
	      hex_buf[.buf_count] = .hex_buf[.buf_count] - %X'A' + %C'A';
	    buf_count = .buf_count + 1;
	  END;
!
	put_string(.buf_count,hex_buf);
!
	RETURN ss$_normal;
END; 					! ROUTINE put_hex


ROUTINE put_dec(
!++
! Functional description:
!
!	This routine displays a decimal number as a string.
!
! Formal parameters:
!
	dec_value			!The decimal value
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

LOCAL
	ascii_char;			!Decimal digit converted to ascii
!
! Well, I'm not sure if I can get away with recursion using inner-mode
! stack space, but the decimal values are usually pretty small and it
! is the most straightforward technique for the conversion and display.
! Soooo, since we're displaying left to right and want to display the most
! significant decimal digit first, we call ourselves to display values
! greater than or equal to 10 while converting and displaying those digits
! between 0 and 9 inclusive.
!
	IF .dec_value GEQ 10 THEN
	  BEGIN
	    put_dec(.dec_value / 10);
	    ascii_char = (.dec_value MOD 10) + %C'0';
	  END
	ELSE
	  ascii_char = .dec_value + %C'0';
!
	put_char(.ascii_char);
!
	RETURN ss$_normal;
END; 					! ROUTINE put_dec


ROUTINE put_ascii(
!++
! Functional description:
!
!	This routine displays an ascii string, replacing any nonprintable
! characters with "." for readability. Once again, the string is purposely NOT
! passed by descriptor because I don't know what they're going to look like
! in the 64-bit calling standard.
!
! Formal parameters:
!
	str_size,			!String size
	str_address			!String address
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

LITERAL
	str_chunk_size = %BPVAL / 8;
BIND
	str = .str_address: VECTOR[,BYTE];	!To look at each character
LOCAL
	str_count,				!Byte count
	str_chunk: VECTOR[str_chunk_size,BYTE];	!Buffer for string chunks
!
! Loop for each byte, displaying a "." for nonprintable characters or the
! the suitable ascii character
!
	str_count = 0;
	INCR index FROM 0 TO (.str_size - 1) DO
	  BEGIN
	    IF ((.str[.index] AND %X'7F') LSS space) OR
	       ((.str[.index] AND %X'7F') EQL delete) THEN
	      str_chunk[.str_count] = %C'.'
	    ELSE
	      str_chunk[.str_count] = .str[.index];
	    str_count = .str_count + 1;
	    IF .str_count GEQ str_chunk_size THEN
	      BEGIN
		put_string(.str_count,str_chunk);
		str_count = 0;
	      END;
	  END;
!
	IF .str_count GTR 0 THEN
	  put_string(.str_count,str_chunk);
!
	RETURN ss$_normal;
END; 					! ROUTINE put_ascii


ROUTINE put_next_adr(
!++
! Functional description:
!
!	This routine displays the "current location" address and does
! something different depending on what it is. The current location might
! be an internal processor register number, a GPR, PC, PS, an address close
! to a current X-register, or merely an address to be displayed. Note that
! there are a few assumptions in this routine which may not always be valid...
! such as assuming that the register save area is an array of quadwords. All
! register numbers, be they GPRs or X registers, are displayed in decimal.
!
! Formal parameters:
!
	ctx: REF BLOCK[0,BYTE]		!Ptr to mode context block
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

BIND
	dot = ctx[mctx$q_dot],		!Current location
	iregbuf = ctx[mctx$q_iregbuf],	!GPR save area address
	fregbuf = ctx[mctx$q_fregbuf];	!FP register save area address
LOCAL
	regnum,				!Temp. storage for register number
	offset;				!Temp. storage for offset
!
! If this is DELTA and the address belongs to some other process, then
! we want to first display the PID as a prefix to what follows.
!
	%if delta %then
	  IF .ctx[mctx$l_pid] NEQ 0 THEN
	    BEGIN
	      put_hex(.ctx[mctx$l_pid],2*long_size);
	      put_char(%C':');
	    END;
	%fi
!
! First, if this is a processor register number, display it as such
!
	IF .ctx[mctx$v_preg] THEN
	  BEGIN
	    put_char(%C'P');
	    put_preg(.dot);
	  END
	ELSE
!
! If it's a plain ol' down-to-earth register, display it as such...And, yes,
! someday I'll get around to fixing this disgusting test below...
!
	  IF ((regnum = (.dot - .iregbuf)) GEQ 0) AND
	     ((regnum = (.regnum / quad_size)) LSS num_gprs) THEN
	    BEGIN
	      put_char(%C'R');
	      put_dec(.regnum);
	    END
	  ELSE
!
! It might be the saved PC or PS
!
	    IF .dot EQL (.iregbuf + (32 * quad_size)) THEN
	      BEGIN
		put_char(%C'P');
		put_char(%C'C');
	      END
	    ELSE
	      IF .dot EQL (.iregbuf + (33 * quad_size)) THEN
		BEGIN
		  put_char(%C'P');
		  put_char(%C'S');
		END
	      ELSE
!
! If it's a floating point register, display it as such
!
		IF ((regnum = (.dot - .fregbuf)) GEQ 0) AND
		   ((regnum = (.regnum / quad_size)) LEQ num_gprs) THEN
		  BEGIN
		    put_char(%C'F');
		    put_char(%C'P');
		    IF .regnum LSS num_gprs THEN
		      put_dec(.regnum)
		    ELSE
		      BEGIN
			put_char(%C'C');
			put_char(%C'R');
		      END;
		  END
		ELSE
!
! Hey, maybe it's pretty close to one of our X-registers! Wouldn't THAT
! be a thrill!
!
		  IF find_xreg(.dot,regnum,offset) THEN
		    BEGIN
		      put_char(%C'X');
		      put_dec(.regnum);
		      put_char(%C'+');
		      put_hex(.offset,long_size*2);
		    END
		  ELSE
!
! NO??? Well, as a last resort, just dump out the value in hex. Note that
! an "address" is displayed as either a 32-bit or 64-bit quantity, depending
! on the address display mode.
!
		    put_address(.dot,.ctx);
!
! Now print an indicator of the prevailing display mode
!
	IF .ctx[mctx$v_instruction] THEN
	  put_char(%C'!')
	ELSE
	  IF .ctx[mctx$v_ascii] THEN
	    put_char(%C'"')
	  ELSE
	    put_char(%C'/');
!
	RETURN ss$_normal;
END; 					! ROUTINE put_next_adr


ROUTINE put_address(
!++
! Functional description:
!
!	This routine displays the specified parameter as an address. An
! address is displayed as either a 32-bit or 64-bit hex value, depending
! on the state of the address display mode bit.
!
! Formal parameters:
!
	addr_value,			!The address value
	ctx: REF BLOCK[0,BYTE]		!Ptr to mode context block
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

!
! Look at the addr64 mode bit. If it's clear (always in "32-bit mode" and
! the default in "64-bit mode"), then display the address as a 32-bit hex
! value. If it's set, display a full 64-bit value.
!
	IF .ctx[mctx$v_addr64] THEN
	  put_hex(.addr_value,quad_size * 2)
	ELSE
	  put_hex(.addr_value,long_size * 2);
!
	RETURN ss$_normal;
END; 					! ROUTINE put_address


ROUTINE put_location(
!++
! Functional description:
!
!	This routine displays the contents of the "current" location in
! the prevailing display mode. So, for example, if we're in instruction
! mode, the contents are interpreted as an instruction and displayed as
! such. This always entails fetching the contents of the current location,
! storing the result as the current quantity prior to the display.
!
! Formal parameters:
!
	ctx: REF BLOCK[0,BYTE]		!Ptr to mode context block
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

BIND
	quan = ctx[mctx$q_quan];		!Current quantity
LOCAL
	status;					!Return status value
!
! Reflect that the current location is open
!
	ctx[mctx$v_open] = 1;
!
! If in instruction display mode, display the contents of the current
! location as an instruction
!
	IF (.ctx[mctx$v_instruction]) AND (NOT .ctx[mctx$v_preg]) THEN
	  BEGIN
	    IF NOT (status = put_instruction(.ctx)) THEN
	      RETURN .status;
	  END
	ELSE
!
! Otherwise, fetch the contents of the current location and either display
! it as ascii (if in ascii display mode) or as plain ol' hex
!
	  IF NOT (status = fetch_current(.ctx)) THEN
	    RETURN .status
	  ELSE
	    BEGIN
	      IF .ctx[mctx$v_ascii] THEN
	        put_ascii(.ctx[mctx$l_data_length],quan)
	      ELSE
	        put_hex(.quan,.ctx[mctx$l_data_length] ^ 1);
	    END;
!
! Throw a space out there
!
	put_char(space);
!
	RETURN ss$_normal;
END; 					! ROUTINE put_location


ROUTINE put_quan(
!++
! Functional description:
!
!	This routine displays the contents of the current quantity, the
! value of Q in the debugger. This is typically the most recently displayed
! value. Any expressions or fields are terminated. The first input field,
! if any, becomes the current quantity and is displayed in the prevailing
! display mode.
!
! Formal parameters:
!
	ctx: REF BLOCK[0,BYTE]		!Ptr to mode context block
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

BIND
	fld = ctx[mctx$q_fields] : VECTOR,	!Input field array
	quan = ctx[mctx$q_quan];		!Current quantity
LOCAL
	status;					!Return status value
!
! Explicity turn off ascii display mode and terminate the current field
!
	ctx[mctx$v_ascii] = 0;
	IF NOT (status = end_field(.ctx)) THEN
	  RETURN .status;
!
! If an input field was specified, that becomes the quantity to display
!
	IF .ctx[mctx$v_f0] THEN
	  quan = .fld[0];
!
! Display the current quantity in hex using the prevailing data length
!
	put_hex(.quan,.ctx[mctx$l_data_length] ^ 1);
	put_char(space);
!
! Prepare for the next input command
!
	cmd_reset(.ctx);
!
	RETURN ss$_normal;
END; 					! ROUTINE put_quan


ROUTINE put_pc(
!++
! Functional description:
!
!	This routine displays the current PC and the instruction at that PC.
! Note that the saved PC becomes the "current location."
!
! Formal parameters:
!
	ctx: REF BLOCK[0,BYTE]		!Ptr to mode context block
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

MACRO
	%if delta %then
	  modipl_msg = %STRING(' (New mode = ') %,
	  kernel_msg = %STRING('KERNEL') %,
	  exec_msg = %STRING('EXEC') %,
	  super_msg = %STRING('SUPER') %,
	  user_msg = %STRING('USER') %,
	%else
	  modipl_msg = %STRING(' (New IPL = ') %,
	%fi
	cparen_msg = %STRING(') ') %;
BIND
	dot = ctx[mctx$q_dot],			!Current location
	iregbuf = ctx[mctx$q_iregbuf],		!Register save area address
	save_pc = .iregbuf + (32 * quad_size),	!Saved PC
	%if delta %then
	  kernel_message = UPLIT(BYTE(kernel_msg)),
	  exec_message = UPLIT(BYTE(exec_msg)),
	  super_message = UPLIT(BYTE(super_msg)),
	  user_message = UPLIT(BYTE(user_msg)),
	%fi
	modipl_message = UPLIT(BYTE(modipl_msg)),
	cparen_message = UPLIT(BYTE(cparen_msg));
LITERAL
	%if delta %then
	  kernel_msg_len = %CHARCOUNT(kernel_msg),
	  exec_msg_len = %CHARCOUNT(exec_msg),
	  super_msg_len = %CHARCOUNT(super_msg),
	  user_msg_len = %CHARCOUNT(user_msg),
	%fi
	modipl_msg_len = %CHARCOUNT(modipl_msg),
	cparen_msg_len = %CHARCOUNT(cparen_msg);
OWN
	current_mode_ipl:			!The last time here
	  INITIAL(				!With an initial value of
	    %if delta %then			!
	      psl$c_user			!User-mode for DELTA
	    %else				!and
	      ipl$_power			!IPL$_POWER for XDELTA
	    %fi
	  );
LOCAL
	status;					!Return status value
!
! Enable instruction display mode. Set the current location to point to
! the saved PC. Then display the PC address and contents as an instruction.
!
	ctx[mctx$v_instruction] = 1;
	ctx[mctx$v_ascii] = 0;
!
	dot = .save_pc;
	new_line();
	put_next_adr(.ctx);
	IF NOT (status = put_location(.ctx)) THEN
	  RETURN .status;
!
! If the mode in DELTA or the IPL in XDELTA has changed since the last time
! here, we'll display some hopefully useful information to make sure the
! user is aware of the change.
!
	IF .current_mode_ipl NEQ .ctx[mctx$l_index] THEN
	  BEGIN
	    put_string(modipl_msg_len,modipl_message);
	    %if delta %then
	      CASE .ctx[mctx$l_index] FROM psl$c_kernel TO psl$c_user OF
		SET
		  [psl$c_kernel] :
		    put_string(kernel_msg_len,kernel_message);
		  [psl$c_exec] :
		    put_string(exec_msg_len,exec_message);
		  [psl$c_super] :
		    put_string(super_msg_len,super_message);
		  [psl$c_user] :
		    put_string(user_msg_len,user_message);
		TES
	    %else
	      put_dec(.ctx[mctx$l_index])
	    %fi ;
	    put_string(cparen_msg_len,cparen_message);
	  END;
!
	current_mode_ipl = .ctx[mctx$l_index];
!
	RETURN ss$_normal;
END; 					! ROUTINE put_pc


ROUTINE put_instruction(
!++
! Functional description:
!
!	This routine displays the contents of the current location as an
! instruction. The lib$ins_decode routine is used to convert the location
! contents into the appropriate instruction ascii string.
!	The current quantity is set to point to the last "address" in the
! instruction. Actually, this would be the last operand. If the instruction
! cannot be decoded for some reason, its hex value is displayed instead.
!
! Formal parameters:
!
	ctx: REF BLOCK[0,BYTE]		!Ptr to mode context block
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

LITERAL
	outbuf_size = 40;			!Output string size
BIND
	dot = ctx[mctx$q_dot],			!Current location
	inst_adr = .dot : LONG SIGNED,		!Instruction address
	quan = ctx[mctx$q_quan];		!Current quantity
LOCAL
	location_ptr,				!Temporarily
	output_buffer: VECTOR[outbuf_size,BYTE],!The output buffer
	out_desc: VECTOR[2,LONG,SIGNED]		!Output string descriptor
	  INITIAL(LONG(outbuf_size,output_buffer)),
	status;					!Return status value
!
! If we can't read the contents of the current location, return an error
!
	IF NOT (status = xdt$check_address(.dot,inst_size,0)) THEN
	  RETURN .status;
!
! Setup and make the call to lib$ins_decode. If it's successful at decoding
! the instruction, display the resulting instruction string. If it fails,
! print the value of the so-called instruction in hex as a longword.
!
	quan = .inst_adr;
	location_ptr = .dot;
!
	IF lib$ins_decode(
			location_ptr,
			out_desc,
			out_desc,
			0) THEN
	  put_string(.out_desc[0],output_buffer)
	ELSE
	  put_hex(.quan,inst_size * 2);
!
	RETURN ss$_normal;
END; 					! ROUTINE put_instruction


ROUTINE put_preg(
!++
! Functional description:
!
!	This routine displays the processor register name associated with
! the pseudo register number specified. This is all a foolish attempt to
! hide the internal numbers from the user and present a "name" interface.
!
! Formal parameters:
!
	regnum				!Pseudo processor register number
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

!
! Display the leading "(" first
!
	put_char(%C'(');
!
! Now display the appropriate register name based on the number specified
!
	CASE .regnum FROM min_pr_number TO max_pr_number OF
	  SET
	    [pr$k_asn] : put_string(asn_string_size,asn_string_adr);
	    [pr$k_asten] : put_string(asten_string_size,asten_string_adr);
	    [pr$k_astsr] : put_string(astsr_string_size,astsr_string_adr);
	    [pr$k_datfx] : put_string(datfx_string_size,datfx_string_adr);
	    [pr$k_esp] : put_string(esp_string_size,esp_string_adr);
	    [pr$k_fen] : put_string(fen_string_size,fen_string_adr);
	    [pr$k_ipir] : put_string(ipir_string_size,ipir_string_adr);
	    [pr$k_ipl] : put_string(ipl_string_size,ipl_string_adr);
	    [pr$k_mces] : put_string(mces_string_size,mces_string_adr);
!	    [pr$k_perfmon] : put_string(perfmon_string_size,perfmon_string_adr);
	    [pr$k_pcbb] : put_string(pcbb_string_size,pcbb_string_adr);
	    [pr$k_prbr] : put_string(prbr_string_size,prbr_string_adr);
	    [pr$k_ptbr] : put_string(ptbr_string_size,ptbr_string_adr);
	    [pr$k_rscc] : put_string(rscc_string_size,rscc_string_adr);
	    [pr$k_scbb] : put_string(scbb_string_size,scbb_string_adr);
	    [pr$k_sirr] : put_string(sirr_string_size,sirr_string_adr);
	    [pr$k_sisr] : put_string(sisr_string_size,sisr_string_adr);
	    [pr$k_ssp] : put_string(ssp_string_size,ssp_string_adr);
	    [pr$k_tbchk] : put_string(tbchk_string_size,tbchk_string_adr);
	    [pr$k_tbia] : put_string(tbia_string_size,tbia_string_adr);
	    [pr$k_tbiap] : put_string(tbiap_string_size,tbiap_string_adr);
	    [pr$k_tbis] : put_string(tbis_string_size,tbis_string_adr);
	    [pr$k_tbisd] : put_string(tbisd_string_size,tbisd_string_adr);
	    [pr$k_tbisi] : put_string(tbisi_string_size,tbisi_string_adr);
	    [pr$k_usp] : put_string(usp_string_size,usp_string_adr);
	    [pr$k_vptbase] : put_string(vptbase_string_size,vptbase_string_adr);
	    [pr$k_whami] : put_string(whami_string_size,whami_string_adr);
	  TES;
!
! Display the closing ")"
!
	put_char(%C')');
!
	RETURN ss$_normal;
END; 					! ROUTINE put_preg


%IF 0 %THEN
ROUTINE find_imgnam(
!++
! Functional description:
!
!	This routine is used by put_exec_images to locate the image name
! and size from the address and size specified.
!
! Formal parameters:
!
	start_adr: REF VECTOR[,BYTE],	!Starting address of the buffer
	buf_size,			!Size of buffer
	imgnam_adr,			!Address for returned start address
	imgnam_size			!Address for returned size
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

!
! Look for a "]" character to indicate the end of a device/directory
! specification on the image name string. If we find one, set the
! start address of the image name itself as well as its size and
! immediately return.
!
	INCR index FROM 0 TO (.buf_size - 1) DO
	  IF .start_adr[.index] EQL %C']' THEN
	    BEGIN
	      .imgnam_adr = start_adr[.index + 1];
	      .imgnam_size = .buf_size - .index - 1;
	      RETURN ss$_normal;
	    END;
!
! OK. We never found it. That means we should just use the starting
! address as the address of the image name.
!
	.imgnam_adr = .start_adr;
	.imgnam_size = .buf_size;
!
	RETURN ss$_normal;
END; 					! ROUTINE find_imgnam

ROUTINE put_exec_images (
!++
! Functional description:
!
!	This routine displays the names and locations of the exec loadable
! images.
!
! Formal parameters:
!
	ctx: REF BLOCK[0,BYTE]		!Ptr to mode context block
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

BIND
	fld = ctx[mctx$q_fields] : VECTOR,
	symvec_label =  UPLIT(BYTE(%ASCIC 'Symbol Vector      '));
LOCAL
	match: initial(0),
	list_head: REF VECTOR[,LONG,SIGNED],	!Image list head
	image_le: REF BLOCK[,BYTE],		!LDR image list entry
	imgnam_buf: VECTOR[ldrimg$s_imgnam,BYTE],!Image name buffer
	string_adr,				!Image name string address
	string_len,				!Image name string length
	isd_index,				!index into isd label table
	status,					!Return status value
	isd_labels: VECTOR[6]
		INITIAL(UPLIT(BYTE(%ASCIC 'Nonpaged read only ')),
			UPLIT(BYTE(%ASCIC 'Nonpaged read/write')),
			UPLIT(BYTE(%ASCIC 'Paged read only    ')),
			UPLIT(BYTE(%ASCIC 'Paged read/write   ')),
			UPLIT(BYTE(%ASCIC 'Fixup              ')),
			UPLIT(BYTE(%ASCIC 'Initialization     ')));
!
! If we're not linked with SYS, we don't have a loadable image list
!
IF ldr$gq_image_list EQL 0 THEN RETURN 0;
!
! If the queue itself is empty at this point, it's an error
!
IF .ldr$gq_image_list[0] EQL ldr$gq_image_list THEN RETURN 0;
!
! Now, if we're in XDELTA, we can safely traverse the actual loadable
! image database without worrying about possible concurrent updates. In
! DELTA, we have to worry about synchronizing with such updates to get an
! accurate snapshot of the database. So in DELTA we keep a local copy and
! update it now.
!
%if delta %then
    IF NOT (status = get_loadable_images()) THEN RETURN .status;
    list_head = ldr_image_head;
%else
    list_head = ldr$gq_image_list;
%fi

!
! Now traverse the exec loadable image database and display the image
! information
!
image_le = .list_head[0];
WHILE .image_le NEQ .list_head DO
  BEGIN
!
! Make sure this entry is valid before doing anything.
!
  IF .image_le[ldrimg$v_valid]
  THEN
     BEGIN
     IF NOT .ctx[mctx$v_f0] OR
		(.ctx[mctx$v_f0] and (.image_le[ldrimg$l_seq] eql .fld[0]))
     THEN
	BEGIN

!
! Display a header of information to make the image display a little
! more comprehensible
!
	IF .match EQL 0
	THEN 
	   BEGIN
	   new_line();
	   new_line();
	   put_string(imgseq_msg_len,imgseq_message);
	   INCR index FROM 1 TO (long_size - imgseq_msg_len + 2) DO
				put_char(space);
	   put_string(imgnam_msg_len,imgnam_message);
	   INCR index FROM 1 TO (ldrimg$s_imgnam - imgnam_msg_len + 2) DO
	  			put_char(space);
	   put_string(imgbas_msg_len,imgbas_message);
	   INCR index FROM 1 TO (long_size*2 - imgbas_msg_len + 2) DO
	  			put_char(space);
	   put_string(imgend_msg_len,imgend_message);
	   new_line();
	   new_line();
	   END;

	match = 1;

!
! Display the sequence number of the image
!
	   put_hex(.image_le[ldrimg$l_seq],long_size);
	   put_char(space);
	   put_char(space);
!
! Extract the exec loadable image name from the structure, removing
! any device/directory specifier, and print it.
!
        find_imgnam( image_le[ldrimg$t_imgnam],
		    .image_le[ldrimg$b_imgnamlen],
		     string_adr,
		     string_len);
!
	ch$move(.string_len,.string_adr,imgnam_buf);
	ch$fill(%C' ',ldrimg$s_imgnam - .string_len,
		imgnam_buf[.string_len]);
	put_string(ldrimg$s_imgnam,imgnam_buf);

	IF .image_le[ldrimg$v_no_slice]
	THEN
	   BEGIN
!
! Display the base address of the image
!
	   put_char(space);
	   put_char(space);
	   put_hex(.image_le[ldrimg$l_base],2*long_size);
!
! Compute and display the ending address of the image
!
	   put_char(space);
	   put_char(space);
	   put_hex(.image_le[ldrimg$l_base] +
	          (.image_le[ldrimg$l_page_count] ^ -.mmg$gl_va_to_vpn),
		   2*long_size);
	   new_line();
	   END
	ELSE
	   BEGIN

! sliced image display

	   new_line();
           isd_index = 0;
	   INCRA isd from image_le[ldrimg$l_nonpag_r_base]
		     to   image_le[ldrimg$l_init_base]
		     by   ldrimg$k_isd_length DO
	      BEGIN
	      MAP ISD: REF BLOCK[,BYTE];
!
! display the start and ending address of each image section
!
	      IF .isd[ldrimg$l_isd_len] NEQ 0
	      THEN
	         BEGIN
	         BIND isd_label = .isd_labels[.isd_index]: vector[,byte];

	         INCR index FROM 1 TO 10 DO put_char(space);
	         put_string(.isd_label[0],isd_label[1]);
	         INCR index FROM 1 TO 18 DO put_char(space);
	         put_hex(.isd[ldrimg$l_isd_base],2*long_size);
	         put_char(space);
	         put_char(space);
	         put_hex(.isd[ldrimg$l_isd_base] + .isd[ldrimg$l_isd_len],
		          2*long_size);
!
	         new_line();
	         END;
	      isd_index = .isd_index +1;
	      END;
	   END; 
!
! Display the symbol vector address of the image if it's valid
!
	   IF .image_le[ldrimg$l_symvva] NEQ 0
	   THEN
	      BEGIN
	      MAP symvec_label: vector[,byte];
	      INCR index FROM 1 TO 10 DO put_char(space);
	      put_string(.symvec_label[0],symvec_label[1]);
	      INCR index FROM 1 TO 18 DO put_char(space);
	      put_hex(.image_le[ldrimg$l_symvva],2*long_size);
	      put_char(space);
	      put_char(space);
	      put_hex(.image_le[ldrimg$l_symvva_end],2*long_size);
	      new_line();
	     END;
                  
        END; 
     END;
!
! Get the next queue entry
!
  image_le = .image_le[ldrimg$l_flink];
  END;
!

IF .match eql 0
THEN
   RETURN 0
ELSE 
   RETURN SS$_NORMAL;

END; 					! ROUTINE put_exec_images


ROUTINE locate_address ( 
!++
! Functional description:
!
!	This routine displays the name and location of the exec loadable
!       images which contains ab input address
!
! Formal parameters:
!
	ctx: REF BLOCK[0,BYTE]		!Ptr to mode context block
	) =
!
!	Address - system space address we are attempting to identify
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

BIND
	fld = ctx[mctx$q_fields] : VECTOR;		!Input fields
LOCAL
	seq_num: LONG,
	offset: LONG UNSIGNED INITIAL(-1),
	address: LONG SIGNED INITIAL(0),	!address to be check
	list_head: REF VECTOR[,LONG,SIGNED],	!Image list head
	image_le: REF BLOCK[,BYTE],		!LDR image list entry
	imgnam_buf: VECTOR[ldrimg$s_imgnam,BYTE],!Image name buffer
	string_adr,				!Image name string address
	string_len,				!Image name string length
	isd_index,				!index into isd label table
	status,					!Return status value
	isd_labels: VECTOR[6]
		INITIAL(UPLIT(BYTE(%ASCIC 'Nonpaged read only ')),
			UPLIT(BYTE(%ASCIC 'Nonpaged read/write')),
			UPLIT(BYTE(%ASCIC 'Paged read only    ')),
			UPLIT(BYTE(%ASCIC 'Paged read/write   ')),
			UPLIT(BYTE(%ASCIC 'Fixup              ')),
			UPLIT(BYTE(%ASCIC 'Initialization     ')));
!
! If this is XDELTA, then this must be a system space address. If it's DELTA,
! then it can be system space or process space and the system space address
! could be a resident code section of an image or somewhere in the exec.
! So for DELTA, we'll first search the image data (since that's the more likely
! place to find it). If we find it there, we're done. If not, we'll proceed
! with the exec search.
!
IF NOT .ctx[mctx$v_f0] THEN RETURN 0;

%if delta %then
IF NOT .ctx[mctx$v_f1] THEN
  IF locate_process_address(.ctx) THEN RETURN ss$_normal;
%fi

IF NOT .ctx[mctx$v_f1]
THEN 
   BEGIN
   address = .fld[0];
   IF .address GEQ 0 THEN RETURN 0;
   END
ELSE
   BEGIN
   offset = .fld[1];
   seq_num = .fld[0];
   END;

!
! If we're not linked with SYS, we don't have a loadable image list
!
IF ldr$gq_image_list EQL 0 THEN RETURN 0;
!
! If the queue itself is empty at this point, it's an error
!
IF .ldr$gq_image_list[0] EQL ldr$gq_image_list THEN RETURN 0;
!
! Now, if we're in XDELTA, we can safely traverse the actual loadable
! image database without worrying about possible concurrent updates. In
! DELTA, we have to worry about synchronizing with such updates to get an
! accurate snapshot of the database. So in DELTA we keep a local copy and
! update it now.
!
%if delta %then
    IF NOT (status = get_loadable_images()) THEN RETURN .status;
    list_head = ldr_image_head;
%else
    list_head = ldr$gq_image_list;
%fi

! Now traverse the exec loadable image database and display the image
! information
!
image_le = .list_head[0];
WHILE .image_le NEQ .list_head DO
   BEGIN
!
! Make sure this entry is valid before doing anything.
!
   IF .image_le[ldrimg$v_valid]
   THEN
      BEGIN
      IF NOT .ctx[mctx$v_f1] OR
	    (.ctx[mctx$v_f1] AND 
	    (.image_le[ldrimg$l_seq] EQL .seq_num))
      THEN
	 BEGIN
	
	 IF .image_le[ldrimg$v_no_slice]
         THEN
	    BEGIN

! Is the address within this execlet?

	    IF (.address GEQ .image_le[ldrimg$l_base] AND
	        .address LSS (.image_le[ldrimg$l_base] + 
	       (.image_le[ldrimg$l_page_count] ^ -.mmg$gl_va_to_vpn))) OR
	        .ctx[mctx$v_f1] 
	    THEN
               BEGIN
!
! Display a header of information to make the image display a little
! more comprehensible
!
	       new_line();
	       new_line();

	       put_string(imgseq_msg_len,imgseq_message);
	       INCR index FROM 1 TO (long_size - imgseq_msg_len + 2) DO
				put_char(space);
	       put_string(imgnam_msg_len,imgnam_message);
	       INCR index FROM 1 TO (ldrimg$s_imgnam - imgnam_msg_len + 2) DO
	  			put_char(space);
	       put_string(imgbas_msg_len,imgbas_message);
	       INCR index FROM 1 TO (long_size*2 - imgbas_msg_len + 2) DO
			put_char(space);
	       put_string(imgend_msg_len,imgend_message);
	       INCR index FROM 1 TO (long_size*2 - imgend_msg_len + 2) DO
			put_char(space);
	       IF NOT .ctx[mctx$v_f1]
	       THEN
		   put_string(imgoff_msg_len,imgoff_message)
	       ELSE
		   put_string(imgadd_msg_len,imgadd_message);
	       new_line();
	       new_line();
!
! Display the sequence number of the image
!
	       put_hex(.image_le[ldrimg$l_seq],long_size);
	       put_char(space);
	       put_char(space);
!
!
! Extract the exec loadable image name from the structure, removing
! any device/directory specifier, and print it.
!
	       find_imgnam( image_le[ldrimg$t_imgnam],
			   .image_le[ldrimg$b_imgnamlen],
			    string_adr,
			    string_len);
!
	       ch$move(.string_len,.string_adr,imgnam_buf);
	       ch$fill(%C' ',ldrimg$s_imgnam - .string_len,
			    	imgnam_buf[.string_len]);
	       put_string(ldrimg$s_imgnam,imgnam_buf);
!
! Display the base address of the image
!
 	       put_char(space);
	       put_char(space);
	       put_hex(.image_le[ldrimg$l_base],2*long_size);
!
! Compute and display the ending address of the image
!
	       put_char(space);
	       put_char(space);
	       put_hex(.image_le[ldrimg$l_base] +
		      (.image_le[ldrimg$l_page_count] ^ -.mmg$gl_va_to_vpn),
		        2*long_size);
!
! Compute and display the offset within the linker map or system space address
!
	       put_char(space);
	       put_char(space);                              
	       IF NOT .ctx[mctx$v_f1]
	       THEN
	          put_hex(.address - .image_le[ldrimg$l_base],2*long_size)
	       ELSE
	          put_hex(.offset + .image_le[ldrimg$l_base],2*long_size);
	       new_line();
	       RETURN ss$_normal;
	       END;
	    END
	 ELSE
	    BEGIN
            isd_index = 0;
	    INCRA isd from image_le[ldrimg$l_nonpag_r_base]
		     to   image_le[ldrimg$l_init_base]
		     by   ldrimg$k_isd_length DO
	       BEGIN
	       MAP ISD: REF BLOCK[,BYTE];
!
! check the start and ending address or offset of each image section
!
	       IF .isd[ldrimg$l_isd_len] NEQ 0 AND
	        ((.address GEQ .isd[ldrimg$l_isd_base] AND
	          .address LSS (.isd[ldrimg$l_isd_base] + 
		  .isd[ldrimg$l_isd_len] )) OR
		 (.offset GEQ .isd[ldrimg$l_isd_offset] AND
		  .offset LSS (.isd[ldrimg$l_isd_offset] + 
		  .isd[ldrimg$l_isd_len] )) )
	       THEN
		  BEGIN
		  BIND isd_label = .isd_labels[.isd_index]: vector[,byte];
!
! Display a header of information to make the image display a little
! more comprehensible
!
	          new_line();
		  new_line();

	          put_string(imgseq_msg_len,imgseq_message);
	          INCR index FROM 1 TO (long_size - imgseq_msg_len + 2) DO
				put_char(space);
	          put_string(imgnam_msg_len,imgnam_message);
	          INCR index FROM 1 TO (ldrimg$s_imgnam - imgnam_msg_len + 2) DO
	  			put_char(space);
		  put_string(imgbas_msg_len,imgbas_message);
		  INCR index FROM 1 TO (long_size*2 - imgbas_msg_len + 2) DO
			    		put_char(space);
		  put_string(imgend_msg_len,imgend_message);
		  INCR index FROM 1 TO (long_size*2 - imgend_msg_len + 2) DO
		 		  	put_char(space);
		  IF NOT .ctx[mctx$v_f1]
		  THEN
		     put_string(imgoff_msg_len,imgoff_message)
		  ELSE
		     put_string(imgadd_msg_len,imgadd_message);
		  new_line();
		  new_line();
!
! Display the sequence number of the image
!
	          put_hex(.image_le[ldrimg$l_seq],long_size);
	          put_char(space);
	          put_char(space);

! 
! Extract the exec loadable image name from the structure, removing
! any device/directory specifier, and print it.
!
		  find_imgnam( image_le[ldrimg$t_imgnam],
			      .image_le[ldrimg$b_imgnamlen],
			       string_adr,
			       string_len);
!
		  ch$move(.string_len,.string_adr,imgnam_buf);
		  ch$fill(%C' ',ldrimg$s_imgnam - .string_len,
			  imgnam_buf[.string_len]);
		  put_string(ldrimg$s_imgnam,imgnam_buf);
		  new_line(); 
		  INCR index FROM 1 TO 10 DO put_char(space);
		  put_string(.isd_label[0],isd_label[1]);
		  INCR index FROM 1 TO 18 DO put_char(space);
!
! Compute and display the image section base and end addresses
!
		  put_hex(.isd[ldrimg$l_isd_base],2*long_size);
		  put_char(space);
		  put_char(space);
		  put_hex(.isd[ldrimg$l_isd_base] + .isd[ldrimg$l_isd_len],
			  2*long_size);
!
! Compute and display the offset within the linker map or system space address
!
		  put_char(space);
		  put_char(space);                              
		  IF NOT .ctx[mctx$v_f1]
		  THEN
		     put_hex(.address - .isd[ldrimg$l_isd_base] +
			     .isd[ldrimg$l_isd_offset],
			      2*long_size)
		  ELSE
		     put_hex(.offset - .isd[ldrimg$l_isd_offset] +
			     .isd[ldrimg$l_isd_base],
			      2*long_size);
		  new_line();
		  RETURN ss$_normal;
		  END;
	       isd_index = .isd_index +1;
	       END;
	    END;
	 END;
      END;
!
! Get the next queue entry
!
   image_le = .image_le[ldrimg$l_flink];
   END;
!

RETURN 0;		
END; 			! ROUTINE locate_address


%FI

ROUTINE bpt_message(
!++
! Functional description:
!
!	This routine displays the breakpoint message when a permanent
! breakpoint is hit. Strangely enough, this routine also sets up certain
! state such as the input source.
!
! Formal parameters:
!
	bpt_num,			!Breakpoint number
	ctx: REF BLOCK[0,BYTE]		!Ptr to mode context block
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

MACRO
	brk_msg = %STRING('Brk ') %,
	at_msg = %STRING(' at ') %,
	cpu_msg = %STRING(' on CPU ') %;
BIND
	dot = ctx[mctx$q_dot],				!Current location
	input_ptr = ctx[mctx$q_input_ptr],		!Input pointer
	iregbuf = ctx[mctx$q_iregbuf],			!Register save area adr
	save_pc = .iregbuf + (32 * quad_size),		!Saved PC
	bpt_disp = perm_bpts[.bpt_num,pbpt$q_display],	!Display address
	bpt_cmd = perm_bpts[.bpt_num,pbpt$q_cmd_string];!Command string address
LOCAL
	status: INITIAL(ss$_normal);			!Return status value
!
! Display the breakpoint message
!
	new_line();
	put_string(
		%CHARCOUNT(brk_msg),
		UPLIT(BYTE(brk_msg)));
	put_dec(.bpt_num);
	put_string(
		%CHARCOUNT(at_msg),
		UPLIT(BYTE(at_msg)));
	put_address(.save_pc,.ctx);
!
! If this is XDELTA on an SMP system, we need to also display the CPU ID
! for this breakpoint. We do this by checking to see if any CPUs besides the
! primary are in the active set.
!
	%if xdelta %then
	  IF $init_done THEN
	    IF (.smp$gl_cpuconf AND (NOT (1 ^ .smp$gl_primid))) NEQ 0 THEN
	      BEGIN
	        put_string(
			%CHARCOUNT(cpu_msg),
			UPLIT(BYTE(cpu_msg)));
	        put_dec(.xdt$gl_owner_id);
	      END;
	%fi
!
! Flag that we've seen a breakpoint at long last
!
	ctx[mctx$v_breaks] = 1;
!
! If this breakpoint has a display address associated with it, set the
! current location to point to it and display the address as well as its
! contents
!
	IF .bpt_disp NEQ 0 THEN
	  BEGIN
	    ctx[mctx$v_ascii] = 0;
	    ctx[mctx$v_instruction] = 0;
	    dot = .bpt_disp;
	    put_char(space);
	    put_char(space);
	    put_char(space);
	    put_next_adr(.ctx);
	    status = put_location(.ctx);
	  END;
!
	new_line();
!
! Set the input source if an input command string is associated with this
! breakpoint
!
	IF .bpt_cmd NEQ 0 THEN
	  input_ptr = .bpt_cmd;
!
	RETURN .status;
END; 					! ROUTINE bpt_message


ROUTINE step_over_message(
!++
! Functional description:
!
!	This routine displays the "step-over" message. This message is displayed
! if intermediate breakpoints were handled before completing the step-over
! operation or if the next instruction happens to execute on a different CPU
! (in XDELTA only). This helps the user figure out where he/she is and how
! he/she got there from here.
!
! Formal parameters:
!
	bpt_index,			!Temporary breakpoint index
	ctx: REF BLOCK[0,BYTE]		!Ptr to mode context block
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

MACRO
	step_msg = %STRING('Step-over at ') %,
	on_msg = %STRING(' on CPU ') %;
LITERAL
	step_msg_len = %CHARCOUNT(step_msg),
	on_msg_len = %CHARCOUNT(on_msg);
BIND
	step_message = UPLIT(BYTE(step_msg)),	!The step-over message text
	on_message = UPLIT(BYTE(on_msg)),	!The "on CPU" message text
	iregbuf = ctx[mctx$q_iregbuf],		!Register save area address
	save_pc = .iregbuf + (32 * quad_size),	!Saved PC
	origin_cpu = step_overs[.bpt_index,tbpt$q_cpu_id]; !Originating CPU
LOCAL
	cpu_id: INITIAL(0),			!Current CPU ID
	some_other_reason: INITIAL(0);		!Boolean flag
!
! If any breakpoints occurred or if the current CPU is different than the
! one which initiated the step-over (in XDELTA), display the step-over message
!
	%if xdelta %then
	  cpu_id = $cpu_id;
	  IF .cpu_id NEQ .origin_cpu THEN
	    some_other_reason = 1;
	%fi
!
	IF (.ctx[mctx$v_breaks]) OR (.some_other_reason) THEN
	  BEGIN
	    new_line();
	    put_string(step_msg_len,step_message);
	    put_hex(.save_pc,.ctx[mctx$l_data_length] ^ 1);
!
	    IF .some_other_reason THEN
	      BEGIN
		put_string(on_msg_len,on_message);
		put_dec(.cpu_id);
	      END;
	  END;
!
	RETURN ss$_normal;
END; 					! ROUTINE step_over_message


ROUTINE single_step_message(
!++
! Functional description:
!
!	This routine displays the "single-step" message. This message is
! displayed if intermediate breakpoints were handled before completing the
! single-step operation or if the current CPU is different than the one which
! initiated the single-step (in XDELTA only). This helps the user figure out
! where he/she is and how he/she got there from here.
!
! Formal parameters:
!
	bpt_index,			!Temporary breakpoint index
	ctx: REF BLOCK[0,BYTE]		!Ptr to mode context block
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

MACRO
	step_msg = %STRING('Single-step at ') %,
	on_msg = %STRING(' on CPU ') %;
LITERAL
	step_msg_len = %CHARCOUNT(step_msg),
	on_msg_len = %CHARCOUNT(on_msg);
BIND
	step_message = UPLIT(BYTE(step_msg)),	!The single-step message text
	on_message = UPLIT(BYTE(on_msg)),	!The "on CPU" message text
	iregbuf = ctx[mctx$q_iregbuf],		!Register save area address
	save_pc = .iregbuf + (32 * quad_size),	!Saved PC
	origin_cpu = temp_bpts[.bpt_index,tbpt$q_cpu_id]; !Originating CPU
LOCAL
	cpu_id: INITIAL(0),			!Current CPU ID
	some_other_reason: INITIAL(0);		!Boolean flag
!
! If any breakpoints occurred or if the current CPU is different than the
! one which initiated the single-step (in XDELTA), display the single-step
! message
!
	%if xdelta %then
	  cpu_id = $cpu_id;
	  IF .cpu_id NEQ .origin_cpu THEN
	    some_other_reason = 1;
	%fi
!
	IF (.ctx[mctx$v_breaks]) OR (.some_other_reason) THEN
	  BEGIN
	    new_line();
	    put_string(step_msg_len,step_message);
	    put_hex(.save_pc,.ctx[mctx$l_data_length] ^ 1);
!
	    IF .some_other_reason THEN
	      BEGIN
		put_string(on_msg_len,on_message);
		put_dec(.cpu_id);
	      END;
	  END;
!
	RETURN ss$_normal;
END; 					! ROUTINE single_step_message


ROUTINE flush_input(
!++
! Functional description:
!
!	This routine flushes the input buffer.
!
! Formal parameters:
!
	ctx: REF BLOCK[0,BYTE]		!Ptr to mode context block
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

BIND
	input_ptr = ctx[mctx$q_input_ptr] : REF VECTOR[,BYTE];
!
! Reset the pointer to the beginning of the input buffer and set the
! first byte in the input buffer itself to be zero, indicating the end
! of the input buffer (How many times do you think you can use the term
! "input buffer" in one sentence?)
!
	input_ptr = ctx[mctx$b_input_buffer];
	input_ptr[0] = 0;
!
	RETURN ss$_normal;
END; 					! ROUTINE flush_input


ROUTINE get_char(
!++
! Functional description:
!
!	This routine retrieves the next input character. They are pulled
! out of the input buffer until it is empty, at which point fill_input_buffer
! is called to fill 'er up again. The input buffer is expected to be an
! ASCIZ string and could be anywhere in memory. However, when the terminator
! is reached, fill_input_buffer resets the input buffer to the beginning of
! the local buffer again. This routine is independent of input device type
! and whether we're running in DELTA or XDELTA.
!
! Formal parameters:
!
	ctx: REF BLOCK[0,BYTE],		!Ptr to mode context block
	next_char_adr			!Address for next input character
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

BIND
	inptr = ctx[mctx$q_input_ptr] : REF VECTOR[,BYTE];
!
! First, make sure our input buffer pointer is pointing to something
! worthwhile (if it's pointing to a null, then it's time to refill the
! input buffer).
!
	WHILE .inptr[0] EQL 0 DO
	  fill_input_buffer(.ctx);
!
! OK, we have something nonzero. Return it and update the input pointer
! to point to the next potential character in the input buffer. Note that
! we're converting to upper case as we go along even though it's a bit
! redundant given that fill_input_buffer also does this. The reason is that
! we may be pointing into a user command buffer which may not be in
! upper case.
!
	IF (.inptr[0] AND %X'40') NEQ 0 THEN
	  .next_char_adr = .inptr[0] AND (NOT %X'20')
	ELSE
	  .next_char_adr = .inptr[0];
	inptr = .inptr + 1;
!
	RETURN ss$_normal;
END; 					! ROUTINE get_char


ROUTINE fill_input_buffer(
!++
! Functional description:
!
!	This routine retrieves a terminated input command line from the
! input device and fills the input buffer for get_char. It uses a $QIO
! interface for DELTA where in XDELTA, it depends on whether we're running
! on the primary or some other CPU. The primary reads data directly from
! the console and the others use the virtual console interface.
!	Data is stored in the input buffer as an ASCIZ string. When get_char
! has reached the end of the string, the input buffer is reset to the
! beginning again. No fancy ring buffers in this code!
!
! Formal parameters:
!
	ctx: REF BLOCK[0,BYTE]		!Ptr to mode context block
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

BIND
	input_ptr = ctx[mctx$q_input_ptr] : REF VECTOR[,BYTE];
!
! Reset the input buffer pointer
!
	input_ptr = ctx[mctx$b_input_buffer];
!
! If this is DELTA, we use a $QIO read operation, specifying the appropriate
! terminators, to retrieve the input data. Resource errors imply a certain
! number of retries...
!
	%if delta %then
	BEGIN

	LOCAL
	  done: INITIAL(0),			!Boolean loop terminator
	  loop_counter: INITIAL(0),		!Loop iteration counter
	  term_desc: VECTOR[2,LONG]		!Termination mask descriptor
	    INITIAL(LONG(			!Initialized at runtime
	      term_mask_size,			!for the temp solution only
	      term_mask				!to point to the termination
	    )),					!mask size and address
	  status;				!Return status
!
	  WHILE NOT .done DO
	    BEGIN
	      status = $QIOW(
			EFN  = in_efn,
			CHAN = .ttchan,
			FUNC = IO$_READVBLK OR IO$M_EXTEND,
			IOSB = iosb,
			P1   = .input_ptr,
			P2   = cmd_size - 1,
			P5   = item_list,
			P6   = item_list_size * long_size);
	      IF (.status EQL ss$_insfmem) OR (.status EQL ss$_exquota) OR
	        ((.status GEQ ss$_exquotastrt) AND (.status LEQ ss$_exquotaend))
	      THEN
		BEGIN
!***		  $waitfr( EFN = in_efn );
		  loop_counter = .loop_counter + 1;
		  IF .loop_counter GEQ max_retries THEN
		    done = 1;
		END
	      ELSE
		done = 1;
	    END;
!
! Now that we've kicked out of the read loop, we presumably have something
! in the input buffer (as long as we didn't exceed our retry count trying).
! The final step is to make sure the buffer is properly terminated.
!
!***	  IF .status THEN
	  IF .loop_counter LSS max_retries THEN
	    IF .iosb[0] THEN
	      IF .iosb[1] LSS (cmd_size - 1) THEN
		input_ptr[1 + .iosb[1]] = 0
	      ELSE
		input_ptr[cmd_size - 1] = 0;
	END;
!
! For XDELTA, there are a couple of possibilities. The primary processor
! reads data directly from the console. Other processors use the virtual
! console interface. In either case, we loop until we see an acceptable
! terminator and fill the input buffer one character at a time. Note that
! we must also handle terminal editing functions to some degree such as
! <DEL>.
!
	%else
	BEGIN

	BIND
	  tmp_ptr = ctx[mctx$b_input_buffer] : VECTOR[,BYTE];
	LOCAL
	  done: INITIAL(0),		!To kick out of the loop
	  the_char: INITIAL(0),		!The input character
	  char_count: INITIAL(0),	!Character counter
	  rubout: INITIAL(0),		!Rubout state flag
	  quoted: INITIAL(0),		!Quoted string state flag
	  cpu_id;			!The current CPU ID
!
! Now loop, reading characters from the appropriate place, until we see
! a valid read terminator
!
	WHILE (NOT .done) AND ((cmd_size - .char_count) GTR 1)  DO
	  BEGIN
!
! If we're the primary CPU, read the data directly from the console. Otherwise,
! use the virtual console interface
!
	    IF $init_done THEN
	      BEGIN
		cpu_id = $cpu_id;
		IF .cpu_id EQL .smp$gl_primid THEN
		  the_char = con$getchar()
		ELSE
		  virtual_getchar(the_char);
	      END
	    ELSE
	      the_char = con$getchar();
!
! If this is one of those special characters...you know, like a <DEL>, we
! have to do some really, really advanced editing functions here. Watch
! closely...Nothing up my sleeve...
!
! Basically, if we see a delete character and the buffer's empty, we don't
! do anything. If the buffer's nonempty, we back up the pointer one character
! and then do the "rubout" depending on the mode. We either do a scope-type
! of rubout or do a hardcopy rubout sequence.
!
	    IF (.the_char EQL delete) AND (.char_count GTR 0) THEN
	      BEGIN
		char_count = .char_count - 1;
		IF (.tmp_ptr[.char_count] EQL quote) OR
		   (.tmp_ptr[.char_count] EQL back_slash) THEN
		  quoted = NOT .quoted;
		IF .ctx[mctx$v_hardcopy] THEN
		  BEGIN
		    IF NOT .rubout THEN
		      put_char(back_slash);
		    put_char(.tmp_ptr[.char_count]);
		    rubout = 1;
		  END
		ELSE
		  BEGIN
		    put_char(back_space);
		    put_char(space);
		    put_char(back_space);
		  END;
	      END
!
! OK, if it wasn't a <DEL> character at all, we still have a few odds and
! ends to do...such as terminate a rubout sequence perhaps...
!
	    ELSE
	      IF .the_char NEQ delete THEN
		BEGIN
		  IF .rubout THEN
		    BEGIN
		      put_char(back_slash);
		      rubout = 0;
		    END;
!
! Convert the character to uppercase, if appropriate, and stuff it ever
! so gently into the input buffer
!
		  IF (.the_char AND %X'40') NEQ 0 THEN
		    IF NOT .quoted THEN
		      the_char = .the_char AND (NOT %X'20');
		  tmp_ptr[.char_count] = .the_char;
		  char_count = .char_count + 1;
!
! Now, control characters get echoed as spaces and act as terminators.
! Other characters get echoed "as is" but are then checked against the
! command terminator list to see if we're done (as long as we're not in
! the middle of processing a quoted string)
!
		  IF .the_char LSS space THEN
		    BEGIN
		      put_char(space);
		      done = 1;
		    END
		  ELSE
		    BEGIN
		      put_char(.the_char);
		      IF (.the_char EQL quote) OR
			 (.the_char EQL back_slash) THEN
			quoted = NOT .quoted
		      ELSE
			IF NOT .quoted THEN
			  IF (.the_char EQL slash) OR
			     (.the_char EQL double_quote) OR
			     (.the_char EQL %C'!') OR
			     (.the_char EQL %C'=') OR
			     (.the_char EQL %C'S') OR
			     (.the_char EQL %C'O') THEN
			    done = 1;
		    END;
		END;
	  END;
!
! Now that we're out of the read loop, make sure the input buffer is
! properly terminated before returning
!
	  tmp_ptr[.char_count] = 0;
	END;
	%fi
!
	RETURN ss$_normal;
END; 					! ROUTINE fill_input_buffer


ROUTINE peek_char(
!++
! Functional description:
!
!	This routine permits a look-ahead at the input stream without
! "getting" those characters. Normally, this is used to look at the next
! character in the input stream (index = 0).
!
! Formal parameters:
!
	ctx: REF BLOCK[0,BYTE],		!Ptr to mode context block
	index,				!Index into input stream
	next_char_adr			!Address for next input character
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

BIND
	input_ptr = ctx[mctx$q_input_ptr] : REF VECTOR[,BYTE];
!
! Just return the specified byte, regardless of what it is, converting it
! to uppercase if necessary
!
	IF (.input_ptr[.index] AND %X'40') NEQ 0 THEN
	  .next_char_adr = .input_ptr[.index] AND (NOT %X'20')
	ELSE
	  .next_char_adr = .input_ptr[.index];
!
	RETURN ss$_normal;
END; 					! ROUTINE peek_char


ROUTINE get_register(
!++
! Functional description:
!
!	This routine retrieves a register number from the input stream. It
! looks ahead in the input stream before deciding what to do and returns an
! error status if no register number is discovered. The register number is
! converted into the specified base before being returned. Note that "old
! style" register numbers specified in hex are still supported for some
! mysterious unknown reason.
!
! Formal parameters:
!
	base,				!Base for number to be returned
	ctx: REF BLOCK[0,BYTE],		!Ptr to mode context block
	regnum				!Address for register number returned
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	1 (or true)  : Normal successful completion status
!	0 (or false) : No register number found
!
! Side effects:
!
!	None
!
!--

BEGIN

LOCAL
	accumulator: INITIAL(0),		!For value to be returned
	digit,					!Temp. for digit
	new_char,				!Next input character
	done: INITIAL(0),			!To kick out of the loop
	got_one: INITIAL(0);			!To insure we do it once anyway
!
! Loop while we still see digits of a register number in the input stream,
! peeking ahead first before removing those characters from the input stream.
! Each digit is converted from ascii to integer and, using the specified
! base, added to the accumulator to form a register number.
!
	WHILE NOT .done DO
	  BEGIN
	    IF NOT peek_char(.ctx,0,new_char) THEN
	      input_reset(.ctx)
	    ELSE
	      BEGIN
	        IF (.new_char GEQ %C'0') AND (.new_char LEQ %C'9') THEN
	          digit = .new_char - %C'0'
	        ELSE
	          IF (.new_char GEQ %C'A') AND (.new_char LEQ %C'F') THEN
		    digit = .new_char - %C'A' + 10
	          ELSE
		    done = 1;
!
	        IF NOT .done THEN
	          BEGIN
	            get_char(.ctx,new_char);
		    accumulator = (.accumulator * .base) + .digit;
		    got_one = 1;
	          END;
	      END;
	  END;
!
! Pass the result back along with an indicator as to whether a register
! number was found in the input stream
!
	IF .got_one THEN
	  BEGIN
	    .regnum = .accumulator;
	    RETURN ss$_normal;
	  END
	ELSE
	  RETURN 0;
END; 					! ROUTINE get_register


ROUTINE get_fp_register(
!++
! Functional description:
!
!	This routine retrieves a floating point register number from the input
! stream. It looks ahead in the input stream before deciding what to do and
! returns an error status if no register number is discovered. The register
! number is converted into the specified base before being returned. Note that
! "old style" register numbers specified in hex are still supported for some
! mysterious unknown reason.
!
! Formal parameters:
!
	base,				!Base for number to be returned
	ctx: REF BLOCK[0,BYTE],		!Ptr to mode context block
	regnum				!Address for register number returned
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	1 (or true)  : Normal successful completion status
!	0 (or false) : No register number found
!
! Side effects:
!
!	None
!
!--

BEGIN

LOCAL
	accumulator: INITIAL(0),		!For value to be returned
	digit,					!Temp. for digit
	new_char,				!Next input character
	done: INITIAL(0),			!To kick out of the loop
	got_one: INITIAL(0);			!To insure we do it once anyway
!
! Look ahead in the input stream to see if a "P" immediately follows the "F".
! If not, return an error (not an FP register).
!
	IF NOT peek_char(.ctx,0,new_char) THEN
	  BEGIN
	    input_reset(.ctx);
	    RETURN 0;
	  END;
!
	IF .new_char NEQ %C'P' THEN
	  RETURN 0;
!
! Make sure that the character which follows the "P" is a numeric (or the
! letter "C" for FPCR). If it is, assume it's safe to extract the "P" from
! the input stream and toss it aside like some piece of used trash. Otherwise,
! the "P" might be the start of an IPR specifier which requires processing in
! the top-level command scanner.
!
	IF NOT peek_char(.ctx,1,new_char) THEN
	  BEGIN
	    input_reset(.ctx);
	    RETURN 0;
	  END;
!
	IF (.new_char LSS %C'0') OR (.new_char GTR %C'9') AND
	   (.new_char NEQ %C'C') THEN
	  RETURN 0;
!
! FPCR is stuck at the end and treated like FP32. So if the user specified
! FPCR, we can safely just assign the pseudo register number and not parse
! for it.
!
	IF .new_char EQL %C'C' THEN
	  BEGIN
	    get_char(.ctx,new_char);
	    get_char(.ctx,new_char);
	    IF NOT peek_char(.ctx,0,new_char) THEN
	      BEGIN
	        input_reset(.ctx);
	        RETURN 0;
	      END;
	    IF .new_char NEQ %C'R' THEN
	      RETURN 0;
	    get_char(.ctx,new_char);
	    .regnum = 32;
	    RETURN ss$_normal;
	  END;
!
	get_char(.ctx,new_char);
!
! Loop while we still see digits of a register number in the input stream,
! peeking ahead first before removing those characters from the input stream.
! Each digit is converted from ascii to integer and, using the specified
! base, added to the accumulator to form a register number.
!
	WHILE NOT .done DO
	  BEGIN
	    IF NOT peek_char(.ctx,0,new_char) THEN
	      input_reset(.ctx)
	    ELSE
	      BEGIN
	        IF (.new_char GEQ %C'0') AND (.new_char LEQ %C'9') THEN
	          digit = .new_char - %C'0'
	        ELSE
	          IF (.new_char GEQ %C'A') AND (.new_char LEQ %C'F') THEN
		    digit = .new_char - %C'A' + 10
	          ELSE
		    done = 1;
!
	        IF NOT .done THEN
	          BEGIN
	            get_char(.ctx,new_char);
		    accumulator = (.accumulator * .base) + .digit;
		    got_one = 1;
	          END;
	      END;
	  END;
!
! Pass the result back along with an indicator as to whether a register
! number was found in the input stream
!
	IF .got_one THEN
	  BEGIN
	    .regnum = .accumulator;
	    RETURN ss$_normal;
	  END
	ELSE
	  RETURN 0;
END; 					! ROUTINE get_fp_register


ROUTINE get_preg(
!++
! Functional description:
!
!	This routine retrieves a processor register name from the input stream.
! Yes, I said "name" and not number since there are no processor register
! numbers on EVAX analogous to VAX. Instead, there are PAL calls to manipulate
! processor-specific data which, in some cases, resembles what used to be
! stored in VAX processor registers. So, to provide a reference model, we
! still deal with them like processor registers in XDELTA for the most part.
!	This routine is invoked after the user has typed "P" to indicate
! that what follows is a processor register specifier. The name itself is
! entered in parenthesis (e.g. P(ASTEN) or P(IPL)). These will usually be
! followed by a "/" to "open" the location for reading and/or writing. However,
! it should be noted that some processor registers are read-only or write-only.
!	This routine looks ahead in the input stream before deciding what to do
! and returns an error status if no appropriate register name is discovered.
! The characters are only removed from the input stream if they look like a
! valid register name in parenthesis.
!	Internally, what is stored is a constant known only to XDELTA which
! represents a particular register. Reading and writing of processor
! registers use this constant to figure out which PAL calls to use.
!
! Formal parameters:
!
	ctx: REF BLOCK[0,BYTE]		!Ptr to mode context block
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	1 (or true)  : Normal successful completion status
!	0 (or false) : No register number found
!
! Side effects:
!
!	None
!
!--

BEGIN

BIND
	val = ctx[mctx$q_val] : SIGNED;		!The current value
LITERAL
	max_reg_name = 10;			!Max. allowed register name size
LOCAL
	new_char,				!Next input character
	name_size: INITIAL(0),			!Register name size
	name_buffer: VECTOR[max_reg_name,BYTE];	!The register name buffer
!
! The first thing we should find in the input stream is either a "(" to signify
! the start of a processor name string or a "C" or "S" for PC or PS
! respectively. Otherwise, it's an error.
!
	IF NOT peek_char(.ctx,0,new_char) THEN
	  BEGIN
	    input_reset(.ctx);
	    RETURN 0;
	  END;
!
	IF (.new_char EQL %C'(') OR (.new_char EQL %C'C')
	OR (.new_char EQL %C'S') THEN
	  get_char(.ctx,new_char)
	ELSE
	  RETURN 0;
!
! PC and PS are handled like normal registers
!
	IF (.new_char EQL %C'C') THEN
	  BEGIN
	    BIND iregbuf = ctx[mctx$q_iregbuf];
	    val = .iregbuf + (32 * quad_size);
	    ctx[mctx$v_infield] = 1;
	    RETURN ss$_normal;
	  END;
!
	IF (.new_char EQL %C'S') THEN
	  BEGIN
	    BIND iregbuf = ctx[mctx$q_iregbuf];
	    val = .iregbuf + (33 * quad_size);
	    ctx[mctx$v_infield] = 1;
	    RETURN ss$_normal;
	  END;
!
! Now we want to pull in characters until we see the ")" string terminator
! and store them away.
!
	WHILE (.new_char NEQ %C')') AND (.name_size LSS max_reg_name) DO
	  BEGIN
	    IF NOT get_char(.ctx,new_char) THEN
	      input_reset(.ctx)
	    ELSE
	      IF .new_char NEQ %C')' THEN
	        BEGIN
		  name_buffer[.name_size] = .new_char;
		  name_size = .name_size + 1;
	        END;
	  END;
!
! If we didn't get anything between the parenthesis or never saw the
! terminating parenthesis, return an error
!
	IF (.name_size EQL 0) OR (.name_size GEQ max_reg_name) THEN
	  RETURN 0;
!
! OK, now that we have something, we have to figure out what it is to
! return the appropriate pseudo processor register number. This could be
! setup as a table of known names to match against, building in assumptions
! about the ordering of the register numbers...or else we can do it inline
! with no such dependency. For the time being, it's inline. Modifications
! to the processor register set must be reflected below.
!
	 IF ch$eql(
		.name_size,name_buffer,
		asn_string_size,asn_string_adr,
		%C' ') THEN
	  BEGIN
	    val = pr$k_asn;
	    ctx[mctx$v_infield] = 1;
	    ctx[mctx$v_prmode] = 1;
	    RETURN ss$_normal;
	  END;
!
	 IF ch$eql(
		.name_size,name_buffer,
		asten_string_size,asten_string_adr,
		%C' ') THEN
	  BEGIN
	    val = pr$k_asten;
	    ctx[mctx$v_infield] = 1;
	    ctx[mctx$v_prmode] = 1;
	    RETURN ss$_normal;
	  END;
!
	 IF ch$eql(
		.name_size,name_buffer,
		astsr_string_size,astsr_string_adr,
		%C' ') THEN
	  BEGIN
	    val = pr$k_astsr;
	    ctx[mctx$v_infield] = 1;
	    ctx[mctx$v_prmode] = 1;
	    RETURN ss$_normal;
	  END;
!
	 IF ch$eql(
		.name_size,name_buffer,
		esp_string_size,esp_string_adr,
		%C' ') THEN
	  BEGIN
	    val = pr$k_esp;
	    ctx[mctx$v_infield] = 1;
	    ctx[mctx$v_prmode] = 1;
	    RETURN ss$_normal;
	  END;
!
	 IF ch$eql(
		.name_size,name_buffer,
		fen_string_size,fen_string_adr,
		%C' ') THEN
	  BEGIN
	    val = pr$k_fen;
	    ctx[mctx$v_infield] = 1;
	    ctx[mctx$v_prmode] = 1;
	    RETURN ss$_normal;
	  END;
!
	 IF ch$eql(
		.name_size,name_buffer,
		ipir_string_size,ipir_string_adr,
		%C' ') THEN
	  BEGIN
	    val = pr$k_ipir;
	    ctx[mctx$v_infield] = 1;
	    ctx[mctx$v_prmode] = 1;
	    RETURN ss$_normal;
	  END;
!
	 IF ch$eql(
		.name_size,name_buffer,
		ipl_string_size,ipl_string_adr,
		%C' ') THEN
	  BEGIN
	    val = pr$k_ipl;
	    ctx[mctx$v_infield] = 1;
	    ctx[mctx$v_prmode] = 1;
	    RETURN ss$_normal;
	  END;
!
	 IF ch$eql(
		.name_size,name_buffer,
		mces_string_size,mces_string_adr,
		%C' ') THEN
	  BEGIN
	    val = pr$k_mces;
	    ctx[mctx$v_infield] = 1;
	    ctx[mctx$v_prmode] = 1;
	    RETURN ss$_normal;
	  END;
!
	 IF ch$eql(
		.name_size,name_buffer,
		pcbb_string_size,pcbb_string_adr,
		%C' ') THEN
	  BEGIN
	    val = pr$k_pcbb;
	    ctx[mctx$v_infield] = 1;
	    ctx[mctx$v_prmode] = 1;
	    RETURN ss$_normal;
	  END;
!
!	 IF ch$eql(
!		.name_size,name_buffer,
!		perfmon_string_size,perfmon_string_adr,
!		%C' ') THEN
!	  BEGIN
!	    val = pr$k_perfmon;
!	    ctx[mctx$v_infield] = 1;
!	    ctx[mctx$v_prmode] = 1;
!	    RETURN ss$_normal;
!	  END;
!
	 IF ch$eql(
		.name_size,name_buffer,
		prbr_string_size,prbr_string_adr,
		%C' ') THEN
	  BEGIN
	    val = pr$k_prbr;
	    ctx[mctx$v_infield] = 1;
	    ctx[mctx$v_prmode] = 1;
	    RETURN ss$_normal;
	  END;
!
	 IF ch$eql(
		.name_size,name_buffer,
		ptbr_string_size,ptbr_string_adr,
		%C' ') THEN
	  BEGIN
	    val = pr$k_ptbr;
	    ctx[mctx$v_infield] = 1;
	    ctx[mctx$v_prmode] = 1;
	    RETURN ss$_normal;
	  END;
!
	 IF ch$eql(
		.name_size,name_buffer,
		rscc_string_size,rscc_string_adr,
		%C' ') THEN
	  BEGIN
	    val = pr$k_rscc;
	    ctx[mctx$v_infield] = 1;
	    ctx[mctx$v_prmode] = 1;
	    RETURN ss$_normal;
	  END;
!
	 IF ch$eql(
		.name_size,name_buffer,
		scbb_string_size,scbb_string_adr,
		%C' ') THEN
	  BEGIN
	    val = pr$k_scbb;
	    ctx[mctx$v_infield] = 1;
	    ctx[mctx$v_prmode] = 1;
	    RETURN ss$_normal;
	  END;
!
	 IF ch$eql(
		.name_size,name_buffer,
		sirr_string_size,sirr_string_adr,
		%C' ') THEN
	  BEGIN
	    val = pr$k_sirr;
	    ctx[mctx$v_infield] = 1;
	    ctx[mctx$v_prmode] = 1;
	    RETURN ss$_normal;
	  END;
!
	 IF ch$eql(
		.name_size,name_buffer,
		sisr_string_size,sisr_string_adr,
		%C' ') THEN
	  BEGIN
	    val = pr$k_sisr;
	    ctx[mctx$v_infield] = 1;
	    ctx[mctx$v_prmode] = 1;
	    RETURN ss$_normal;
	  END;
!
	 IF ch$eql(
		.name_size,name_buffer,
		ssp_string_size,ssp_string_adr,
		%C' ') THEN
	  BEGIN
	    val = pr$k_ssp;
	    ctx[mctx$v_infield] = 1;
	    ctx[mctx$v_prmode] = 1;
	    RETURN ss$_normal;
	  END;
!
	 IF ch$eql(
		.name_size,name_buffer,
		tbchk_string_size,tbchk_string_adr,
		%C' ') THEN
	  BEGIN
	    val = pr$k_tbchk;
	    ctx[mctx$v_infield] = 1;
	    ctx[mctx$v_prmode] = 1;
	    RETURN ss$_normal;
	  END;
!
	 IF ch$eql(
		.name_size,name_buffer,
		tbia_string_size,tbia_string_adr,
		%C' ') THEN
	  BEGIN
	    val = pr$k_tbia;
	    ctx[mctx$v_infield] = 1;
	    ctx[mctx$v_prmode] = 1;
	    RETURN ss$_normal;
	  END;
!
	 IF ch$eql(
		.name_size,name_buffer,
		tbiap_string_size,tbiap_string_adr,
		%C' ') THEN
	  BEGIN
	    val = pr$k_tbiap;
	    ctx[mctx$v_infield] = 1;
	    ctx[mctx$v_prmode] = 1;
	    RETURN ss$_normal;
	  END;
!
	 IF ch$eql(
		.name_size,name_buffer,
		tbis_string_size,tbis_string_adr,
		%C' ') THEN
	  BEGIN
	    val = pr$k_tbis;
	    ctx[mctx$v_infield] = 1;
	    ctx[mctx$v_prmode] = 1;
	    RETURN ss$_normal;
	  END;
!
	 IF ch$eql(
		.name_size,name_buffer,
		tbisd_string_size,tbisd_string_adr,
		%C' ') THEN
	  BEGIN
	    val = pr$k_tbisd;
	    ctx[mctx$v_infield] = 1;
	    ctx[mctx$v_prmode] = 1;
	    RETURN ss$_normal;
	  END;
!
	 IF ch$eql(
		.name_size,name_buffer,
		tbisi_string_size,tbisi_string_adr,
		%C' ') THEN
	  BEGIN
	    val = pr$k_tbisi;
	    ctx[mctx$v_infield] = 1;
	    ctx[mctx$v_prmode] = 1;
	    RETURN ss$_normal;
	  END;
!
	 IF ch$eql(
		.name_size,name_buffer,
		usp_string_size,usp_string_adr,
		%C' ') THEN
	  BEGIN
	    val = pr$k_usp;
	    ctx[mctx$v_infield] = 1;
	    ctx[mctx$v_prmode] = 1;
	    RETURN ss$_normal;
	  END;
!
	 IF ch$eql(
		.name_size,name_buffer,
		vptbase_string_size,vptbase_string_adr,
		%C' ') THEN
	  BEGIN
	    val = pr$k_vptbase;
	    ctx[mctx$v_infield] = 1;
	    ctx[mctx$v_prmode] = 1;
	    RETURN ss$_normal;
	  END;
!
	 IF ch$eql(
		.name_size,name_buffer,
		whami_string_size,whami_string_adr,
		%C' ') THEN
	  BEGIN
	    val = pr$k_whami;
	    ctx[mctx$v_infield] = 1;
	    ctx[mctx$v_prmode] = 1;
	    RETURN ss$_normal;
	  END;
!
	RETURN 0;			! Return error (no match found)
END; 					! ROUTINE get_preg

 
!ROUTINE cvt_hex(
!!++
!! Functional description:
!!
!!	This routine converts a hex value into a string.
!!
!! Formal parameters:
!!
!	hex_value,			!The value to convert
!	width,				!Number of digits
!	hex_str: REF VECTOR[0,BYTE]	!Resultant hex string
!	) =
!!
!! Implicit inputs:
!!
!!	None
!!
!! Implicit outputs:
!!
!!	None
!!
!! Routine value:
!! Completion codes:
!!
!!	SS$_NORMAL : Normal successful completion status
!!	0 : Unable to convert specified value
!!
!! Side effects:
!!
!!	None
!!
!!--
!
!BEGIN
!
!LOCAL
!	val,				!Local copy of hex value
!	this_digit;			!A particular digit
!!
!! The width argument cannot be bigger than (%BPVAL/4), which is the number
!! of ascii bytes it takes to represent a 32-bit or 64-bit hex value. Return
!! an error if something larger was specified.
!!
!	IF .width GTR (%BPVAL / 4) THEN
!	  RETURN 0;
!!
!! Loop for each digit (based on the specified width), converting each
!! nibble into its hex string equivalent. Note that nibbles are extracted
!! from right to left but stored in the resultant string from left to
!! right.
!!
!	val = .hex_value;
!!
!	DECR digit_ctr FROM (.width - 1) TO 0 DO
!	  BEGIN
!	    this_digit = .val AND %X'F';
!	    IF .this_digit LSS %X'A' THEN
! 	      hex_str[.digit_ctr] = .this_digit + %C'0'
!	    ELSE
!	      hex_str[.digit_ctr] = .this_digit - %X'A' + %C'A';
!	    val = .val ^ -4;
!	  END;
!!
!	RETURN ss$_normal;
!END; 					! ROUTINE cvt_hex


!ROUTINE cvt_dec(
!!++
!! Functional description:
!!
!!	This routine converts a decimal value into a string.
!!
!! Formal parameters:
!!
!	dec_value,			!The value to convert
!	width,				!Number of digits
!	dec_str: REF VECTOR[0,BYTE]	!Resultant decimal string
!	) =
!!
!! Implicit inputs:
!!
!!	None
!!
!! Implicit outputs:
!!
!!	None
!!
!! Routine value:
!! Completion codes:
!!
!!	SS$_NORMAL : Normal successful completion status
!!
!! Side effects:
!!
!!	None
!!
!!--
!
!BEGIN
!
!LOCAL
!	val,				!Local copy of decimal value
!	this_digit;			!A particular digit
!!
!! Loop for each digit (based on the specified width), converting each
!! decimal digit into its decimal string equivalent. Note that the value
!! is processed from right to left but stored in the resultant string
!! from left to right.
!!
!	val = .dec_value;
!!
!	DECR digit_ctr FROM (.width - 1) TO 0 DO
!	  BEGIN
!	    this_digit = .val MOD 10;
! 	    dec_str[.digit_ctr] = .this_digit + %C'0';
!	    val = .val / 10;
!	  END;
!!
!	RETURN ss$_normal;
!END; 					! ROUTINE cvt_dec


ROUTINE cmd_reset(
!++
! Functional description:
!
!	This routine resets the input scanner at the end of a command. So
! any command-specific state is initialized here.
!
! Formal parameters:
!
	ctx: REF BLOCK[0,BYTE]		!Ptr to mode context block
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

BIND
	val = ctx[mctx$q_val],			!The current value
	expression = ctx[mctx$q_expression],	!Current expression value
	fld = ctx[mctx$q_fields] : VECTOR,	!Input fields
	gh_prefix = ctx[mctx$q_gh_prefix];	!G/H prefix value
!
! Reinitialize all the pertinent fields
!
	ctx[mctx$v_infield] = 0;
	ctx[mctx$v_negate] = 0;
	ctx[mctx$v_prefix_flag] = 0;
	ctx[mctx$v_prmode] = 0;
!
	val = 0;
	expression = 0;
	gh_prefix = 0;
	ctx[mctx$l_field_counter] = 0;
	ctx[mctx$l_fflg] = 0;
	ctx[mctx$l_operator] = opr$k_add;
!
	INCR index FROM 0 TO (num_fields - 1) DO
	  fld[.index] = 0;
!
	RETURN ss$_normal;
END; 					! ROUTINE cmd_reset


ROUTINE input_reset(
!++
! Functional description:
!
!	This routine resets the input scanner to its initial state.
!
! Formal parameters:
!
	ctx: REF BLOCK[0,BYTE]		!Ptr to mode context block
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

!
! Do a command reset and flush the input buffer
!
	flush_input(.ctx);
	cmd_reset(.ctx);
!
! Reinitialize all the pertinent fields
!
	ctx[mctx$v_scanner_done] = 0;
	ctx[mctx$v_open] = 0;
	ctx[mctx$v_preg] = 0;
	ctx[mctx$l_pid] = 0;
!
	RETURN ss$_normal;
END; 					! ROUTINE input_reset


ROUTINE internal_error(
!++
! Functional description:
!
!	This routine handles internal debugger errors. An error message
! is displayed. The command parser is reset as is the input buffer after
! calling this routine.
! 	This routine takes a status parameter which gives some indication
! of the error. Nothing is done with this error status currently. At some
! point, it might be helpful to either display it or some appropriate error
! text.
!
! Formal parameters:
!
	ctx: REF BLOCK[0,BYTE],		!Ptr to mode context block
	status				!Error status code
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	None
!
! Side effects:
!
!	None
!
!--

BEGIN

MACRO
	error_msg = %STRING('Eh?') %;
LITERAL
	error_msg_len = 4 + %CHARCOUNT(error_msg);
BIND
	error_msg_buf = UPLIT(BYTE(
				cr,lf,
				error_msg,
				cr,lf));
!
! Display a remarkably informative error message
!
	put_string(error_msg_len,error_msg_buf);
!
! Reset the command scanner and input buffer
!
	cmd_reset(.ctx);
	flush_input(.ctx);
!
	RETURN ss$_normal;
END; 					! ROUTINE internal_error


ROUTINE end_expression(
!++
! Functional description:
!
!	This routine terminates the current expression. The last value
! from the input stream is merged with the current expression using the
! stored arithmetic operator. Appropriate flags and holding cells are
! then cleared for the next expression.
!
! Formal parameters:
!
	ctx: REF BLOCK[0,BYTE]		!Ptr to mode context block
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

BIND
	val = ctx[mctx$q_val] : SIGNED,		!The current value
	expression = ctx[mctx$q_expression]	!Current expression value
	  : SIGNED,				!
	gh_prefix = ctx[mctx$q_gh_prefix];	!G/H prefix value
!
! If we need to negate or apply a G/H prefix to the current value, do it
!
	IF .ctx[mctx$v_prefix_flag] THEN
	  BEGIN
	    ctx[mctx$v_prefix_flag] = 0;
	    val = .val + .gh_prefix;
	    gh_prefix = 0;
	  END;
!
	IF .ctx[mctx$v_negate] THEN
	  BEGIN
	    ctx[mctx$v_negate] = 0;
	    val = - (.val);
	  END;
!
! Now, based on the currently stored operator, include this value in the
! current expression
!
	SELECTONE .ctx[mctx$l_operator] OF
	  SET
	    [opr$k_add] : expression = .expression + .val;
	    [opr$k_shift] : expression = .expression ^ .val;
	    [opr$k_multiply] : expression = .expression * .val;
	    [opr$k_divide] : expression = .expression / .val;
	  TES;
!
! Reset the value and operator cells for the next time around
!
	val = 0;
	ctx[mctx$l_operator] = opr$k_add;
!
	RETURN ss$_normal;
END; 					! ROUTINE end_expression


ROUTINE end_field(
!++
! Functional description:
!
!	This routine terminates the current input field. The current
! expression (if any) is terminated, the value saved. The expression and
! value holding cells are reset for the next time around.
!
! Formal parameters:
!
	ctx: REF BLOCK[0,BYTE]		!Ptr to mode context block
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

BIND
	val = ctx[mctx$q_val],			!The current value
	expression = ctx[mctx$q_expression],	!Current expression value
	gh_prefix = ctx[mctx$q_gh_prefix];	!G/H prefix value
!
! If we're not in the middle of processing an input field, then we shouldn't
! be here in the first place. So just return.
!
	IF NOT .ctx[mctx$v_infield] THEN
	  RETURN ss$_normal;
!
! If we're in the process of scanning an input field, terminate the current
! expression and save this field.
!
	ctx[mctx$v_infield] = 0;
	end_expression(.ctx);
!
	IF .ctx[mctx$l_field_counter] GEQ num_fields THEN
	  RETURN 0
	ELSE
!
! Update the field flags, appropriate field storage cell, and field counter
!
	  BEGIN
	    BIND
	      fld_flags = ctx[mctx$l_fflg] : BITVECTOR,
	      fld = ctx[mctx$q_fields] : VECTOR,
	      fld_count = ctx[mctx$l_field_counter];
!
	    fld_flags[.fld_count] = 1;
	    fld[.fld_count] = .expression;
	    fld_count = .fld_count + 1;
	  END;
!
! Reset for the next field to come our way
!
	expression = 0;
	val = 0;
	gh_prefix = 0;
!
	RETURN ss$_normal;
END; 					! ROUTINE end_field


ROUTINE next_dot(
!++
! Functional description:
!
!	This routine increments the "current" location. The increment depends
! on the current display mode. So, for example, if we're in instruction
! display mode, the increment is the instruction length. If we're in "normal"
! data display mode, then it depends on whether we're in byte, word, longword,
! or quadword display mode.
!
! Formal parameters:
!
	ctx: REF BLOCK[0,BYTE]		!Ptr to mode context block
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

BIND
	dot = ctx[mctx$q_dot],			!Current location
	iregbuf = ctx[mctx$q_iregbuf],		!GPR save area address
	fregbuf = ctx[mctx$q_fregbuf];		!FP register save area address
LOCAL
	regnum;					!Register number
!
! If we're in instruction display mode, use the instruction size as the
! increment
!
	IF .ctx[mctx$v_instruction] THEN
	  dot = .dot + inst_size
	ELSE
!
! Well then, maybe we're displaying processor registers
!
	  IF .ctx[mctx$v_preg] THEN
	    dot = MIN(max_pr_number,.dot + preg_size)
	  ELSE
!
! If we happen to be flipping through the saved registers, then we
! must always use quadword increments. Note that optimizations can be
! put in place in the code below if you make the assumption that the
! register save areas for GPRs and FP registers are contiguous. Even
! though it's currently the case, I'm not making that assumption below.
!
	    IF ((.dot GEQU .iregbuf) AND
	        (.dot LSSU (.iregbuf + (quad_size * (num_gprs + 2))))) OR
	       ((.dot GEQU .fregbuf) AND
	        (.dot LEQU (.fregbuf + (quad_size * num_gprs)))) THEN
	      dot = .dot + quad_size
	    ELSE
!
! I guess this means we're in "normal" display mode and need to use
! the prevailing display/data type length for the increment. Note that if
! this increment bumps us into the saved register address space, we align
! the current location with R0.
!
	      BEGIN
		dot = .dot + .ctx[mctx$l_data_length];
	        IF (.dot GTRU .iregbuf) AND
	           (.dot LSSU (.iregbuf + (quad_size * (num_gprs + 2)))) THEN
		  dot = .iregbuf
		ELSE
		  IF (.dot GTRU .fregbuf) AND
		     (.dot LEQU (.fregbuf + (quad_size * num_gprs))) THEN
		    dot = .fregbuf;
	      END;
!
	RETURN ss$_normal;
END; 					! ROUTINE next_dot


ROUTINE previous_dot(
!++
! Functional description:
!
!	This routine decrements the "current" location. The amount to
! decrement depends on the current display mode. So, for example, if we're in
! instruction display mode, the amount is the instruction length. If we're in
! "normal" data display mode, then it depends on whether we're in byte, word,
! longword, or quadword display mode.
!
! Formal parameters:
!
	ctx: REF BLOCK[0,BYTE]		!Ptr to mode context block
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

BIND
	dot = ctx[mctx$q_dot],			!Current location
	iregbuf = ctx[mctx$q_iregbuf],		!GPR save area address
	fregbuf = ctx[mctx$q_fregbuf];		!FP register save area address
LOCAL
	regnum;					!Register number
!
! If we're in instruction display mode, use the instruction size as the
! decrement amount
!
	IF .ctx[mctx$v_instruction] THEN
	  dot = .dot - inst_size
	ELSE
!
! Well then, maybe we're displaying processor registers
!
	  IF .ctx[mctx$v_preg] THEN
	    dot = MAX(min_pr_number,.dot - preg_size)
	  ELSE
!
! If we happen to be flipping through the saved registers, then we
! must always use quadword decrements. Note that the code below can
! be optimized if you make the assumption that the register save areas
! (for GPRs and FP registers) are contiguous. I'm not currently making
! that assumption.
!
	    IF ((.dot GEQU .iregbuf) AND
	        (.dot LSSU (.iregbuf + (quad_size * (num_gprs + 2))))) OR
	       ((.dot GEQU .fregbuf) AND
	        (.dot LEQU (.fregbuf + (quad_size * num_gprs)))) THEN
	      dot = .dot - quad_size
	    ELSE
!
! I guess this means we're in "normal" display mode and need to use
! the prevailing display/data type length for the decrement. Note that if
! this decrement pushes us into the saved register address space, we align
! the current location with PS or FP31.
!
	      BEGIN
		dot = .dot - .ctx[mctx$l_data_length];
	        IF (.dot GTRU .fregbuf) AND
	           (.dot LEQU (.fregbuf + (quad_size * num_gprs))) THEN
		  dot = .fregbuf + (num_gprs * quad_size)
		ELSE
	          IF (.dot GTRU .iregbuf) AND
	             (.dot LSSU (.iregbuf + (quad_size * (num_gprs + 2)))) THEN
		    dot = .iregbuf + (33 * quad_size);
	      END;
!
	RETURN ss$_normal;
END; 					! ROUTINE previous_dot


ROUTINE fetch_preg(
!++
! Functional description:
!
!	This routine fetches the contents of the current location when it
! is a processor register. To do so requires that this routine execute in
! kernel mode. It is invoked by fetch_current to perform this specialized
! function.
!
! Formal parameters:
!
	ctx: REF BLOCK[0,BYTE]		!Ptr to mode context block
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

BIND
	quan = ctx[mctx$q_quan],		!Current quantity
	dot = ctx[mctx$q_dot];			!Current location
!
! Use the correct PAL call to retrieve the processor register contents
!
	CASE .dot FROM min_pr_number TO max_pr_number OF
	  SET
	    [pr$k_asn] :
	      BEGIN
		BUILTIN pal_mfpr_asn;
		quan = pal_mfpr_asn();
	      END;
	    [pr$k_asten] :
	      BEGIN
!		BUILTIN pal_mtpr_asten;
!		quan = pal_mtpr_asten(%x'F');
		BUILTIN pal_mfpr_asten;
		quan = pal_mfpr_asten();
	      END;
	    [pr$k_astsr] :
	      BEGIN
!		BUILTIN pal_mtpr_astsr;
!		quan = pal_mtpr_astsr(%x'F');
		BUILTIN pal_mfpr_astsr;
		quan = pal_mfpr_astsr();
	      END;
	    [pr$k_esp] :
	      BEGIN
		BUILTIN pal_mfpr_esp;
		quan = pal_mfpr_esp();
	      END;
	    [pr$k_fen] :
	      BEGIN
		BUILTIN pal_mfpr_fen;
		quan = pal_mfpr_fen();
	      END;
!	    [pr$k_ipir] :		!Write only
!	      BEGIN
!	      END;
	    [pr$k_ipl] :
	      BEGIN
		BUILTIN pal_mfpr_ipl;
		quan = pal_mfpr_ipl();
	      END;
	    [pr$k_mces] :
	      BEGIN
		BUILTIN pal_mfpr_mces;
		quan = pal_mfpr_mces();
	      END;
	    [pr$k_pcbb] :
	      BEGIN
		BUILTIN pal_mfpr_pcbb;
		quan = pal_mfpr_pcbb();
	      END;
!	    [pr$k_perfmon] :
!	      BEGIN
!		BUILTIN pal_mfpr_perfmon;
!		quan = pal_mfpr_perfmon();
!		RETURN 0;
!	      END;
	    [pr$k_prbr] :
	      BEGIN
		BUILTIN pal_mfpr_prbr;
		quan = pal_mfpr_prbr();
	      END;
	    [pr$k_ptbr] :
	      BEGIN
		BUILTIN pal_mfpr_ptbr;
		quan = pal_mfpr_ptbr();
	      END;
	    [pr$k_rscc] :
	      BEGIN
		BUILTIN pal_rscc;
		quan = pal_rscc();
	      END;
	    [pr$k_scbb] :
	      BEGIN
		BUILTIN pal_mfpr_scbb;
		quan = pal_mfpr_scbb();
	      END;
!	    [pr$k_sirr] :		!Write only
!	      BEGIN
!	      END;
	    [pr$k_sisr] :
	      BEGIN
		BUILTIN pal_mfpr_sisr;
		quan = pal_mfpr_sisr();
	      END;
	    [pr$k_ssp] :
	      BEGIN
		BUILTIN pal_mfpr_ssp;
		quan = pal_mfpr_ssp();
	      END;
!	    [pr$k_tbchk] :		!Read requires input value of VA
!	      BEGIN
!		BUILTIN pal_mfpr_tbchk;
!		quan = pal_mfpr_tbchk();
!	      END;
!	    [pr$k_tbia] :		!Write only
!	      BEGIN
!	      END;
!	    [pr$k_tbiap] :		!Write only
!	      BEGIN
!	      END;
!	    [pr$k_tbis] :		!Write only
!	      BEGIN
!	      END;
!	    [pr$k_tbisd] :		!Write only
!	      BEGIN
!	      END;
!	    [pr$k_tbisi] :		!Write only
!	      BEGIN
!	      END;
	    [pr$k_usp] :
	      BEGIN
		BUILTIN pal_mfpr_usp;
		quan = pal_mfpr_usp();
	      END;
	    [pr$k_vptbase] :
	      BEGIN
!		BUILTIN pal_mfpr_vptb;
!		quan = pal_mfpr_vptb();
		RETURN 0;
	      END;
	    [pr$k_whami] :
	      BEGIN
		BUILTIN pal_mfpr_whami;
		quan = pal_mfpr_whami();
	      END;
	    [INRANGE] : RETURN 0;
	    [OUTRANGE] : RETURN 0;
	  TES;
!
	RETURN ss$_normal;
END; 					! ROUTINE fetch_preg


ROUTINE fetch_current(
!++
! Functional description:
!
!	This routine fetches the contents of the current location. The
! fetched data is stored as the "current quantity." How this is done depends
! on whether or not the current location points to a processor register or
! not. Processor registers require a PAL call to retrieve their contents
! whereas everything else doesn't. The amount of data moved also depends
! on the prevailing data type length.
!
! Formal parameters:
!
	ctx: REF BLOCK[0,BYTE]		!Ptr to mode context block
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

BIND
	dot = ctx[mctx$q_dot],			!Current location
	quan = ctx[mctx$q_quan];		!Current quantity
LOCAL
	arg_list: VECTOR[2,LONG],		!$CMKRNL arglst for DELTA
	status;					!Return status value

!
! If the current location points to a processor register, we can't simply
! fetch the contents. Instead, we must use a privileged PAL call to retrieve
! it. This implies we must get into kernel mode to do it in DELTA.
!
	IF .ctx[mctx$v_preg] THEN
	  BEGIN
	    %if delta %then
	      IF .ctx[mctx$l_index] EQL psl$c_kernel THEN
		RETURN fetch_preg(.ctx)
	      ELSE
		BEGIN
		  arg_list[0] = 1;
		  arg_list[1] = .ctx;
		  RETURN $cmkrnl(
			routin = fetch_preg,
			arglst = arg_list);
		END;
	    %else
	      RETURN fetch_preg(.ctx);
	    %fi
	  END;
!
! Got some data to fetch apparently. Well, if this is XDELTA, we'll do
! some access checking to avoid unwanted exceptions. If it's DELTA, then
! we need to ascertain the process context for the fetch. If it's another
! process, we use a special routine to take care of it.
!
	%if delta %then
	  IF .ctx[mctx$l_pid] NEQ 0 THEN
	    RETURN poke_other_process(
				.ctx,
				.dot,
				quan,
				.ctx[mctx$l_data_length],
				0);
	%fi
!
	IF NOT (status = xdt$check_address(.dot,.ctx[mctx$l_data_length],0))
	  THEN RETURN .status;
!
! We now want to move the appropriate amount of data into "Q". On Alpha,
! this means fetching a longword or a quadword at a shot. So you'll notice
! a little bizarre behavior for byte and word modes below. This is to force
! the compiler to do longword fetches instead of quadwords. For longword
! mode, all values are sign-extended into 64-bit Q by default.
!
	SELECTONE .ctx[mctx$l_data_length] OF
	  SET
	    [byte_size] :
	      BEGIN
		BIND source_adr = .dot : VECTOR[,LONG];
		quan = .source_adr[0] AND %x'FF';
	      END;
	    [word_size] :
	      BEGIN
		BIND source_adr = .dot : VECTOR[,LONG];
		quan = .source_adr[0] AND %x'FFFF';
	      END;
	    [long_size] :
	      BEGIN
		BIND source_adr = .dot : VECTOR[,LONG,SIGNED];
		quan = .source_adr[0];
	      END;
	    [quad_size] :
	      quan = ..dot;
	  TES;
!
	RETURN ss$_normal;		! Successful completion
END; 					! ROUTINE fetch_current


GLOBAL ROUTINE xdt$check_address(
!++
! Functional description:
!
!	This routine is used to check the accessability of a particular
! address. It's done in a routine in case an exception occurs. If all goes
! according to plan, this routine will merely return to its caller with an
! error status if an exception occurs.
!	First this routine will reduce the access check to either longword
! or quadword, based on the size specified. Next it will do a PROBE on the
! address. If we're still alive, then a fetch or store operation on the
! address will be attempted.
!
! Formal parameters:
!
	check_adr,		!Address to check
	size,			!How much access needed?
	read_or_write		!Kind of access needed (0=>read, 1=>write)
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!	SS$_ACCVIO : Probe failed or exception occurred
!	Exception status : Some exception (like TNV) occurred
!
! Side effects:
!
!	None
!
!--

BEGIN

LOCAL
	test_size;			!Size to actually test
!
! We want to make sure this routine has a call frame of some kind. That will
! insure than any unwinds start in this routine so that the caller is
! guaranteed to just get an error (or success) return status from this
! routine. By enabling a condition handler, the compiler will be forced
! to create a call frame. In XDELTA, the handler doesn't do anything. In
! DELTA, the handler actually does an unwind.
!
	%if delta %then
	  ENABLE delta_handler
	%else
	  ENABLE xdelta_handler
	%fi ;
!
! Reduce size to one of two possibilities for reads or writes
!
	IF .size LEQ long_size THEN
	  test_size = long_size
	ELSE
	  test_size = quad_size;
!
! For read checks, we first try a PROBER. If successful, we try to
! fetch some data. If an exception occurs, we'll never know it. If not,
! we'll return success.
!
	IF .read_or_write EQL 0 THEN
	  BEGIN
	    IF NOT $my_probe(.check_adr,.test_size,r,0) THEN
	      RETURN ss$_accvio;
!
	    IF .test_size EQL long_size THEN
	      BEGIN
		BIND adr_as_vec = .check_adr : VECTOR[,LONG];
		temp_data = .adr_as_vec[0];
	      END
	    ELSE
	      BEGIN
		BIND adr_as_vec = .check_adr : VECTOR;
		temp_data = .adr_as_vec[0];
	      END;
	  END
!
! For write checks, we first try a PROBEW. If successful, we try to
! store some data. If an exception occurs, we'll never know it. If not,
! we'll return success.
!
	ELSE
	  BEGIN
	    IF NOT $my_probe(.check_adr,.test_size,w,0) THEN
	      RETURN ss$_accvio;
!
	    IF .test_size EQL long_size THEN
	      BEGIN
		BIND adr_as_vec = .check_adr : VECTOR[,LONG];
		adr_as_vec[0] = .adr_as_vec[0];
	      END
	    ELSE
	      BEGIN
		BIND adr_as_vec = .check_adr : VECTOR;
		adr_as_vec[0] = .adr_as_vec[0];
	      END;
	  END;
!
	RETURN ss$_normal;		! Successful completion
END; 					! ROUTINE xdt$check_address


ROUTINE store_preg(
!++
! Functional description:
!
!	This routine takes input data from the first input field and stores
! it as the contents of the current location when it happens to be a
! processor register. To do so requires that this routine execute in
! kernel mode. It is invoked by store_current to perform this specialized
! function.
!
! Formal parameters:
!
	ctx: REF BLOCK[0,BYTE]		!Ptr to mode context block
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

BIND
	fld = ctx[mctx$q_fields],		!First input field
	dot = ctx[mctx$q_dot];			!Current location
!
! Use the correct PAL call to modify the processor register contents
!
	CASE .dot FROM min_pr_number TO max_pr_number OF
	  SET
!	    [pr$k_asn] :		!Read only
!	      BEGIN
!	      END;
	    [pr$k_asten] :
	      BEGIN
		BUILTIN pal_mtpr_asten;
		pal_mtpr_asten(.fld);
	      END;
	    [pr$k_astsr] :
	      BEGIN
		BUILTIN pal_mtpr_astsr;
		pal_mtpr_astsr(.fld);
	      END;
	    [pr$k_esp] :
	      BEGIN
		BUILTIN pal_mtpr_esp;
		pal_mtpr_esp(.fld);
	      END;
	    [pr$k_fen] :
	      BEGIN
		BUILTIN pal_mtpr_fen;
		pal_mtpr_fen(.fld);
	      END;
	    [pr$k_ipir] :
	      BEGIN
		BUILTIN pal_mtpr_ipir;
		pal_mtpr_ipir(.fld);
	      END;
	    [pr$k_ipl] :
	      BEGIN
		BUILTIN pal_mtpr_ipl;
		pal_mtpr_ipl(.fld);
	      END;
	    [pr$k_mces] :
	      BEGIN
		BUILTIN pal_mtpr_mces;
		pal_mtpr_mces(.fld);
	      END;
!	    [pr$k_pcbb] :		!Read only
!	      BEGIN
!	      END;
!	    [pr$k_perfmon] :
!	      BEGIN
!		BUILTIN pal_mtpr_perfmon;
!		pal_mtpr_perfmon(.fld);
!		RETURN 0;
!	      END;
	    [pr$k_prbr] :
	      BEGIN
		BUILTIN pal_mtpr_prbr;
		pal_mtpr_prbr(.fld);
	      END;
!	    [pr$k_ptbr] :		!Read only
!	      BEGIN
!	      END;
!	    [pr$k_rscc] :		!Read only
!	      BEGIN
!	      END;
!	    [pr$k_scbb] :		!Should this be allowed?
!	      BEGIN
!		BUILTIN pal_mtpr_scbb;
!		pal_mtpr_scbb(.fld);
!	      END;
	    [pr$k_sirr] :
	      BEGIN
		BUILTIN pal_mtpr_sirr;
		pal_mtpr_sirr(.fld);
	      END;
!	    [pr$k_sisr] :		!Read only
!	      BEGIN
!	      END;
	    [pr$k_ssp] :
	      BEGIN
		BUILTIN pal_mtpr_ssp;
		pal_mtpr_ssp(.fld);
	      END;
!	    [pr$k_tbchk] :		!Read only
!	      BEGIN
!	      END;
	    [pr$k_tbia] :
	      BEGIN
		BUILTIN pal_mtpr_tbia;
		pal_mtpr_tbia();
	      END;
	    [pr$k_tbiap] :
	      BEGIN
		BUILTIN pal_mtpr_tbiap;
		pal_mtpr_tbiap();
	      END;
	    [pr$k_tbis] :
	      BEGIN
		BUILTIN pal_mtpr_tbis;
		pal_mtpr_tbis(.fld);
	      END;
	    [pr$k_tbisd] :
	      BEGIN
!		BUILTIN pal_mtpr_tbisd;
!		pal_mtpr_tbisd(.fld);
		RETURN 0;
	      END;
	    [pr$k_tbisi] :
	      BEGIN
!		BUILTIN pal_mtpr_tbisi;
!		pal_mtpr_tbisi(.fld);
		RETURN 0;
	      END;
	    [pr$k_usp] :
	      BEGIN
		BUILTIN pal_mtpr_usp;
		pal_mtpr_usp(.fld);
	      END;
	    [pr$k_vptbase] :
	      BEGIN
!		BUILTIN pal_mtpr_vptb;
!		pal_mtpr_vptb(.fld);
		RETURN 0;
	      END;
!	    [pr$k_whami] :		!Read only
!	      BEGIN
!	      END;
	    [INRANGE] : RETURN 0;
	    [OUTRANGE] : RETURN 0;
	  TES;
!
	RETURN ss$_normal;
END; 					! ROUTINE store_preg


ROUTINE store_current(
!++
! Functional description:
!
!	This routine stores input data in the current location. The input
! data is found in the first input field. The prevailing data type length
! is used to determine how much data to move into the current location,
! unless the current location is a processor register, in which case a PAL
! call is required to move the data.
!
! Formal parameters:
!
	ctx: REF BLOCK[0,BYTE]		!Ptr to mode context block
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

BIND
	dot = ctx[mctx$q_dot],			!Current location
	iregbuf = ctx[mctx$q_iregbuf],		!GPR save area address
	fregbuf = ctx[mctx$q_fregbuf];		!FP register save area address
LOCAL
	prev_prot,				!Previous page protection
	arg_list: VECTOR[2,LONG],		!$CMKRNL arglst for DELTA
	status;					!Return status value
!
! If the current location points to a processor register, we can't simply
! move the new data. Instead, we must use a privileged PAL call to store
! it. This implies we must get into kernel mode to do it in DELTA.
!
	IF .ctx[mctx$v_preg] THEN
	  BEGIN
	    %if delta %then
	      IF .ctx[mctx$l_index] EQL psl$c_kernel THEN
		RETURN store_preg(.ctx)
	      ELSE
		BEGIN
		  arg_list[0] = 1;
		  arg_list[1] = .ctx;
		  RETURN $cmkrnl(
			routin = store_preg,
			arglst = arg_list);
		END;
	    %else
	      RETURN store_preg(.ctx);
	    %fi
	  END;
!
! It's an error to attempt to modify the saved SP
!
	IF .dot EQL (.iregbuf + (30 * quad_size)) THEN
	  RETURN ss$_badparam;
!
! Attempts to modify R31, the sink register, have no effect
!
	IF .dot EQL (.iregbuf + (31 * quad_size)) THEN
	  RETURN ss$_normal;
!
! Attempts to modify FP31, another sink register, have no effect
!
	IF .dot EQL (.fregbuf + (31 * quad_size)) THEN
	  RETURN ss$_normal;
!
! Now, in theory, we're just supposed to move some data from the
! input fields to the current location. Sure...this sounds easy...but no..
! In XDELTA, we want to do a little access checking to avoid unwanted
! exceptions. In DELTA, if we're modifying our own process address space,
! we'll temporarily force the locations to be writeable. If dealing with
! another process' address space, we have even more work to do (in a
! different routine).
!
	%if delta %then
	  IF .ctx[mctx$l_pid] NEQ 0 THEN
	    RETURN poke_other_process(
				.ctx,
				ctx[mctx$q_fields],
				.dot,
				.ctx[mctx$l_data_length],
				1);
	%fi
!
	IF NOT (status = xdt$check_address(.dot,.ctx[mctx$l_data_length],1))
	  THEN RETURN .status;
!
! OK, if we get here in either XDELTA or DELTA, we have access to the
! destination location and can proceed with the write.
!
	ch$move(
	    .ctx[mctx$l_data_length],	!Prevailing data length
	    ctx[mctx$q_fields],		!From first input field
	    .dot);			!To current location
!
	RETURN ss$_normal;
END; 					! ROUTINE store_current


ROUTINE open_location(
!++
! Functional description:
!
!	This routine opens a location (or range of locations) and displays the
! contents. The last location is left open.
!
! Formal parameters:
!
	ctx: REF BLOCK[0,BYTE]		!Ptr to mode context block
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

BIND
	dot = ctx[mctx$q_dot],			!Current location
	quan = ctx[mctx$q_quan],		!Current quantity
	fld = ctx[mctx$q_fields] : VECTOR;	!Input fields
LOCAL
	status;					!Return status value
!
! Terminate the current field and set the "current" location. If the
! first input field is valid, then it becomes the current location. If
! not, the current quantity assumes this role.
!
	IF NOT (status = end_field(.ctx)) THEN
	  RETURN .status;
!
	IF .ctx[mctx$v_f0] THEN
	  dot = .fld[0]
	ELSE
	  dot = .quan;
!
! Make sure we're properly setup to handle processor register displays
! and incrementing. Then display (and open) the current location.
!
	ctx[mctx$v_preg] = .ctx[mctx$v_prmode];
	IF NOT (status = put_location(.ctx)) THEN
	  RETURN .status;
!
! Now if we're doing a range, indicated by the presence of a valid second
! input field, then we must loop while the current location is less than
! the specified upper limit on the range, incrementing the current location
! and displaying its value and contents.
!
	IF .ctx[mctx$v_f1] THEN
	  WHILE .dot LSS .fld[1] DO
	    BEGIN
	      new_line();
	      next_dot(.ctx);
	      put_next_adr(.ctx);
	      IF NOT (status = put_location(.ctx)) THEN
		RETURN .status;
	    END;
!
! Reset for the next input command
!
	cmd_reset(.ctx);
!
	RETURN ss$_normal;
END; 					! ROUTINE open_location


ROUTINE close_location(
!++
! Functional description:
!
!	This routine closes a location, optionally storing new contents
! prior to closing. The new contents, if any, are stored in the first valid
! input field. If no location is currently open but an input field has been
! specified, it assumes the role of current location.
!
! Formal parameters:
!
	ctx: REF BLOCK[0,BYTE]		!Ptr to mode context block
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

LOCAL
	status;					!Return status value
!
! Start a new line on the screen
!
	new_line();
!
! Terminate the current field first
!
	IF NOT (status = end_field(.ctx)) THEN
	  RETURN .status;
!
! If we have an open location, close it and optionally store the
! specified input field in it
!
	IF .ctx[mctx$v_open] THEN
	  BEGIN
	    ctx[mctx$v_open] = 0;
	    IF NOT (.ctx[mctx$v_ascii] OR .ctx[mctx$v_instruction]) THEN
	      IF .ctx[mctx$v_f0] THEN
		IF NOT (status = store_current(.ctx)) THEN
		  RETURN .status;
	  END
	ELSE
!
! If no location was open to begin with but an input field has been
! specified, treat it as the current location for display (no opening
! or closing necessary)
!
	  IF .ctx[mctx$v_f0] THEN
	    IF NOT (status = put_quan(.ctx)) THEN
	      RETURN .status;
!
! In any event, reset for the next input command
!
	cmd_reset(.ctx);
!
	RETURN ss$_normal;
END; 					! ROUTINE close_location


ROUTINE set_display_mode(
!++
! Functional description:
!
!	This routine changes the prevailing display mode or data type length.
! The new quadword display mode only has an effect when this module is built
! with a 64-bit compiler.
!	The possible data_type specifiers  are as follows:
!
!		B => 1 byte
!		W => 2 bytes
!		L => 4 bytes
!		Q => 8 bytes (only allowed if built with 64-bit compiler)
!		I => No change to length (instruction display mode)
!		C => No change to length (character/ascii display mode)
!		A => No change to length (64-bit address display mode)
!
! Formal parameters:
!
	data_type,			!The new data type specifier
	ctx: REF BLOCK[0,BYTE]		!Ptr to mode context block
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

!
! Key off the letter specifier and set the appropriate mode flags
!
	SELECTONE .data_type OF
	  SET
!
! 64-bit address display mode (only allowed if compiled with a 64-bit compiler -
! Otherwise, this command has no effect). A "[A" command toggles the mode (the
! default is to display addresses as 32-bit values in Phase I).
!
	    [%C'A'] :
	      %if %BPVAL GEQ 64 %then
		ctx[mctx$v_addr64] = NOT .ctx[mctx$v_addr64]
	      %fi ;
!
! Byte mode
!
	    [%C'B'] :
	      BEGIN
		ctx[mctx$l_data_length] = byte_size;
		ctx[mctx$v_ascii] = 0;
		ctx[mctx$v_instruction] = 0;
	      END;
!
! Character mode
!
	    [%C'C'] :
	      BEGIN
		ctx[mctx$v_ascii] = 1;
		ctx[mctx$v_instruction] = 0;
	      END;
!
! Instruction mode
!
	    [%C'I'] :
	      BEGIN
		ctx[mctx$v_ascii] = 0;
		ctx[mctx$v_instruction] = 1;
	      END;
!
! Longword mode
!
	    [%C'L'] :
	      BEGIN
		ctx[mctx$l_data_length] = long_size;
		ctx[mctx$v_ascii] = 0;
		ctx[mctx$v_instruction] = 0;
	      END;
!
! Quadword mode (only allowed if compiled with a 64-bit compiler - Otherwise,
! this command has no effect on the display mode).
!
	    [%C'Q'] :
	      %if %BPVAL GEQ 64 %then
		BEGIN
		  ctx[mctx$l_data_length] = quad_size;
		  ctx[mctx$v_ascii] = 0;
		  ctx[mctx$v_instruction] = 0;
		END
	      %fi ;
!
! Word mode
!
	    [%C'W'] :
	      BEGIN
		ctx[mctx$l_data_length] = word_size;
		ctx[mctx$v_ascii] = 0;
		ctx[mctx$v_instruction] = 0;
	      END;
!
! Unknown mode..and how do you handle an unknown mode? I don't know.
! We can always drop back 15 and punt...
!
	    [OTHERWISE] : RETURN 0;
	  TES;
!
	RETURN ss$_normal;
END; 					! ROUTINE set_display_mode


%IF 0 %THEN
ROUTINE validate_queue(
!++
! Functional description:
!
!	This routine processes a ";Q" or validate_queue command.
! The queue header of interest is located along with the type of queue
! and these are passed along to analyze_queue for analysis. Only longword
! queues are currently supported.
!
! Formal parameters:
!
	ctx: REF BLOCK[0,BYTE]		!Ptr to mode context block
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

BIND
	fld = ctx[mctx$q_fields] : VECTOR;	!Input fields
LOCAL
	status,					!Return status
	queue_type;				!The type of queue
!
! The first input field must exist and must be readable prior to assuming
! it's a valid queue header.
!
	IF NOT .ctx[mctx$v_f0] THEN
	  RETURN 0;
!
	IF NOT (status = xdt$check_address(.fld[0],quad_size,0)) THEN
	  RETURN .status;
!
! If the user specified the queue type (absolute vs. self-relative), use
! the specified type. Otherwise, default to absolute.
!
	IF (.ctx[mctx$v_f1]) AND (.fld[1] NEQ 0) THEN
	  queue_type = 1
	ELSE
	  queue_type = 0;
!
! We're ready to analyze this queue.
!
	status = analyze_queue(.fld[0],.queue_type,.ctx);
	new_line();
!
	RETURN .status;
END; 					! ROUTINE validate_queue


ROUTINE analyze_queue(
!++
! Functional description:
!
!	This routine analyzes the specified queue, displaying results
! of the analysis. We try to determine the validity of the queue header
! and consistency of the queue itself, while trying to not fall off the
! end of the earth in the process. Only longword queues are currently
! supported.
!
! Formal parameters:
!
	queue_head: REF VECTOR[,LONG,SIGNED],	!Queue header address
	queue_type,				!Type of queue
	ctx: REF BLOCK[0,BYTE]			!Ptr to mode context block
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

MACRO
	srqhbad_msg = %STRING('Self-relative queue header not octaword-aligned') %,
	srqebad_msg = %STRING('Self-relative queue entry not octaword-aligned') %,
	intset_msg = %STRING('Secondary interlock set on ') %,
	onqh_msg = %STRING('queue header') %,
	cantrd_msg = %STRING('Cannot read ') %,
	badqhblink_msg = %STRING('Queue header BLINK invalid') %,
	badqhflink_msg = %STRING('Queue header FLINK invalid') %,
	qempty_msg = %STRING('Queue is empty') %,
	validq_msg = %STRING('Valid queue contains ') %,
	exmax_msg = %STRING('Queue check aborted after max allowed ') %,
	element_msg = %STRING(' elements') %,
	qentry_msg = %STRING('Queue entry #') %,
	atadr_msg = %STRING(' at address ') %,
	ivblink_msg = %STRING(' BLINK is invalid') %;
LITERAL
	max_queue_elements = 10000,
	srqhbad_msg_len = %CHARCOUNT(srqhbad_msg),
	srqebad_msg_len = %CHARCOUNT(srqebad_msg),
	intset_msg_len = %CHARCOUNT(intset_msg),
	onqh_msg_len = %CHARCOUNT(onqh_msg),
	cantrd_msg_len = %CHARCOUNT(cantrd_msg),
	badqhblink_msg_len = %CHARCOUNT(badqhblink_msg),
	badqhflink_msg_len = %CHARCOUNT(badqhflink_msg),
	qempty_msg_len = %CHARCOUNT(qempty_msg),
	validq_msg_len = %CHARCOUNT(validq_msg),
	exmax_msg_len = %CHARCOUNT(exmax_msg),
	element_msg_len = %CHARCOUNT(element_msg),
	qentry_msg_len = %CHARCOUNT(qentry_msg),
	atadr_msg_len = %CHARCOUNT(atadr_msg),
	ivblink_msg_len = %CHARCOUNT(ivblink_msg);
BIND
	srqhbad_message = UPLIT(BYTE(srqhbad_msg)),
	srqebad_message = UPLIT(BYTE(srqebad_msg)),
	intset_message = UPLIT(BYTE(intset_msg)),
	onqh_message = UPLIT(BYTE(onqh_msg)),
	cantrd_message = UPLIT(BYTE(cantrd_msg)),
	badqhblink_message = UPLIT(BYTE(badqhblink_msg)),
	badqhflink_message = UPLIT(BYTE(badqhflink_msg)),
	qempty_message = UPLIT(BYTE(qempty_msg)),
	validq_message = UPLIT(BYTE(validq_msg)),
	exmax_message = UPLIT(BYTE(exmax_msg)),
	element_message = UPLIT(BYTE(element_msg)),
	qentry_message = UPLIT(BYTE(qentry_msg)),
	atadr_message = UPLIT(BYTE(atadr_msg)),
	ivblink_message = UPLIT(BYTE(ivblink_msg));
LOCAL
	low_bits,				!For checking entry addresses
	blink,					!Temp. holder for BLINK
	entry_adr: REF VECTOR[,LONG,SIGNED],	!Queue entry
	prev_entry_adr,				!Address of previous entry
	element_count: INITIAL(0);		!Count of queue elements
!
! We first must do some preliminary checking of the specified queue header.
! It must be octaword-aligned for self-relative queues and we must be able
! to read it in both cases.
!
	new_line();
	IF .queue_type NEQ 0 THEN
	  IF (.queue_head AND 7) NEQ 0 THEN
	    BEGIN
	      put_string(srqhbad_msg_len,srqhbad_message);
	      RETURN ss$_normal;
	    END;
!
	IF NOT xdt$check_address(.queue_head,quad_size,0) THEN
	  BEGIN
	    put_string(cantrd_msg_len,cantrd_message);
	    put_string(onqh_msg_len,onqh_message);
	    RETURN ss$_normal;
	  END;
!
! Let's have a looksie at the queue header contents first to see if
! the queue appears to be empty according to either the flink or blink.
! If so, we'll print out that either the queue is empty or that either flink
! or blink in the queue header is bogus.
!
	IF .queue_type EQL 0 THEN
	  BEGIN
	    entry_adr = .queue_head[0];
	    prev_entry_adr = .queue_head[1];
	  END
	ELSE
	  BEGIN
	    entry_adr = queue_head[0] + .queue_head[0];
	    prev_entry_adr = queue_head[0] + .queue_head[1];
	    IF (.queue_head[0] AND 1) NEQ 0 THEN
	      BEGIN
		put_string(intset_msg_len,intset_message);
		put_string(onqh_msg_len,onqh_message);
		new_line();
		entry_adr = .entry_adr AND (NOT 1);
	      END;
	  END;
!
! If the queue is empty according to the FLINK, make sure BLINK matches
!
	IF .entry_adr EQL queue_head[0] THEN
	  BEGIN
	    IF .prev_entry_adr NEQ queue_head[0] THEN
	      put_string(badqhblink_msg_len,badqhblink_message)
	    ELSE
	      put_string(qempty_msg_len,qempty_message);
	    RETURN ss$_normal;
	  END;
!
! If the queue is empty according to the BLINK, make sure FLINK matches
!
	IF .prev_entry_adr EQL queue_head[0] THEN
	  BEGIN
	    IF .entry_adr NEQ queue_head[0] THEN
	      put_string(badqhflink_msg_len,badqhflink_message)
	    ELSE
	      put_string(qempty_msg_len,qempty_message);
	    RETURN ss$_normal;
	  END;
!
! Now we look at each entry in the queue, making sure the BLINK points
! back at the previous queue entry, that the queue headers are readable,
! and that we haven't fallen off the end of the earth on a wild goose chase.
!
	prev_entry_adr = queue_head[0];
	WHILE (.entry_adr NEQ queue_head[0]) AND
	      (.element_count LSS max_queue_elements) DO
	  BEGIN
	    element_count = .element_count + 1;
!
! See if self-relative queue entry address is valid
!
	    IF .queue_type NEQ 0 THEN
	      BEGIN
		low_bits = .entry_adr AND 7;
		IF .low_bits NEQ 0 THEN
		  IF .low_bits EQL 1 THEN
		    BEGIN
		      put_string(intset_msg_len,intset_message);
		      put_string(qentry_msg_len,qentry_message);
		      put_dec(.element_count - 1);
		      put_string(atadr_msg_len,atadr_message);
		      entry_adr = .entry_adr AND (NOT 1);
		      put_address(.prev_entry_adr,.ctx);
		    END
		  ELSE
		    BEGIN
		      put_string(srqebad_msg_len,srqebad_message);
		      new_line();
		      put_string(qentry_msg_len,qentry_message);
		      put_dec(.element_count);
		      put_string(atadr_msg_len,atadr_message);
		      put_address(.entry_adr,.ctx);
		      RETURN ss$_normal;
		    END;
	      END;
!
! Make sure we can read this queue entry
!
	    IF NOT xdt$check_address(.entry_adr,quad_size,0) THEN
	      BEGIN
	        put_string(cantrd_msg_len,cantrd_message);
		put_char(space);
		put_string(qentry_msg_len,qentry_message);
		put_dec(.element_count);
		put_string(atadr_msg_len,atadr_message);
		put_address(.entry_adr,.ctx);
	        RETURN ss$_normal;
	      END;
!
! See if BLINK valid
!
	    IF .queue_type EQL 0 THEN
	      blink = .entry_adr[1]
	    ELSE
	      blink = .entry_adr + .entry_adr[1];
!
	    IF .blink NEQ .prev_entry_adr THEN
	      BEGIN
		new_line();
		put_string(qentry_msg_len,qentry_message);
		put_dec(.element_count);
		put_string(atadr_msg_len,atadr_message);
		put_address(.entry_adr,.ctx);
		put_string(ivblink_msg_len,ivblink_message);
		RETURN ss$_normal;
	      END;
!
	    prev_entry_adr = .entry_adr;
	    IF .queue_type EQL 0 THEN
	      entry_adr = .entry_adr[0]
	    ELSE
	      entry_adr = .entry_adr + .entry_adr[0];
	  END;
!
! If we fell out of the loop, we either have a valid queue on our hands
! or got tired of looking at queue entries (exceeded max_queue_elements).
! Print out a message indicating what happened.
!
	new_line();
	IF .element_count LSS max_queue_elements THEN
	  BEGIN
	    put_string(validq_msg_len,validq_message);
	    put_dec(.element_count);
	    put_string(element_msg_len,element_message);
	  END
	ELSE
	  BEGIN
	    put_string(exmax_msg_len,exmax_message);
	    put_dec(.element_count);
	    put_string(element_msg_len,element_message);
	  END;
!
	RETURN ss$_normal;
END; 					! ROUTINE analyze_queue


ROUTINE execute_bugcheck: NOVALUE =
!++
! Functional description:
!
!	This routine executes a specific fatal BUGCHECK in response to
! user command (;C). This is the BUG$_DEBUGCRASH BUGCHECK. This routine
! isn't invoked directly. Instead, the code address of the first instruction
! of this routine is loaded into "saved PC" along with the procedure
! descriptor address of this routine in R27. The debugger then returns,
! leaving the debugger, to continue execution at this routine and hopefully
! stop here as well. This allows us to crash without overwriting code
! somewhere (which allows us to do this from anywhere - such as within
! BUGCHECK itself) and leaves an obvious signature in the crash dump as to
! where the crash occurred.
!
! Formal parameters:
!
!	None
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

!
! All we need to do is use the $BUG_CHECK macro
!
	$bug_check(debugcrash,fatal);
!
END; 					! ROUTINE execute_bugcheck

%FI

!
! The routines which follow are DELTA-specific and are only included
! when building DELTA. These routines handle DELTA initialization and
! a variety of utility functions.
!
	%if delta %then


GLOBAL ROUTINE xdt$start(
!++
! Functional description:
!
!	This routine is invoked at debugger startup to perform all the
! necessary DELTA initialization. This includes data relocation, establishing
! condition handlers, particularly at the exception vectors, setting the
! rundown handler, assigning a channel for terminal I/O, printing the welcome
! message, and setting up the initial breakpoint at the transfer address
! (if any).
!
! Formal parameters:
!
	xfer_vector: REF VECTOR[,LONG,SIGNED]	!Image transfer vectors
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

MACRO
	prc_lnm_tables = %STRING('LNM$PROCESS_TABLE') %,
	sys_lnm_tables = %STRING('LNM$SYSTEM_TABLE') %,
	welcome_msg = %STRING('Alpha/VMS DELTA Version 1.0') %;
LITERAL
	prc_lnm_table_len = %CHARCOUNT(prc_lnm_tables),	!Table name size
	sys_lnm_table_len = %CHARCOUNT(sys_lnm_tables),	!Table name size
	wel_msg_len = 4 + %CHARCOUNT(welcome_msg);	!String length
BIND
	bpt_adr = perm_bpts[0,pbpt$q_breakpoint],
	bpt_disp = perm_bpts[0,pbpt$q_display],
	bpt_cmd = perm_bpts[0,pbpt$q_cmd_string],
	welcome = UPLIT(BYTE(
				cr,lf,		!Start a new line
				welcome_msg,	!Print the welcome message
				cr,lf		!Begin a fresh line
			));			!
OWN
	prc_lnm_tab: VECTOR[prc_lnm_table_len,BYTE] !The logical name table
	  INITIAL(BYTE(prc_lnm_tables)),	! string buffer
	sys_lnm_tab: VECTOR[sys_lnm_table_len,BYTE] !The logical name table
	  INITIAL(BYTE(sys_lnm_tables));	! string buffer
LOCAL
	prc_lnm_tab_desc: VECTOR[2,LONG]	!Logical name table descriptor
	  INITIAL(LONG(prc_lnm_table_len,prc_lnm_tab)),	!
	sys_lnm_tab_desc: VECTOR[2,LONG]	!Logical name table descriptor
	  INITIAL(LONG(sys_lnm_table_len,sys_lnm_tab)),	!
	lnm_items: VECTOR[4,LONG]		!$trnlnm item list
	  INITIAL(LONG(				!Initialized at runtime
		(lnm$_string^16) + devnam_size,	!Equivalence name string
		devname,			!Relocated buffer address
		dev_desc,			!Relocated buffer size address
		0				!Conan, The Terminator
	  )),					!
	lnm_attr: INITIAL(lnm$m_case_blind),	!$TRNLNM attributes
	arg_list: VECTOR[2,LONG]		!$CMKRNL argument list
	  INITIAL(LONG(1,0)),			!
	proc_status,				!Processor status
	bpt_address,				!For initial BPT computation
	user_pd: INITIAL(0),			!User's PD address
	prev_prot,				!To hold previous protection
	address_range: VECTOR[2,LONG],		!For $lkwset
	prv_mask: BLOCK[8,BYTE]			!Privilege mask
	  INITIAL(LONG(0,0)),			!Nothing to start with
	prvprv_mask: BLOCK[8,BYTE]		!Previous privilege mask
	  INITIAL(LONG(0,0)),			!Nothing to start with
	status;					!Return status value
!
! Establish the condition handler for exceptions within the image which
! are not handled elsewhere.
!
	ENABLE xdt$delta_catchall;
!
! Now check to see if we should setup an initial DELTA breakpoint
!
	perm_bpts[0,pbpt$v_invalid] = 0;
	perm_bpts[0,pbpt$l_instruction] = 0;
	bpt_disp = 0;
	bpt_cmd = 0;
	bpt_adr = 0;
!
! If the transfer address points right here, we have to setup the
! temporary breakpoint AND pretend we're SYS$IMGSTA, transferring control
! to the user's start address when we're done initializing.
!
	IF .xfer_vector[0] NEQ 0 THEN
	  BEGIN
	    IF .xfer_vector[2] EQL xdt$start THEN
	      BEGIN
		user_pd = .xfer_vector[4];
		bpt_address = .(.user_pd + 8);
		BEGIN
		  BIND code_address = .bpt_address : LONG;
		  loosen_protection(.bpt_address,.bpt_address,prev_prot);
		  IF xdt$check_address(.bpt_address,inst_size,1) THEN
		    BEGIN
		      bpt_adr = .bpt_address;
		      perm_bpts[0,pbpt$l_instruction] = .code_address;
		      code_address = bpt_opcode;
		    END;
		  reset_protection(.bpt_address,.bpt_address,.prev_prot);
		END;
	      END
	    ELSE
!
! If called by SYS$IMGSTA, we only have to setup the temporary breakpoint
! at the specified code address in the transfer vector (if any). So
! set up the specified code address as perm_bpts[0].
!
	      BEGIN
	        BIND code_address = .xfer_vector[0] : LONG;
	        loosen_protection(.xfer_vector[0],.xfer_vector[0],prev_prot);
	        IF xdt$check_address(.xfer_vector[0],inst_size,1) THEN
		  BEGIN
		    bpt_adr = .xfer_vector[0];
		    perm_bpts[0,pbpt$l_instruction] = .code_address;
		    code_address = bpt_opcode;
		  END;
	        reset_protection(.xfer_vector[0],.xfer_vector[0],.prev_prot);
	      END;
	  END;
!
! If we haven't been through initialization yet, we have lots to setup
!
	IF NOT .init_flag THEN
	  BEGIN
!
	    init_flag = 1;
!
! And then Moe said to Larry, "Wake up and go to sleep!"
!
!	    $wake();
!	    $hiber();
!
! Any necessary data structure initialization goes here
!
	    mode_context[0,mctx$l_data_length] = long_size;
	    mode_context[1,mctx$l_data_length] = long_size;
	    mode_context[2,mctx$l_data_length] = long_size;
	    mode_context[3,mctx$l_data_length] = long_size;
!
! Relocate any data addresses that need it
!
	    tt_desc[1] = ttname;
	    dbg_desc[1] = dbgname;
	    dev_desc[1] = devname;
	    item_list[4] = term_mask;
	    exit_block[1] = xdt$exit_handler;
	    exit_block[3] = exit_status;
!
! Read the current PS and get the current mode so we know what mode the debugger
! started in.
!
	    proc_status = $proc_status;
	    BEGIN
	      MAP proc_status : BLOCK[,BYTE];
	      arg_list[1] = .proc_status[psl$v_curmod];
	    END;
!
! If the image is running with SETPRV turned on but not CMKRNL or CMEXEC,
! then DELTA would fail to setup the inner mode exception handlers. This
! causes problems if the image itself turns on CMKRNL or CMEXEC and the
! user attempts to set breakpoints in the inner mode code (basically, it
! crashes the system). So DELTA will attempt to turn on CMKRNL and CMEXEC
! privileges before trying to setup the inner mode vectors. If it fails,
! then I shouldn't have to worry about the image turning them on either.
!
	    prv_mask[prv$v_cmkrnl] = 1;
	    prv_mask[prv$v_cmexec] = 1;
	    $setprv(
		ENBFLG = 1,		!Turn the privs on
		PRVADR = prv_mask,	!Privs to turn on
		PRMFLG = 0,		!Just temporarily
		PRVPRV = prvprv_mask);	!Previous privileges
!
! Try to setup the kernel mode exception vectors (and executive and supervisor
! mode ones while we're at it).
!
	    status = $cmkrnl(
			ROUTIN = set_kernel_exceptions,
			ARGLST = arg_list);
!
! If we failed for any reason, we still might be able to
! setup the executive and supervisor mode exception vectors. If that
! doesn't work either for something other than insufficient privs,
! return with an error
!
	    IF NOT .status THEN
	      BEGIN
	        status = $cmexec(
				ROUTIN = set_exec_exceptions,
				ARGLST = arg_list);
	        IF (NOT .status) AND (.status NEQ ss$_nopriv) THEN
	          RETURN .status;
	      END;
!
! Restore the previous state of CMKRNL and CMEXEC privs. We do this if either
! or both of CMKRNL/CMEXEC were previously disabled, and we do it by merely
! calling $SETPRV to disable any and all privs that were previously disabled.
!
	    IF NOT (.prvprv_mask[prv$v_cmkrnl] AND
		    .prvprv_mask[prv$v_cmexec]) THEN
	      BEGIN
		MAP prvprv_mask : VECTOR[2,LONG];
		prvprv_mask[0] = NOT .prvprv_mask[0];
		prvprv_mask[1] = NOT .prvprv_mask[1];
		$setprv(
			ENBFLG = 0,		!Turn the privs off
			PRVADR = prvprv_mask,	!Privs to turn off
			PRMFLG = 0);		!Just temporarily
	      END;
!
! Declare the user mode exception vectors
!
	    $setexv(
		ADDRES = xdt$delta_exception,	!Primary handler
		ACMODE = PSL$C_USER,		!User mode
		VECTOR = 0);			!Primary vector
!
	    $setexv(
		ADDRES = xdt$delta_catchall,	!Last chance handler
		ACMODE = PSL$C_USER,		!User mode
		VECTOR = 2);			!Last chance vector
!
! Declare an image exit handler
!
	    $dclexh( DESBLK = exit_block );
!
! Make all DELTA code user-writeable and locked in the working set
! for debugging purposes. What the hell.
!
	    loosen_protection(code_start_marker,code_end_marker,0);
	    address_range[0] = code_start_marker;
	    address_range[1] = code_end_marker;
	    $lkwset( inadr = address_range );
!
! Let's get a channel for terminal I/O, first trying to translate 
! DBG$DELTA and then TT.
!
	    IF NOT (status = $trnlnm(
				ATTR   = lnm_attr,
				TABNAM = prc_lnm_tab_desc,
				LOGNAM = dbg_desc,
				ITMLST = lnm_items)) THEN
	      status = $trnlnm(
				ATTR   = lnm_attr,
				TABNAM = sys_lnm_tab_desc,
				LOGNAM = dbg_desc,
				ITMLST = lnm_items);
!
	    IF NOT .status THEN
	      IF NOT (status = $trnlnm(
				ATTR   = lnm_attr,
				TABNAM = prc_lnm_tab_desc,
				LOGNAM = tt_desc,
				ITMLST = lnm_items)) THEN
	        status = $trnlnm(
				ATTR   = lnm_attr,
				TABNAM = sys_lnm_tab_desc,
				LOGNAM = tt_desc,
				ITMLST = lnm_items);
!
! Strip off any process permanent header bytes from the equivalence name
! string and assign a channel to the device (if we have what looks like a
! good device name, we'll use that. Otherwise, we'll take a shot at using
! the logical "TT" in the $assign).
!
	    IF (.status) AND (.dev_desc[0] GTR 0) THEN
	      BEGIN
		IF .devname[0] EQL esc THEN
		  BEGIN
	            dev_desc[0] = .dev_desc[0] - 4;
	            dev_desc[1] = .dev_desc[1] + 4;
	          END;
		status = $assign(
				DEVNAM = dev_desc,
				CHAN   = ttchan);
	      END
	    ELSE
	      status = $assign(
				DEVNAM = tt_desc,
				CHAN   = ttchan);
!
	    IF NOT .status THEN
	      RETURN .status;
	  END;
!
! Display the welcome message
!
	put_string(wel_msg_len,welcome);
!
! Lastly, if we're pretending to be SYS$IMGSTA and we've made it this
! far, we may need to invoke the user's start address before returning.
!
	IF .user_pd NEQ 0 THEN
	  BEGIN
	    BIND ROUTINE users_start_adr = .user_pd;
	    users_start_adr();
	  END;
!
	RETURN ss$_normal;
END; 					! ROUTINE xdt$start


ROUTINE delta_handler(
!++
! Functional description:
!
!	This routine is the condition handler for DELTA to handle conditions
! which occur within DELTA itself.
!
! Formal parameters:
!
	signal_array: REF BLOCK[0,BYTE],
	mechanism_array: REF BLOCK[0,BYTE]
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

BIND
	saved_r0 = mechanism_array[chf$ih_mch_savr0];
!
! Make routine which incurred the exception return to its caller with
! the condition status in R0.
!
	saved_r0 = .signal_array[chf$l_sig_name];
	$UNWIND( DEPADR = %REF(1) );
!
	RETURN ss$_continue;		! We took care of the exception
END; 					! ROUTINE delta_handler


GLOBAL ROUTINE xdt$delta_bpt(
!++
! Functional description:
!
!	This routine is invoked by the condition handler for the primary
! exception vectors in DELTA to handle conditions such as BPT (SS$_BREAK).
!
! Formal parameters:
!
	fen,			!Floating point enabled flag
	ireg_adr,		!Address of GPRs, PC, PS
	freg_adr,		!Address of FPRs
	no_bpt			!True if simulating BPT; False if real BPT
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

BIND
	save_ps = .ireg_adr + (8 * 33): BLOCK[,BYTE];
LOCAL
	ctx: REF BLOCK[,BYTE];			!Context block pointer
!
! Make sure we're using the correct context block for DELTA. If this is DELTA,
! we must figure out the current mode and use it as an index into the context
! block array. Note that in DELTA, we also use the mode as an index into
! the temporary breakpoint arrays so that each mode has their own. In XDELTA,
! we use the IPL as the index.
!
	ctx = mode_context + (.save_ps[psl$v_curmod] * mctx$k_block_size);
	ctx[mctx$l_index] = .save_ps[psl$v_curmod];
	ctx[mctx$v_fen] = .fen;
	BEGIN
	  BIND
	    iregbuf = ctx[mctx$q_iregbuf],	!GPR save area address
	    fregbuf = ctx[mctx$q_fregbuf];	!FP register save area address
	  iregbuf = .ireg_adr;
	  fregbuf = .freg_adr;
	END;
!
! Reestablish the primary exception vector
!
	$setexv(
		ADDRES = xdt$delta_exception,	!Primary handler
		ACMODE = .ctx[mctx$l_index],	!Current mode
		VECTOR = 0);			!Primary vector
!
! Now take care of the breakpoint
!
	IF NOT break_point(.no_bpt,.ctx) THEN
	  RETURN ss$_resignal;
!
	RETURN ss$_continue;
END; 					! ROUTINE delta_bpt


GLOBAL ROUTINE xdt$delta_oops(
!++
! Functional description:
!
!	This routine is invoked by the "catch all" condition handler for
! DELTA which handles "last chance" exceptions. It does practically the
! same thing as DELTA_BPT in handling primary exceptions except for a
! message which is displayed prior to giving control to the user.
!
! Formal parameters:
!
	fen,			!Floating point enabled flag
	ireg_adr,		!Address of GPRs, PC, PS
	freg_adr,		!Address of FPRs
	depth: SIGNED,		!Depth argument from mechanism array
	sig_name: LONG		!Signal name/reason
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

MACRO
	except_msg = %STRING('Exception - Signal reason = ') %;
LITERAL
	except_msg_len = 4 + %CHARCOUNT(except_msg);
BIND
	except_msg_buf = UPLIT(BYTE(
				cr,lf,
				except_msg)),
	save_ps = .ireg_adr + (8 * 33): BLOCK[,BYTE];
LOCAL
	ctx: REF BLOCK[,BYTE];			!Context block pointer
!
! Make sure we're using the correct context block for DELTA. If this is DELTA,
! we must figure out the current mode and use it as an index into the context
! block array. Note that in DELTA, we also use the mode as an index into
! the temporary breakpoint arrays so that each mode has their own. In XDELTA,
! we use the IPL as the index.
!
	ctx = mode_context + (.save_ps[psl$v_curmod] * mctx$k_block_size);
	ctx[mctx$l_index] = .save_ps[psl$v_curmod];
	ctx[mctx$v_fen] = .fen;
	BEGIN
	  BIND
	    iregbuf = ctx[mctx$q_iregbuf],	!GPR save area address
	    fregbuf = ctx[mctx$q_fregbuf];	!FP register save area address
	  iregbuf = .ireg_adr;
	  fregbuf = .freg_adr;
	END;
!
! Reestablish the last chance exception vector
!
	IF .depth LSS 0 THEN
	  $setexv(
		ADDRES = xdt$delta_catchall,	!Last chance handler
		ACMODE = .ctx[mctx$l_index],	!Current mode
		VECTOR = 2);			!Last chance vector
!
! Display the "Exception" message
!
	put_string(except_msg_len,except_msg_buf);
	put_hex(.sig_name,2*long_size);
	new_line();
!
! We don't need no stinkin' single-step or step-over messages
!
	ctx[mctx$v_breaks] = 0;
!
! Now take care of this like any breakpoint
!
	break_point(1,.ctx);
!
	RETURN ss$_continue;
END; 					! ROUTINE delta_oops


GLOBAL ROUTINE xdt$delta_exit(
!++
! Functional description:
!
!	This routine is invoked by the exit handler for DELTA when it
! is necessary to go back into command mode from an exit or to do cleanup
! for image exit. It does practically the same thing as DELTA_BPT and
! DELTA_OOPS except for the message which is displayed prior to giving
! control to the user.
!
! Formal parameters:
!
	true_exit,		!Flag indicating type of exit processing needed
	fen,			!Floating point enabled flag
	ireg_adr,		!Address of GPRs, PC, PS
	freg_adr		!Address of FPRs
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

MACRO
	exit_msg = %STRING('Exit ') %;
LITERAL
	exit_msg_len = %CHARCOUNT(exit_msg);
BIND
	exit_msg_buf = UPLIT(BYTE(exit_msg)),
	save_ps = .ireg_adr + (8 * 33): BLOCK[,BYTE];
LOCAL
	prv_mask: BLOCK[8,BYTE]			!Privilege mask
	  INITIAL(LONG(0,0)),			!
	ctx: REF BLOCK[,BYTE];			!Context block pointer
!
! If we're being called to just do cleanup for an image exit, do it and
! let's get outta here...
!
	IF .true_exit THEN
	  BEGIN
	    prv_mask[prv$v_cmkrnl] = 1;
	    prv_mask[prv$v_cmexec] = 1;
	    $setprv(
		ENBFLG = 1,		!Turn the privs on
		PRVADR = prv_mask,	!Privs to turn on
		PRMFLG = 0);		!Just temporarily
	    IF NOT $cmkrnl( ROUTIN = reset_kernel_exceptions ) THEN
	      $cmexec( ROUTIN = reset_exec_exceptions );
	    RETURN ss$_normal;
	  END;
!
! Make sure we're using the correct context block for DELTA. If this is DELTA,
! we must figure out the current mode and use it as an index into the context
! block array. Note that in DELTA, we also use the mode as an index into
! the temporary breakpoint arrays so that each mode has their own. In XDELTA,
! we use the IPL as the index.
!
	ctx = mode_context + (.save_ps[psl$v_curmod] * mctx$k_block_size);
	ctx[mctx$l_index] = .save_ps[psl$v_curmod];
	ctx[mctx$v_fen] = .fen;
	BEGIN
	  BIND
	    iregbuf = ctx[mctx$q_iregbuf],	!GPR save area address
	    fregbuf = ctx[mctx$q_fregbuf];	!FP register save area address
	  iregbuf = .ireg_adr;
	  fregbuf = .freg_adr;
	END;
!
! Reestablish the exit handler
!
	$dclexh( DESBLK = exit_block );
!
! Display the "Exit" message
!
	new_line();
	put_string(exit_msg_len,exit_msg_buf);
	put_hex(.exit_status,long_size * 2);
	new_line();
!
! Now take care of this like any breakpoint
!
	ctx[mctx$v_breaks] = 0;
	break_point(1,.ctx);
!
	RETURN ss$_normal;
END; 					! ROUTINE delta_exit


ROUTINE set_kernel_exceptions(
!++
! Functional description:
!
!	This routine sets up the kernel mode primary and last chance
! exception vectors for DELTA, saving the previous contents for later
! restoration. This routine must be called from kernel mode.
!
! Formal parameters:
!
	startup_mode			!Debugger startup mode
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

LOCAL
	status;				!Return status value
!
! First, make sure we can establish a kernel rundown handler. If we can't,
! then it's not a good idea to setup our own vectors since we won't be
! able to restore the previous ones.
!
	IF NOT (status = set_rundown(
				reset_kernel_exceptions,
				2,
				.startup_mode)) THEN
	  RETURN .status;
!
! Declare the kernel mode exception vectors
!
	$setexv(
		ADDRES = xdt$delta_exception,	!Primary handler
		ACMODE = PSL$C_KERNEL,		!Kernel mode
		PRVHND = kernel_primary,	!Private stash for old contents
		VECTOR = 0);			!Primary vector
!
	$setexv(
		ADDRES = xdt$delta_catchall,	!Last chance handler
		ACMODE = PSL$C_KERNEL,		!Kernel mode
		PRVHND = kernel_last_chance,	!Private stash for old contents
		VECTOR = 2);			!Last chance vector
!
! While we're here in kernel mode with nothing better to do, try to
! setup the exec and supervisor mode vectors
!
	RETURN set_exec_exceptions(.startup_mode);
!
END; 					! ROUTINE set_kernel_exceptions


ROUTINE set_exec_exceptions(
!++
! Functional description:
!
!	This routine sets up the executive and supervisor mode primary and
! last chance exception vectors for DELTA, saving the previous contents for
! later restoration. We try the exec mode vectors first and then the supervisor
! ones, returning an error if neither were successfully setup. This routine
! must be called from execute or kernel mode.
!
! Formal parameters:
!
	startup_mode			!Debugger startup mode
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

LOCAL
	arg_list: VECTOR[4,LONG],		!$CMKRNL argument list
	status;					!Return status value
!
! We may need to setup a process rundown handler for executive mode because
! we may have failed to do so in kernel mode. This rundown handler will
! reset both the executive and supervisor mode primary and last chance
! exception vectors. However, if the kernel rundown handler was setup, it'll
! take care of this. The set_rundown routines keeps track of this.
!
	arg_list[0] = 3;
	arg_list[1] = reset_exec_exceptions;
	arg_list[2] = 3;
	arg_list[3] = .startup_mode;
!
	IF NOT (status = $cmkrnl(
				ROUTIN = set_rundown,
				ARGLST = arg_list)) THEN
	  RETURN .status;
!
! Declare the executive mode exception vectors
!
	$setexv(
		ADDRES = xdt$delta_exception,	!Primary handler
		ACMODE = PSL$C_EXEC,		!Executive mode
		PRVHND = exec_primary,		!Private stash for old contents
		VECTOR = 0);			!Primary vector
!
	$setexv(
		ADDRES = xdt$delta_catchall,	!Last chance handler
		ACMODE = PSL$C_EXEC,		!Executive mode
		PRVHND = exec_last_chance,	!Private stash for old contents
		VECTOR = 2);			!Last chance vector
!
! Declare the supervisor mode exception vectors
!
	$setexv(
		ADDRES = xdt$delta_exception,	!Primary handler
		ACMODE = PSL$C_SUPER,		!Supervisor mode
		PRVHND = super_primary,		!Private stash for old contents
		VECTOR = 0);			!Primary vector
!
	$setexv(
		ADDRES = xdt$delta_catchall,	!Last chance handler
		ACMODE = PSL$C_SUPER,		!Supervisor mode
		PRVHND = super_last_chance,	!Private stash for old contents
		VECTOR = 2);			!Last chance vector
!
	RETURN ss$_normal;
END; 					! ROUTINE set_exec_exceptions


ROUTINE set_rundown(
!++
! Functional description:
!
!	This routine sets up process rundown handlers (if possible) to
! reset the primary and last chance exception vectors for the inner modes.
! This routine must be called from kernel mode.
!
! Formal parameters:
!
	handler_adr,			!Rundown handler address
	vector_type,			!Rundown vector (2 => kernel; 3 => exec)
	startup_mode			!Debugger startup mode
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

OWN
	rundown_set: INITIAL(0);		!Flag to only do it once
LOCAL
	status;					!Return status value
!
! If we've already established a rundown handler, we don't have to do it
! again
!
	IF .rundown_set THEN
	  RETURN ss$_normal;
!
! OK...First time...I know you're nervous...Take deep breaths and relax...
! If DELTA started up in an inner mode, we don't have to worry about it.
!
	IF .startup_mode NEQ psl$c_user THEN
	  RETURN ss$_normal;
!
! Add the new vector if possible.
!
	IF img$add_privileged_vector_entry EQL 0 THEN
	  RETURN ss$_normal;
!
	status = img$add_privileged_vector_entry(
				.handler_adr,		!Routine address
				.vector_type,		!Kernel or exec
				0);			!Image-temporary
!
	IF .status THEN
	  rundown_set = 1;
!
	RETURN .status;			! Return status
END; 					! ROUTINE set_rundown


ROUTINE reset_kernel_exceptions =
!++
! Functional description:
!
!	This routine resets the kernel mode primary and last chance
! exception vectors for DELTA, restoring what was stashed away when we
! established our own vectors. While it's at it, it'll reset the exec
! and supervisor mode ones as well.
!
! Formal parameters:
!
!	None
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

LOCAL
	status;					!Return status value
!
! Reset the kernel mode exception vectors
!
	IF .kernel_primary NEQ -1 THEN
	  BEGIN
	    IF $setexv(
			ADDRES = .kernel_primary,	!Primary handler
			ACMODE = PSL$C_KERNEL,		!Kernel mode
			VECTOR = 0) THEN		!Primary vector
	      kernel_primary = -1;
	  END;
!
	IF .kernel_last_chance NEQ -1 THEN
	  BEGIN
	    IF $setexv(
			ADDRES = .kernel_last_chance,	!Last chance handler
			ACMODE = PSL$C_KERNEL,		!Kernel mode
			VECTOR = 2) THEN		!Last chance vector
	      kernel_last_chance = -1;
	  END;
!
! Now take care of the executive and supervisor mode ones while we're at it
!
	reset_exec_exceptions();
!
	RETURN ss$_normal;
END; 					! ROUTINE reset_kernel_exceptions


ROUTINE reset_exec_exceptions =
!++
! Functional description:
!
!	This routine resets the executive and supervisor mode primary and
! last chance exception vectors for DELTA, restoring what we stashed away
! during setup of our own vectors for debug.
!
! Formal parameters:
!
!	None
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

LOCAL
	status;					!Return status value
!
! Reset the executive mode exception vectors
!
	IF .exec_primary NEQ -1 THEN
	  BEGIN
	    IF $setexv(
			ADDRES = .exec_primary,		!Primary handler
			ACMODE = PSL$C_EXEC,		!Executive mode
			VECTOR = 0) THEN		!Primary vector
	      exec_primary = -1;
	  END;
!
	IF .exec_last_chance NEQ -1 THEN
	  BEGIN
	    IF $setexv(
			ADDRES = .exec_last_chance,	!Last chance handler
			ACMODE = PSL$C_EXEC,		!Executive mode
			VECTOR = 2) THEN		!Last chance vector
	      exec_last_chance = -1;
	  END;
!
! Declare the supervisor mode exception vectors
!
	IF .super_primary NEQ -1 THEN
	  BEGIN
	    IF $setexv(
			ADDRES = .super_primary,	!Primary handler
			ACMODE = PSL$C_SUPER,		!Supervisor mode
			VECTOR = 0) THEN		!Primary vector
	      super_primary = -1;
	  END;
!
	IF .super_last_chance NEQ -1 THEN
	  BEGIN
	    IF $setexv(
			ADDRES = .super_last_chance,	!Last chance handler
			ACMODE = PSL$C_SUPER,		!Supervisor mode
			VECTOR = 2) THEN		!Last chance vector
	      super_last_chance = -1;
	  END;
!
	RETURN ss$_normal;
END; 					! ROUTINE reset_exec_exceptions


ROUTINE loosen_protection(
!++
! Functional description:
!
!	This routine sets an address range to be writeable. If the starting
! and ending addresses are the same, one page only will be unprotected.
!
! Formal parameters:
!
	start_adr,			!Starting virtual address
	end_adr,			!Ending virtual address
	prev_prot			!Address for previous protection (or 0)
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

LOCAL
	arg_list: VECTOR[5,LONG],		!$CMKRNL argument list
	old_prot,				!Temp. holder for protection
	status;					!Return status
!
! First try to change the page protection in kernel mode
!
	arg_list[0] = 4;
	arg_list[1] = .start_adr;
	arg_list[2] = .end_adr;
	arg_list[3] = prt$c_uw;
	arg_list[4] = old_prot;
!
	status = $cmkrnl(
			ROUTIN = set_protection,
			ARGLST = arg_list);
!
! If that failed for some reason, we'll take another shot at just calling
! it, hoping it'll work from a less privileged mode
!
	IF NOT .status THEN
	  status = set_protection(.start_adr,.end_adr,prt$c_uw,old_prot);
!
! If the caller wants the previous protection, return it
!
	IF .prev_prot NEQ 0 THEN
	  .prev_prot = .old_prot;
!
	RETURN .status;			! Return the appropriate status
END; 					! ROUTINE loosen_protection


ROUTINE set_protection(
!++
! Functional description:
!
!	This routine sets an address range to be writeable. If the starting
! and ending addresses are the same, one page protection will be modified.
!
! Formal parameters:
!
	start_adr,			!Starting virtual address
	end_adr,			!Ending virtual address
	new_prot,			!New page protection to use
	prev_prot			!Address for previous protection
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

LOCAL
	address_range: VECTOR[2,LONG];		!Input address range
!
! Just call the system service and return its status to the caller
!
	address_range[0] = .start_adr;
	address_range[1] = .end_adr;
	.prev_prot = 0;
!
	RETURN $setprt(
			INADR  = address_range,
			PROT   = .new_prot,
!			ACMODE = 0,
			PRVPRT = .prev_prot);
!
END; 					! ROUTINE set_protection


ROUTINE reset_protection(
!++
! Functional description:
!
!	This routine resets address space protection back to what it was
! before.
!
! Formal parameters:
!
	start_adr,			!Starting virtual address
	end_adr,			!Ending virtual address
	new_prot			!The protection to restore
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

LOCAL
	arg_list: VECTOR[5,LONG],		!$CMKRNL argument list
	old_prot,				!Temp. holder for protection
	status;					!Return status
!
! First try to change the page protection in kernel mode
!
	arg_list[0] = 4;
	arg_list[1] = .start_adr;
	arg_list[2] = .end_adr;
	arg_list[3] = .new_prot;
	arg_list[4] = old_prot;
!
	status = $cmkrnl(
			ROUTIN = set_protection,
			ARGLST = arg_list);
!
! If that failed for some reason, we'll take another shot at just calling
! it, hoping it'll work from a less privileged mode
!
	IF NOT .status THEN
	  status = set_protection(.start_adr,.end_adr,.new_prot,old_prot);
!
	RETURN .status;			! Return the appropriate status
END; 					! ROUTINE reset_protection


ROUTINE get_loadable_images =
!++
! Functional description:
!
!	This routine is invoked to make a current, local copy of the exec
! loadable image database for DELTA (if what we currently have isn't currently
! current). This must be synchronized with any updates to the loadable image
! database. It is invoked whenever the DELTA user requests a display of the
! exec loadable images.
!
! Formal parameters:
!
!	None
!
! Implicit inputs:
!
!	ldr_image_head	: Local queue header
!	ldr_seq		: Local sequence number
!	ldr_cnt		: Local image count
!	ldr_size	: Size of currently allocated buffer
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

LOCAL
	alloc_needed,			!Allocation needed flag
	ldr_vm,				!Temp. holder for allocated buffer adr
	ldr_entry: REF BLOCK[,BYTE],	!System entry pointer
	status;				!Return status value
!
! If we don't have dynamic memory allocation/deallocation routines
! available, then we don't support ";L" in DELTA.
!
	IF (lib$get_vm EQL 0) OR (lib$free_vm EQL 0) THEN
	  RETURN 0;
!
! This entire routine executes in a loop, trying to get an accurate snapshot
! of the exec loadable image database, until it gets through it all with
! sequence numbers that match. As you can imagine, this could potentially
! take a while...
!
	DO BEGIN
!
	alloc_needed = 0;
!
! If we don't yet have a local buffer allocated, just flag that one is
! needed.
!
	IF .ldr_size EQL 0 THEN
	  alloc_needed = 1
	ELSE
!
! If we currently have a local buffer allocated, see if it's already
! up to date. If not, see if it might be reusable (the correct size).
!
	  IF .ldr_cnt LSS .exe$gl_ldr_cnt THEN
	    BEGIN
	      ldr_vm = .ldr_image_head[0];
	      lib$free_vm(ldr_size,ldr_vm);
	      ldr_image_head[0] = ldr_image_head;
	      ldr_image_head[1] = ldr_image_head;
	      alloc_needed = 1;
	    END
	  ELSE
!
! If it just so happens that we already have a local copy of the current
! exec loadable image database, no point in hanging around here. Just
! return right away.
!
	    IF .ldr_seq EQL .exe$gl_ldr_seq THEN
	      RETURN ss$_normal
	    ELSE
	      BEGIN
		ldr_vm = .ldr_image_head[0];
		ch$fill(0,.ldr_size,.ldr_vm);
		ldr_image_head[0] = ldr_image_head;
		ldr_image_head[1] = ldr_image_head;
	      END;
!
! Record the current sequence number (once it's in a consistent state) and
! allocate a new buffer if we need one
!
	WHILE .exe$gl_ldr_seq DO ;
!
	ldr_seq = .exe$gl_ldr_seq;
	ldr_cnt = .exe$gl_ldr_cnt;
!
	IF .alloc_needed THEN
	  BEGIN
	    ldr_size = .ldr_cnt * ldrimg$c_length;
	    IF NOT (status = lib$get_vm(ldr_size,ldr_vm)) THEN
	      BEGIN
		ldr_size = 0;
		RETURN .status;
	      END;
	  END;
!
! OK, I now have a buffer of adequate size in ldr_vm, its size stashed away
! for future reference. The local queue header has been initialized to
! empty. Now we're going to go through the system exec loadable image list
! one entry at a time, making copies as we go and adding them to our local
! queue. If at any time during this activity the sequence numbers get out
! of synch, we start over again.
!
	ldr_entry = .ldr$gq_image_list[0];
	WHILE (.ldr_entry NEQ ldr$gq_image_list) AND
	      (.ldr_seq EQL .exe$gl_ldr_seq) DO
	  BEGIN
	    ch$move(ldrimg$c_length,.ldr_entry,.ldr_vm);
	    $insert_queue(.ldr_vm,.ldr_image_head[1]);
	    ldr_entry = .ldr_entry[ldrimg$l_flink];
	    ldr_vm = .ldr_vm + ldrimg$c_length;
	  END;
!
! What allows this routine to finally complete are matching sequence numbers
! (our local copy matches the system one).
!
	END UNTIL .ldr_seq EQL .exe$gl_ldr_seq;
!
	RETURN ss$_normal;
END; 					! ROUTINE get_loadable_images


ROUTINE put_shareable_images =
!++
! Functional description:
!
!	This routine displays the names and locations of the shareable
! images currently mapped with this executable image.
!
! Formal parameters:
!
!	None
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

LOCAL
	list_head: REF VECTOR[,LONG,SIGNED],	!IMCB list head
	image_le: REF BLOCK[,BYTE],		!Image list entry
	imgnam_buf: VECTOR[imcb$s_image_name,BYTE],!Image name buffer
	kferes_ptr: REF BLOCK[,BYTE],		!Resident code section ptr
	section_count,				!Count of resident code sections
	data_count,				!Compressed data sections
	status;					!Return status value
!
! If we can't resolve the pointer to the list head, we can't go any further
!
	IF ctl$gl_imglstptr EQL 0 THEN
	  RETURN 0;
!
	list_head = .ctl$gl_imglstptr;
!
! If the queue itself is empty at this point, there's nothing to display
!
	IF .list_head[0] EQL list_head[0] THEN
	  RETURN ss$_normal;
!
! Display a header of information to make the image display a little
! more comprehensible
!
	new_line();
	put_string(imgnam_msg_len,imgnam_message);
	INCR index FROM 1 TO (imcb$s_image_name - imgnam_msg_len + 1) DO
	  put_char(space);
	put_string(imgbas_msg_len,imgbas_message);
	INCR index FROM 1 TO (long_size*2 - imgbas_msg_len + 1) DO
	  put_char(space);
	put_string(imgend_msg_len,imgend_message);
	INCR index FROM 1 TO (long_size*2 - imgend_msg_len + 1) DO
	  put_char(space);
	put_string(imgsym_msg_len,imgsym_message);
	put_char(space);
	put_char(space);
	put_string(imgflg_msg_len,imgflg_message);
	new_line();
	new_line();
!
! Now traverse the IMCB list and display the image information
!
	image_le = .list_head[0];
	WHILE .image_le NEQ .list_head DO
	  BEGIN
	    BIND
	      imgnam_size = image_le[imcb$t_image_name] : BYTE,
	      imgnam_adr = 1 + image_le[imcb$t_image_name];
!
	    ch$copy(.imgnam_size,imgnam_adr,		!Source size and address
		    %C' ',				!Fill with blanks
		    imcb$s_image_name,imgnam_buf);	!Destination string
	    put_string(imcb$s_image_name,imgnam_buf);
!
! Display the base address of the image
!
	    put_char(space);
	    put_hex(.image_le[imcb$l_starting_address],2*long_size);
!
! Display the ending address of the image
!
	    put_char(space);
	    put_hex(.image_le[imcb$l_end_address],2*long_size);
!
! Display the symbol vector address of the image if it's valid
!
	    IF .image_le[imcb$ps_symbol_vector_address] NEQ 0 THEN
	      BEGIN
		put_char(space);
		put_hex(.image_le[imcb$ps_symbol_vector_address],2*long_size);
		INCR index FROM 1 TO (imgsym_msg_len - long_size*2 + 2) DO
		  put_char(space);
	      END
	    ELSE
	      INCR index FROM 1 TO (imgsym_msg_len + 3) DO
		put_char(space);
!
! Display some flag information about the image
!
	    IF .image_le[imcb$b_act_code] EQL imcb$k_main_program THEN
	      put_char(%C'M')
	    ELSE
	      put_char(space);
	    put_char(space);
	    IF .image_le[imcb$v_shareable] THEN
	      put_char(%C'S')
	    ELSE
	      put_char(space);
	    put_char(space);
	    IF .image_le[imcb$v_protected] THEN
	      put_char(%C'P');
!
! If there are resident code sections in this image, display the starting
! and ending addresses of each...after displaying some header info.
!
	    IF .image_le[imcb$v_discontiguous] THEN
	      BEGIN
		new_line();
		put_string(imgres_msg_len,imgres_message);
!
		kferes_ptr = .image_le[imcb$l_kferes_ptr];
		section_count = .kferes_ptr[kferes$l_count];
		data_count = .kferes_ptr[kferes$l_data_count];
		kferes_ptr = .kferes_ptr + kferes$k_fixed_length;
		INCR index FROM 1 TO .section_count DO
		  BEGIN
		    new_line();
		    INCR index FROM 1 TO (imcb$s_image_name + 1) DO
		      put_char(space);
		    put_hex(.kferes_ptr[kferes$l_va],2*long_size);
		    put_char(space);
		    put_hex(.kferes_ptr[kferes$l_va] +
			    .kferes_ptr[kferes$l_length],2*long_size);
		    kferes_ptr = .kferes_ptr + kferes$k_section_length;
		  END;
!
! If there are also compressed data sections in this image, display the starting
! and ending addresses of each...after displaying some header info.
!
		IF .image_le[imcb$v_compress_datasec] THEN
		  BEGIN
		    new_line();
		    put_string(imgdat_msg_len,imgdat_message);
!
		    INCR index FROM 1 TO .data_count DO
		      BEGIN
			new_line();
			INCR index FROM 1 TO (imcb$s_image_name + 1) DO
			  put_char(space);
			put_hex(.kferes_ptr[kferes$l_va],2*long_size);
			put_char(space);
			put_hex(.kferes_ptr[kferes$l_va] +
			    .kferes_ptr[kferes$l_length],2*long_size);
			kferes_ptr = .kferes_ptr + kferes$k_section_length;
		      END;
		  END;
	      END;
!
! Get the next queue entry
!
	    new_line();
	    image_le = .image_le[imcb$l_flink];
	  END;
!
	RETURN ss$_normal;
END; 					! ROUTINE put_shareable_images


ROUTINE locate_process_address( 
!++
! Functional description:
!
!	This routine displays the name and location of the mapped image
! (shareable or main) which contains the input address. Because image
! sections can be scattered all over creation, it's nice to have the
! debugger do this for you, the desperate user. Then the user can have a
! prayer of finding this address in a map file somewhere.
!
! Formal parameters:
!
	ctx: REF BLOCK[0,BYTE]		!Ptr to mode context block
	) =
!
!	Address - system space address we are attempting to identify
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

BIND
	fld = ctx[mctx$q_fields] : VECTOR;	!Input fields
LOCAL
	list_head: REF VECTOR[,LONG,SIGNED],	!IMCB list head
	image_le: REF BLOCK[,BYTE],		!Image list entry
	imgnam_buf: VECTOR[imcb$s_image_name,BYTE],!Image name buffer
	kferes_ptr: REF BLOCK[,BYTE],		!Resident code section ptr
	section_count,				!Count of resident code sections
	data_count,				!Count of data sections
	section_no,				!Section number
	address: LONG SIGNED,			!Address we're looking for
	found,					!Boolean flag
	offset,					!Map file offset
	status;					!Return status value
!
! If we can't resolve the pointer to the list head, we can't go any further
!
	IF ctl$gl_imglstptr EQL 0 THEN
	  RETURN 0;
!
	list_head = .ctl$gl_imglstptr;
!
! If the queue itself is empty at this point, there's nothing to display
!
	IF .list_head[0] EQL list_head[0] THEN
	  RETURN 0;
	address = .fld[0];
!
! Now traverse the IMCB list and try to find the mystery address
!
	image_le = .list_head[0];
	WHILE .image_le NEQ .list_head DO
	  BEGIN
	    BIND
	      imgnam_size = image_le[imcb$t_image_name] : BYTE,
	      imgnam_adr = 1 + image_le[imcb$t_image_name];
!
! We first check to see if this is a sliced and diced image. If so,
! we want to first look through the resident code sections and compressed
! data sections (if any) for the specified address. We look here first
! because if we have compressed data sections, the correct value can only
! be found here. A misleading match could be found in the IMCB.
!
	    found = 0;
	    IF .image_le[imcb$v_discontiguous] THEN
	      BEGIN
		kferes_ptr = .image_le[imcb$l_kferes_ptr];
		IF .image_le[imcb$v_compress_datasec] THEN
		  section_count = .kferes_ptr[kferes$l_count] +
				  .kferes_ptr[kferes$l_data_count]
		ELSE
		  section_count = .kferes_ptr[kferes$l_count];
		kferes_ptr = .kferes_ptr + kferes$k_fixed_length;
		section_no = 0;
		WHILE (.section_no LSS .section_count) AND (NOT .found) DO
		  BEGIN
		    IF (.address GEQ .kferes_ptr[kferes$l_va]) AND
		       (.address LEQ
		       (.kferes_ptr[kferes$l_va] +
			.kferes_ptr[kferes$l_length])) THEN
		      BEGIN
			found = 1;
!
! We found the address in a KFERES section. A shareable image is effectively
! based at zero, but a main image is based wherever the linker put it. So
! the "offset" calculation below reflects that difference.
!
			offset = (.address - .kferes_ptr[kferes$l_va]) +
					.kferes_ptr[kferes$l_image_offset];
			IF .image_le[imcb$b_act_code] EQL imcb$k_main_program
			  THEN offset = .offset +
					.image_le[imcb$l_starting_address];
		      END
		    ELSE
		      BEGIN
			section_no = .section_no + 1;
			kferes_ptr = .kferes_ptr + kferes$k_section_length;
		      END;
		  END;
	      END
	    ELSE
!
! If the image isn't sliced and diced, we just try to find a match with
! the starting and ending address from the IMCB. Once again, the "offset"
! calculation, which is attempting to locate this address in the map file
! of the respective image, reflects the difference between main images and
! shareable images, where the latter is effectively based at zero.
!
	      IF (.address GEQ .image_le[imcb$l_starting_address]) AND
	         (.address LEQ .image_le[imcb$l_end_address]) THEN
	        BEGIN
		  found = 1;
		  IF .image_le[imcb$b_act_code] EQL imcb$k_main_program THEN
		    offset = .address
		  ELSE
		    offset = .address - .image_le[imcb$l_starting_address];
	        END;
!
! If we found something, we'll display all the regular gobbledegook about
! this image as well as the where the specified address can be found in
! the map file (offset from the base of the image).
!
	    IF .found THEN
	      BEGIN
!
! Display a header of information to make the image display a little
! more comprehensible
!
		new_line();
		put_string(imgnam_msg_len,imgnam_message);
		INCR index FROM 1 TO (imcb$s_image_name - imgnam_msg_len + 1) DO
		  put_char(space);
		put_string(imgbas_msg_len,imgbas_message);
		INCR index FROM 1 TO (long_size*2 - imgbas_msg_len + 1) DO
		  put_char(space);
		put_string(imgend_msg_len,imgend_message);
		INCR index FROM 1 TO (long_size*2 - imgend_msg_len + 1) DO
		  put_char(space);
		put_string(imgsym_msg_len,imgsym_message);
		put_char(space);
		put_char(space);
		put_string(imgflg_msg_len,imgflg_message);
		new_line();
		new_line();
!
! Display the image name
!
		ch$copy(.imgnam_size,imgnam_adr,	!Source size and address
		        %C' ',				!Fill with blanks
		        imcb$s_image_name,imgnam_buf);	!Destination string
		put_string(imcb$s_image_name,imgnam_buf);
!
! Display the base address of the image
!
		put_char(space);
		put_hex(.image_le[imcb$l_starting_address],2*long_size);
!
! Display the ending address of the image
!
		put_char(space);
		put_hex(.image_le[imcb$l_end_address],2*long_size);
!
! Display the symbol vector address of the image if it's valid
!
		IF .image_le[imcb$ps_symbol_vector_address] NEQ 0 THEN
		  BEGIN
		    put_char(space);
		    put_hex(.image_le[imcb$ps_symbol_vector_address],
			    2*long_size);
		    INCR index FROM 1 TO (imgsym_msg_len - long_size*2 + 2) DO
		      put_char(space);
	          END
		ELSE
		  INCR index FROM 1 TO (imgsym_msg_len + 3) DO
		    put_char(space);
!
! Display some flag information about the image
!
		IF .image_le[imcb$b_act_code] EQL imcb$k_main_program THEN
		  put_char(%C'M')
		ELSE
		  put_char(space);
		put_char(space);
		IF .image_le[imcb$v_shareable] THEN
		  put_char(%C'S')
		ELSE
		  put_char(space);
		put_char(space);
		IF .image_le[imcb$v_protected] THEN
		  put_char(%C'P');
!
! If there are resident code sections in this image, display the starting
! and ending addresses of each...after displaying some header info.
!
		IF .image_le[imcb$v_discontiguous] THEN
		  BEGIN
		    new_line();
		    put_string(imgres_msg_len,imgres_message);
!
		    kferes_ptr = .image_le[imcb$l_kferes_ptr];
		    section_count = .kferes_ptr[kferes$l_count];
		    data_count = .kferes_ptr[kferes$l_data_count];
		    kferes_ptr = .kferes_ptr + kferes$k_fixed_length;
		    INCR index FROM 1 TO .section_count DO
		      BEGIN
		        new_line();
		        INCR index FROM 1 TO (imcb$s_image_name + 1) DO
		          put_char(space);
		        put_hex(.kferes_ptr[kferes$l_va],2*long_size);
		        put_char(space);
		        put_hex(.kferes_ptr[kferes$l_va] +
				.kferes_ptr[kferes$l_length],2*long_size);
		        kferes_ptr = .kferes_ptr + kferes$k_section_length;
		      END;
!
! If there are also compressed data sections in this image, display the starting
! and ending addresses of each...after displaying some header info.
!
		    IF .image_le[imcb$v_compress_datasec] THEN
		      BEGIN
			new_line();
			put_string(imgdat_msg_len,imgdat_message);
!
			INCR index FROM 1 TO .data_count DO
			  BEGIN
			    new_line();
			    INCR index FROM 1 TO (imcb$s_image_name + 1) DO
			      put_char(space);
			    put_hex(.kferes_ptr[kferes$l_va],2*long_size);
			    put_char(space);
			    put_hex(.kferes_ptr[kferes$l_va] +
			            .kferes_ptr[kferes$l_length],2*long_size);
			    kferes_ptr = .kferes_ptr + kferes$k_section_length;
		          END;
		      END;
		  END;
!
! Lastly, display the map file offset (the whole reason for doing this
! nonsense to begin with)
!
		new_line();
		new_line();
		put_string(imgmoff_msg_len,imgmoff_message);
	        put_hex(.offset,2*long_size);
!
! Since we found one, we're done
!
		new_line();
		RETURN ss$_normal;
	      END;
!
! Get the next queue entry
!
	    image_le = .image_le[imcb$l_flink];
	  END;
!
	RETURN 0;
END; 					! ROUTINE locate_process_address


ROUTINE poke_other_process(
!++
! Functional description:
!
!	This routine is invoked to do an examine or deposit in the address
! space of another process. It invokes new exec support routines to do
! the actual work. However, we must get into kernel mode to call them.
!
! Formal parameters:
!
	ctx: REF BLOCK[0,BYTE],		!Ptr to mode context block
	source_adr,			!Source address of data
	dest_adr,			!Destination address for data
	data_size,			!Amount of data
	operation			!Fetch (0) or store (1)
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

LOCAL
	arg_list: VECTOR[6,LONG];	!$CMKRNL argument list
!
! If this is a write operation and writes have not been enabled via
! the ";M" command, we can return immediately
!
	IF .operation THEN
	  IF NOT .ctx[mctx$l_modify_enable] THEN
	    RETURN 0;
!
! Just call the routine which does the actual work in kernel mode and wait
! for it to complete.
!
	arg_list[0] = 5;
	arg_list[1] = .ctx;
	arg_list[2] = .source_adr;
	arg_list[3] = .dest_adr;
	arg_list[4] = .data_size;
	arg_list[5] = .operation;
!
	RETURN $cmkrnl(
			ROUTIN = other_process,
			ARGLST = arg_list);
!
END; 					! ROUTINE poke_other_process


ROUTINE other_process(
!++
! Functional description:
!
!	This routine is invoked to do an examine or deposit in the address
! space of another process. This routine uses new VMS exec routines to do
! the actual work.
!
! Formal parameters:
!
	ctx: REF BLOCK[0,BYTE],		!Ptr to mode context block
	source_adr,			!Source address of data
	dest_adr,			!Destination address for data
	data_size,			!Amount of data
	operation			!Fetch (0) or store (1)
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

BIND
	dot = ctx[mctx$q_dot],		!Current location
	iregbuf = ctx[mctx$q_iregbuf],	!GPR save area address
	fregbuf = ctx[mctx$q_fregbuf];	!FP register save area address
LOCAL
	access_type,			!Memory or register
	target_adr,			!Target address or register number
	regnum;				!Temp. storage for register number
!
! If these new exec support routines are not defined, disallow this operation
!
	IF (exe$read_process EQL 0) OR (exe$write_process EQL 0) THEN
	  RETURN 0;
!
! Based on the operation type, invoke the VMS exec routine to do it.
!
	IF .operation EQL 0 THEN
	  BEGIN
!
! If this is an attempt to read a floating point register, return an error
! (it's not yet supported)
!
	    IF ((regnum = (.source_adr - .fregbuf)) GEQ 0) AND
	       ((regnum = (.regnum / quad_size)) LEQ num_gprs) THEN
	      BEGIN
		RETURN 0;
	      END;
!
! Let's assume a memory access until we know otherwise
!
	    access_type = eacb$k_memory;
	    target_adr = .source_adr;
!
! If this is an attempt to read a GPR, PC, or PS from another process, we
! need to derive the register number for the call.
!
	    IF ((regnum = (.source_adr - .iregbuf)) GEQ 0) AND
	       ((regnum = (.regnum / quad_size)) LSS (num_gprs + 2)) THEN
	      BEGIN
		SELECTONE .regnum OF
		  SET
		    [0 TO 29] :
		      BEGIN
			target_adr = .regnum;
			access_type = eacb$k_general_register;
		      END;
		    [30] : RETURN 0;
		    [31] :
		      BEGIN
			ch$fill(0,.data_size,.dest_adr);
			RETURN ss$_normal;
		      END;
		    [32 TO 33] :
		      BEGIN
			target_adr = .regnum - 2;
			access_type = eacb$k_general_register;
		      END;
		  TES;
	      END;
!
	    RETURN exe$read_process(
				.ctx[mctx$l_pid],
				.data_size,
				.target_adr,
				.dest_adr,
				.access_type,
				ast_counter);
	  END
	ELSE
!
! OK, we're doing a write operation
!
	  BEGIN
!
! If this is an attempt to write a floating point register, return an error
! (it's not yet supported)
!
	    IF ((regnum = (.dest_adr - .fregbuf)) GEQ 0) AND
	       ((regnum = (.regnum / quad_size)) LEQ num_gprs) THEN
	      BEGIN
		RETURN 0;
	      END;
!
! Let's assume a memory access until we know otherwise
!
	    access_type = eacb$k_memory;
	    target_adr = .dest_adr;
!
! If this is an attempt to write a GPR, PC, or PS in another process, we
! need to derive the register number for the call.
!
	    IF ((regnum = (.dest_adr - .iregbuf)) GEQ 0) AND
	       ((regnum = (.regnum / quad_size)) LSS (num_gprs + 2)) THEN
	      BEGIN
		SELECTONE .regnum OF
		  SET
		    [0 TO 29] :
		      BEGIN
			target_adr = .regnum;
			access_type = eacb$k_general_register;
		      END;
		    [30 TO 31] : RETURN 0;
		    [32 TO 33] :
		      BEGIN
			target_adr = .regnum - 2;
			access_type = eacb$k_general_register;
		      END;
		  TES;
	      END;
!
	    RETURN exe$write_process(
				.ctx[mctx$l_pid],
				.data_size,
				.source_adr,
				.target_adr,
				.access_type,
				ast_counter);
	  END;
!
END; 					! ROUTINE other_process


!
! This marks the end of the DELTA-specific initialization and utility
! routines and the start of XDELTA-specific initialization and utility
! routines.
!
	%else

!
! First thing we gotta do is declare XDT$SYSDBG_INIT as an initialization
! routine so that it can be found by SYS$DOINIT upon initialization of the
! SYSTEM_DEBUG exec loadable image...and none of the other XDELTA environments
! really care. Next we put XDT$SYSDBG_INIT (code and linkage section) into
! special PSECTs (note that $declare_psect implicitly takes care of the
! linkage section).
!
$initialization_routine( name = xdt$sysdbg_init );
$declare_psect(exec$init_code);


GLOBAL ROUTINE xdt$sysdbg_init(
!++
! Functional description:
!
!	This routine handles XDELTA-specific initialization in the context
! of the SYSTEM_DEBUG exec loadable image.. It is meant to be called once by
! SYS$DOINIT only prior to using any XDELTA functions. It performs many of
! the same initialization functions as XDT$INIT, using common flags to only
! initialize certain things once. So it shouldn't hurt to call this routine
! multiple times. This routine does NOT setup the initial breakpoint. XDT$INIT
! must be called to do that.
! 	This routine stuffs the XDELTA breakpoint ISR address into the SCB
! and sets up the SCB parameter. A few other XDELTA-specific things are also
! initialized.
!
! Formal parameters:
!
	ldrimg_base,			!Loadable image base address
	ldrimg_flags			!Flags for loader
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	System SCB modified.
!
!--

BEGIN

!
! Note: In this version of XDELTA, exe$gl_scb is always defined and points
!	to the current SCB, whether it's the one being used by VMB, SYSBOOT,
!	or the debug loadable image.
!
BIND
	bpt_entry = .exe$gl_scb + %x'400' : SIGNED,
	scb_param = .exe$gl_scb + %x'408' : SIGNED,
	ipl14_entry = .exe$gl_scb + %x'5E0' : SIGNED,
	ipl14_param = .exe$gl_scb + %x'5E8' : SIGNED,
	iregbuf = mode_context[mctx$q_iregbuf],
	fregbuf = mode_context[mctx$q_fregbuf],
	bpt_adr = perm_bpts[0,pbpt$q_breakpoint],
	bpt_disp = perm_bpts[0,pbpt$q_display],
	bpt_cmd = perm_bpts[0,pbpt$q_cmd_string];
LOCAL
	bpt_address;

!
! Do any data structure/state initialization here, but not more than once
! for some things
!
	iregbuf = xdt$iregsav;
	fregbuf = xdt$fregsav;
	mode_context[mctx$l_data_length] = long_size;
!
	IF NOT .init_flag THEN
	  BEGIN
	    init_flag = 1;
	    IF pfn$pl_database NEQ 0 THEN
	      BEGIN
		xregs[13] = .pfn$pl_database;
		xregs[14] = xds$gt_pfn_x0;
		xregs[15] = xds$gt_pfn_r0;
	      END;
	  END;
!
! Write the XDELTA breakpoint ISR address into the SCB. Note that the
! xdt$bpt symbol is already the start address of the code and NOT a
! procedure descriptor.
!
	bpt_entry = xdt$bpt;
!
! Load the SCB parameter with the linkage pointer for the benefit of
! interrupt and exception routines written in assembly language.
!
	scb_param = xdt$bpt_lp;
!
! If VMS is up and running, setup the software interrupt level 14 handler
! which traps into XDELTA.
!
	IF $init_done THEN
	  BEGIN
!	    ipl14_entry = xdt$ipl14_handler;
!	    ipl14_param = xdt$bpt_lp;
!
! Disable SMP timeouts while XDELTA is loaded (if VMS up and running).
!
	    exe$gl_time_control = .exe$gl_time_control OR
				(exe$m_nosmpsanity OR exe$m_nospinwait);
	  END;
!
! Let's remember the transfer address through SYS.EXE for future reference
! (if we're linked with SYS.EXE).
!
	IF ini$writable NEQ 0 THEN
	  BEGIN
	    xfer_address = ini$writable;
	    xfer_address = .(.xfer_address + 8);
	  END;
!
! Since this routine is called only by EXEC_INIT, we can safely default
! to using INI$BRK to represent the address of the initial breakpoint
! (as long as it's defined).
!
	perm_bpts[0,pbpt$v_invalid] = 0;
	perm_bpts[0,pbpt$l_instruction] = 0;
	bpt_disp = 0;
	bpt_cmd = 0;
	bpt_adr = 0;
!
	IF ini$brk NEQ 0 THEN
!
! If we can find the address of the BPT instruction, set it up as perm_bpts[0].
! Otherwise, forget it.
!
	  BEGIN
	    bpt_address = ini$brk;
	    bpt_address = .(.bpt_address + 8);
	    BEGIN
	      BIND code_adr = .bpt_address : BLOCK[,BYTE];
	      IF (.code_adr[ei$v_opcode] EQL evx$opc_pal) AND
	         (.code_adr[ei$v_pal_func] EQL evx$pal_bpt) THEN
	        bpt_adr = .bpt_address;
	    END;
	  END;
!
	RETURN ss$_normal;
END; 					! ROUTINE xdt$sysdbg_init

!
! Restore the original PSECT definitions
!
PSECT
	CODE = z$debug_code (READ,WRITE,EXECUTE,NOSHARE,PIC,CONCATENATE,
			ALIGN(2)),	!,ADDRESSING_MODE (GENERAL)),
	LINK = z$debug_link (READ,WRITE,NOEXECUTE,NOSHARE,PIC,CONCATENATE,
			ALIGN(4));	!,ADDRESSING_MODE (GENERAL));


GLOBAL ROUTINE xdt$init(
!++
! Functional description:
!
!	This routine handles all XDELTA-specific initialization. It is meant
! to be called once by VMB, SYSBOOT, or INIT, depending on the environment,
! prior to using any XDELTA functions. It shouldn't hurt to call this routine
! multiple times though.
!	This routine must be called to setup the initial breakpoint (if any).
! So in the context of the SYSTEM_DEBUG loadable image, both XDT$SYSDBG_INIT
! and XDT$INIT are likely to be called. They share some of the same
! initialization code to insure that it is done at least once. Common flags
! shared between the routines insure that certain things are never initialized
! more than once.
! 	This routine stuffs the XDELTA breakpoint ISR address into the SCB
! and sets up the SCB parameter. A few other XDELTA-specific things are also
! initialized, depending on the environment in which is invoked.
!
! Formal parameters:
!
	bpt_address: REF BLOCK[,BYTE]		!Initial BPT address (if any)
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	System SCB modified.
!
!--

BEGIN

BUILTIN
	nullparameter;
!
! Note: In this version of XDELTA, exe$gl_scb is always defined and points
!	to the current SCB, whether it's the one being used by VMB, SYSBOOT,
!	or the debug loadable image.
!
BIND
	bpt_entry = .exe$gl_scb + %x'400' : SIGNED,
	scb_param = .exe$gl_scb + %x'408' : SIGNED,
	ipl14_entry = .exe$gl_scb + %x'5E0' : SIGNED,
	ipl14_param = .exe$gl_scb + %x'5E8' : SIGNED,
	iregbuf = mode_context[mctx$q_iregbuf],
	fregbuf = mode_context[mctx$q_fregbuf],
	bpt_adr = perm_bpts[0,pbpt$q_breakpoint],
	bpt_disp = perm_bpts[0,pbpt$q_display],
	bpt_cmd = perm_bpts[0,pbpt$q_cmd_string];
!
! Do any data structure/state initialization here, but not more than once
! for some things
!
	iregbuf = xdt$iregsav;
	fregbuf = xdt$fregsav;
	mode_context[mctx$l_data_length] = long_size;
!
	IF NOT .init_flag THEN
	  BEGIN
	    init_flag = 1;
	    IF pfn$pl_database NEQ 0 THEN
	      BEGIN
		xregs[13] = .pfn$pl_database;
		xregs[14] = xds$gt_pfn_x0;
		xregs[15] = xds$gt_pfn_r0;
	      END;
	  END;
!
! Write the XDELTA breakpoint ISR address into the SCB. Note that the
! xdt$bpt symbol is already the start address of the code and NOT a
! procedure descriptor.
!
	bpt_entry = xdt$bpt;
!
! Load the SCB parameter with the linkage pointer for the benefit of
! interrupt and exception routines written in assembly language.
!
	scb_param = xdt$bpt_lp;
!
! If VMS is up and running, setup the software interrupt level 14 handler
! which traps into XDELTA.
!
	IF $init_done THEN
	  BEGIN
!	    ipl14_entry = xdt$ipl14_handler;
!	    ipl14_param = xdt$bpt_lp;
!
! Disable SMP timeouts while XDELTA is loaded (if VMS up and running).
!
	    exe$gl_time_control = .exe$gl_time_control OR
				(exe$m_nosmpsanity OR exe$m_nospinwait);
	  END;
!
! Let's remember the transfer address through SYS.EXE for future reference
! (if we're linked with SYS.EXE).
!
	IF ini$writable NEQ 0 THEN
	  BEGIN
	    xfer_address = ini$writable;
	    xfer_address = .(.xfer_address + 8);
	  END;
!
! Now if the one optional parameter was specified, it is assumed to be
! the address of the initial breakpoint. Of course, I'll do a little extra
! checking before blindly making this assumption. 
!
	perm_bpts[0,pbpt$v_invalid] = 0;
	perm_bpts[0,pbpt$l_instruction] = 0;
	bpt_disp = 0;
	bpt_cmd = 0;
	bpt_adr = 0;
!
	IF NOT nullparameter(1) THEN
!
! If the caller specified an initial breakpoint, set it up as perm_bpts[0].
! Note that if no parameter is specified or one with a value of zero, the
! initial breakpoint will be cleared. Also note that the specified breakpoint
! address better point to a BPT PAL call or an error will be returned (and no
! breakpoint setup).
!
	  IF .bpt_address NEQ 0 THEN
	    IF NOT xdt$check_address(.bpt_address,long_size,0) THEN
	      RETURN 0
	    ELSE
	      IF (.bpt_address[ei$v_opcode] EQL evx$opc_pal) AND
	         (.bpt_address[ei$v_pal_func] EQL evx$pal_bpt) THEN
	         bpt_adr = .bpt_address
	      ELSE
	        RETURN 0;
!
	RETURN ss$_normal;
END; 					! ROUTINE xdt$init


GLOBAL ROUTINE xdt$xdelta_bpt(
!++
! Functional description:
!
!	This routine handles XDELTA-specific BPT entries. It is invoked
! by the BPT interrupt service routine in the SCB (xdt$bpt) and takes care of
! XDELTA stuff prior to (and after) invoking the generic break_point handler.
! DELTA has an analogous routine which is invoked in response to exceptions
! (instead of directly via interrupts).
!	The only parameter to this routine is a flag indicating whether or
! not floating point is currently enabled.
!
! Formal parameters:
!
	fp_enabled		!FP enabled flag (0 => no; 1 => enabled)
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	0	   : Breakpoint not owned by XDELTA
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

BIND
	iregbuf = mode_context[mctx$q_iregbuf],
	save_pc = .iregbuf + (8 * 32),
	save_ps = .iregbuf + (8 * 33): BLOCK[,BYTE];
LOCAL
	ctx: REF BLOCK[0,BYTE],		!Context block pointer
	bpt_type,			!Breakpoint type
	bpt_index,			!Breakpoint index
	current_cpu;			!Current CPU ID
!
! Set up the context block pointer for XDELTA. If this is XDELTA, there is
! only one context block. Note that in DELTA, we also use the mode as an
! index into the temporary breakpoint arrays so that each mode has their own.
! In XDELTA, we use the IPL as the index.
!
	ctx = mode_context;
	ctx[mctx$l_index] = .save_ps[psl$v_ipl];
	ctx[mctx$v_fen] = .fp_enabled;
!
! We will pre-screen this breakpoint to see if it's owned by XDELTA to
! avoid incurring all the overhead associated with an XDELTA breakpoint
! unless it's absolutely necessary. If not, we'll hand it off to the VMS
! generic breakpoint handler.
!
	IF NOT find_bpt(.save_pc - inst_size,bpt_type,bpt_index) THEN
	  BEGIN
	    unlock_xdelta();
	    RETURN 0;
	  END;
!
! Setup the rest of the XDELTA context, such as making the system writeable,
! saving console state, and switching to the XDELTA SCB
!
	xdelta_save_state(.ctx);
!
! Invoke the generic breakpoint handler
!
	break_point(0,.ctx);
!
! Restore any XDELTA-specific context (the actual registers will be restored by
! the BPT ISR).
!
	xdelta_restore_state(.ctx);
!
	RETURN ss$_normal;
END; 					! ROUTINE xdt$xdelta_bpt


GLOBAL ROUTINE xdt$owner_check =
!++
! Functional description:
!
!	This routine checks to see if the current CPU can acquire ownership
! of XDELTA. If not, it is put into the benign state (XDT$CPU_WAIT) and then
! returns a "false" status to indicate to the caller that it should REI without
! further XDELTA processing. If it *is* able to acquire XDELTA ownership, the
! appropriate global cells are updated and a "true" status returned to indicate
! that XDELTA processing can continue.
!
! Formal parameters:
!
!	None
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	0	   : Don't own XDELTA
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

LOCAL
	current_cpu;			!Current CPU ID
!
! If the global cells aren't even defined, it's safe to continue
!
	IF (xdt$gl_interlock EQL 0) OR (xdt$gl_owner_id EQL 0) THEN
	  RETURN ss$_normal;
!
! Attempt to get XDELTA ownership on SMP system
!
	WHILE testbitssi(xdt$gl_interlock) DO
	  WHILE .xdt$gl_interlock DO ;
!
! We have the interlock which grants us exclusive access to the XDELTA
! ownership field. See if we're the owner. If not, then we must release
! the interlock, wait for other CPU's to exit the benign state, reenable
! interrupts, and return to reexecute the instruction which got us here
! in the first place. The reason for doing this is because action by some
! other CPU could have changed the instruction at that address and we may
! not need to return here.
!
	current_cpu = $cpu_id;
!
	IF (.xdt$gl_owner_id GEQ 0) AND
	   (.current_cpu NEQ .xdt$gl_owner_id) THEN
	  BEGIN
	    testbitcci(xdt$gl_interlock);
	    xdt$cpu_wait();
	    RETURN 0;
	  END;
!
	xdt$gl_owner_id = .current_cpu;
	testbitcci(xdt$gl_interlock);
!
	RETURN ss$_normal;
END; 					! ROUTINE xdt$xdelta_bpt


ROUTINE xdelta_save_state(
!++
! Functional description:
!
!	This routine is invoked via XDELTA BPT trap handling to save any
! pertinent state as part of preparation for handling a breakpoint.
!
! Formal parameters:
!
	ctx: REF BLOCK[0,BYTE]		!Ptr to mode context block
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

%if NOT %declared(cpu$m_inv_istream) %then
  LITERAL cpu$m_inv_istream = %x'1000';
%fi

LOCAL
	cpu_data: REF BLOCK[0,BYTE],	!CPU database
	cpu_id;				!The current CPU ID
!
! Hit all the active CPUs and force them into the benign state (on an SMP
! system). Then make the system writeable. Note this is only necessary if
! past the init stage of a bootstrap. If we're the primary CPU (always the
! case when not linked with SYS.EXE or through INIT), save the console state.
!
	IF $init_done THEN
	  BEGIN
	    smp$intall_bit_acq($bit_position(cpu$m_inv_istream));
	    ini$writable();
	    cpu_id = $cpu_id;
	    IF .cpu_id EQL .smp$gl_primid THEN
	      con$save_cty();
	  END
	ELSE
	  con$save_cty();
!
! Retrieve the current PCB pointer if pointing hasn't been inhibited
! Note: We assume the current PCB is contained within the first longword
!	of the CPU database. The address of the PCB address is merely
!	the start address of the CPU database itself.
!
	IF NOT .ctx[mctx$v_no_curpcb] THEN
	  BEGIN
	    xregs[4] = $get_cpu_db;
!	    xregs[4] = cpu_data[cpu$l_curpcb];
	  END;
!
! Switch SCBs to XDELTA's private SCB
!
	switch_scb();
!
	RETURN ss$_normal;
END; 					! ROUTINE xdelta_save_state


ROUTINE xdelta_restore_state(
!++
! Functional description:
!
!	This routine is invoked via XDELTA BPT trap handling to restore the
! previously saved state and prepare for exit from XDELTA.
!
! Formal parameters:
!
	ctx: REF BLOCK[0,BYTE]		!Ptr to mode context block
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

BUILTIN
	draint;					!To drain pending exceptions
LOCAL
	cpu_id;					!Current CPU ID
!
! Drain any and all pending exceptions and restore the system SCB
!
	draint();
	$write_scb(.saved_scb);
!
! If this is the primary CPU (always the case when not linked with SYS.EXE
! or if not through INIT), restore the saved console state. Then, if
! appropriate, make the system code read-only once again.
!
	IF $init_done THEN
	  BEGIN
	    cpu_id = $cpu_id;
	    IF .cpu_id EQL .smp$gl_primid THEN
	      con$restore_cty();
	    ini$rdonly();
	  END
	ELSE
	  con$restore_cty();
!
! Invalidate the local TB to accommodate any PTE changes
!
	$invalidate_tb;
!
	RETURN ss$_normal;
END; 					! ROUTINE xdelta_restore_state


ROUTINE switch_scb =
!++
! Functional description:
!
!	This routine switches the current system SCB to be the XDELTA
! SCB. This routine also handles initialization of the XDELTA SCB the first
! time this is done.
!
! Formal parameters:
!
!	None
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

LITERAL
	scb_entry_size = 2 * quad_size;
BIND
	first_scb_entry = .xdt$gl_scb;
LOCAL
	vpn,				!Virtual page number
	virtual_adr;			!Virtual address to translate
!
! Stash away the current SCB address (actually, the PFN of the system
! SCB)
!
	saved_scb = $read_scb;
!
! If the XDELTA SCB has not yet been initialized, do it now. We determine
! it hasn't yet been initialized by looking at the first %BPVAL bits (first
! longword or quadword).
!
	IF .first_scb_entry EQL 0 THEN
	  BEGIN
!
! The SCB is initialized first with every entry pointing to the XDT$EXCEPTION
! code address (not the PD address). The SCB parameter is an error or exception
! code value which indicates the exception reason. Once we've done that, a few
! of the entries may require copies of what's in the real SCB
!
	    INCR entry_no FROM 0 TO (scb_entries - 1) DO
	      BEGIN
		BIND
		  scb_entry = .xdt$gl_scb + (.entry_no * scb_entry_size),
		  scb_param = quad_size + scb_entry;
!
		scb_entry = xdt$exception;
		scb_param = .scb_errors[.entry_no];
	      END;
!
! Now copy the FP instruction emulator into the XDELTA SCB here
! from the real SCB (from whatever context we happen to be running in).
!
	    BEGIN
	      BIND
		xdelta_scb_entry = .xdt$gl_scb + %x'10',
		xdelta_scb_param = quad_size + xdelta_scb_entry,
		current_scb_entry = .exe$gl_scb + %x'10' : SIGNED,
		current_scb_param = quad_size + current_scb_entry;
!
	      xdelta_scb_entry = .current_scb_entry;
	      xdelta_scb_param = .current_scb_param;
	    END;
!
! Now copy all the data alignment handlers from the "current" SCB into
! the XDELTA version.
!
	    INCR entry_adr FROM %x'300' TO %x'3F0' BY %x'10' DO
	      BEGIN
		BIND
		  xdelta_scb_entry = .xdt$gl_scb + .entry_adr,
		  xdelta_scb_param = quad_size + xdelta_scb_entry,
		  current_scb_entry = .exe$gl_scb + .entry_adr : SIGNED,
		  current_scb_param = quad_size + current_scb_entry;
!
		xdelta_scb_entry = .current_scb_entry;
		xdelta_scb_param = .current_scb_param;
	      END;
	  END;
!
! The following block of code is temporary. Every time we come through
! here, we're going to reload XDELTA's SCB entry with the system entry
! for the FOW trap. This will enable us to use the VMS FOW handler when
! such faults occur in XDELTA instead of treating them as any other
! exception. This is being done to facilitate debug.
!
!	BEGIN
!	  BIND
!	    xdelta_fow_entry = .xdt$gl_scb + %x'B0',
!	    xdelta_fow_param = quad_size + xdelta_fow_entry,
!	    system_fow_entry = .exe$gl_scb + %x'B0' : SIGNED,
!	    system_fow_param = quad_size + system_fow_entry;
!!
!	    xdelta_fow_entry = .system_fow_entry;
!	    xdelta_fow_param = .system_fow_param;
!	END;
!
! Convert the system virtual address of the XDELTA SCB into a physical
! address and then make it the current system SCB. We assume that xdt$gl_scb
! is page-aligned and in S0 space. PR$_SCBB requires the SCB PFN.
!
! NOTE: va$v_vpn must be computed at run-time since it depends on the page
!	size. The appropriate PAL call must also be added to actually
!	store the XDELTA SCB PFN into PR$_SCBB.
!
	IF .physical_scb LSS 0 THEN
	  IF mmg$gl_sptbase[0,0,0,0,0] EQL 0 THEN
	    physical_scb = .xdt$gl_scb ^ .mmg$gl_va_to_vpn
	  ELSE
	    BEGIN
	      virtual_adr = .xdt$gl_scb;
	      vpn = (.virtual_adr AND %x'7FFFFFFF') ^ .mmg$gl_va_to_vpn;
	      physical_scb = .mmg$gl_sptbase[.vpn,pte$v_pfn];
	    END;
!
! Now write the new SCB
!
	$write_scb(.physical_scb);
!
	RETURN ss$_normal;
END; 					! ROUTINE switch_scb


GLOBAL ROUTINE xdt$cpu_wait =
!++
! Functional description:
!
!	This routine waits for the CPU that has interlocked entry into
! XDELTA to release the interlock. The primary CPU tries to do some useful
! work (virtual console) while it's waiting around. And now, a quote from
! the VAX version of this routine:
!
!	"When released, invalidate the local CPU's translation
!	buffer to ensure that the effects of the other CPU's
!	operations in XDELTA (PROT changes, I-stream changes) take effect
!	in this CPU's TB. (For normal system space address changes,
!	there is an interprocessor-interrupt driven exchange between
!	the active set of CPUs to ensure consistent TB's across all
!	CPUs. However, XDELTA operates at too high an IPL to use
!	this mechanism, plus XDELTA may be invoked from a CPU that is
!	not a member of the "active set" and is thus outside the range
!	of the standard interprocessor-interrupt driven tools in VMS,
!	and XDELTA is much simpler if it doesn't have to worry about
!	ACK's from other CPUs.)"
!
! Formal parameters:
!
!	None
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

LOCAL
	saved_tmit,			!Saved console transmit status
	saved_rcv,			!Saved console receive status
	cpu_id;				!Current CPU ID
!
! If any of the symbols for SMP operation are undefined, then merely return.
! For now, we pick two, and if they're defined, we'll assume the rest are too.
!
	IF NOT $init_done THEN
	  RETURN ss$_normal;
!
! Get the current CPU ID
!
	cpu_id = $cpu_id;
!
! Now, I'm not going to point fingers, but some idiot may have called
! this routine not realizing that the current CPU actually holds the
! XDELTA lock. If this is the case, then we'd end up spinning in here
! forever, waiting for ourselves to give up the lock. So, instead of
! doing that, it might make more sense to just leave.
!
	IF (.xdt$gl_owner_id GEQ 0) AND (.xdt$gl_owner_id EQL .cpu_id) THEN
	  RETURN ss$_normal;
!
! Set the bit corresponding to this CPU in the mask of benign CPUs
!
	testbitssi(xdt$gl_benign_cpus[.cpu_id]); 
!
! If this is the primary CPU, we can do some virtual console stuff while
! we're not doing anything else useful. So we'll preserve the console state
! while we interact with the virtual console registers and the console
! itself.
!
	IF .cpu_id EQL .smp$gl_primid THEN
	  BEGIN
	    con$save_cty();
	    WHILE .xdt$gl_owner_id GEQ 0 DO
	      virtual_console();
	    con$restore_cty();
	  END
!
! The other CPUs merely spin, waiting for XDELTA ownership to be relinquished
!
	ELSE
	  WHILE .xdt$gl_owner_id GEQ 0 DO ;
!
! Reflect that we're no longer benign
!
	testbitcci(xdt$gl_benign_cpus[.cpu_id]); 
!
! Throw in an instruction stream barrier and invalidate the TB
!
	$instruction_memory_barrier;
	$invalidate_tb;
!
	RETURN ss$_normal;
END; 					! ROUTINE xdt$cpu_wait


ROUTINE unlock_xdelta =
!++
! Functional description:
!
!	This routine releases the XDELTA lock, allowing CPUs waiting on the
! the lock to proceed. Any checking as to whether or not the lock should be
! released should be done elsewhere, prior to calling this routine.
!
! Formal parameters:
!
!	None
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

!
! If the interlock cells aren't defined, this is a nop
!
	IF (xdt$gl_interlock EQL 0) OR (xdt$gl_owner_id EQL 0) THEN
	  RETURN ss$_normal;
!
! Attempt to get XDELTA ownership on SMP system
!
	WHILE testbitssi(xdt$gl_interlock) DO
	  WHILE .xdt$gl_interlock DO ;
!
! We have the interlock which grants us exclusive access to the XDELTA
! ownership field. We now reset the ownership field and release the lock.
!
	xdt$gl_owner_id = -1;
	testbitcci(xdt$gl_interlock);
!
	RETURN ss$_normal;
END; 					! ROUTINE unlock_xdelta


ROUTINE virtual_console =
!++
! Functional description:
!
!	This routine handles the virtual console on behalf of the primary
! CPU. It is called only by the primary CPU when unable to do "useful" work.
! This routine handles AT MOST one character of input and one character of
! output to the physical console device. It should be called in a loop while
! there's nothing better to do.
!	There are 3 transmit and 3 receive "registers" that make up the
! virtual console. Transmit in this context implies data to be output to
! the console terminal for all concerned. Receive obviously implies input data.
! The registers are called:
!
!		Receive				Transmit
!		-------				--------
!		rcv_ie				tmit_ie
!		rcv_ready			tmit_ready
!		rcv_data			tmit_data
!
!	To output a character from a "secondary" CPU, it uses the transmit
! registers and some hand-shaking with the primary CPU, which should soon
! be in (if not already) the benign state just looking for something
! interesting like this to do. The protocol looks like this:
!
!		Secondary CPU			Primary CPU
!		-------------			-----------
!	- Put character in tmit_data
!	- Set tmit_ie
!					- Clear tmit_ie (recognizing was set)
!					- Send tmit_data contents to console
!					- Set tmit_ready
!	- Spin on and clear tmit_ready
!
!	To get an input character, the secondary CPUs need to read it
! from a virtual console register after indicating a read request. The
! primary recognizes the read request, retrieves a character from the
! console device, and stuffs it into the virtual console register as follows:
!
!		Secondary CPU			Primary CPU
!		-------------			-----------
!	- Set rcv_ie
!					- Clear rcv_ie (recognizing was set)
!					- Get console character into rcv_data
!					- Set rcv_ready
!	- Spin on and clear rcv_ready
!	- Pull character from rcv_data
!
! Formal parameters:
!
!	None
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

!
! See if some other CPU is in need of some data. If so, retrieve a data
! byte from the physical console and stuff it into the virtual console
! register.
!
	IF NOT testbitcci(rcv_ie) THEN
	  BEGIN
	    rcv_data = con$getchar();
	    testbitssi(rcv_ready);
	  END;
!
! See if there's any output data to send to the physical console.
!
	IF NOT testbitcci(tmit_ie) THEN
	  BEGIN
	    con$putchar(.tmit_data);
	    testbitssi(tmit_ready);
	  END;
!
	RETURN ss$_normal;
END; 					! ROUTINE virtual_console


ROUTINE virtual_putchar(
!++
! Functional description:
!
!	This routine writes a single character to the virtual console
! interface. This is used when the "current" CPU is not the "primary" CPU.
!
! Formal parameters:
!
	out_char			!Character to output
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

!
! Stuff this character into the virtual console output (transmit) register
! and then signal its presence.
!
	tmit_data = .out_char;
	testbitssi(tmit_ie);
!
! Now we spin, waiting for the primary CPU to suck that character out of
! the register.
!
	WHILE testbitcci(tmit_ready) DO
	  WHILE NOT .tmit_ready DO ;
!
	RETURN ss$_normal;
END; 					! ROUTINE virtual_putchar


ROUTINE virtual_getchar(
!++
! Functional description:
!
!	This routine reads a single character from the virtual console
! interface. This is used when the "current" CPU is not the "primary" CPU.
!
! Formal parameters:
!
	got_char			!Address for input character
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

!
! First indicate our unwonted desire for an input character
!
	testbitssi(rcv_ie);
!
! Now just loop until we get one
!
	WHILE testbitcci(rcv_ready) DO
	  WHILE NOT .rcv_ready DO ;
!
	.got_char = .rcv_data;
!
	RETURN ss$_normal;
END; 					! ROUTINE virtual_getchar


ROUTINE xdelta_handler =
!++
! Functional description:
!
!	This routine doesn't do anything. It's only here as part of
! a covert scheme to force the compiler to generate a real call frame
! for XDT$CHECK_ADDRESS in XDELTA. XDELTA's exception handling code
! ignores call frame handlers, especially this one.
!
! Formal parameters:
!
!	None
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

!
	RETURN ss$_normal;
END; 					! ROUTINE xdelta_handler


!
! This marks the end of the DELTA- and XDELTA-specific routines
!
	%fi


ROUTINE single_step(
!++
! Functional description:
!
!	This routine sets up for a single-step operation. It does this by
! initializing the temporary breakpoint array appropriately (the breakpoints
! will be "set" later, prior to leaving XDELTA). 
!	The "saved PC" points to the instruction which caused the BPT trap
! and not the "updated PC." For most instructions, the "updated PC" is the
! appropriate place to set a single temporary breakpoint to cause a trap
! after executing a single instruction. However, if the previous instruction
! (at saved_PC) was a branch or call instruction of some kind, we'll
! need to recompute where to set the temporary breakpoint(s). We use the
! mode/IPL index in the context block to figure out which temporary breakpoint
! slot(s) to use. Each mode (DELTA) or IPL (XDELTA) has their own.
!
! Formal parameters:
!
	ctx: REF BLOCK[0,BYTE]		!Ptr to mode context block
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

BIND
	bpt_adr = temp_bpts[.ctx[mctx$l_index] ^ 1,tbpt$q_breakpoint],
	bpt2_adr = temp_bpts[1 + (.ctx[mctx$l_index] ^ 1),tbpt$q_breakpoint],
	cpu_id = temp_bpts[.ctx[mctx$l_index] ^ 1,tbpt$q_cpu_id],
	cpu2_id = temp_bpts[1 + (.ctx[mctx$l_index] ^ 1),tbpt$q_cpu_id],
	iregbuf = ctx[mctx$q_iregbuf],
	save_sp = .iregbuf + (30 * quad_size),
	save_pc = .iregbuf + (32 * quad_size): REF BLOCK[0,BYTE];
LOCAL
	mode,				!For locating REI stack frame
	prev_prot,			!Previous protection
	status;				!Return status value
!
! Initialize the temporary breakpoint slots and the "breaks" flag
!
	bpt_adr = 0;
	bpt2_adr = 0;
	%if xdelta %then
	  cpu_id = $cpu_id
	%else
	  cpu_id = 0
	%fi ;
	cpu2_id = 0;
	temp_bpts[.ctx[mctx$l_index],tbpt$l_instruction] = 0;
	temp_bpts[.ctx[mctx$l_index] + 1,tbpt$l_instruction] = 0;
	ctx[mctx$v_breaks] = 0;
!
! Determine the instruction catagory and setup the temporary breakpoint
! array accordingly.
!
	SELECTONE .save_pc[ei$v_opcode] OF
	  SET
!
! For unconditional branches and subroutine calls, we have a single possible
! destination to compute for a temporary breakpoint. The computation differs
! between JSR and the branch format instructions. For JSR, the Rb register
! operand contains the absolute 64-bit destination address. We look back in
! the saved register context area to find this address. The branch format
! instructions take the sign-extended branch displacement field shifted left
! 2 bits (it's a longword offset) and add it to the updated PC.
!
	    [evx$opc_jsr,evx$opc_bsr,evx$opc_br] :
	      BEGIN
		IF .save_pc[ei$v_opcode] EQL evx$opc_jsr THEN
		  BEGIN
		    BIND
		      rb = (.save_pc[ei$v_mem_rb] * quad_size) + .iregbuf;
		    bpt_adr = .rb;
		  END
		ELSE
		  bpt_adr = .save_pc + inst_size + (.save_pc[ei$v_br_disp] ^ 2);
	      END;
!
! For conditional branches, we have two possible destinations for the next
! instruction: the "updated PC" or the branch target, depending on whether or
! not the branch is taken. For these instructions, we set temporary breakpoints
! at both possible destinations (branch target computed same as above).
!
	    [evx$opc_blbc,evx$opc_blbs,evx$opc_fbeq,evx$opc_fbne,
	     evx$opc_beq,evx$opc_bne,evx$opc_fblt,evx$opc_fbge,
	     evx$opc_blt,evx$opc_bge,evx$opc_fble,evx$opc_fbgt,
	     evx$opc_ble,evx$opc_bgt] :
	      BEGIN
		bpt_adr = .save_pc + inst_size + (.save_pc[ei$v_br_disp] ^ 2);
		bpt2_adr = .save_pc + inst_size;
		cpu2_id = .cpu_id;
	      END;
!
! For an REI PAL instruction, we have to look back on the stack to
! figure out where we're going. Other PAL instructions are treated like
! "normal" instructions, setting a temporary breakpoint at the updated PC.
! When the instruction in the instruction stream is an REI, we have to assume
! that the stack is setup properly to execute it. We merely look back on the
! stack to find the PC that REI will find. It should be noted that it doesn't
! matter which stack we're on. R30 contains the SP just prior to executing
! the REI instruction.
!
	    [evx$opc_pal] :
	      IF .save_pc[ei$v_pal_func] EQL evx$pal_rei THEN
		bpt_adr = .(.save_sp + (6 * quad_size))
	      ELSE
		bpt_adr = .save_pc + inst_size;
!
! For everything else, the updated PC is the next instruction and the
! appropriate place to set a single temporary breakpoint.
!
	    [OTHERWISE] : bpt_adr = .save_pc + inst_size;
!
	  TES;
!
! In XDELTA only, we want to treat the exec transfer code address a
! little differently...OK, it's a hack. But we can't set temporary
! breakpoints in the transfer code because we ourselves in XDELTA go
! through the transfer code when invoking exec routines. So we end up
! running into our own breakpoints.
!
	%if xdelta %then
	  IF .bpt_adr EQL .xfer_address THEN
	    BEGIN
	      BIND
		saved_r27 = (27 * quad_size) + .iregbuf,
		proc_val = .saved_r27 + 16;
	      bpt_adr = .(.proc_val + 8);
	    END;
!
	  IF .bpt2_adr NEQ 0 THEN
	    IF .bpt2_adr EQL .xfer_address THEN
	      BEGIN
		BIND
		  saved_r27 = (27 * quad_size) + .iregbuf,
		  proc_val = .saved_r27 + 16;
		bpt2_adr = .(.proc_val + 8);
	      END;
	%fi
!
! Now we check to see if we'll actually be able to setup these temporary
! breakpoints. If not, they'll be cleared and an error returned.
!
	%if delta %then
	  loosen_protection(.bpt_adr,.bpt_adr,prev_prot);
	%fi
	status = xdt$check_address(.bpt_adr,inst_size,1);
	%if delta %then
	  reset_protection(.bpt_adr,.bpt_adr,.prev_prot);
	%fi
!
	IF NOT .status THEN
	  BEGIN
	    clear_single_step(.ctx);
	    RETURN .status;
	  END;
!
	IF .bpt2_adr NEQ 0 THEN
	  BEGIN
	    %if delta %then
	      loosen_protection(.bpt2_adr,.bpt2_adr,prev_prot);
	    %fi
	    status = xdt$check_address(.bpt2_adr,inst_size,1);
	    %if delta %then
	      reset_protection(.bpt2_adr,.bpt2_adr,.prev_prot);
	    %fi
!
	    IF NOT .status THEN
	      BEGIN
	        clear_single_step(.ctx);
	        RETURN .status;
	      END;
	  END;
!
	RETURN ss$_normal;
END; 					! ROUTINE single_step


ROUTINE clear_single_step(
!++
! Functional description:
!
!	This routine clears a single-step temporary breakpoint.
!
! Formal parameters:
!
	ctx: REF BLOCK[0,BYTE]		!Ptr to mode context block
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

BIND
	iregbuf = ctx[mctx$q_iregbuf],
	save_pc = .iregbuf + (32 * quad_size);	!Saved PC
LOCAL
	index;					!Mode/IPL Index holder
!
! Clear out all the single-step temporary breakpoints at the current PC
!
	INCR bpt_num FROM 0 TO (num_tmp_bpts - 1) DO
	  BEGIN
	    BIND
	      bpt_adr = temp_bpts[.bpt_num,tbpt$q_breakpoint];
!
	    IF .bpt_adr EQL .save_pc THEN
	      BEGIN
		index = .bpt_num AND (NOT 1);
		BEGIN
		  BIND
		    bpt1_inst = temp_bpts[.index,tbpt$l_instruction] : LONG,
		    cpu1_id = temp_bpts[.index,tbpt$q_cpu_id],
		    bpt1_adr = temp_bpts[.index,tbpt$q_breakpoint],
		    bpt2_inst = temp_bpts[.index+1,tbpt$l_instruction] : LONG,
		    cpu2_id = temp_bpts[.index+1,tbpt$q_cpu_id],
		    bpt2_adr = temp_bpts[.index+1,tbpt$q_breakpoint];
!
		  bpt1_inst = 0;
		  cpu1_id = 0;
		  bpt1_adr = 0;
		  bpt2_inst = 0;
		  cpu2_id = 0;
		  bpt2_adr = 0;
		END;
	      END;
	  END;
!
	RETURN ss$_normal;
END; 					! ROUTINE clear_single_step


ROUTINE step_over(
!++
! Functional description:
!
!	This routine performs a "step over" operation, if possible. It
! first insures that this is a routine call of some sort that we're looking
! at. If it isn't, then the status return value indicates that a normal
! single step should be performed. If it is a routine call but problems
! are encountered while trying to decode the instruction, an error status
! is returned. If all goes well, this routine establishes a step-over
! temporary breakpoint and returns a success status.
!
! Formal parameters:
!
	ctx: REF BLOCK[0,BYTE]		!Ptr to mode context block
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	0 => Unable to decode instruction or some other error
!	1 => Normal successful completion
!	2 => Not a call - Normal single-step should be performed
!
! Side effects:
!
!	None
!
!--

BEGIN

BIND
	iregbuf = ctx[mctx$q_iregbuf],
	save_pc = .iregbuf + (32 * quad_size): REF BLOCK[0,BYTE],
	cpu_id = step_overs[.ctx[mctx$l_index],tbpt$q_cpu_id],
	bpt_adr = step_overs[.ctx[mctx$l_index],tbpt$q_breakpoint];
LOCAL
	prev_prot,
	new_pc,
	status;
!
! Extract the opcode from the instruction at the saved PC. If it's not
! some flavor of call instruction, return with the appropriate status.
!
	IF (.save_pc[ei$v_opcode] NEQ evx$opc_jsr) AND
	   (.save_pc[ei$v_opcode] NEQ evx$opc_bsr) THEN
	  RETURN 2;
!
! OK, we have a JSR or BSR instruction of some flavor. We can look more
! closely at the instruction to see if it will never actually "return"
! and should be handled as an unconditional branch. This determination
! is made by looking at the register number for the saved PC in the
! instruction. If it happens to be R31, the sink register, then there
! is no intention to return. For now we ignore "hints" in the instruction
! for branch prediction logic and assume that all other registers are fair
! game if used to store the return PC.
!
	IF .save_pc[ei$v_mem_ra] EQL 31 THEN
	  RETURN 2;
!
! If we don't have write access to the location needed for the step-over,
! we'll return an error.
!
	new_pc = .save_pc + inst_size;
	%if delta %then
	  loosen_protection(.new_pc,.new_pc,prev_prot);
	%fi
	status = xdt$check_address(.new_pc,inst_size,1);
	%if delta %then
	  reset_protection(.new_pc,.new_pc,.prev_prot);
	%fi
	IF NOT .status THEN
	  RETURN 0;
!
! Well, this looks like something that might actually return someday. So
! we'll setup a step-over temporary breakpoint and hope for the best (we
! don't want to be *too* careful - this is XDELTA afterall).
!
	ctx[mctx$v_breaks] = 0;
	bpt_adr = .new_pc;
	%if xdelta %then
	  cpu_id = $cpu_id
	%else
	  cpu_id = 0
	%fi ;
	step_overs[.ctx[mctx$l_index],tbpt$l_instruction] = 0;
!
	RETURN ss$_normal;
END; 					! ROUTINE step_over


ROUTINE clear_step_over(
!++
! Functional description:
!
!	This routine removes a "step over" temporary breakpoint. The
! mode/IPL index in the context block is used to determine which step-over
! breakpoint to remove. All others are left alone.
!
! Formal parameters:
!
	ctx: REF BLOCK[0,BYTE]		!Ptr to mode context block
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

BIND
	iregbuf = ctx[mctx$q_iregbuf],
	save_pc = .iregbuf + (32 * quad_size);	!Saved PC
!
! Zero out all the step-over temporary breakpoints at the current PC
!
	INCR bpt_num FROM 0 TO (num_sos - 1) DO
	  BEGIN
	    BIND
	      bpt_adr = step_overs[.bpt_num,tbpt$q_breakpoint],
	      bpt_inst = step_overs[.bpt_num,tbpt$l_instruction] : LONG,
	      cpu_id = step_overs[.bpt_num,tbpt$q_cpu_id];
!
	    IF .bpt_adr EQL .save_pc THEN
	      BEGIN
		bpt_inst = 0;
		cpu_id = 0;
		bpt_adr = 0;
	      END;
	  END;
!
	RETURN ss$_normal;
END; 					! ROUTINE clear_step_over


ROUTINE add_bpt(
!++
! Functional description:
!
!	This routine attempts to add a permanent breakpoint. It does not
! actually "set" the breakpoint. Only the data structure of known breakpoints
! is updated. The user specifies the following on the command line:
!
!		address,number,display_address,command_address;B	where,
!
!	address = Address for breakpoint (zero clears this breakpoint)
!	number = Breakpoint number (if omitted or zero, an available one found)
!	display_address = To display when breakpoint occurs (optional)
!	command_address = Address of XDELTA command string to be executed when
!			  breakpoint occurs (optional)
!
!	If no number is specified, an attempt is made to find the next
! available one. If none are available, an error occurs. All addresses
! specified on the command line are checked for readibility. The breakpoint
! address is also checked for writability. Access attempt violations result
! in errors.
!
! Formal parameters:
!
	ctx: REF BLOCK[0,BYTE]		!Ptr to mode context block
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

BIND
	fld = ctx[mctx$q_fields] : VECTOR;	!Input fields
LOCAL
	found,					!Boolean loop kicker-outer
	prev_prot,				!Previous protection
	bpt_type,				!Type of breakpoint
	bpt_index,				!Index into array of BPTs
	bpt_num,				!Breakpoint number
	status;					!Return status value
!
! Before even considering adding this as a new permanent breakpoint, make
! sure it isn't one already
!
	IF (.ctx[mctx$v_f0]) AND (.fld[0] NEQ 0) THEN
	  IF find_bpt(.fld[0],bpt_type,bpt_index) THEN
	    IF .bpt_type EQL bpt$k_perm THEN
	      RETURN 0;
!
! If the user specified a breakpoint number, use it
!
	IF (.ctx[mctx$v_f1]) AND (.fld[1] NEQ 0) THEN
	  bpt_num = .fld[1]
	ELSE
!
! If the user didn't specify one, try to find an available one
!
	  BEGIN
	    bpt_num = 1;
	    found = 0;
	    WHILE (.bpt_num LEQ num_perm_bpts) AND (NOT .found) DO
	      BEGIN
		BIND bpt_adr = perm_bpts[.bpt_num,pbpt$q_breakpoint];
		IF .bpt_adr EQL 0 THEN
		  found = 1
		ELSE
		  bpt_num = .bpt_num + 1;
	      END;
	  END;
!
! If we have an invalid breakpoint number, it's an error
!
	IF (.bpt_num LSS 0) OR (.bpt_num GTR num_perm_bpts) THEN
	  RETURN 0;
!
! So far, so good. Zero out the rest of this breakpoint slot.
!
	BEGIN
	  BIND
	    bpt_adr = perm_bpts[.bpt_num,pbpt$q_breakpoint],
	    bpt_disp = perm_bpts[.bpt_num,pbpt$q_display],
	    bpt_cmd = perm_bpts[.bpt_num,pbpt$q_cmd_string];
!
	  bpt_adr = 0;
	  bpt_disp = 0;
	  bpt_cmd = 0;
	  perm_bpts[.bpt_num,pbpt$v_invalid] = 0;
	  perm_bpts[.bpt_num,pbpt$l_instruction] = 0;
!
! If a display address field was specified and we can read it, use it
!
	  IF (.ctx[mctx$v_f2]) AND (.fld[2] NEQ 0) THEN
	    BEGIN
	      IF xdt$check_address(.fld[2],%BPVAL/8,0) THEN
		bpt_disp = .fld[2]
	      ELSE
		RETURN ss$_accvio;
	    END;
!
! If a command string address field was specified and we can read it, use it
!
	  IF (.ctx[mctx$v_f3]) AND (.fld[3] NEQ 0) THEN
	    BEGIN
	      IF xdt$check_address(.fld[3],%BPVAL/8,0) THEN
		bpt_cmd = .fld[3]
	      ELSE
		RETURN ss$_accvio;
	    END;
!
! If a nonzero breakpoint address was specified, we must insure that we
! can read AND write it (here we're assuming that if we can write it, we
! can read it).
!
	  status = ss$_normal;
	  IF (.ctx[mctx$v_f0]) AND (.fld[0] NEQ 0) THEN
	    BEGIN
	      %if delta %then
		loosen_protection(.fld[0],.fld[0],prev_prot);
	      %fi
	      IF xdt$check_address(.fld[0],inst_size,1) THEN
		bpt_adr = .fld[0]
	      ELSE
		status = ss$_accvio;
	      %if delta %then
		reset_protection(.fld[0],.fld[0],.prev_prot);
	      %fi
	    END;
!
	END;
!
	RETURN .status;
END; 					! ROUTINE add_bpt


ROUTINE show_bpt(
!++
! Functional description:
!
!	This routine shows all the permanent breakpoints.
!
! Formal parameters:
!
	ctx: REF BLOCK[0,BYTE]		!Ptr to mode context block
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

MACRO
	inv_msg = %STRING(' inv') %;		!Invalid breakpoint msg string
LITERAL
	inv_msg_len = %CHARCOUNT(inv_msg);
BIND
	inv_message = UPLIT(BYTE(inv_msg));

!
! For each breakpoint slot, if the breakpoint address is nonzero, display
! the stored breakpoint information
!
	new_line();
!
	INCR bpt_num FROM 1 TO num_perm_bpts DO
	  BEGIN
	    BIND
	      bpt_adr = perm_bpts[.bpt_num,pbpt$q_breakpoint],
	      bpt_disp = perm_bpts[.bpt_num,pbpt$q_display],
	      bpt_cmd = perm_bpts[.bpt_num,pbpt$q_cmd_string];
!
! If the breakpoint address is nonzero, display it in hex along with
! other breakpoint-specific information. Addresses are always displayed
! as either 32-bit or 64-bit values.
!
	    IF .bpt_adr NEQ 0 THEN
	      BEGIN
		put_char(space);
		put_dec(.bpt_num);
		put_char(space);
		put_address(.bpt_adr,.ctx);
!
		IF .bpt_disp NEQ 0 THEN
		  BEGIN
		    put_char(%C',');
		    put_address(.bpt_disp,.ctx);
		  END;
!
		IF .bpt_cmd NEQ 0 THEN 
		  BEGIN
		    put_char(%C',');
		    put_address(.bpt_cmd,.ctx);
		  END;
!
		IF .perm_bpts[.bpt_num,pbpt$v_invalid] THEN
		  put_string(inv_msg_len,inv_message);
!
		new_line();
	      END;
	  END;
!
	RETURN ss$_normal;
END; 					! ROUTINE show_bpt


ROUTINE set_bpt(
!++
! Functional description:
!
!	This routine sets all breakpoints. It goes through the permanent,
! step-over, and single-step breakpoint arrays and makes sure each valid
! breakpoint is established. This is usually done just prior to continuing
! execution. Note that if we're currently at a permanent breakpoint, we
! don't reestablish that breakpoint right away. We need to effectively do
! a single-step to execute the real instruction from that location first
! and then replace the instruction with the breakpoint once again.
!
! Formal parameters:
!
	ctx: REF BLOCK[0,BYTE]		!Ptr to mode context block
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

BIND
	original_pc = ctx[mctx$q_original_pc];
LOCAL
	bpt_type,				!Type of breakpoint
	bpt_index,				!Index into table
	prev_prot;				!Previous page protection
!
! First do the permanent breakpoints. Note that the "current" breakpoint
! is not setup like the others to allow us to execute the real instruction
! normally found at that location before reestablishing the breakpoint or
! single-stepping from a permanent breakpoint.
!
	INCR bpt_num FROM 1 TO num_perm_bpts DO
	  BEGIN
	    BIND
	      bpt_adr = perm_bpts[.bpt_num,pbpt$q_breakpoint];
!
	    IF (.bpt_adr NEQ 0) AND
	       (NOT .perm_bpts[.bpt_num,pbpt$v_invalid]) THEN
	      IF NOT ((.ctx[mctx$v_at_bpt] OR
		       .ctx[mctx$v_do_step] OR
		       .ctx[mctx$v_step_over]) AND
		      (.bpt_adr EQL .original_pc)) THEN
		BEGIN
		  %if delta %then
		    loosen_protection(.bpt_adr,.bpt_adr,prev_prot);
		  %fi
!
		  IF xdt$check_address(.bpt_adr,inst_size,1) THEN
		    BEGIN
		      BIND inst_adr = .bpt_adr : LONG;
		      perm_bpts[.bpt_num,pbpt$l_instruction] = .inst_adr;
		      inst_adr = bpt_opcode;
		    END;
!
		  %if delta %then
		    reset_protection(.bpt_adr,.bpt_adr,.prev_prot);
		  %fi
		END;
	  END;
!
! Execute an instruction memory barrier PAL call to flush the icache
!
	$instruction_memory_barrier;
!
! Do the same thing with the step-overs.
!
	INCR bpt_num FROM 0 TO (num_sos - 1) DO
	  BEGIN
	    BIND
	      bpt_adr = step_overs[.bpt_num,tbpt$q_breakpoint];
!
	    IF .bpt_adr NEQ 0 THEN
	      BEGIN
		%if delta %then
		  loosen_protection(.bpt_adr,.bpt_adr,prev_prot);
		%fi
!
		IF xdt$check_address(.bpt_adr,inst_size,1) THEN
		  BEGIN
		    BIND inst_adr = .bpt_adr : LONG;
		    IF .inst_adr NEQ bpt_opcode THEN
		      BEGIN
			step_overs[.bpt_num,tbpt$l_instruction] = .inst_adr;
			inst_adr = bpt_opcode;
		      END
		    ELSE
		      IF NOT find_bpt(.inst_adr,bpt_type,bpt_index) THEN
			step_overs[.bpt_num,tbpt$l_instruction] = .inst_adr;
		  END;
!
		  %if delta %then
		    reset_protection(.bpt_adr,.bpt_adr,.prev_prot);
		  %fi
	      END;
	  END;
!
! Execute an instruction memory barrier PAL call to flush the icache
!
	$instruction_memory_barrier;
!
! Lastly, do the single-step entries
!
	INCR bpt_num FROM 0 TO (num_tmp_bpts - 1) DO
	  BEGIN
	    BIND
	      bpt_adr = temp_bpts[.bpt_num,tbpt$q_breakpoint];
!
	    IF .bpt_adr NEQ 0 THEN
	      BEGIN
		  %if delta %then
		    loosen_protection(.bpt_adr,.bpt_adr,prev_prot);
		  %fi
!
		IF xdt$check_address(.bpt_adr,inst_size,1) THEN
		  BEGIN
		    BIND inst_adr = .bpt_adr : LONG;
		    IF .inst_adr NEQ bpt_opcode THEN
		      BEGIN
			temp_bpts[.bpt_num,tbpt$l_instruction] = .inst_adr;
			inst_adr = bpt_opcode;
		      END
		    ELSE
		      IF NOT find_bpt(.inst_adr,bpt_type,bpt_index) THEN
			temp_bpts[.bpt_num,tbpt$l_instruction] = .inst_adr;
		  END;
!
		  %if delta %then
		    reset_protection(.bpt_adr,.bpt_adr,.prev_prot);
		  %fi
	      END;
	  END;
!
! Execute an instruction memory barrier PAL call to flush the icache
!
	$instruction_memory_barrier;
!
	RETURN ss$_normal;
END; 					! ROUTINE set_bpt


ROUTINE delete_bpt =
!++
! Functional description:
!
!	This routine deletes (or un-sets) all breakpoints. It does this by
! replacing the BPT instruction with the original instruction from that
! location. If we don't find a BPT instruction there and the contents we
! do find doesn't match the instruction we have stashed away, then mark
! this breakpoint as invalid.
!
! Formal parameters:
!
!	None
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

LOCAL
	prev_prot;			!Holder for previous page protection
!
! In DELTA, if permanent breakpoint zero is setup, we restore the
! actual instruction and clear the permanent breakpoint slot. It's
! basically a "one shot deal" used when starting up DELTA.
!
	%if delta %then
	  BEGIN
	    BIND
	      bpt_adr = perm_bpts[0,pbpt$q_breakpoint];
!
	    IF .bpt_adr NEQ 0 THEN
	      BEGIN
		BIND inst_adr = .bpt_adr : LONG;
		loosen_protection(.bpt_adr,.bpt_adr,prev_prot);
		IF xdt$check_address(.bpt_adr,inst_size,1) THEN
		  IF .inst_adr EQL bpt_opcode THEN
		    BEGIN
		      inst_adr = .perm_bpts[0,pbpt$l_instruction];
		      bpt_adr = 0;
		    END;
		reset_protection(.bpt_adr,.bpt_adr,.prev_prot);
	      END;
	  END;
	%fi
!
! First undo the permanent breakpoints
!
	INCR bpt_num FROM 1 TO num_perm_bpts DO
	  BEGIN
	    BIND
	      bpt_adr = perm_bpts[.bpt_num,pbpt$q_breakpoint];
!
! If the breakpoint address is nonzero, check to see if there's a BPT
! there. If so, replace it with the original instruction. If not, make
! sure what's there matches the instruction we have stashed away for that
! address. If it doesn't match, mark this breakpoint as invalid.
!
	    IF .bpt_adr NEQ 0 THEN
	      BEGIN
		BIND inst_adr = .bpt_adr : LONG;
		perm_bpts[.bpt_num,pbpt$v_invalid] = 0;
		%if delta %then
		  loosen_protection(.bpt_adr,.bpt_adr,prev_prot);
		%fi
		IF NOT xdt$check_address(.bpt_adr,inst_size,1) THEN
		  perm_bpts[.bpt_num,pbpt$v_invalid] = 1
		ELSE
		  IF .inst_adr EQL bpt_opcode THEN
		    inst_adr = .perm_bpts[.bpt_num,pbpt$l_instruction]
		  ELSE
		    IF .inst_adr NEQ .perm_bpts[.bpt_num,pbpt$l_instruction]
		      THEN perm_bpts[.bpt_num,pbpt$v_invalid] = 1;
		%if delta %then
		  reset_protection(.bpt_adr,.bpt_adr,.prev_prot);
		%fi
	      END;
	  END;
!
! Time to do the same thing with the step-overs.
!
	INCR bpt_num FROM 0 TO (num_sos - 1) DO
	  BEGIN
	    BIND
	      bpt_adr = step_overs[.bpt_num,tbpt$q_breakpoint];
!
! If the breakpoint address is nonzero, check to see if there's a BPT
! there. If so, replace it with the original instruction. If not, make
! sure what's there matches the instruction we have stashed away for that
! address. If it doesn't match, update our copy. Note that there could
! be some overlap between temporary breakpoints and permanent breakpoints.
!
	    IF .bpt_adr NEQ 0 THEN
	      BEGIN
		BIND inst_adr = .bpt_adr : LONG;
		%if delta %then
		  loosen_protection(.bpt_adr,.bpt_adr,prev_prot);
		%fi
		IF xdt$check_address(.bpt_adr,inst_size,1) THEN
		  IF .inst_adr EQL bpt_opcode THEN
		    inst_adr = .step_overs[.bpt_num,tbpt$l_instruction]
		  ELSE
		    IF .inst_adr NEQ .step_overs[.bpt_num,tbpt$l_instruction]
		      THEN step_overs[.bpt_num,tbpt$l_instruction] = .inst_adr;
		%if delta %then
		  reset_protection(.bpt_adr,.bpt_adr,.prev_prot);
		%fi
	      END;
	  END;
!
! Lastly, do the single-step entries
!
	INCR bpt_num FROM 0 TO (num_tmp_bpts - 1) DO
	  BEGIN
	    BIND
	      bpt_adr = temp_bpts[.bpt_num,tbpt$q_breakpoint];
!
! If the breakpoint address is nonzero, check to see if there's a BPT
! there. If so, replace it with the original instruction. If not, make
! sure what's there matches the instruction we have stashed away for that
! address. Note that there could be some overlap between temporary breakpoints
! and permanent breakpoints.
!
	    IF .bpt_adr NEQ 0 THEN
	      BEGIN
		BIND inst_adr = .bpt_adr : LONG;
		%if delta %then
		  loosen_protection(.bpt_adr,.bpt_adr,prev_prot);
		%fi
		IF xdt$check_address(.bpt_adr,inst_size,1) THEN
		  IF .inst_adr EQL bpt_opcode THEN
		    inst_adr = .temp_bpts[.bpt_num,tbpt$l_instruction]
		  ELSE
		    IF .inst_adr NEQ .temp_bpts[.bpt_num,tbpt$l_instruction]
		      THEN temp_bpts[.bpt_num,tbpt$l_instruction] = .inst_adr;
		%if delta %then
		  reset_protection(.bpt_adr,.bpt_adr,.prev_prot);
		%fi
	      END;
	  END;
!
! Execute an instruction memory barrier PAL call to flush the icache
!
	$instruction_memory_barrier;
!
	RETURN ss$_normal;
END; 					! ROUTINE delete_bpt


ROUTINE find_bpt(
!++
! Functional description:
!
!	This routine finds the breakpoint index, if any, which matches with
! the specified address.
!
! Formal parameters:
!
	bpt_address,			!Address to match
	bpt_type,			!Address for breakpoint type
	bpt_index			!Address for breakpoint index
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

!
! If the specified address is invalid, return an error
!
	IF .bpt_address EQL 0 THEN
	  RETURN 0;
!
! First try to match the saved PC with a permanent breakpoint. Note that
! the search includes the "initial" breakpoint in slot zero in the event
! it was setup by XDT$INIT in XDELTA.
!
	INCR bpt_num FROM 0 TO num_perm_bpts DO
	  BEGIN
	    BIND
	      bpt_adr = perm_bpts[.bpt_num,pbpt$q_breakpoint];
!
! If the breakpoint address matches, return with the information
!
	    IF .bpt_adr EQL .bpt_address THEN
	      BEGIN
		.bpt_type = bpt$k_perm;
		.bpt_index = .bpt_num;
		RETURN ss$_normal;
	      END;
	  END;
!
! No luck so far. Let's try the list of step-overs
!
	INCR bpt_num FROM 0 TO (num_sos - 1) DO
	  BEGIN
	    BIND
	      bpt_adr = step_overs[.bpt_num,tbpt$q_breakpoint];
!
! If the breakpoint address matches, return with the information
!
	    IF .bpt_adr EQL .bpt_address THEN
	      BEGIN
		.bpt_type = bpt$k_step_over;
		.bpt_index = .bpt_num;
		RETURN ss$_normal;
	      END;
	  END;
!
! Lastly, try to match the saved PC with a single-step
!
	INCR bpt_num FROM 0 TO (num_tmp_bpts - 1) DO
	  BEGIN
	    BIND
	      bpt_adr = temp_bpts[.bpt_num,tbpt$q_breakpoint];
!
! If the breakpoint address matches, return with the information
!
	    IF .bpt_adr EQL .bpt_address THEN
	      BEGIN
		.bpt_type = bpt$k_single_step;
		.bpt_index = .bpt_num;
		RETURN ss$_normal;
	      END;
	  END;
!
	RETURN 0;			! No match found
END; 					! ROUTINE find_bpt


ROUTINE proceed_from_bpt(
!++
! Functional description:
!
!	This routine handles proceeding from breakpoints. More than that,
! it makes preparations to exit XDELTA and proceed with execution. Its
! primary responsibility is to insure that all breakpoints, both permanent
! and temporary, are ready to go.
!
! Formal parameters:
!
	ctx: REF BLOCK[0,BYTE]		!Ptr to mode context block
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

LOCAL
	status;				!Return status value
!
! If somebody along the way wants us to do a single-step, make sure
! we're setup to do it
!
	IF .ctx[mctx$v_do_step] THEN
	  IF NOT (status = single_step(.ctx)) THEN
	    BEGIN
	      IF NOT .ctx[mctx$v_at_bpt] THEN
		ctx[mctx$v_do_step] = 0;
	      RETURN .status;
	    END;
!
! Make sure all those breakpoints are ready to go...
!
	set_bpt(.ctx);
!
! If this is XDELTA and we're not single-stepping for any reason,
! then we want to release the XDELTA lock.
!
	%if xdelta %then
	  IF NOT .ctx[mctx$v_do_step] THEN
	    unlock_xdelta();
	%fi
!
! Reset the mode/state flags for the next time around
!
	ctx[mctx$v_step_over] = 0;
	ctx[mctx$v_do_step] = 0;
	ctx[mctx$v_preg] = 0;
	ctx[mctx$v_prmode] = 0;
!
	RETURN ss$_normal;
END; 					! ROUTINE proceed_from_bpt


ROUTINE break_point(
!++
! Functional description:
!
!	This routine handles breakpoints when they occur. These breakpoints
! can be permanent ones, step-overs, or of the single-step variety. They
! may not be expected at all. Unexpected ones are dismissed right away.
! For expected ones, we stash away some breakpoint context and enter
! command mode. When the user is done with command mode, we proceed with
! execution.
!
! Formal parameters:
!
	no_bpt,				!True if simulating BPT occurrence
	ctx: REF BLOCK[0,BYTE]		!Ptr to mode context block
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	0 => Normal successful completion
!	1 => Unexpected breakpoint interrupt
!
! Side effects:
!
!	None
!
!--

BEGIN

BIND
	iregbuf = ctx[mctx$q_iregbuf],		!Register save area address
	original_pc = ctx[mctx$q_original_pc],	!PC when we got here
	save_pc = .iregbuf + (32 * quad_size);	!Saved PC
LOCAL
	cpu_id,					!To hold CPU ID
	bpt_type,				!The type of breakpoint
	bpt_index,				!Index into breakpoint array
	status;					!Return status value
!
! If this is DELTA, declare a condition handler to take care of exceptions.
!
	%if delta %then
	  ENABLE delta_handler;
	%fi
!
! Determine the breakpoint type and index. If we can't find it, then we
! weren't expecting this breakpoint...unless, of course, we *shouldn't*
! find it. We then backup the saved PC to reexecute the instruction which
! caused the trap to begin with (on with real BPTs). On EVAX, when a BPT
! occurs, the saved PC which is pushed on the stack is actually the updated
! PC, pointing to the ! instruction which follows the BPT in the instruction
! stream.
!
	IF .no_bpt THEN
	  BEGIN
	    bpt_type = bpt$k_single_step;
	    bpt_index = 0;
	  END
	ELSE
	  BEGIN
	    IF NOT find_bpt(.save_pc - inst_size,bpt_type,bpt_index) THEN
	      RETURN 0;
	    save_pc = .save_pc - inst_size;
	  END;
!
	original_pc = .save_pc;
!
! Reset the input/command scanner to start fresh and undo all the other
! breakpoints while we're here
!
	input_reset(.ctx);
	delete_bpt(.ctx);
!
! Now reset the breakpoint structures according to the breakpoint type
!
	SELECTONE .bpt_type OF
	  SET
!
! A permanent breakpoint has occured. We need to flag that we've hit one
! and that we want to do a single-step from here prior to reestablishing
! the breakpoint (for anything other than the "initial" breakpoint). We
! also need to display the breakpoint message. Note that in case a
! temporary breakpoint happens to be sitting on this same instruction, we
! clear it.
!
	    [bpt$k_perm] :
	      BEGIN
		IF .bpt_index EQL 0 THEN
		  BEGIN
		    ctx[mctx$v_at_bpt] = 0;
		    ctx[mctx$v_do_step] = 0;
		  END
		ELSE
		  BEGIN
		    ctx[mctx$v_at_bpt] = 1;
		    ctx[mctx$v_do_step] = 1;
		  END;
		bpt_message(.bpt_index,.ctx);
		clear_step_over(.ctx);
		clear_single_step(.ctx);
	      END;
!
! For step-overs, we want to clear this particular step-over temporary
! breakpoint and display the step-over message if appropriate.
!
	    [bpt$k_step_over] :
	      BEGIN
!
! Clear out the step-over and display the step-over message (if appropriate)
!
		step_over_message(.bpt_index,.ctx);
		clear_step_over(.ctx);
	      END;
!
! If this single-step resulted from us proceeding from a permanent breakpoint,
! then we must merely clear this temporary breakpoint and proceed with
! execution. If it was an explicit single-step operation, then we'll go
! into command mode with the user.
!
	    [bpt$k_single_step] :
	      BEGIN
!
! Display the single-step message if appropriate, clear out the single-step,
! and check to see if we're merely proceeding from a hard breakpoint
!
		IF NOT .ctx[mctx$v_at_bpt] THEN
		  single_step_message(.bpt_index,.ctx);
		clear_single_step(.ctx);
!
		IF .ctx[mctx$v_at_bpt] THEN
		  BEGIN
		    ctx[mctx$v_at_bpt] = 0;
		    proceed_from_bpt(.ctx);
		    RETURN ss$_normal;
		  END;
	      END;
	  TES;
!
! Display the "current" PC and its contents. Note that an error might occur
! in trying to display the contents (an error status return from put_pc).
! However, it is ignored here until I can think of something more appropriate
! to do...
!
	put_pc(.ctx);
!
! Process user commands until the user tires of this. Then proceed with
! execution. If we abort out of the command scanner somehow (such as due
! to an exception), we'll go right back in.
!
	status = 0;
	WHILE NOT .status DO
	  BEGIN
	    status = command_scanner(.ctx);
	    IF .status THEN
	      IF NOT (status = proceed_from_bpt(.ctx)) THEN
		internal_error(.ctx,.status);
	  END;
!
! In XDELTA only, before we actually proceed from this BPT, if this was our
! initial breakpoint, we shouldn't have backed up the saved PC (and should
! instead proceed with the next instruction if the PC hasn't been altered for
! us).
!
	%if xdelta %then
	  IF .bpt_index EQL 0 THEN
	    IF .bpt_type EQL bpt$k_perm THEN
	      IF .save_pc EQL .original_pc THEN
		save_pc = .save_pc + inst_size;
	%fi
!
	RETURN ss$_normal;		! Normal completion
END; 					! ROUTINE break_point


ROUTINE add_xreg(
!++
! Functional description:
!
!	This routine adds a new X-register definition. The command is specified
! by the user as follows:
!			address,xreg_number[,extent];X
! The address is the value to be stored in the X-register. An address of zero
! is used to clear a particular X-register. If no register number is specified,
! an attempt is made to find a free one. If no free ones can be found, an
! error status is returned. The optional extent specifier can be used to
! override the default 800 hex. The extent can be no larger than a longword
! currently (numerous assemptions are made here and elsewhere that it is no
! larger.
!
! Formal parameters:
!
	ctx: REF BLOCK[0,BYTE]		!Ptr to mode context block
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

BIND
	fld = ctx[mctx$q_fields] : VECTOR;	!Input fields

LOCAL
	found,					!Loop kicker-outer
	extent,					!X-register extent
	register_number;			!Temp. for register number
!
! If the user supplied a register number, use that. Otherwise, search for
! a "free" one
!
	IF .ctx[mctx$v_f1] THEN
	  register_number = .fld[1]
	ELSE
	  BEGIN
	    register_number = 0;
	    found = 0;
	    WHILE (.register_number LSS num_x) AND (NOT .found) DO
	      IF .xregs[.register_number] EQL 0 THEN
		found = 1
	      ELSE
		register_number = .register_number + 1;
	  END;
!
! Make sure we have a valid register number. If not, return an error
!
	IF (.register_number LSS 0) OR (.register_number GEQ num_x) THEN
	  RETURN 0;
!
! If this happens to be X4 and we're running XDELTA, then disable future
! attempts to load X4 with the current PCB pointer
!
	%if xdelta %then
	  IF .register_number EQL 4 THEN
	    ctx[mctx$v_no_curpcb] = 1;
	%fi
!
! If the user specified an extent for this X-register, we'll use it.
! Otherwise, we default to that industry-standard 800 (hex) for historical
! reasons.
!
	IF .ctx[mctx$v_f2] THEN
	  extent = .fld[2]
	ELSE
	  extent = def_xreg_extent;
!
	xreg_extents[.register_number] = .extent;
!
! It's OK. Store the new X-register contents
!
	xregs[.register_number] = .fld[0];
!
	RETURN ss$_normal;
END; 					! ROUTINE add_xreg


ROUTINE find_xreg(
!++
! Functional description:
!
!	This routine finds the best-match X-register to the specified address.
! The "best match" is the X-register value which is less than the specified
! address but within the X-register extent and still closer to the X-register
! than any others.
!
! Formal parameters:
!
	match_adr,			!Input address to match
	x_found,			!Address for X-register number found
	offset				!Address for offset found
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	0 => No good match found
!	1 => Match found and data returned in formal parameters
!
! Side effects:
!
!	None
!
!--

BEGIN

LOCAL
	x_num,				!X-register number
	this_offset,			!While looking for best offset
	best_x: INITIAL(num_x + 1),	!Best X so far
	best_offset;			!Best offset so far
!
! We're going to loop through and look at every X-register. For the ones
! that are nonzero and less than the specified address, we'll see if it's
! the best so far. If so, we'll remember this one before going on to the
! next.
!
	INCR x_num FROM 0 TO (num_x - 1) DO
	  IF (.xregs[.x_num] NEQ 0) AND (.xregs[.x_num] LEQ .match_adr) AND
	     (.match_adr LSS (.xregs[.x_num] + .xreg_extents[.x_num])) THEN
	    BEGIN
	      this_offset = .match_adr - .xregs[.x_num];
	      IF .best_x GTR num_x THEN
		BEGIN
		  best_offset = .this_offset;
		  best_x = .x_num;
		END
	      ELSE
		IF .this_offset LSS .best_offset THEN
		  BEGIN
		    best_offset = .this_offset;
		    best_x = .x_num;
		  END;
	    END;
!
! If we didn't find anything, return an "error" status. If we did, return
! a success status and return what we found
!
	IF .best_x GTR num_x THEN
	  RETURN 0
	ELSE
	  BEGIN
	    .x_found = .best_x;
	    .offset = .best_offset;
	    RETURN ss$_normal;
	  END;
END; 					! ROUTINE find_xreg


ROUTINE show_xreg(
!++
! Functional description:
!
!	This routine shows the current X-registers. Only ones with nonzero
! contents are displayed.
!
! Formal parameters:
!
	ctx: REF BLOCK[0,BYTE]		!Ptr to mode context block
	) =
!
! Implicit inputs:
!
!	None
!
! Implicit outputs:
!
!	None
!
! Routine value:
! Completion codes:
!
!	SS$_NORMAL : Normal successful completion status
!
! Side effects:
!
!	None
!
!--

BEGIN

!
! Loop for each X-register. If the contents are nonzero, display them.
! Note that addresses are always displayed as either 32-bit or 64-bit
! quantities.
!
	new_line();
	INCR regnum FROM 0 TO (num_x - 1) DO
	  IF .xregs[.regnum] NEQ 0 THEN
	    BEGIN
	      put_char(space);
	      IF .regnum LSS 10 THEN
		put_char(space);
	      put_dec(.regnum);
	      put_char(space);
	      put_address(.xregs[.regnum],.ctx);
	      IF .xreg_extents[.regnum] NEQ def_xreg_extent THEN
		BEGIN
		  put_char(space);
		  put_char(space);
		  put_hex(.xreg_extents[.regnum],long_size*2);
		END;
	      new_line();
	    END;
!
	RETURN ss$_normal;
END; 					! ROUTINE show_xreg


END 				! MODULE xdelta
ELUDOM
